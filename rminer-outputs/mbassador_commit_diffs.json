[
    {
        "commit hash": "3e7d5fdb362f4bf9236c4b1f0483c90684b5e2f2",
        "previous commit hash": "3da444255c2abf840c3cafda73081e9b3476098e",
        "diff stats": {
            "file_path": ".travis.yml",
            "additions": 6,
            "deletions": 2
        },
        "diff content": "@@ -1,4 +1,8 @@\n+arch:\n+ - amd\n+ - ppc64le\n+ \n jdk:\n-  - openjdk7\n+  - openjdk11\n script:\n-  mvn clean test\n\\ No newline at end of file\n+  mvn clean test\n"
    },
    {
        "commit hash": "499ae3a4a3beb4c20de6d856a3eadeb7aaa0119b",
        "previous commit hash": "3da444255c2abf840c3cafda73081e9b3476098e",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -76,7 +76,7 @@\n         <dependency>\n             <groupId>junit</groupId>\n             <artifactId>junit</artifactId>\n-            <version>4.12</version>\n+            <version>4.13.1</version>\n             <scope>test</scope>\n         </dependency>\n \n"
    },
    {
        "commit hash": "521ce6e6d96c238b14eb2e0c83e5ffadba8c3785",
        "previous commit hash": "3da444255c2abf840c3cafda73081e9b3476098e",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MessagePublication.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -111,7 +111,7 @@ public class MessagePublication implements IMessagePublication {\n         return message;\n     }\n \n-    private enum State {\n+    protected enum State {\n         Initial, Scheduled, Running, Finished\n     }\n \n"
    },
    {
        "commit hash": "3da444255c2abf840c3cafda73081e9b3476098e",
        "previous commit hash": "5974076faa647b8dd426bde5d26f7df68bb23b7a",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -11,7 +11,7 @@ MBassador is a light-weight, high-performance event bus implementing the [publis\n \n The core of MBassador is built around a *custom data structure* that provides **non-blocking reads** and minimized lock contention for writes such that performance degradation of concurrent read/write access is minimal. Benchmarks that illustrate the advantages of this design are available in this [github repository](https://github.com/bennidi/eventbus-performance).\n \n-[![wiki](https://github.com/bennidi/eventbus-performance/blob/master/results/ReadWriteLowConcurrency/mbassador-1.3.0/chart.jpg?raw=true)](wiki)\n+[![wiki](https://github.com/bennidi/eventbus-performance/blob/master/results/ReadWriteHighConcurrency/mbassador-1.3.0/chart.jpg?raw=true)](wiki)\n \n The code is **production ready**: 86% instruction coverage, 82% branch coverage with randomized and concurrently run test sets, no major bug has been reported in the last 18 month. No modifications to the core will be made without thoroughly testing the code.\n \n"
    },
    {
        "commit hash": "5974076faa647b8dd426bde5d26f7df68bb23b7a",
        "previous commit hash": "60c153fb72868fc31e535852cf0c420022d26c2b",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 0
        },
        "diff content": "@@ -11,6 +11,8 @@ MBassador is a light-weight, high-performance event bus implementing the [publis\n \n The core of MBassador is built around a *custom data structure* that provides **non-blocking reads** and minimized lock contention for writes such that performance degradation of concurrent read/write access is minimal. Benchmarks that illustrate the advantages of this design are available in this [github repository](https://github.com/bennidi/eventbus-performance).\n \n+[![wiki](https://github.com/bennidi/eventbus-performance/blob/master/results/ReadWriteLowConcurrency/mbassador-1.3.0/chart.jpg?raw=true)](wiki)\n+\n The code is **production ready**: 86% instruction coverage, 82% branch coverage with randomized and concurrently run test sets, no major bug has been reported in the last 18 month. No modifications to the core will be made without thoroughly testing the code.\n \n \n"
    },
    {
        "commit hash": "60c153fb72868fc31e535852cf0c420022d26c2b",
        "previous commit hash": "1e98ff489d2b2cbc78717a6f543a16fbaa1a8118",
        "diff stats": {
            "file_path": "changelog/README.md",
            "additions": 6,
            "deletions": 3
        },
        "diff content": "@@ -1,13 +1,16 @@\n-### 1.3.2\n+### 1.3.3\n \n + TODO\n   + Remove IBusConfiguration (merge with BusConfiguration)\n-  + Investigate https://github.com/bennidi/mbassador/issues/101\n   + Introduce @Asynchronous as alternative to delivery mode\n   + @Enveloped.messages -> @Enveloped.types\n   + MessageEnvelope -> Envelope\n-\n+  \n ### 1.3.2\n+  \n+  + Merged PR #153: Support of handler definition in interfaces\n+\n+### 1.3.1\n \n + Merged PR #150: Filter definition as reusable annotation\n \n"
    },
    {
        "commit hash": "60c153fb72868fc31e535852cf0c420022d26c2b",
        "previous commit hash": "1e98ff489d2b2cbc78717a6f543a16fbaa1a8118",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -3,7 +3,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.3.1</version>\n+    <version>1.3.3-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n"
    },
    {
        "commit hash": "1e98ff489d2b2cbc78717a6f543a16fbaa1a8118",
        "previous commit hash": "4e8692bb401091cae172db5b4520cd73c7033aff",
        "diff stats": {
            "file_path": ".travis.yml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n jdk:\n-  - openjdk6\n+  - openjdk7\n script:\n   mvn clean test\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "1e98ff489d2b2cbc78717a6f543a16fbaa1a8118",
        "previous commit hash": "4e8692bb401091cae172db5b4520cd73c7033aff",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -54,9 +54,9 @@\n     </developers>\n \n     <properties>\n-        <jdk.version>1.6</jdk.version>\n+        <jdk.version>1.7</jdk.version>\n         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-        <project.build.java.version>1.6</project.build.java.version>\n+        <project.build.java.version>1.7</project.build.java.version>\n         <github.url>file://${project.basedir}/mvn-local-repo</github.url>\n     </properties>\n \n"
    },
    {
        "commit hash": "6af52178c3b2ad5d1a08e27f6896c3afad3db824",
        "previous commit hash": "c6565f3cfd5a6b3b807e4198690ae4daf9a10a0c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandler.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -45,6 +45,7 @@ public class MessageHandler {\n          */\r\n         public static final Map<String, Object> Create(Method handler,\r\n                                                        Handler handlerConfig,\r\n+                                                       Enveloped enveloped,\r\n                                                        IMessageFilter[] filter,\r\n                                                        MessageListener listenerConfig){\r\n             if(handler == null){\r\n@@ -53,7 +54,6 @@ public class MessageHandler {\n             if(filter == null){\r\n                 filter = new IMessageFilter[]{};\r\n             }\r\n-            Enveloped enveloped = ReflectionUtils.getAnnotation( handler, Enveloped.class );\r\n             Class[] handledMessages = enveloped != null\r\n                     ? enveloped.messages()\r\n                     : handler.getParameterTypes();\r\n"
    },
    {
        "commit hash": "6af52178c3b2ad5d1a08e27f6896c3afad3db824",
        "previous commit hash": "c6565f3cfd5a6b3b807e4198690ae4daf9a10a0c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MetadataReader.java",
            "additions": 7,
            "deletions": 2
        },
        "diff content": "@@ -89,18 +89,23 @@ public class MetadataReader {\n             if (!ReflectionUtils.containsOverridingMethod(allHandlers, handler)) {\n \n                 // for each handler there will be no overriding method that specifies @Handler annotation\n-                // but an overriding method does inherit the listener configuration of the overwritten method\n+                // but an overriding method does inherit the listener configuration of the overridden method\n \n                 Handler handlerConfig = ReflectionUtils.getAnnotation(handler, Handler.class);\n+                Enveloped enveloped = ReflectionUtils.getAnnotation( handler, Enveloped.class );\n+\n                 if (!handlerConfig.enabled() || !isValidMessageHandler(handler)) {\n                     continue; // disabled or invalid listeners are ignored\n                 }\n+\n                 Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n-                // if a handler is overwritten it inherits the configuration of its parent method\n+                // if a handler is overridden it inherits the configuration of its parent method\n                 Map<String, Object> handlerProperties = MessageHandler.Properties.Create(overriddenHandler == null ? handler : overriddenHandler,\n                                                                                          handlerConfig,\n+                                                                                         enveloped,\n                                                                                          getFilter(handler, handlerConfig),\n                                                                                          listenerMetadata);\n+\n                 MessageHandler handlerMetadata = new MessageHandler(handlerProperties);\n                 listenerMetadata.addHandler(handlerMetadata);\n             }\n"
    },
    {
        "commit hash": "6af52178c3b2ad5d1a08e27f6896c3afad3db824",
        "previous commit hash": "c6565f3cfd5a6b3b807e4198690ae4daf9a10a0c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MetadataReaderTest.java",
            "additions": 10,
            "deletions": 10
        },
        "diff content": "@@ -43,13 +43,13 @@ public class MetadataReaderTest extends AssertSupport {\n         validator.check(listener);\n     }\n \n-    /*@Test\n+    @Test\n     public void testInterfacedEnveloped() {\n         MessageListener listener = reader.getMessageListener(EnvelopedInterfacedListener.class);\n         ListenerValidator validator = new ListenerValidator()\n-                .expectHandlers(1, Object.class);\n+                .expectHandlers(1, Integer.class);\n         validator.check(listener);\n-    } WIP */\n+    }\n \n \n     @Test\n@@ -215,32 +215,32 @@ public class MetadataReaderTest extends AssertSupport {\n \n     }\n \n-    public static interface EnvelopedListenerInterface {\n+    public interface EnvelopedListenerInterface {\n \n         @Handler\n-        @Enveloped(messages = Object.class)\n+        @Enveloped(messages = Integer.class)\n         void handle(MessageEnvelope envelope);\n     }\n \n-    public class EnvelopedInterfacedListener implements  EnvelopedListenerInterface {\n+    public class EnvelopedInterfacedListener implements EnvelopedListenerInterface {\n \n         @Override\n         public void handle(MessageEnvelope envelope) {\n-            //\n+\n         }\n     }\n \n-    public static interface ListenerInterface {\n+    public interface ListenerInterface {\n \n         @Handler\n         void handle(String str);\n     }\n \n-    public class InterfacedListener implements  ListenerInterface{\n+    public class InterfacedListener implements ListenerInterface {\n \n         @Override\n         public void handle(String str) {\n-            //\n+\n         }\n     }\n \n"
    },
    {
        "commit hash": "c6565f3cfd5a6b3b807e4198690ae4daf9a10a0c",
        "previous commit hash": "3e7232147c5a7bfcadd36f13c9c3f9822c3bb552",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ReflectionUtils.java",
            "additions": 17,
            "deletions": 8
        },
        "diff content": "@@ -27,20 +27,29 @@ public class ReflectionUtils\n \n     public static void getMethods(IPredicate<Method> condition, Class<?> target, ArrayList<Method> methods) {\n         try {\n-            for ( Method method : target.getDeclaredMethods() ) {\n-                if ( condition.apply( method ) ) {\n-                    methods.add( method );\n+            for (Method method : target.getDeclaredMethods()) {\n+                if (condition.apply(method)) {\n+                    methods.add(method);\n+                }\n+            }\n+\n+            for (Class superType : getSuperTypes(target)) {\n+                if (superType.equals(Object.class)) {\n+                    continue;\n+                }\n+\n+                for (Method superTypeMethod : superType.getDeclaredMethods()) {\n+                    if (condition.apply(superTypeMethod )) {\n+                        methods.add(superTypeMethod);\n+                    }\n                 }\n             }\n         }\n-        catch ( Exception e ) {\n+        catch (Exception e) {\n             //nop\n         }\n-        if ( !target.equals( Object.class ) ) {\n-            getMethods(condition, target.getSuperclass(), methods);\n-        }\n     }\n-    \n+\n     /**\n     * Traverses the class hierarchy upwards, starting at the given subclass, looking\n     * for an override of the given methods -> finds the bottom most override of the given\n"
    },
    {
        "commit hash": "c6565f3cfd5a6b3b807e4198690ae4daf9a10a0c",
        "previous commit hash": "3e7232147c5a7bfcadd36f13c9c3f9822c3bb552",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MetadataReaderTest.java",
            "additions": 26,
            "deletions": 4
        },
        "diff content": "@@ -35,13 +35,21 @@ public class MetadataReaderTest extends AssertSupport {\n         validator.check(listener);\n     }\n \n-    /*\n+    @Test\n     public void testInterfaced() {\n         MessageListener listener = reader.getMessageListener(InterfacedListener.class);\n+        ListenerValidator validator = new ListenerValidator()\n+                .expectHandlers(1, String.class);\n+        validator.check(listener);\n+    }\n+\n+    /*@Test\n+    public void testInterfacedEnveloped() {\n+        MessageListener listener = reader.getMessageListener(EnvelopedInterfacedListener.class);\n         ListenerValidator validator = new ListenerValidator()\n                 .expectHandlers(1, Object.class);\n         validator.check(listener);\n-    }  WIP */\n+    } WIP */\n \n \n     @Test\n@@ -207,14 +215,14 @@ public class MetadataReaderTest extends AssertSupport {\n \n     }\n \n-    public static interface ListenerInterface{\n+    public static interface EnvelopedListenerInterface {\n \n         @Handler\n         @Enveloped(messages = Object.class)\n         void handle(MessageEnvelope envelope);\n     }\n \n-    public class InterfacedListener implements  ListenerInterface{\n+    public class EnvelopedInterfacedListener implements  EnvelopedListenerInterface {\n \n         @Override\n         public void handle(MessageEnvelope envelope) {\n@@ -222,4 +230,18 @@ public class MetadataReaderTest extends AssertSupport {\n         }\n     }\n \n+    public static interface ListenerInterface {\n+\n+        @Handler\n+        void handle(String str);\n+    }\n+\n+    public class InterfacedListener implements  ListenerInterface{\n+\n+        @Override\n+        public void handle(String str) {\n+            //\n+        }\n+    }\n+\n }\n"
    },
    {
        "commit hash": "3e7232147c5a7bfcadd36f13c9c3f9822c3bb552",
        "previous commit hash": "3023b26ee0d84a0617c34a0361b00c4d63dcf1e0",
        "diff stats": {
            "file_path": "README.md",
            "additions": 34,
            "deletions": 0
        },
        "diff content": "@@ -95,6 +95,40 @@ Instead of using weak references, a listener can be configured to be referenced\n \n MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to a single message handler. Since version 1.2.0 Java EL expressions in `@Handler` are another way to define conditional message dispatch. Messages that have matching handlers but do not pass the configured filters result in the publication of a FilteredMessage object which wraps the original message. FilteredMessage events can be handled by registering listeners that handle FilteredMessage.\n \n+Note: Since version 1.3.1 it is possible to wrap a filter in a custom annotation for reuse\n+\n+```java\n+\n+\n+\n+\n+    public static final class RejectAllFilter implements IMessageFilter {\n+\n+        @Override\n+        public boolean accepts(Object event,  SubscriptionContext context) {\n+            return false;\n+        }\n+    }\n+\n+    @IncludeFilters({@Filter(RejectAllFilter.class)})\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface RejectAll {}\n+    \n+    public static class FilteredMessageListener{\n+    \n+        // will cause republication of a FilteredEvent\n+        @Handler\n+        @RejectAll\n+        public void handleNone(Object any){\n+            FilteredEventCounter.incrementAndGet();\n+        }\n+\n+        \n+    }\n+\n+\n+```\n+\n > Enveloped messages\n \n Message handlers can declare to receive an enveloped message using `Enveloped`. The envelope can wrap different types of messages to allow a single handler to handle multiple, unrelated message types.\n"
    },
    {
        "commit hash": "3e7232147c5a7bfcadd36f13c9c3f9822c3bb552",
        "previous commit hash": "3023b26ee0d84a0617c34a0361b00c4d63dcf1e0",
        "diff stats": {
            "file_path": "changelog/README.md",
            "additions": 3,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-### 1.3.1\n+### 1.3.2\n \n + TODO\n   + Remove IBusConfiguration (merge with BusConfiguration)\n@@ -7,7 +7,9 @@\n   + @Enveloped.messages -> @Enveloped.types\n   + MessageEnvelope -> Envelope\n \n+### 1.3.2\n \n++ Merged PR #150: Filter definition as reusable annotation\n \n ### 1.3.0\n  + Non-Breaking API changes\n"
    },
    {
        "commit hash": "3e7232147c5a7bfcadd36f13c9c3f9822c3bb552",
        "previous commit hash": "3023b26ee0d84a0617c34a0361b00c4d63dcf1e0",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/IncludeFilters.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -6,15 +6,15 @@ import java.lang.annotation.RetentionPolicy;\n import java.lang.annotation.Target;\n \n /**\n- * The repeated filters annotation is used to add multiple {@link Filter}s to\n- * a single {@link ElementType#ANNOTATION_TYPE annotation type} when using\n- * \"inherited filters\".\n+ * The include filters directive can be used to add multiple {@link Filter}s to\n+ * a single {@link ElementType#ANNOTATION_TYPE annotation type}. This allows to add\n+ * filters to message handlers with one or more user-defined annotations.\n  *\n  * @see Filter\n  */\n @Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.ANNOTATION_TYPE)\n-public @interface RepeatedFilters {\n+public @interface IncludeFilters {\n \n     /**\n      * An array of filters to be used for filtering {@link Handler}s.\n"
    },
    {
        "commit hash": "3e7232147c5a7bfcadd36f13c9c3f9822c3bb552",
        "previous commit hash": "3023b26ee0d84a0617c34a0361b00c4d63dcf1e0",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MetadataReader.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -61,7 +61,7 @@ public class MetadataReader {\n         Annotation[] annotations = method.getAnnotations();\n         for (int i = 0; i < method.getAnnotations().length; i++) {\n             Class<? extends Annotation> annotationType = annotations[i].annotationType();\n-            RepeatedFilters repeated = annotationType.getAnnotation(RepeatedFilters.class);\n+            IncludeFilters repeated = annotationType.getAnnotation(IncludeFilters.class);\n             if (repeated != null) {\n                 Collections.addAll(filters, repeated.value());\n             }\n"
    },
    {
        "commit hash": "3e7232147c5a7bfcadd36f13c9c3f9822c3bb552",
        "previous commit hash": "3023b26ee0d84a0617c34a0361b00c4d63dcf1e0",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/FilterTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -158,7 +158,7 @@ public class FilterTest extends MessageBusTest {\n \n     }\n \n-    @RepeatedFilters({@Filter(RejectAllFilter.class)})\n+    @IncludeFilters({@Filter(RejectAllFilter.class)})\n     @Retention(RetentionPolicy.RUNTIME)\n     public @interface RejectAll {\n \n"
    },
    {
        "commit hash": "3023b26ee0d84a0617c34a0361b00c4d63dcf1e0",
        "previous commit hash": "54bf17dc35aff1df7e15dd5767ffc4727ecdd033",
        "diff stats": {
            "file_path": "README.md",
            "additions": 19,
            "deletions": 16
        },
        "diff content": "@@ -1,10 +1,7 @@\n-<img src=\"https://travis-ci.org/bennidi/mbassador.svg?branch=master\" alt=\"build-status\" />\n-\n-<a href=\"https://maven-badges.herokuapp.com/maven-central/net.engio/mbassador\" target=\"blank\" ><img src=\"https://img.shields.io/maven-central/v/net.engio/mbassador.svg\" /></a>\n-\n-<a href=\"http://www.javadoc.io/doc/net.engio/mbassador\"><img src=\"http://www.javadoc.io/badge/net.engio/mbassador.svg\" alt=\"Javadocs\"></a>\n-\n-<a href=\"wiki\" target=\"blank\"><img src=\"assets/wiki.png?raw=true\" alt=\"wiki\" width=\"50\" height=\"20\"/></a>\n+[![build status](https://travis-ci.org/bennidi/mbassador.svg?branch=master)](https://travis-ci.org/bennidi/mbassador)\n+[![maven central](https://img.shields.io/maven-central/v/net.engio/mbassador.svg)](https://maven-badges.herokuapp.com/maven-central/net.engio/mbassador)\n+[![javadoc](http://www.javadoc.io/badge/net.engio/mbassador.svg)](http://www.javadoc.io/doc/net.engio/mbassador)\n+[![wiki](assets/wiki.png?raw=true)](wiki)\n \n \n MBassador\n@@ -12,9 +9,9 @@ MBassador\n \n MBassador is a light-weight, high-performance event bus implementing the [publish subscribe pattern](https://en.wikipedia.org/wiki/Publish-subscribe_pattern). It is designed for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. \n \n-The core of MBassador's high performance is a **specialized data structure** that provides **non-blocking readers** and minimizes lock contention for writers such that performance degradation of concurrent read/write access is minimal. The advantages of this design are illustrated in this [github repository](https://github.com/bennidi/eventbus-performance).\n+The core of MBassador is built around a *custom data structure* that provides **non-blocking reads** and minimized lock contention for writes such that performance degradation of concurrent read/write access is minimal. Benchmarks that illustrate the advantages of this design are available in this [github repository](https://github.com/bennidi/eventbus-performance).\n \n-The code is **production ready**: 86% instruction coverage, 82% branch coverage with highly randomized and concurrently run test sets, no severe bugs have been reported in the last 18 month. No modifications to the core will be made without thoroughly testing the code.\n+The code is **production ready**: 86% instruction coverage, 82% branch coverage with randomized and concurrently run test sets, no major bug has been reported in the last 18 month. No modifications to the core will be made without thoroughly testing the code.\n \n \n [Usage](#usage) | [Features](#features) | [Installation](#installation) | [Wiki](#wiki) | [Release Notes](#./changelog) | [Integrations](#integrations) | [Credits](#credits) | [Contribute](#contribute) | [License](#license)\n@@ -77,10 +74,16 @@ Messages do not need to implement any interface and can be of any type. The clas\n \n > Synchronous and asynchronous message delivery\n \n-There are two types of (a-)synchronicity when using MBassador: message dispatch and handler invocation. \n-For message dispatch _synchronous_ means that the publishing method blocks until messages are delivered to all handlers and _asynchronous_ means that the publish method returns immediately and the message will be dispatched in another thread (fire and forget).\n+There are **two types of (a-)synchronicity** when using MBassador: message dispatch and handler invocation. \n+**Message dispatch** \n+\n+_Synchronous_ dispatch means that the publish method blocks until all handlers have been *processed*. Note: This does not necessarily imply that each handler has been invoked and received the message - due to the possibility to combine synchronous dispatch with asynchronous handlers. This is the semantics of `publish(Object obj)` and `post(Objec obj).now()`\n+\n+_Asynchronous_ dispatch means that the publish method returns immediately and the message will be dispatched in another thread (fire and forget). This is the semantics of `publishAsync(Object obj)` and `post(Objec obj).asynchronously()`\n+\n+**Handler invocation**\n \n-For handler invocation synchronous means that within a running publication all handlers are called sequentially. _Asynchronous_ means that the handler invocation is pushed into a queue and the next handler is invoked with waiting for the previous to finish.\n+_Synchronous_ handlers are invoked sequentially and from the same thread within a running publication. _Asynchronous_ handlers means that the actual handler invocation is pushed to a queue that is processed by a pool of worker threads.\n \n > Configurable reference types\n \n@@ -133,12 +136,12 @@ There is ongoing effort to extend documentation and provide code samples and det\n \n ## Integrations\n \n-There is a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. This is a good example of integration with other frameworks. An example of [Guice integration](https://github.com/bennidi/mbassador/wiki/Guice-Integration) also exists.\n+There is a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. This is a good example of integration with other frameworks. Another example is the [Guice integration](https://github.com/bennidi/mbassador/wiki/Guice-Integration).\n \n \n ## Credits\n The initial inspiration for creating this component comes from Google Guava's event bus implementation.\n-I liked the simplicity of its design and I trust in the code quality of google libraries. The main reason it proved to be unusable for our scenario was that it uses strong references to the listeners.\n+I liked the simplicity of its design and I trust in the code quality of google libraries. Unfortunately it uses strong references only.\n \n Thanks to all [contributors](https://github.com/bennidi/mbassador/pulls?q=is%3Apr+is%3Aclosed), especially\n + [arne-vandamme](http://github.com/arne-vandamme) for adding support for [meta-annotations](https://github.com/bennidi/mbassador/pull/74)\n@@ -153,7 +156,7 @@ Many thanks also to ej-technologies for providing an open source license of\n OSS used by MBassador: [jUnit](http://www.junit.org) | [maven](http://www.maven.org) | [mockito](http://www.mockito.org) | [slf4j](http://www.slf4j.org) | [Odysseus JUEL](http://juel.sourceforge.net/guide/start.html)\n \n \n-##Contribute\n+## Contribute\n \n Pick an issue from the list of open issues and start implementing. Make your PRs small and provide test code! Take a look at [this issue](bennidi/mbassador#109) for a good example.\n \n@@ -161,6 +164,6 @@ Pick an issue from the list of open issues and start implementing. Make your PRs\n \n Sample code and documentation are both very appreciated contributions. Especially integration with different frameworks is of great value. Feel free and welcome to create Wiki pages to share your code and ideas. Example: [Guice integration](https://github.com/bennidi/mbassador/wiki/Guice-Integration)\n \n-<h2>License</h2>\n+## License\n \n This project is distributed under the terms of the MIT License. See file \"LICENSE\" for further reference.\n"
    },
    {
        "commit hash": "3023b26ee0d84a0617c34a0361b00c4d63dcf1e0",
        "previous commit hash": "54bf17dc35aff1df7e15dd5767ffc4727ecdd033",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -3,7 +3,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.3.1-SNAPSHOT</version>\n+    <version>1.3.1</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n"
    },
    {
        "commit hash": "3023b26ee0d84a0617c34a0361b00c4d63dcf1e0",
        "previous commit hash": "54bf17dc35aff1df7e15dd5767ffc4727ecdd033",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/FilterTest.java",
            "additions": 8,
            "deletions": 8
        },
        "diff content": "@@ -85,14 +85,14 @@ public class FilterTest extends MessageBusTest {\n \n         // FilteredEvents that contain messages of class Object will be filtered (again) and should cause a DeadEvent to be thrown\n         @Handler\n-        @RejectFilteredObjectsFilter\n+        @RejectFiltered\n         public void handleFilteredEvent(FilteredMessage filtered){\n             FilteredEventCounter.incrementAndGet();\n         }\n \n         // will cause republication of a FilteredEvent\n         @Handler\n-        @RejectAllFilter\n+        @RejectAll\n         public void handleNone(Object any){\n             FilteredEventCounter.incrementAndGet();\n         }\n@@ -133,7 +133,7 @@ public class FilterTest extends MessageBusTest {\n \n     }\n \n-    public static class RejectFilteredObjects implements IMessageFilter{\n+    public static class RejectFilteredObjectsFilter implements IMessageFilter{\n \n         @Override\n         public boolean accepts(Object message, SubscriptionContext context) {\n@@ -144,7 +144,7 @@ public class FilterTest extends MessageBusTest {\n         }\n     }\n \n-    public static final class RejectAll implements IMessageFilter {\n+    public static final class RejectAllFilter implements IMessageFilter {\n \n         @Override\n         public boolean accepts(Object event,  SubscriptionContext context) {\n@@ -152,15 +152,15 @@ public class FilterTest extends MessageBusTest {\n         }\n     }\n \n-    @Filter(RejectFilteredObjects.class)\n+    @Filter(RejectFilteredObjectsFilter.class)\n     @Retention(RetentionPolicy.RUNTIME)\n-    public @interface RejectFilteredObjectsFilter {\n+    public @interface RejectFiltered {\n \n     }\n \n-    @RepeatedFilters({@Filter(RejectAll.class)})\n+    @RepeatedFilters({@Filter(RejectAllFilter.class)})\n     @Retention(RetentionPolicy.RUNTIME)\n-    public @interface RejectAllFilter {\n+    public @interface RejectAll {\n \n     }\n \n"
    },
    {
        "commit hash": "ea8a0dc22b1522e64404a54bd483428edf460f30",
        "previous commit hash": "1bd581b0d7eea2fa2b12b2fd9d16ea82220d8496",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MetadataReader.java",
            "additions": 27,
            "deletions": 8
        },
        "diff content": "@@ -4,13 +4,13 @@ import net.engio.mbassy.common.IPredicate;\n import net.engio.mbassy.common.ReflectionUtils;\n import net.engio.mbassy.subscription.MessageEnvelope;\n \n+import java.lang.annotation.Annotation;\n import java.lang.reflect.Method;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.HashMap;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n-import java.util.Queue;\n \n /**\n  * The meta data reader is responsible for parsing and validating message handler configurations.\n@@ -32,13 +32,14 @@ public class MetadataReader {\n     private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n \n     // retrieve all instances of filters associated with the given subscription\n-    private IMessageFilter[] getFilter(Handler subscription) {\n-        if (subscription.filters().length == 0) {\n+    private IMessageFilter[] getFilter(Method method, Handler subscription) {\n+        Filter[] filterDefinitions = collectFilters(method, subscription);\n+        if (filterDefinitions.length == 0) {\n             return null;\n         }\n-        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n+        IMessageFilter[] filters = new IMessageFilter[filterDefinitions.length];\n         int i = 0;\n-        for (Filter filterDef : subscription.filters()) {\n+        for (Filter filterDef : filterDefinitions) {\n             IMessageFilter filter = filterCache.get(filterDef.value());\n             if (filter == null) {\n                 try {\n@@ -54,6 +55,24 @@ public class MetadataReader {\n         return filters;\n     }\n \n+    private Filter[] collectFilters(Method method, Handler subscription) {\n+        List<Filter> filters = new ArrayList<Filter>(subscription.filters().length);\n+        Collections.addAll(filters, subscription.filters());\n+        Annotation[] annotations = method.getAnnotations();\n+        for (int i = 0; i < method.getAnnotations().length; i++) {\n+            Class<? extends Annotation> annotationType = annotations[i].annotationType();\n+            RepeatedFilters repeated = annotationType.getAnnotation(RepeatedFilters.class);\n+            if (repeated != null) {\n+                Collections.addAll(filters, repeated.value());\n+            }\n+            Filter filter = annotationType.getAnnotation(Filter.class);\n+            if (filter != null) {\n+                filters.add(filter);\n+            }\n+        }\n+        return filters.toArray(new Filter[filters.size()]);\n+    }\n+\n     // get all listeners defined by the given class (includes\n     // listeners defined in super classes)\n     public MessageListener getMessageListener(Class target) {\n@@ -72,7 +91,7 @@ public class MetadataReader {\n                 // for each handler there will be no overriding method that specifies @Handler annotation\n                 // but an overriding method does inherit the listener configuration of the overwritten method\n \n-                Handler handlerConfig = ReflectionUtils.getAnnotation( handler, Handler.class);\n+                Handler handlerConfig = ReflectionUtils.getAnnotation(handler, Handler.class);\n                 if (!handlerConfig.enabled() || !isValidMessageHandler(handler)) {\n                     continue; // disabled or invalid listeners are ignored\n                 }\n@@ -80,7 +99,7 @@ public class MetadataReader {\n                 // if a handler is overwritten it inherits the configuration of its parent method\n                 Map<String, Object> handlerProperties = MessageHandler.Properties.Create(overriddenHandler == null ? handler : overriddenHandler,\n                                                                                          handlerConfig,\n-                                                                                         getFilter(handlerConfig),\n+                                                                                         getFilter(handler, handlerConfig),\n                                                                                          listenerMetadata);\n                 MessageHandler handlerMetadata = new MessageHandler(handlerProperties);\n                 listenerMetadata.addHandler(handlerMetadata);\n"
    },
    {
        "commit hash": "ea8a0dc22b1522e64404a54bd483428edf460f30",
        "previous commit hash": "1bd581b0d7eea2fa2b12b2fd9d16ea82220d8496",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/RepeatedFilters.java",
            "additions": 23,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,23 @@\n+package net.engio.mbassy.listener;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The repeated filters annotation is used to add multiple {@link Filter}s to\n+ * a single {@link ElementType#ANNOTATION_TYPE annotation type} when using\n+ * \"inherited filters\".\n+ *\n+ * @see Filter\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.ANNOTATION_TYPE)\n+public @interface RepeatedFilters {\n+\n+    /**\n+     * An array of filters to be used for filtering {@link Handler}s.\n+     */\n+    Filter[] value();\n+}\n"
    },
    {
        "commit hash": "ea8a0dc22b1522e64404a54bd483428edf460f30",
        "previous commit hash": "1bd581b0d7eea2fa2b12b2fd9d16ea82220d8496",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/FilterTest.java",
            "additions": 18,
            "deletions": 2
        },
        "diff content": "@@ -12,6 +12,8 @@ import net.engio.mbassy.messages.TestMessage;\n import net.engio.mbassy.subscription.SubscriptionContext;\n import org.junit.Test;\n \n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n import java.util.List;\n import java.util.concurrent.atomic.AtomicInteger;\n \n@@ -82,13 +84,15 @@ public class FilterTest extends MessageBusTest {\n         }\n \n         // FilteredEvents that contain messages of class Object will be filtered (again) and should cause a DeadEvent to be thrown\n-        @Handler(filters = {@Filter(RejectFilteredObjects.class)})\n+        @Handler\n+        @RejectFilteredObjectsFilter\n         public void handleFilteredEvent(FilteredMessage filtered){\n             FilteredEventCounter.incrementAndGet();\n         }\n \n         // will cause republication of a FilteredEvent\n-        @Handler(filters = {@Filter(RejectAll.class)})\n+        @Handler\n+        @RejectAllFilter\n         public void handleNone(Object any){\n             FilteredEventCounter.incrementAndGet();\n         }\n@@ -148,4 +152,16 @@ public class FilterTest extends MessageBusTest {\n         }\n     }\n \n+    @Filter(RejectFilteredObjects.class)\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface RejectFilteredObjectsFilter {\n+\n+    }\n+\n+    @RepeatedFilters({@Filter(RejectAll.class)})\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface RejectAllFilter {\n+\n+    }\n+\n }\n"
    },
    {
        "commit hash": "e9dd105c4aee861fa0f7634022479d9a724a8e88",
        "previous commit hash": "25bff4c6f943a86a5f283685ee8ac7f0ffe32016",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java",
            "additions": 4,
            "deletions": 2
        },
        "diff content": "@@ -28,12 +28,14 @@ public class SubscriptionFactory {\n             return new Subscription(context, dispatcher, handlerMetadata.useStrongReferences()\n                 ? new StrongConcurrentSet<Object>()\n                 : new WeakConcurrentSet<Object>());\n+        } catch (MessageBusException e) {\n+            throw e;\n         } catch (Exception e) {\n             throw new MessageBusException(e);\n         }\n     }\n \n-    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {\n+    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws MessageBusException {\n         IHandlerInvocation invocation = createBaseHandlerInvocation(context);\n         if(context.getHandler().isSynchronized()){\n             invocation = new SynchronizedHandlerInvocation(invocation);\n@@ -44,7 +46,7 @@ public class SubscriptionFactory {\n         return invocation;\n     }\n \n-    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n+    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) throws MessageBusException {\n         IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n         if (context.getHandler().isEnveloped()) {\n             dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n"
    },
    {
        "commit hash": "ff0f5fa14351a3dc5514f2b6d24a4a53a1328290",
        "previous commit hash": "e297c9dd4e4d38b81d57e995552d89b20f95e554",
        "diff stats": {
            "file_path": "assets/java.png",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/assets/java.png and /dev/null differ\n"
    },
    {
        "commit hash": "e297c9dd4e4d38b81d57e995552d89b20f95e554",
        "previous commit hash": "29def20bc1b300260abebb850abdfbee2dd17e1a",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -2,7 +2,7 @@\n \n <a href=\"https://maven-badges.herokuapp.com/maven-central/net.engio/mbassador\" target=\"blank\" ><img src=\"https://img.shields.io/maven-central/v/net.engio/mbassador.svg\" /></a>\n \n-<a href=\"http://bennidi.github.io/mbassador/\" target=\"blank\"><img src=\"assets/java.png?raw=true\" alt=\"javadoc\" width=\"20\" height=\"20\"/>javadoc</a>\n+<a href=\"http://www.javadoc.io/doc/net.engio/mbassador\"><img src=\"http://www.javadoc.io/badge/net.engio/mbassador.svg\" alt=\"Javadocs\"></a>\n \n <a href=\"wiki\" target=\"blank\"><img src=\"assets/wiki.png?raw=true\" alt=\"wiki\" width=\"50\" height=\"20\"/></a>\n \n"
    },
    {
        "commit hash": "29def20bc1b300260abebb850abdfbee2dd17e1a",
        "previous commit hash": "8bcb9776ad1e683447067f36cab7c31ca1cf3980",
        "diff stats": {
            "file_path": "README.md",
            "additions": 6,
            "deletions": 5
        },
        "diff content": "@@ -59,7 +59,7 @@ bus.post(new File(\"/tmp/bigfile.csv\")).asynchronously();\n \n ```   \n \n-##Features\n+## Features\n \n \n > Annotation driven\n@@ -108,8 +108,9 @@ Errors during message delivery are sent to all registered error handlers which c\n \n MBassador is designed to be extensible with custom implementations of various components like message dispatchers and handler invocations (using the decorator pattern), metadata reader (you can add your own annotations) and factories for different kinds of objects. A configuration object is used to customize the different configurable parts, see [Features](https://github.com/bennidi/mbassador/wiki/Components#Feature)\n \n-<h2>Installation</h2>\n+## Installation\n MBassador is available from the Maven Central Repository using the following coordinates:\n+\n ```xml\n \n <dependency>\n@@ -122,7 +123,7 @@ MBassador is available from the Maven Central Repository using the following coo\n \n You can also download binary release and javadoc from the [maven central repository](http://search.maven.org/#search|ga|1|mbassador). Of course you can always clone the repository and build from source.\n \n-<h2>Documentation</h2>\n+## Documentation\n There is ongoing effort to extend documentation and provide code samples and detailed explanations of how the message bus works. Code samples can also be found in the various test cases. Please read about the terminology used in this project to avoid confusion and misunderstanding.\n \n + [javadoc](http://bennidi.github.io/mbassador/)\n@@ -130,12 +131,12 @@ There is ongoing effort to extend documentation and provide code samples and det\n + API examples on programcreek: [Handler](http://www.programcreek.com/java-api-examples/index.php?api=net.engio.mbassy.listener.Handler), [BusConfiguration](http://www.programcreek.com/java-api-examples/index.php?api=net.engio.mbassy.bus.config.BusConfiguration), [MBassador](http://www.programcreek.com/java-api-examples/index.php?api=net.engio.mbassy.bus.MBassador)\n \n \n-<h2>Integrations</h2>\n+## Integrations\n \n There is a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. This is a good example of integration with other frameworks. An example of [Guice integration](https://github.com/bennidi/mbassador/wiki/Guice-Integration) also exists.\n \n \n-<h2>Credits</h2>\n+## Credits\n The initial inspiration for creating this component comes from Google Guava's event bus implementation.\n I liked the simplicity of its design and I trust in the code quality of google libraries. The main reason it proved to be unusable for our scenario was that it uses strong references to the listeners.\n \n"
    },
    {
        "commit hash": "8bcb9776ad1e683447067f36cab7c31ca1cf3980",
        "previous commit hash": "3e6d0e6e0e7b7d60c8b914be21e70f3f6e63dd12",
        "diff stats": {
            "file_path": "README.md",
            "additions": 4,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,9 @@\n <img src=\"https://travis-ci.org/bennidi/mbassador.svg?branch=master\" alt=\"build-status\" />\n-[![Maven Central](https://img.shields.io/maven-central/v/net.engio/mbassador.svg)](https://maven-badges.herokuapp.com/maven-central/net.engio/mbassador)\n+\n+<a href=\"https://maven-badges.herokuapp.com/maven-central/net.engio/mbassador\" target=\"blank\" ><img src=\"https://img.shields.io/maven-central/v/net.engio/mbassador.svg\" /></a>\n+\n <a href=\"http://bennidi.github.io/mbassador/\" target=\"blank\"><img src=\"assets/java.png?raw=true\" alt=\"javadoc\" width=\"20\" height=\"20\"/>javadoc</a>\n+\n <a href=\"wiki\" target=\"blank\"><img src=\"assets/wiki.png?raw=true\" alt=\"wiki\" width=\"50\" height=\"20\"/></a>\n \n \n"
    },
    {
        "commit hash": "8ea1dc100f49840d95830feffc5fa1fceefc8e0b",
        "previous commit hash": "16686c561d603b888c31321f22bdfb952a00a378",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -1,4 +1,5 @@\n <img src=\"https://travis-ci.org/bennidi/mbassador.svg?branch=master\" alt=\"build-status\" />\n+[![Maven Central](https://img.shields.io/maven-central/v/net.engio/mbassador.svg)](https://maven-badges.herokuapp.com/maven-central/net.engio/mbassador)\n <a href=\"http://bennidi.github.io/mbassador/\" target=\"blank\"><img src=\"assets/java.png?raw=true\" alt=\"javadoc\" width=\"20\" height=\"20\"/>javadoc</a>\n <a href=\"wiki\" target=\"blank\"><img src=\"assets/wiki.png?raw=true\" alt=\"wiki\" width=\"50\" height=\"20\"/></a>\n \n"
    },
    {
        "commit hash": "16686c561d603b888c31321f22bdfb952a00a378",
        "previous commit hash": "a155f2417daf98719917c540b57f1f8df5688bd6",
        "diff stats": {
            "file_path": "README.md",
            "additions": 8,
            "deletions": 20
        },
        "diff content": "@@ -13,7 +13,7 @@ The core of MBassador's high performance is a **specialized data structure** tha\n The code is **production ready**: 86% instruction coverage, 82% branch coverage with highly randomized and concurrently run test sets, no severe bugs have been reported in the last 18 month. No modifications to the core will be made without thoroughly testing the code.\n \n \n-[Usage](#usage) | [Features](#features) | [Installation](#installation) | [Wiki](#wiki) | [Release Notes](#release-notes) | [Integrations](#integrations) | [Credits](#credits) | [Contribute](#contribute) | [License](#license)\n+[Usage](#usage) | [Features](#features) | [Installation](#installation) | [Wiki](#wiki) | [Release Notes](#./changelog) | [Integrations](#integrations) | [Credits](#credits) | [Contribute](#contribute) | [License](#license)\n \n <h2>Usage</h2>\n \n@@ -130,41 +130,29 @@ There is ongoing effort to extend documentation and provide code samples and det\n \n There is a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. This is a good example of integration with other frameworks. An example of [Guice integration](https://github.com/bennidi/mbassador/wiki/Guice-Integration) also exists.\n \n-<h2>Release Notes</h2>\n-\n-Release notes moved to the [changelog](./changelog).\n-\n \n <h2>Credits</h2>\n The initial inspiration for creating this component comes from Google Guava's event bus implementation.\n I liked the simplicity of its design and I trust in the code quality of google libraries. The main reason it proved to be unusable for our scenario was that it uses strong references to the listeners.\n \n-I want to thank the development team from [friendsurance](http://www.friendsurance.de) for their support and feedback on the bus implementation and the management for allowing me to publish the component as an open source project.\n-\n-I also want to thank all githubbers who have made [contributions](https://github.com/bennidi/mbassador/pulls?q=is%3Apr+is%3Aclosed). Special thanks go to\n+Thanks to all [contributors](https://github.com/bennidi/mbassador/pulls?q=is%3Apr+is%3Aclosed), especially\n + [arne-vandamme](http://github.com/arne-vandamme) for adding support for [meta-annotations](https://github.com/bennidi/mbassador/pull/74)\n + [Bernd Rosstauscher](http://github.com/Rossi1337) for providing an initial integration with JUEL\n + [David Sowerby](http://github.com/davidsowerby) for answering user questions, his tutorial on [guice integration](bennidi/mbassador/wiki/guice-integration) and his various PRs\n-+ [dorkbox](http://github.com/dorkbox) for various PRs and his incredible [work on performance tuning](http://github.com/bennidi/eventbus-performance/issues/1) which is still to be integrated\n++ [dorkbox](http://github.com/dorkbox) for various PRs and his [work on performance tuning](http://github.com/bennidi/eventbus-performance/issues/1) which is still to be integrated\n + [durron597](http://github.com/durron597) for his many PRs and the help he offered to other users\n \n-Many thanks also to ej-technologies for providing me with an open source license of \n+Many thanks also to ej-technologies for providing an open source license of \n [![JProfiler](http://www.ej-technologies.com/images/banners/jprofiler_small.png)](http://www.ej-technologies.com/products/jprofiler/overview.html) and Jetbrains for a license of [IntelliJ IDEA](http://www.jetbrains.com/idea/)\n \n-MBassador uses the following open source projects:\n-\n-* [jUnit](http://www.junit.org)\n-* [maven](http://www.maven.org)\n-* [mockito](http://www.mockito.org)\n-* [slf4j](http://www.slf4j.org)\n-* [Odysseus JUEL](http://juel.sourceforge.net/guide/start.html)\n-\n-Special thanks also to [Sonatype](http://www.sonatype.com/) for the hosting of their [oss nexus repository](https://oss.sonatype.org/).\n+OSS used by MBassador: [jUnit](http://www.junit.org) | [maven](http://www.maven.org) | [mockito](http://www.mockito.org) | [slf4j](http://www.slf4j.org) | [Odysseus JUEL](http://juel.sourceforge.net/guide/start.html)\n \n \n ##Contribute\n \n-Please feel invited to contribute by creating a pull request to submit the code you would like to be included. Make your PRs small and provide test code! Take a look at [this issue](bennidi/mbassador#109) for a good example.\n+Pick an issue from the list of open issues and start implementing. Make your PRs small and provide test code! Take a look at [this issue](bennidi/mbassador#109) for a good example.\n+\n+> Note: Due to the complexity of the data structure and synchronization code it took quite a while to get a stable core. New features will only be implemented if they do not require significant modification to the core. The primary focus of MBassador is to provide high-performance extended pub/sub.\n \n Sample code and documentation are both very appreciated contributions. Especially integration with different frameworks is of great value. Feel free and welcome to create Wiki pages to share your code and ideas. Example: [Guice integration](https://github.com/bennidi/mbassador/wiki/Guice-Integration)\n \n"
    },
    {
        "commit hash": "a155f2417daf98719917c540b57f1f8df5688bd6",
        "previous commit hash": "8ba22efd48d5754f5ce734f04f468ac49a575fce",
        "diff stats": {
            "file_path": "README.md",
            "additions": 25,
            "deletions": 20
        },
        "diff content": "@@ -8,24 +8,12 @@ MBassador\n \n MBassador is a light-weight, high-performance event bus implementing the [publish subscribe pattern](https://en.wikipedia.org/wiki/Publish-subscribe_pattern). It is designed for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. \n \n-The core of MBassador's high performance is a specialized data structure that provides non-blocking readers and minimizes lock contention for writers such that performance degradation of concurrent read/write access is minimal. The advantages of this design are illustrated in this [github repository](https://github.com/bennidi/eventbus-performance).\n+The core of MBassador's high performance is a **specialized data structure** that provides **non-blocking readers** and minimizes lock contention for writers such that performance degradation of concurrent read/write access is minimal. The advantages of this design are illustrated in this [github repository](https://github.com/bennidi/eventbus-performance).\n \n-The code is production ready: 86% instruction coverage, 82% branch coverage with highly randomized and concurrently run test sets, no severe bugs have been reported in the last 18 month. No modifications to the core will be made without thouroughly testing the code.\n+The code is **production ready**: 86% instruction coverage, 82% branch coverage with highly randomized and concurrently run test sets, no severe bugs have been reported in the last 18 month. No modifications to the core will be made without thoroughly testing the code.\n \n-For documentation you can browse the [javadoc](http://bennidi.github.io/mbassador/), read this overview, check out the wiki resources.\n \n-There is a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. This is a good example of integration with other frameworks. An example of [Guice integration](https://github.com/bennidi/mbassador/wiki/Guice-Integration) also exists.\n-\n-Table of contents:\n-  *  [Usage](#usage)\n-  *  [Features](#features)\n-  *  [Installation](#installation)\n-  *  [Wiki](#wiki)\n-  *  [Release Notes](#release-notes)\n-  *  [Integrations](#integrations)\n-  *  [Credits](#credits)\n-  *  [Contribute](#contribute)\n-  *  [License](#license)\n+[Usage](#usage) | [Features](#features) | [Installation](#installation) | [Wiki](#wiki) | [Release Notes](#release-notes) | [Integrations](#integrations) | [Credits](#credits) | [Contribute](#contribute) | [License](#license)\n \n <h2>Usage</h2>\n \n@@ -35,21 +23,33 @@ As a first reference, consider this illustrative example. You might want to have\n \n ```java\n       \n-// Define your listener\n+// Define your handlers\n+\n+@Listener(references = References.Strong)\n class SimpleFileListener{\n \n     @Handler\n-    public void handle(File msg){\n+    public void handle(File file){\n+      // do something with the file\n+    }\n+    \n+    @Handler(delivery = Invoke.Asynchronously)\n+    public void expensiveOperation(File file){\n       // do something with the file\n     }\n+    \n+    @Handler(condition = \"msg.size >= 10000\")\n+    @Enveloped(messages = {HashMap.class, LinkedList.class})\n+    public void handleLarge(MessageEnvelope envelope) {\n+       // handle objects without common super type\n+    }\n \n }\n \n // somewhere else in your code\n \n MBassador bus = new MBassador();\n-Object listener = new SimpleFileListener();\n-bus.subscribe (listener);\n+bus.subscribe (new SimpleFileListener());\n bus.post(new File(\"/tmp/smallfile.csv\")).now();\n bus.post(new File(\"/tmp/bigfile.csv\")).asynchronously();\n \n@@ -125,6 +125,11 @@ There is ongoing effort to extend documentation and provide code samples and det\n + [wiki](wiki)\n + API examples on programcreek: [Handler](http://www.programcreek.com/java-api-examples/index.php?api=net.engio.mbassy.listener.Handler), [BusConfiguration](http://www.programcreek.com/java-api-examples/index.php?api=net.engio.mbassy.bus.config.BusConfiguration), [MBassador](http://www.programcreek.com/java-api-examples/index.php?api=net.engio.mbassy.bus.MBassador)\n \n+\n+<h2>Integrations</h2>\n+\n+There is a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. This is a good example of integration with other frameworks. An example of [Guice integration](https://github.com/bennidi/mbassador/wiki/Guice-Integration) also exists.\n+\n <h2>Release Notes</h2>\n \n Release notes moved to the [changelog](./changelog).\n@@ -165,4 +170,4 @@ Sample code and documentation are both very appreciated contributions. Especiall\n \n <h2>License</h2>\n \n-This project is distributed under the terms of the MIT License. See file \"LICENSE\" for further reference.\n\\ No newline at end of file\n+This project is distributed under the terms of the MIT License. See file \"LICENSE\" for further reference.\n"
    },
    {
        "commit hash": "a155f2417daf98719917c540b57f1f8df5688bd6",
        "previous commit hash": "8ba22efd48d5754f5ce734f04f468ac49a575fce",
        "diff stats": {
            "file_path": "changelog/README.md",
            "additions": 12,
            "deletions": 1
        },
        "diff content": "@@ -1,3 +1,14 @@\n+### 1.3.1\n+\n++ TODO\n+  + Remove IBusConfiguration (merge with BusConfiguration)\n+  + Investigate https://github.com/bennidi/mbassador/issues/101\n+  + Introduce @Asynchronous as alternative to delivery mode\n+  + @Enveloped.messages -> @Enveloped.types\n+  + MessageEnvelope -> Envelope\n+\n+\n+\n ### 1.3.0\n  + Non-Breaking API changes\n    + Extended IMessagePublication to allow for error reporting using `hasError()` and `getError()`\n@@ -140,4 +151,4 @@ First stable release!\n \n ### 1.0.4.RC\n \n-  + Introduced BusConfiguration as a central class to encapsulate configurational aspects\n\\ No newline at end of file\n+  + Introduced BusConfiguration as a central class to encapsulate configurational aspects\n"
    },
    {
        "commit hash": "a155f2417daf98719917c540b57f1f8df5688bd6",
        "previous commit hash": "8ba22efd48d5754f5ce734f04f468ac49a575fce",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -14,9 +14,9 @@\n \n         Some features:\n         declarative handler definition via annotations,\n-        sync and/or async message delivery,\n+        sync and/or async event delivery,\n         weak or strong references,\n-        configurable message filters,\n+        configurable event filters,\n     </description>\n \n     <!--\n"
    },
    {
        "commit hash": "a155f2417daf98719917c540b57f1f8df5688bd6",
        "previous commit hash": "8ba22efd48d5754f5ce734f04f468ac49a575fce",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Listener.java",
            "additions": 5,
            "deletions": 7
        },
        "diff content": "@@ -4,11 +4,9 @@ import java.lang.annotation.*;\n \n /**\n  *\n- * This annotation is meant to carry configuration that is shared among all instances of the annotated\n- * listener. Supported configurations are:\n- *\n- *  Reference type: The bus will use either strong or weak references to its registered listeners,\n- *  depending on which reference type (@see References) is set\n+ * Configure how the listener is referenced in the event bus.\n+ * The bus will use either strong or weak references to its registered listeners,\n+ *  depending on which reference type (@see References) is set.\n  *\n  * @author bennidi\n  */\n@@ -18,8 +16,8 @@ import java.lang.annotation.*;\n public @interface Listener {\n \n     /**\n-     * BY DEFAULT, REFERENCES to message listeners ARE WEAK to eliminate risks of memory leaks.\n-     * It is possible to use strong references instead.\n+     * BY DEFAULT, MBassador uses {@link java.lang.ref.WeakReference}. It is possible to use\n+     * strong instead.\n      *\n      */\n     References references() default References.Weak;\n"
    },
    {
        "commit hash": "a155f2417daf98719917c540b57f1f8df5688bd6",
        "previous commit hash": "8ba22efd48d5754f5ce734f04f468ac49a575fce",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 0,
            "deletions": 34
        },
        "diff content": "@@ -115,40 +115,6 @@ public abstract class SyncBusTest extends MessageBusTest {\n         assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n     }\n \n-    @Test\n-    public void testExceptionInHandlerInvocation2(){\n-        final AtomicInteger exceptionCount = new AtomicInteger(0);\n-        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n-            @Override\n-            public void handleError(PublicationError error) {\n-                exceptionCount.incrementAndGet();\n-            }\n-        };\n-\n-        //DS: modified to pass ExceptionCounter via the configuration object\n-        final GenericMessagePublicationSupport bus = getSyncMessageBus(false,ExceptionCounter);\n-        ListenerFactory listeners = new ListenerFactory()\n-                .create(InstancesPerListener, ExceptionThrowingListener.class);\n-\n-        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n-\n-        Runnable publish = new Runnable() {\n-            @Override\n-            public void run() {\n-                bus.post(new Object()).now();\n-            }\n-        };\n-\n-        // single threaded\n-        ConcurrentExecutor.runConcurrent(publish, 1);\n-        assertEquals(InstancesPerListener, exceptionCount.get());\n-        exceptionCount.set(0); // reset for next test\n-\n-        // multi threaded\n-        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n-        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n-    }\n-\n \n     @Test\n     public void testCustomHandlerInvocation(){\n"
    },
    {
        "commit hash": "a155f2417daf98719917c540b57f1f8df5688bd6",
        "previous commit hash": "8ba22efd48d5754f5ce734f04f468ac49a575fce",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/WeakConcurrentSetTest.java",
            "additions": 0,
            "deletions": 4
        },
        "diff content": "@@ -19,10 +19,6 @@ import java.util.Set;\n  */\n public class WeakConcurrentSetTest extends ConcurrentSetTest{\n \n-\n-\n-\n-\n     @Override\n     protected Collection createSet() {\n         return new WeakConcurrentSet();\n"
    },
    {
        "commit hash": "a155f2417daf98719917c540b57f1f8df5688bd6",
        "previous commit hash": "8ba22efd48d5754f5ce734f04f468ac49a575fce",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/AbstractMessageListener.java",
            "additions": 3,
            "deletions": 0
        },
        "diff content": "@@ -2,6 +2,8 @@ package net.engio.mbassy.listeners;\n \n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.References;\n import net.engio.mbassy.messages.AbstractMessage;\n \n /**\n@@ -9,6 +11,7 @@ import net.engio.mbassy.messages.AbstractMessage;\n  * @author bennidi\n  *         Date: 5/24/13\n  */\n+@Listener(references = References.Weak)\n public class AbstractMessageListener {\n \n     private static abstract class BaseListener {\n"
    },
    {
        "commit hash": "a155f2417daf98719917c540b57f1f8df5688bd6",
        "previous commit hash": "8ba22efd48d5754f5ce734f04f468ac49a575fce",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/ICountableListener.java",
            "additions": 3,
            "deletions": 0
        },
        "diff content": "@@ -2,6 +2,8 @@ package net.engio.mbassy.listeners;\n \n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.References;\n import net.engio.mbassy.messages.ICountable;\n \n /**\n@@ -11,6 +13,7 @@ import net.engio.mbassy.messages.ICountable;\n  */\n public class ICountableListener {\n \n+    @Listener(references = References.Weak)\n     private static abstract class BaseListener {\n \n         @Handler\n"
    },
    {
        "commit hash": "a155f2417daf98719917c540b57f1f8df5688bd6",
        "previous commit hash": "8ba22efd48d5754f5ce734f04f468ac49a575fce",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/IMessageListener.java",
            "additions": 3,
            "deletions": 0
        },
        "diff content": "@@ -2,6 +2,8 @@ package net.engio.mbassy.listeners;\n \n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.References;\n import net.engio.mbassy.messages.IMessage;\n \n /**\n@@ -13,6 +15,7 @@ import net.engio.mbassy.messages.IMessage;\n  */\n public class IMessageListener {\n \n+    @Listener(references = References.Weak)\n     private static abstract class BaseListener {\n \n         @Handler\n"
    },
    {
        "commit hash": "a155f2417daf98719917c540b57f1f8df5688bd6",
        "previous commit hash": "8ba22efd48d5754f5ce734f04f468ac49a575fce",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/IMultipartMessageListener.java",
            "additions": 3,
            "deletions": 0
        },
        "diff content": "@@ -2,6 +2,8 @@ package net.engio.mbassy.listeners;\n \n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.References;\n import net.engio.mbassy.messages.IMultipartMessage;\n \n /**\n@@ -11,6 +13,7 @@ import net.engio.mbassy.messages.IMultipartMessage;\n  */\n public class IMultipartMessageListener {\n \n+    @Listener(references = References.Weak)\n     private static abstract class BaseListener {\n \n         @Handler\n"
    },
    {
        "commit hash": "a155f2417daf98719917c540b57f1f8df5688bd6",
        "previous commit hash": "8ba22efd48d5754f5ce734f04f468ac49a575fce",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/MessagesTypeListener.java",
            "additions": 3,
            "deletions": 0
        },
        "diff content": "@@ -2,6 +2,8 @@ package net.engio.mbassy.listeners;\n \n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.References;\n import net.engio.mbassy.messages.MessageTypes;\n \n /**\n@@ -11,6 +13,7 @@ import net.engio.mbassy.messages.MessageTypes;\n  */\n public class MessagesTypeListener {\n \n+    @Listener(references = References.Weak)\n     private static abstract class BaseListener {\n \n         @Handler\n"
    },
    {
        "commit hash": "a155f2417daf98719917c540b57f1f8df5688bd6",
        "previous commit hash": "8ba22efd48d5754f5ce734f04f468ac49a575fce",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/MultipartMessageListener.java",
            "additions": 3,
            "deletions": 0
        },
        "diff content": "@@ -2,6 +2,8 @@ package net.engio.mbassy.listeners;\n \n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.References;\n import net.engio.mbassy.messages.MultipartMessage;\n \n /**\n@@ -11,6 +13,7 @@ import net.engio.mbassy.messages.MultipartMessage;\n  */\n public class MultipartMessageListener {\n \n+    @Listener(references = References.Weak)\n     private static abstract class BaseListener {\n \n         @Handler\n"
    },
    {
        "commit hash": "a155f2417daf98719917c540b57f1f8df5688bd6",
        "previous commit hash": "8ba22efd48d5754f5ce734f04f468ac49a575fce",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/ObjectListener.java",
            "additions": 3,
            "deletions": 1
        },
        "diff content": "@@ -1,12 +1,14 @@\n package net.engio.mbassy.listeners;\n \n import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.References;\n \n import java.util.Collections;\n import java.util.LinkedList;\n import java.util.List;\n \n-\n+@Listener(references = References.Weak)\n public class ObjectListener {\n \n     private List handledMessages = Collections.synchronizedList(new LinkedList());\n"
    },
    {
        "commit hash": "a155f2417daf98719917c540b57f1f8df5688bd6",
        "previous commit hash": "8ba22efd48d5754f5ce734f04f468ac49a575fce",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/StandardMessageListener.java",
            "additions": 3,
            "deletions": 0
        },
        "diff content": "@@ -2,6 +2,8 @@ package net.engio.mbassy.listeners;\n \n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.References;\n import net.engio.mbassy.messages.StandardMessage;\n \n /**\n@@ -11,6 +13,7 @@ import net.engio.mbassy.messages.StandardMessage;\n  */\n public class StandardMessageListener {\n \n+    @Listener(references = References.Weak)\n     private static abstract class BaseListener {\n \n         @Handler(priority = 3)\n"
    },
    {
        "commit hash": "8ba22efd48d5754f5ce734f04f468ac49a575fce",
        "previous commit hash": "4151a4bf361c70b2439d386a0edcf2513964f1e2",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,6 @@\n <img src=\"https://travis-ci.org/bennidi/mbassador.svg?branch=master\" alt=\"build-status\" />\n-<a href=\"http://bennidi.github.io/mbassador/\" target=\"blank\"><img src=\"assets/java.png?raw=true\" alt=\"javadoc\" />javadoc</a>\n-<a href=\"wiki\" target=\"blank\"><img src=\"assets/wiki.png?raw=true\" alt=\"wiki\" /></a>\n+<a href=\"http://bennidi.github.io/mbassador/\" target=\"blank\"><img src=\"assets/java.png?raw=true\" alt=\"javadoc\" width=\"20\" height=\"20\"/>javadoc</a>\n+<a href=\"wiki\" target=\"blank\"><img src=\"assets/wiki.png?raw=true\" alt=\"wiki\" width=\"50\" height=\"20\"/></a>\n \n \n MBassador\n"
    },
    {
        "commit hash": "4151a4bf361c70b2439d386a0edcf2513964f1e2",
        "previous commit hash": "d6c27185b619d392652e355445d5d228e860ab23",
        "diff stats": {
            "file_path": "README.md",
            "additions": 3,
            "deletions": 0
        },
        "diff content": "@@ -1,4 +1,7 @@\n <img src=\"https://travis-ci.org/bennidi/mbassador.svg?branch=master\" alt=\"build-status\" />\n+<a href=\"http://bennidi.github.io/mbassador/\" target=\"blank\"><img src=\"assets/java.png?raw=true\" alt=\"javadoc\" />javadoc</a>\n+<a href=\"wiki\" target=\"blank\"><img src=\"assets/wiki.png?raw=true\" alt=\"wiki\" /></a>\n+\n \n MBassador\n =========\n"
    },
    {
        "commit hash": "4151a4bf361c70b2439d386a0edcf2513964f1e2",
        "previous commit hash": "d6c27185b619d392652e355445d5d228e860ab23",
        "diff stats": {
            "file_path": "assets/java.png",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/assets/java.png differ\n"
    },
    {
        "commit hash": "4151a4bf361c70b2439d386a0edcf2513964f1e2",
        "previous commit hash": "d6c27185b619d392652e355445d5d228e860ab23",
        "diff stats": {
            "file_path": "assets/wiki.png",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/assets/wiki.png differ\n"
    },
    {
        "commit hash": "d6c27185b619d392652e355445d5d228e860ab23",
        "previous commit hash": "344fb7699c45a0b34ccbb473b9c29b59e0054fd4",
        "diff stats": {
            "file_path": ".travis.yml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n jdk:\n   - openjdk6\n script:\n-  mvn clean build\n\\ No newline at end of file\n+  mvn clean test\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "344fb7699c45a0b34ccbb473b9c29b59e0054fd4",
        "previous commit hash": "6690ea6835a7087bb2e4d5fe57a4bb5f431948de",
        "diff stats": {
            "file_path": ".travis.yml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n jdk:\n   - openjdk6\n script:\n-  mvn verify\n\\ No newline at end of file\n+  mvn clean build\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "6690ea6835a7087bb2e4d5fe57a4bb5f431948de",
        "previous commit hash": "e64e31dd7113b4a8cd4fd785f5d1141b95e82cb5",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 0,
            "deletions": 7
        },
        "diff content": "@@ -80,13 +80,6 @@\n             <scope>test</scope>\n         </dependency>\n \n-        <dependency>\n-            <groupId>org.assertj</groupId>\n-            <artifactId>assertj-core</artifactId>\n-            <version>3.3.0</version>\n-            <scope>test</scope>\n-        </dependency>\n-\n         <dependency>\n             <groupId>org.mockito</groupId>\n             <artifactId>mockito-core</artifactId>\n"
    },
    {
        "commit hash": "6690ea6835a7087bb2e4d5fe57a4bb5f431948de",
        "previous commit hash": "e64e31dd7113b4a8cd4fd785f5d1141b95e82cb5",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/bus/AbstractPubSubSupportTest.java",
            "additions": 5,
            "deletions": 6
        },
        "diff content": "@@ -15,7 +15,6 @@ import java.io.ByteArrayOutputStream;\n import java.io.PrintStream;\n import java.util.concurrent.atomic.AtomicInteger;\n \n-import static org.assertj.core.api.Assertions.assertThat;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n@@ -120,7 +119,7 @@ public class AbstractPubSubSupportTest {\n             //when no publication error handler is provided\n             MBassador<String> bus = new MBassador<String>(configuration);\n             // then we see the warning on the console\n-            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);\n+            Assert.assertTrue(baos.toString().contains(AbstractPubSubSupport.ERROR_HANDLER_MSG));\n         } finally {\n             System.out.flush();\n             if (old != null) {\n@@ -144,10 +143,10 @@ public class AbstractPubSubSupportTest {\n             System.setOut(ps);\n             //when\n             SyncMessageBus<String> bus = new SyncMessageBus<String>();\n-            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);\n+            Assert.assertTrue(baos.toString().contains(AbstractPubSubSupport.ERROR_HANDLER_MSG));\n             bus.handlePublicationError(publicationError);\n             //then\n-            assertThat(baos.toString()).contains(errorMsg);\n+            Assert.assertTrue(baos.toString().contains(errorMsg));\n \n         } finally {\n             System.out.flush();\n@@ -171,10 +170,10 @@ public class AbstractPubSubSupportTest {\n             System.setOut(ps);\n             //when\n             MBassador<String> bus = new MBassador<String>();\n-            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);\n+            Assert.assertTrue(baos.toString().contains(AbstractPubSubSupport.ERROR_HANDLER_MSG));\n             bus.handlePublicationError(publicationError);\n             //then\n-            assertThat(baos.toString()).contains(errorMsg);\n+            Assert.assertTrue(baos.toString().contains(errorMsg));\n \n         } finally {\n             System.out.flush();\n"
    },
    {
        "commit hash": "e64e31dd7113b4a8cd4fd785f5d1141b95e82cb5",
        "previous commit hash": "e8abb749e24eea7b5ad153c74f1a65c27c2714d7",
        "diff stats": {
            "file_path": ".travis.yml",
            "additions": 0,
            "deletions": 0
        },
        "diff content": ""
    },
    {
        "commit hash": "e8abb749e24eea7b5ad153c74f1a65c27c2714d7",
        "previous commit hash": "c434078ab85fdd09dd5ee85c46c12933e69d925f",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 0
        },
        "diff content": "@@ -1,3 +1,5 @@\n+<img src=\"https://travis-ci.org/bennidi/mbassador.svg?branch=master\" alt=\"build-status\" />\n+\n MBassador\n =========\n \n"
    },
    {
        "commit hash": "c434078ab85fdd09dd5ee85c46c12933e69d925f",
        "previous commit hash": "f58b0f35f33996968b808d38678f8fa62a775efd",
        "diff stats": {
            "file_path": "README.md",
            "additions": 5,
            "deletions": 1
        },
        "diff content": "@@ -113,9 +113,13 @@ MBassador is available from the Maven Central Repository using the following coo\n \n You can also download binary release and javadoc from the [maven central repository](http://search.maven.org/#search|ga|1|mbassador). Of course you can always clone the repository and build from source.\n \n-<h2>Wiki</h2>\n+<h2>Documentation</h2>\n There is ongoing effort to extend documentation and provide code samples and detailed explanations of how the message bus works. Code samples can also be found in the various test cases. Please read about the terminology used in this project to avoid confusion and misunderstanding.\n \n++ [javadoc](http://bennidi.github.io/mbassador/)\n++ [wiki](wiki)\n++ API examples on programcreek: [Handler](http://www.programcreek.com/java-api-examples/index.php?api=net.engio.mbassy.listener.Handler), [BusConfiguration](http://www.programcreek.com/java-api-examples/index.php?api=net.engio.mbassy.bus.config.BusConfiguration), [MBassador](http://www.programcreek.com/java-api-examples/index.php?api=net.engio.mbassy.bus.MBassador)\n+\n <h2>Release Notes</h2>\n \n Release notes moved to the [changelog](./changelog).\n"
    },
    {
        "commit hash": "c434078ab85fdd09dd5ee85c46c12933e69d925f",
        "previous commit hash": "f58b0f35f33996968b808d38678f8fa62a775efd",
        "diff stats": {
            "file_path": "travis.yml",
            "additions": 4,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,4 @@\n+jdk:\n+  - openjdk6\n+script:\n+  mvn verify\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "f58b0f35f33996968b808d38678f8fa62a775efd",
        "previous commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -3,7 +3,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.3.0</version>\n+    <version>1.3.1-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -26,7 +26,7 @@\n \n     For deployment (and release of non SNAPSHOT): mvn clean deploy\n     For manual release of staging: mvn nexus-staging:release\n-    git push origin <tag>\n+    tagging and release on github\n \n     -->\n \n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "README.md",
            "additions": 45,
            "deletions": 37
        },
        "diff content": "@@ -1,17 +1,15 @@\n MBassador\n =========\n \n-MBassador is a light-weight, high-performance message (event) bus implementation based on the [publish subscribe pattern](https://en.wikipedia.org/wiki/Publish-subscribe_pattern). It is designed for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. \n+MBassador is a light-weight, high-performance event bus implementing the [publish subscribe pattern](https://en.wikipedia.org/wiki/Publish-subscribe_pattern). It is designed for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. \n \n-The core of MBassador's high performance is a specialized data structure that minimizes lock contention such that performance degradation of concurrent read/write access is minimal. The advantages of this design are illustrated in the [eventbus-performance](https://github.com/bennidi/eventbus-performance) github repository.\n+The core of MBassador's high performance is a specialized data structure that provides non-blocking readers and minimizes lock contention for writers such that performance degradation of concurrent read/write access is minimal. The advantages of this design are illustrated in this [github repository](https://github.com/bennidi/eventbus-performance).\n \n-Read this introduction to get an overview of MBassadors features. There is also some documentation in the Wiki - although admittedly not enough to make a developer happy. Additionally, you can browse the [javadoc](http://bennidi.github.io/mbassador/)\n+The code is production ready: 86% instruction coverage, 82% branch coverage with highly randomized and concurrently run test sets, no severe bugs have been reported in the last 18 month. No modifications to the core will be made without thouroughly testing the code.\n \n-There is a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. This is a good example of integration with other frameworks.\n+For documentation you can browse the [javadoc](http://bennidi.github.io/mbassador/), read this overview, check out the wiki resources.\n \n->  ################   NOTE #################### \n-\n-> [15.10.2015] My spare time programming efforts have shifted to another open source project - [openmediaid](http://www.openmediaid.org). I will not be able to actively push development of this library anymore. Any developers interested in becoming co-maintainers of this library... you are very welcome! \n+There is a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. This is a good example of integration with other frameworks. An example of [Guice integration](https://github.com/bennidi/mbassador/wiki/Guice-Integration) also exists.\n \n Table of contents:\n   *  [Usage](#usage)\n@@ -30,24 +28,27 @@ Using MBassador in your project is very easy. Create as many instances of MBassa\n \n As a first reference, consider this illustrative example. You might want to have a look at the collection of [examples](./examples) to see its features on more detail.\n \n-      // Define your listener\n-     class SimpleFileListener{\n-     \n-       @Handler\n-       public void handle(File msg){\n-          // do something with the file\n-       }\n-     \n-     }\n-  \n-      // somewhere else in your code\n-  \n-     MBassador bus = new MBassador();\n-     Object listener = new SimpleFileListener();\n-     bus.subscribe (listener);\n-     bus.post(new File(\"/tmp/smallfile.csv\")).now();\n-     bus.post(new File(\"/tmp/bigfile.csv\")).asynchronously();\n-   \n+```java\n+      \n+// Define your listener\n+class SimpleFileListener{\n+\n+    @Handler\n+    public void handle(File msg){\n+      // do something with the file\n+    }\n+\n+}\n+\n+// somewhere else in your code\n+\n+MBassador bus = new MBassador();\n+Object listener = new SimpleFileListener();\n+bus.subscribe (listener);\n+bus.post(new File(\"/tmp/smallfile.csv\")).now();\n+bus.post(new File(\"/tmp/bigfile.csv\")).asynchronously();\n+\n+```   \n \n ##Features\n \n@@ -56,24 +57,29 @@ As a first reference, consider this illustrative example. You might want to have\n \n |Annotation|Function|\n |:-----|:-----|\n-|`@Handler`|Defines and customizes a message handler. Any well-formed method annotated with `@Handler` will cause instances of the defining class to be treated as message listeners|\n+|`@Handler`|Mark a method as message handler|\n |`@Listener`|Can be used to customize listener wide configuration like the used reference type|\n |`@Enveloped`|A message envelope can be used to pass messages of different types into a single handler|\n |`@Filter`|Add filtering to prevent certain messages from being published|\n \n-> Delivers everything\n+> Delivers everything, respects type hierarchy\n \n Messages do not need to implement any interface and can be of any type. The class hierarchy of a message is considered during message delivery, such that handlers will also receive subtypes of the message type they consume for - e.g. a handler of Object.class receives everything. Messages that do not match any handler result in the publication of a `DeadMessage` object which wraps the original message. DeadMessage events can be handled by registering listeners that handle DeadMessage.\n \n > Synchronous and asynchronous message delivery\n \n-A handler can be invoked to handle a message either synchronously or asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch\n+There are two types of (a-)synchronicity when using MBassador: message dispatch and handler invocation. \n+For message dispatch _synchronous_ means that the publishing method blocks until messages are delivered to all handlers and _asynchronous_ means that the publish method returns immediately and the message will be dispatched in another thread (fire and forget).\n+\n+For handler invocation synchronous means that within a running publication all handlers are called sequentially. _Asynchronous_ means that the handler invocation is pushed into a queue and the next handler is invoked with waiting for the previous to finish.\n \n > Configurable reference types\n \n-By default, MBassador uses weak references for listeners to relieve the programmer of the need to explicitly unsubscribe listeners that are not used anymore and avoid memory-leaks. This is very comfortable in container managed environments where listeners are created and destroyed by frameworks, i.e. Spring, Guice etc. Just stuff everything into the message bus, it will ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job. Instead of using weak references, a listener can be configured to be referenced using strong references using `@Listener(references=References.Strong)`. Strongly referenced listeners will stick around until explicitly unsubscribed.\n+By default, MBassador uses **weak references** for listeners to relieve the programmer of the need to explicitly unsubscribe listeners that are not used anymore and **avoid memory-leaks**. This is very comfortable in container managed environments where listeners are created and destroyed by frameworks, i.e. Spring, Guice etc. Just add everything to the bus, it will ignore objects without handlers and automatically clean-up orphaned weak references after the garbage collector has done its job. \n+\n+Instead of using weak references, a listener can be configured to be referenced using strong references using `@Listener(references=References.Strong)`. Strongly referenced listeners will stick around until explicitly unsubscribed.\n \n-> Filtering\n+> Message filtering\n \n MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to a single message handler. Since version 1.2.0 Java EL expressions in `@Handler` are another way to define conditional message dispatch. Messages that have matching handlers but do not pass the configured filters result in the publication of a FilteredMessage object which wraps the original message. FilteredMessage events can be handled by registering listeners that handle FilteredMessage.\n \n@@ -96,11 +102,13 @@ MBassador is designed to be extensible with custom implementations of various co\n <h2>Installation</h2>\n MBassador is available from the Maven Central Repository using the following coordinates:\n ```xml\n-    <dependency>\n-        <groupId>net.engio</groupId>\n-        <artifactId>mbassador</artifactId>\n-        <version>{see.git.tags.for.latest.version}</version>\n-    </dependency>\n+\n+<dependency>\n+    <groupId>net.engio</groupId>\n+    <artifactId>mbassador</artifactId>\n+    <version>{see.git.tags.for.latest.version}</version>\n+</dependency>\n+\n ```\n \n You can also download binary release and javadoc from the [maven central repository](http://search.maven.org/#search|ga|1|mbassador). Of course you can always clone the repository and build from source.\n@@ -119,7 +127,7 @@ I liked the simplicity of its design and I trust in the code quality of google l\n \n I want to thank the development team from [friendsurance](http://www.friendsurance.de) for their support and feedback on the bus implementation and the management for allowing me to publish the component as an open source project.\n \n-I also want to thank all githubbers who have made [contributions](https://github.com/bennidi/mbassador/pulls?q=is%3Apr+is%3Aclosed). It was always a pleasure to see how users got engaged into the libraries development and support. Special thanks go to\n+I also want to thank all githubbers who have made [contributions](https://github.com/bennidi/mbassador/pulls?q=is%3Apr+is%3Aclosed). Special thanks go to\n + [arne-vandamme](http://github.com/arne-vandamme) for adding support for [meta-annotations](https://github.com/bennidi/mbassador/pull/74)\n + [Bernd Rosstauscher](http://github.com/Rossi1337) for providing an initial integration with JUEL\n + [David Sowerby](http://github.com/davidsowerby) for answering user questions, his tutorial on [guice integration](bennidi/mbassador/wiki/guice-integration) and his various PRs\n@@ -129,7 +137,7 @@ I also want to thank all githubbers who have made [contributions](https://github\n Many thanks also to ej-technologies for providing me with an open source license of \n [![JProfiler](http://www.ej-technologies.com/images/banners/jprofiler_small.png)](http://www.ej-technologies.com/products/jprofiler/overview.html) and Jetbrains for a license of [IntelliJ IDEA](http://www.jetbrains.com/idea/)\n \n-Mbassador uses the following open source projects:\n+MBassador uses the following open source projects:\n \n * [jUnit](http://www.junit.org)\n * [maven](http://www.maven.org)\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "build.gradle",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -2,7 +2,7 @@ apply plugin: 'java'\n apply plugin: 'war' // needed for providedCompile\n \n group=\"org.mbassy\"\n-version=\"1.2.4-SNAPSHOT\"\n+version=\"1.2.5-SNAPSHOT\"\n \n \n \n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "changelog/README.md",
            "additions": 10,
            "deletions": 0
        },
        "diff content": "@@ -1,3 +1,13 @@\n+### 1.3.0\n+ + Non-Breaking API changes\n+   + Extended IMessagePublication to allow for error reporting using `hasError()` and `getError()`\n+   + Any publication method now returns an IMessagePublication object. This resolves [PR-127](../pull/127). Any dispatched\n+    message publication can now be inspected for execution error. Does not support collection of multiple errors due to implied\n+    GC and memory allocation overhead in high-throughput scenarios.\n+ + Breaking API changes\n+    + Added MessagePublication to IHandlerInvocation.invoke(...)\n+    + Added MessagePublication to IMessageDispatcher.dispatch(...)\n+\n ### 1.2.4.2\n  + Updated pom. Now using nexus-staging plugin\n  + Removed pmd\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 8,
            "deletions": 3
        },
        "diff content": "@@ -3,7 +3,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.5-SNAPSHOT</version>\n+    <version>1.3.0</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -24,8 +24,8 @@\n     Documentation for this pom see\n         http://central.sonatype.org/pages/apache-maven.html\n \n-    mvn clean deploy\n-    mvn nexus-staging:release\n+    For deployment (and release of non SNAPSHOT): mvn clean deploy\n+    For manual release of staging: mvn nexus-staging:release\n     git push origin <tag>\n \n     -->\n@@ -323,6 +323,11 @@\n                                         Sets the name of the property containing the settings\n                                         for JaCoCo runtime agent.\n                                     -->\n+                                    <!--\n+                                    <excludes>\n+                                        <exclude>net.engio.mbassy.bus.error.*</exclude>\n+                                    </excludes>\n+                                    -->\n                                     <propertyName>surefireArgLine</propertyName>\n                                 </configuration>\n                             </execution>\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -80,7 +80,7 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n         return runtime;\n     }\n \n-    protected IMessagePublication createMessagePublication(T message) {\n+    protected MessagePublication createMessagePublication(T message) {\n         Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n         if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass()\n                 .equals(DeadMessage.class)) {\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -82,7 +82,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n \n \n     // this method queues a message delivery request\n-    protected IMessagePublication addAsynchronousPublication(IMessagePublication publication) {\n+    protected IMessagePublication addAsynchronousPublication(MessagePublication publication) {\n         try {\n             pendingMessages.put(publication);\n             return publication.markScheduled();\n@@ -93,7 +93,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n     }\n \n     // this method queues a message delivery request\n-    protected IMessagePublication addAsynchronousPublication(IMessagePublication publication, long timeout, TimeUnit unit) {\n+    protected IMessagePublication addAsynchronousPublication(MessagePublication publication, long timeout, TimeUnit unit) {\n         try {\n             return pendingMessages.offer(publication, timeout, unit)\n                     ? publication.markScheduled()\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/IMessagePublication.java",
            "additions": 3,
            "deletions": 10
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy.bus;\n \n+import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.subscription.Subscription;\n \n /**\n@@ -15,11 +16,6 @@ import net.engio.mbassy.subscription.Subscription;\n  */\n public interface IMessagePublication {\n \n-    boolean add(Subscription subscription);  // TODO: this method should not be part of the interface\n-\n-    /*\n-    TODO: document state transitions\n-     */\n     void execute();\n \n     boolean isFinished();\n@@ -28,9 +24,9 @@ public interface IMessagePublication {\n \n     boolean isScheduled();\n \n-    void markDelivered(); // TODO: this method should not be part of the interface\n+    boolean hasError();\n \n-    IMessagePublication markScheduled(); // TODO: this method should not be part of the interface\n+    PublicationError getError();\n \n     boolean isDeadMessage();\n \n@@ -38,7 +34,4 @@ public interface IMessagePublication {\n \n     Object getMessage();\n \n-\n-    // TODO: This interface should only be used as return type to public API calls (clients). Internally the implementation\n-    // of the interface should be used. This would allow to remove the unwanted methods from this interface.\n }\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MBassador.java",
            "additions": 6,
            "deletions": 8
        },
        "diff content": "@@ -45,10 +45,6 @@ public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCo\n         super(configuration);\n     }\n \n-\n-\n-\n-\n     public IMessagePublication publishAsync(T message) {\n         return addAsynchronousPublication(createMessagePublication(message));\n     }\n@@ -64,17 +60,19 @@ public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCo\n      *\n      * @param message\n      */\n-    public void publish(T message) {\n+    public IMessagePublication publish(T message) {\n+        IMessagePublication publication = createMessagePublication(message);\n         try {\n-            IMessagePublication publication = createMessagePublication(message);\n             publication.execute();\n         } catch (Throwable e) {\n             handlePublicationError(new PublicationError()\n                     .setMessage(\"Error during publication of message\")\n                     .setCause(e)\n-                    .setPublishedMessage(message));\n+                    .setPublication(publication));\n+        }\n+        finally{\n+            return publication;\n         }\n-\n     }\n \n \n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MessagePublication.java",
            "additions": 21,
            "deletions": 7
        },
        "diff content": "@@ -2,6 +2,7 @@ package net.engio.mbassy.bus;\n \n import net.engio.mbassy.bus.common.DeadMessage;\n import net.engio.mbassy.bus.common.FilteredMessage;\n+import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.subscription.Subscription;\n \n import java.util.Collection;\n@@ -23,8 +24,10 @@ public class MessagePublication implements IMessagePublication {\n     private final Object message;\n     // message publications can be referenced by multiple threads to query publication progress\n     private volatile State state = State.Initial;\n-    private volatile boolean delivered = false;\n+    private volatile boolean dispatched = false;\n     private final BusRuntime runtime;\n+    private PublicationError error = null;\n+\n \n     protected MessagePublication(BusRuntime runtime, Collection<Subscription> subscriptions, Object message, State initialState) {\n         this.runtime = runtime;\n@@ -51,7 +54,7 @@ public class MessagePublication implements IMessagePublication {\n         // This happens if subscriptions are empty (due to GC of weak listeners or explicit desubscription)\n         // or if configured filters do not let a message pass. The flag is set by the dispatchers.\n         // META: This seems to be a suboptimal design\n-        if (!delivered) {\n+        if (!dispatched) {\n             if (!isFilteredMessage() && !isDeadMessage()) {\n                 runtime.getProvider().publish(new FilteredMessage(message));\n             } else if (!isDeadMessage()) {\n@@ -73,8 +76,20 @@ public class MessagePublication implements IMessagePublication {\n         return state.equals(State.Scheduled);\n     }\n \n-    public void markDelivered() {\n-        delivered = true;\n+    public boolean hasError() {\n+        return this.error != null;\n+    }\n+\n+    @Override\n+    public PublicationError getError() {\n+        return error;\n+    }\n+\n+    public void markDispatched() {\n+        dispatched = true;\n+    }\n+    public void markError(PublicationError error) {\n+        this.error = error;\n     }\n \n     public MessagePublication markScheduled() {\n@@ -84,7 +99,6 @@ public class MessagePublication implements IMessagePublication {\n         return this;\n     }\n \n-\n     public boolean isDeadMessage() {\n         return DeadMessage.class.equals(message.getClass());\n     }\n@@ -98,12 +112,12 @@ public class MessagePublication implements IMessagePublication {\n     }\n \n     private enum State {\n-        Initial, Scheduled, Running, Finished, Error\n+        Initial, Scheduled, Running, Finished\n     }\n \n     public static class Factory {\n \n-        public IMessagePublication createPublication(BusRuntime runtime, Collection<Subscription> subscriptions, Object message) {\n+        public MessagePublication createPublication(BusRuntime runtime, Collection<Subscription> subscriptions, Object message) {\n             return new MessagePublication(runtime, subscriptions, message, State.Initial);\n         }\n \n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/SyncMessageBus.java",
            "additions": 8,
            "deletions": 5
        },
        "diff content": "@@ -42,14 +42,17 @@ public class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements PubSu\n     }\n \n     @Override\n-    public void publish(T message) {\n+    public IMessagePublication publish(T message) {\n+        IMessagePublication publication = createMessagePublication(message);\n         try {\n-            IMessagePublication publication = createMessagePublication(message);\n             publication.execute();\n         } catch (Throwable e) {\n             handlePublicationError(new PublicationError().setMessage(\"Error during publication of message\")\n                                                          .setCause(e)\n-                                                         .setPublishedMessage(message));\n+                                                         .setPublication(publication));\n+        }\n+        finally{\n+            return publication;\n         }\n     }\n \n@@ -67,8 +70,8 @@ public class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements PubSu\n         }\n \n         @Override\n-        public void now() {\n-            publish(message);\n+        public IMessagePublication now() {\n+            return publish(message);\n         }\n     }\n }\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/PubSubSupport.java",
            "additions": 3,
            "deletions": 1
        },
        "diff content": "@@ -1,5 +1,7 @@\n package net.engio.mbassy.bus.common;\n \n+import net.engio.mbassy.bus.IMessagePublication;\n+\n /**\n  * This interface defines the very basic message publication semantics according to the publish subscribe pattern.\n  * Listeners can be subscribed and unsubscribed using the corresponding methods. When a listener is subscribed its\n@@ -37,5 +39,5 @@ public interface PubSubSupport<T> extends RuntimeProvider{\n      *\n      * @param message\n      */\n-    void publish(T message);\n+    IMessagePublication publish(T message);\n }\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/error/MessageBusException.java",
            "additions": 0,
            "deletions": 3
        },
        "diff content": "@@ -8,9 +8,6 @@ package net.engio.mbassy.bus.error;\n  */\n public class MessageBusException extends Exception{\n \n-    public MessageBusException() {\n-    }\n-\n     public MessageBusException(String message) {\n         super(message);\n     }\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/error/PublicationError.java",
            "additions": 28,
            "deletions": 21
        },
        "diff content": "@@ -21,53 +21,55 @@ public class PublicationError{\n \n     // Internal state\n     private Throwable cause;\n-    private String message;\n+    private String errorMsg;\n     private Method handler;\n     private Object listener;\n-    private Object publishedMessage;\n+    private IMessagePublication publication;\n+    private Object message;\n+\n \n \n     /**\n      * Compound constructor, creating a PublicationError from the supplied objects.\n      *\n      * @param cause           The Throwable giving rise to this PublicationError.\n-     * @param message         The message to send.\n+     * @param errorMsg         The message to send.\n      * @param handler        The method where the error was created.\n      * @param listener The object in which the PublicationError was generated.\n-     * @param publishedObject The published object which gave rise to the error.\n+     * @param publication The publication that errored\n      */\n     public PublicationError(final Throwable cause,\n-                            final String message,\n+                            final String errorMsg,\n                             final Method handler,\n                             final Object listener,\n-                            final Object publishedObject) {\n+                            final IMessagePublication publication) {\n \n         this.cause = cause;\n-        this.message = message;\n+        this.errorMsg = errorMsg;\n         this.handler = handler;\n         this.listener = listener;\n-        this.publishedMessage = publishedObject;\n+        this.publication = publication;\n+        this.message = publication != null ? publication.getMessage() : null;\n     }\n \n     public PublicationError(final Throwable cause,\n-                            final String message,\n+                            final String errorMsg,\n                             final IMessagePublication publication) {\n         this.cause = cause;\n-        this.message = message;\n-        this.publishedMessage = publication != null ? publication.getMessage() : null;\n+        this.errorMsg = errorMsg;\n     }\n \n     public PublicationError(final Throwable cause,\n-                            final String message,\n+                            final String errorMsg,\n                             final SubscriptionContext context) {\n         this.cause = cause;\n-        this.message = message;\n+        this.errorMsg = errorMsg;\n         this.handler = context.getHandler().getMethod();\n     }\n \n-    public PublicationError(Throwable cause, String message) {\n+    public PublicationError(Throwable cause, String errorMsg) {\n         this.cause = cause;\n-        this.message = message;\n+        this.errorMsg = errorMsg;\n     }\n \n \n@@ -97,10 +99,15 @@ public class PublicationError{\n     }\n \n     public String getMessage() {\n-        return message;\n+        return errorMsg;\n     }\n \n     public PublicationError setMessage(String message) {\n+        this.errorMsg = message;\n+        return this;\n+    }\n+\n+    public PublicationError setPublishedMessage(Object message) {\n         this.message = message;\n         return this;\n     }\n@@ -124,11 +131,11 @@ public class PublicationError{\n     }\n \n     public Object getPublishedMessage() {\n-        return publishedMessage;\n+        return message;\n     }\n \n-    public PublicationError setPublishedMessage(Object publishedMessage) {\n-        this.publishedMessage = publishedMessage;\n+    public PublicationError setPublication(IMessagePublication publication) {\n+        this.publication = publication;\n         return this;\n     }\n \n@@ -142,13 +149,13 @@ public class PublicationError{\n                 newLine +\n                 \"\\tcause=\" + cause +\n                 newLine +\n-                \"\\tmessage='\" + message + '\\'' +\n+                \"\\tmessage='\" + errorMsg + '\\'' +\n                 newLine +\n                 \"\\thandler=\" + handler +\n                 newLine +\n                 \"\\tlistener=\" + listener +\n                 newLine +\n-                \"\\tpublishedMessage=\" + publishedMessage +\n+                \"\\tpublishedMessage=\" + getPublishedMessage() +\n                 '}';\n     }\n }\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/publication/IPublicationCommand.java",
            "additions": 3,
            "deletions": 1
        },
        "diff content": "@@ -1,5 +1,7 @@\n package net.engio.mbassy.bus.publication;\n \n+import net.engio.mbassy.bus.IMessagePublication;\n+\n /**\n  * A publication command is used as an intermediate object created by a call to the message bus' post method.\n  * It encapsulates the message publication flavors provided by the message bus implementation that created the command.\n@@ -11,5 +13,5 @@ public interface IPublicationCommand {\n      * Execute the message publication immediately. This call blocks until every matching message handler\n      * has been invoked.\n      */\n-    void now();\n+    IMessagePublication now();\n }\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/publication/SyncAsyncPostCommand.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -22,8 +22,8 @@ public class SyncAsyncPostCommand<T> implements ISyncAsyncPublicationCommand {\n     }\n \n     @Override\n-    public void now() {\n-        mBassador.publish(message);\n+    public IMessagePublication now() {\n+        return mBassador.publish(message);\n     }\n \n     @Override\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java",
            "additions": 3,
            "deletions": 2
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n \n@@ -27,11 +28,11 @@ public class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAw\n      * {@inheritDoc}\n      */\n     @Override\n-    public void invoke(final Object listener, final Object message){\n+    public void invoke(final Object listener, final Object message, final MessagePublication publication){\n         executor.execute(new Runnable() {\n             @Override\n             public void run() {\n-                    delegate.invoke(listener, message);\n+                    delegate.invoke(listener, message, publication);\n             }\n         });\n     }\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.dispatch;\n \n import net.engio.mbassy.bus.IMessagePublication;\n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.subscription.MessageEnvelope;\n \n /**\n@@ -20,7 +21,7 @@ public class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher {\n     }\n \n     @Override\n-    public void dispatch(IMessagePublication publication, Object message, Iterable listeners){\n+    public void dispatch(MessagePublication publication, Object message, Iterable listeners){\n         getDelegate().dispatch(publication, new MessageEnvelope(message), listeners);\n     }\n }\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.dispatch;\r\n \r\n import net.engio.mbassy.bus.IMessagePublication;\r\n+import net.engio.mbassy.bus.MessagePublication;\r\n import net.engio.mbassy.listener.IMessageFilter;\r\n \r\n /**\r\n@@ -36,7 +37,7 @@ public final class FilteredMessageDispatcher extends DelegatingMessageDispatcher\n \r\n \r\n     @Override\r\n-    public void dispatch(IMessagePublication publication, Object message, Iterable listeners){\r\n+    public void dispatch(MessagePublication publication, Object message, Iterable listeners){\r\n         if (passesFilter(message)) {\r\n             getDelegate().dispatch(publication, message, listeners);\r\n         }\r\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/HandlerInvocation.java",
            "additions": 3,
            "deletions": 1
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n@@ -20,7 +21,8 @@ public abstract class HandlerInvocation<HANDLER, MESSAGE> extends AbstractSubscr\n         super(context);\n     }\n \n-    protected final void handlePublicationError(PublicationError error){\n+    protected final void handlePublicationError(MessagePublication publication, PublicationError error){\n+        publication.markError(error);\n         getContext().handleError(error);\n     }\n }\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.subscription.ISubscriptionContextAware;\n \n /**\n@@ -25,5 +26,5 @@ public interface IHandlerInvocation<HANDLER, MESSAGE> extends ISubscriptionConte\n      * @param message  The message to be delivered to the handler. This can be any object compatible with the object\n      *                 type that the handler consumes\n      */\n-    void invoke(HANDLER handler, MESSAGE message);\n+    void invoke(HANDLER handler, MESSAGE message, MessagePublication publication);\n }\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.dispatch;\n \n import net.engio.mbassy.bus.IMessagePublication;\n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.subscription.ISubscriptionContextAware;\n \n /**\n@@ -29,7 +30,7 @@ public interface IMessageDispatcher extends ISubscriptionContextAware {\n      * @param message     The message that should be delivered to the listeners\n      * @param listeners   The listeners that should receive the message\n      */\n-    void dispatch(IMessagePublication publication, Object message, Iterable listeners);\n+    void dispatch(MessagePublication publication, Object message, Iterable listeners);\n \n     /**\n      * Get the handler invocation that will be used to deliver the\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.bus.IMessagePublication;\n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n import net.engio.mbassy.subscription.SubscriptionContext;\n \n@@ -24,10 +24,10 @@ public class MessageDispatcher extends AbstractSubscriptionContextAware implemen\n     }\n \n     @Override\n-    public void dispatch(final IMessagePublication publication, final Object message, final Iterable listeners){\n-        publication.markDelivered();\n+    public void dispatch(final MessagePublication publication, final Object message, final Iterable listeners){\n+        publication.markDispatched();\n         for (Object listener : listeners) {\n-            getInvocation().invoke(listener, message);\n+            getInvocation().invoke(listener, message, publication);\n         }\n     }\n \n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java",
            "additions": 20,
            "deletions": 22
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.subscription.SubscriptionContext;\n \n@@ -18,34 +19,31 @@ public class ReflectiveHandlerInvocation extends HandlerInvocation{\n         super(context);\n     }\n \n-    protected void invokeHandler(final Object message, final Object listener, Method handler){\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void invoke(final Object listener, final Object message, MessagePublication publication){\n+        final Method handler = getContext().getHandler().getMethod();\n         try {\n             handler.invoke(listener, message);\n         } catch (IllegalAccessException e) {\n-            handlePublicationError(new PublicationError(e, \"Error during invocation of message handler. \" +\n-                            \"The class or method is not accessible\",\n-                            handler, listener, message));\n+            handlePublicationError(publication, new PublicationError(e, \"Error during invocation of message handler. \" +\n+                    \"The class or method is not accessible\",\n+                    handler, listener, publication));\n         } catch (IllegalArgumentException e) {\n-            handlePublicationError(new PublicationError(e, \"Error during invocation of message handler. \" +\n-                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n-                            + \"Expected: \" + handler.getParameterTypes()[0],\n-                            handler, listener, message));\n+            handlePublicationError(publication, new PublicationError(e, \"Error during invocation of message handler. \" +\n+                    \"Wrong arguments passed to method. Was: \" + message.getClass()\n+                    + \"Expected: \" + handler.getParameterTypes()[0],\n+                    handler, listener, publication));\n         } catch (InvocationTargetException e) {\n-            handlePublicationError( new PublicationError(e, \"Error during invocation of message handler. \" +\n-                            \"Message handler threw exception\",\n-                            handler, listener, message));\n+            handlePublicationError(publication, new PublicationError(e, \"Error during invocation of message handler. \" +\n+                    \"There might be an access rights problem. Do you use non public inner classes?\",\n+                    handler, listener, publication));\n         } catch (Throwable e) {\n-            handlePublicationError( new PublicationError(e, \"Error during invocation of message handler. \" +\n-                            \"The handler code threw an exception\",\n-                            handler, listener, message));\n+            handlePublicationError(publication, new PublicationError(e, \"Error during invocation of message handler. \" +\n+                    \"The handler code threw an exception\",\n+                    handler, listener, publication));\n         }\n     }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public void invoke(final Object listener, final Object message){\n-        invokeHandler(message, listener, getContext().getHandler().getMethod());\n-    }\n }\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/SynchronizedHandlerInvocation.java",
            "additions": 3,
            "deletions": 2
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n \n /**\n@@ -21,9 +22,9 @@ public class SynchronizedHandlerInvocation extends AbstractSubscriptionContextAw\n      * {@inheritDoc}\n      */\n     @Override\n-    public void invoke(final Object listener, final Object message){\n+    public void invoke(final Object listener, final Object message, MessagePublication publication){\n         synchronized (listener){\n-            delegate.invoke(listener, message);\n+            delegate.invoke(listener, message, publication);\n         }\n     }\n \n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.subscription;\n \n import net.engio.mbassy.bus.IMessagePublication;\n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.dispatch.IMessageDispatcher;\n \n import java.util.ArrayList;\n@@ -66,7 +67,7 @@ public class Subscription {\n     }\n \n \n-    public void publish(IMessagePublication publication, Object message){\n+    public void publish(MessagePublication publication, Object message){\n         if(!listeners.isEmpty())\n             dispatcher.dispatch(publication, message, listeners);\n     }\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConcurrentSetTest.java",
            "additions": 56,
            "deletions": 6
        },
        "diff content": "@@ -7,6 +7,7 @@ import org.junit.Before;\n import org.junit.Test;\n \n import java.util.*;\n+import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.CopyOnWriteArraySet;\n import java.util.concurrent.atomic.AtomicInteger;\n \n@@ -27,6 +28,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n     protected final int numberOfElements = 100000;\n     protected final int numberOfThreads = 50;\n \n+    // needed to avoid premature garbage collection for weakly referenced listeners\n     protected Set gcProtector = new HashSet();\n \n     @Before\n@@ -38,6 +40,59 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n     protected abstract Collection createSet();\n \n \n+    @Test\n+    public void testAddAll() {\n+        final Collection testSet = createSet();\n+        final List<Number> notFound = new CopyOnWriteArrayList<Number>();\n+        // insert all elements (containing duplicates) into the set\n+        final Random rand = new Random();\n+        ConcurrentExecutor.runConcurrent(new Runnable() {\n+            @Override\n+            public void run() {\n+                final List<Number> source = new LinkedList<Number>();\n+                for (int i = 0; i < numberOfElements; i++) {\n+                    source.add(rand.nextDouble());\n+                }\n+                testSet.addAll(source);\n+                for (Number src : source) {\n+                    if(!testSet.contains(src)){\n+                        notFound.add(src);\n+                    }\n+                }\n+            }\n+        }, numberOfThreads);\n+\n+        // check that the control set and the test set contain the exact same elements\n+        assertEquals(notFound.size(), 0);\n+    }\n+\n+    @Test\n+    public void testAdd() {\n+        final Collection testSet = createSet();\n+        final List<Number> notFound = new CopyOnWriteArrayList<Number>();\n+        final Random rand = new Random();\n+        // insert all elements (containing duplicates) into the set\n+        ConcurrentExecutor.runConcurrent(new Runnable() {\n+            @Override\n+            public void run() {\n+                final List<Number> source = new LinkedList<Number>();\n+                for (int i = 0; i < numberOfElements; i++) {\n+                    source.add(rand.nextDouble());\n+                }\n+                for (Number src : source) {\n+                    testSet.add(src);\n+                    if(!testSet.contains(src)){\n+                        notFound.add(src);\n+                    }\n+                }\n+            }\n+        }, numberOfThreads);\n+\n+        // check that the control set and the test set contain the exact same elements\n+        assertEquals(notFound.size(), 0);\n+    }\n+\n+\n     @Test\n     public void testUniqueness() {\n         final LinkedList<Object> duplicates = new LinkedList<Object>();\n@@ -158,7 +213,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n \n         // ensure that the test set does not contain any of the elements that have been removed from it\n         for (Object tar : testSet) {\n-            Assert.assertTrue(!toRemove.contains(tar));\n+            assertTrue(!toRemove.contains(tar));\n         }\n         // ensure that the test set still contains all objects from the source set that have not been marked\n         // for removal\n@@ -352,9 +407,4 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n             result.remove(excluded);\n         return result;\n     }\n-\n-    protected void protectFromGarbageCollector(Set elements){\n-        for(Object element : elements)\n-            gcProtector.add(element);\n-    }\n }\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MethodDispatchTest.java",
            "additions": 25,
            "deletions": 20
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy;\n \n+import net.engio.mbassy.bus.IMessagePublication;\n import net.engio.mbassy.bus.common.IMessageBus;\n import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.common.MessageBusTest;\n@@ -15,17 +16,17 @@ import java.util.concurrent.atomic.AtomicInteger;\n  * @author bennidi\n  *         Date: 1/17/13\n  */\n-public class MethodDispatchTest extends MessageBusTest{\n+public class MethodDispatchTest extends MessageBusTest {\n \n-   private boolean listener1Called = false;\n-   private boolean listener2Called = false;\n+    private boolean listener1Called = false;\n+    private boolean listener2Called = false;\n \n     // a simple event listener\n     public class EventListener1 {\n \n         @Handler\n         public void handleString(String s) {\n-             listener1Called = true;\n+            listener1Called = true;\n         }\n \n     }\n@@ -35,44 +36,48 @@ public class MethodDispatchTest extends MessageBusTest{\n \n         // redefine handler implementation (not configuration)\n         public void handleString(String s) {\n-           listener2Called = true;\n+            listener2Called = true;\n         }\n \n     }\n \n     @Test\n-    public void testDispatch1(){\n+    public void testDispatchWithSequentialSubscription() {\n         IMessageBus bus = createBus(SyncAsync());\n         EventListener2 listener2 = new EventListener2();\n         bus.subscribe(listener2);\n-        bus.post(\"jfndf\").now();\n+        bus.post(\"only one listener registered\").now();\n         assertTrue(listener2Called);\n         assertFalse(listener1Called);\n \n         EventListener1 listener1 = new EventListener1();\n         bus.subscribe(listener1);\n-        bus.post(\"jfndf\").now();\n+        bus.post(\"second listener registered and called\").now();\n         assertTrue(listener1Called);\n     }\n \n     @Test\n-    public void testAsyncDispatchAfterExceptionInErrorHandler() throws InterruptedException\n-    {\n-        IMessageBus bus = createBus(SyncAsync(true /*configures an error handler that throws exception*/).addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1)));\n-        final AtomicInteger msgHandlerCounter=new AtomicInteger(0);\n-        bus.subscribe(new Object()\n-        {\n+    public void testAsyncDispatchAfterExceptionInErrorHandler() throws InterruptedException {\n+        IMessageBus bus = createBus(SyncAsync(false /*configures an error handler that throws exception*/).addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1)));\n+        final AtomicInteger msgHandlerCounter = new AtomicInteger(0);\n+        bus.subscribe(new Object() {\n             @Handler\n-            public void handleAndThrowException(String s) throws Exception\n-            {\n+            public void handleAndThrowException(String s) throws Exception {\n                 msgHandlerCounter.incrementAndGet();\n                 throw new Exception(\"error in msg handler on call no. \" + msgHandlerCounter.get());\n             }\n         });\n-        bus.post(\"first event - event handler will raise exception followed by another exception in the error handler\").asynchronously();\n-        bus.post(\"second event - expecting that msg dispatcher will still dispatch this after encountering exception in error handler\").asynchronously();\n+        IMessagePublication first = bus.post(\"first event - event handler will raise exception followed by another exception in the error handler\").asynchronously();\n+        IMessagePublication second = bus.post(\"second event - expecting that msg dispatcher will still dispatch this after encountering exception in error handler\").asynchronously();\n         pause(200);\n-        Assert.assertEquals(\"msg handler is called also on the 2nd event after an exception in error handler following 1st event error\", 2, msgHandlerCounter.get());\n-        Assert.assertFalse(\"no more messages left to process\", bus.hasPendingMessages());\n+        assertEquals(\"msg handler is called also on the 2nd event after an exception in error handler following 1st event error\", 2, msgHandlerCounter.get());\n+        assertFalse(\"no more messages left to process\", bus.hasPendingMessages());\n+        assertTrue(first.hasError());\n+        assertTrue(first.isFinished());\n+        assertNotNull(first.getError().toString());\n+        assertEquals(first.getError().getPublishedMessage(),\"first event - event handler will raise exception followed by another exception in the error handler\" );\n+        assertTrue(second.hasError());\n+        assertTrue(second.isFinished());\n+        assertNotNull(second.getError().toString());\n     }\n }\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/AssertSupport.java",
            "additions": 4,
            "deletions": 0
        },
        "diff content": "@@ -92,6 +92,10 @@ public class AssertSupport {\n         Assert.assertFalse(message, condition);\n     }\n \n+    public void assertEquals(String message, Object expected, Object actual) {\n+        Assert.assertEquals(message, expected, actual);\n+    }\n+\n     public void assertEquals(Object expected, Object actual) {\n         Assert.assertEquals(expected, actual);\n     }\n"
    },
    {
        "commit hash": "744c029ea08c536b3c2fd7f86bcf4ad04b5d311b",
        "previous commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/CustomInvocationListener.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy.listeners;\n \n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.dispatch.HandlerInvocation;\n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Listener;\n@@ -27,7 +28,7 @@ public class CustomInvocationListener {\n         }\n \n         @Override\n-        public void invoke(CustomInvocationListener listener, StandardMessage message) {\n+        public void invoke(CustomInvocationListener listener, StandardMessage message, MessagePublication publication) {\n             listener.handle(message);\n         }\n     }\n"
    },
    {
        "commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "previous commit hash": "e2d9b8f6869182abcb9ffc77038d9343b1753e0c",
        "diff stats": {
            "file_path": "changelog/README.md",
            "additions": 4,
            "deletions": 3
        },
        "diff content": "@@ -1,6 +1,7 @@\n-### 1.2.4.1\n- + Updated maven plugins\n- + Fixed #133\n+### 1.2.4.2\n+ + Updated pom. Now using nexus-staging plugin\n+ + Removed pmd\n+ + Fixed #135 and #136\n \n ### [1.2.4](http://github.com/bennidi/mbassador/milestones/1.2.4)\n  + API-Changes:\n"
    },
    {
        "commit hash": "96986c3637b173fa5f172b5f7382854b7a386faf",
        "previous commit hash": "e2d9b8f6869182abcb9ffc77038d9343b1753e0c",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 12,
            "deletions": 1
        },
        "diff content": "@@ -3,7 +3,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.4.2</version>\n+    <version>1.2.5-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -19,6 +19,17 @@\n         configurable message filters,\n     </description>\n \n+    <!--\n+\n+    Documentation for this pom see\n+        http://central.sonatype.org/pages/apache-maven.html\n+\n+    mvn clean deploy\n+    mvn nexus-staging:release\n+    git push origin <tag>\n+\n+    -->\n+\n     <url>https://github.com/bennidi/mbassador</url>\n     <licenses>\n         <license>\n"
    },
    {
        "commit hash": "e2d9b8f6869182abcb9ffc77038d9343b1753e0c",
        "previous commit hash": "2bf0f19f327e29b081aa7b2a4a85fc82107c544a",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 20,
            "deletions": 1
        },
        "diff content": "@@ -3,7 +3,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.4.2-SNAPSHOT</version>\n+    <version>1.2.4.2</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -54,6 +54,10 @@\n             <id>ossrh</id>\n             <url>https://oss.sonatype.org/content/repositories/snapshots</url>\n         </snapshotRepository>\n+        <repository>\n+            <id>ossrh</id>\n+            <url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>\n+        </repository>\n     </distributionManagement>\n \n     <dependencies>\n@@ -141,6 +145,21 @@\n                 </configuration>\n             </plugin>\n \n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-gpg-plugin</artifactId>\n+                <version>1.6</version>\n+                <executions>\n+                    <execution>\n+                        <id>sign-artifacts</id>\n+                        <phase>verify</phase>\n+                        <goals>\n+                            <goal>sign</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n             <plugin>\n                 <groupId>org.apache.felix</groupId>\n                 <artifactId>maven-bundle-plugin</artifactId>\n"
    },
    {
        "commit hash": "2bf0f19f327e29b081aa7b2a4a85fc82107c544a",
        "previous commit hash": "796486ba772e70cf709a0c8799de3d889dfb029c",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 21,
            "deletions": 48
        },
        "diff content": "@@ -1,15 +1,9 @@\n <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n \n-    <parent>\n-        <groupId>org.sonatype.oss</groupId>\n-        <artifactId>oss-parent</artifactId>\n-        <version>7</version>\n-    </parent>\n-\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.5-SNAPSHOT</version>\n+    <version>1.2.4.2-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -55,6 +49,13 @@\n         <github.url>file://${project.basedir}/mvn-local-repo</github.url>\n     </properties>\n \n+    <distributionManagement>\n+        <snapshotRepository>\n+            <id>ossrh</id>\n+            <url>https://oss.sonatype.org/content/repositories/snapshots</url>\n+        </snapshotRepository>\n+    </distributionManagement>\n+\n     <dependencies>\n \n         <dependency>\n@@ -115,9 +116,6 @@\n \n \n     </dependencies>\n-    <distributionManagement>\n-\n-    </distributionManagement>\n \n     <!--  Local repository (for testing)\n     <distributionManagement>\n@@ -130,6 +128,19 @@\n \n     <build>\n         <plugins>\n+\n+            <plugin>\n+                <groupId>org.sonatype.plugins</groupId>\n+                <artifactId>nexus-staging-maven-plugin</artifactId>\n+                <version>1.6.7</version>\n+                <extensions>true</extensions>\n+                <configuration>\n+                    <serverId>ossrh</serverId>\n+                    <nexusUrl>https://oss.sonatype.org/</nexusUrl>\n+                    <autoReleaseAfterClose>true</autoReleaseAfterClose>\n+                </configuration>\n+            </plugin>\n+\n             <plugin>\n                 <groupId>org.apache.felix</groupId>\n                 <artifactId>maven-bundle-plugin</artifactId>\n@@ -308,43 +319,5 @@\n                 </plugins>\n             </build>\n         </profile>\n-\n-\n-        <!-- Configure the signing of the artefact when the release is performed\n-\n-        mvn clean deploy\n-        mvn release:clean\n-        mvn release:prepare\n-        mvn release:perform\n-\n-\n-        -->\n-        <profile>\n-            <id>release-sign-artifacts</id>\n-            <activation>\n-                <property>\n-                    <name>performRelease</name>\n-                    <value>true</value>\n-                </property>\n-            </activation>\n-            <build>\n-                <plugins>\n-                    <plugin>\n-                        <groupId>org.apache.maven.plugins</groupId>\n-                        <artifactId>maven-gpg-plugin</artifactId>\n-                        <version>1.6</version>\n-                        <executions>\n-                            <execution>\n-                                <id>sign-artifacts</id>\n-                                <phase>verify</phase>\n-                                <goals>\n-                                    <goal>sign</goal>\n-                                </goals>\n-                            </execution>\n-                        </executions>\n-                    </plugin>\n-                </plugins>\n-            </build>\n-        </profile>\n     </profiles>\n </project>\n"
    },
    {
        "commit hash": "796486ba772e70cf709a0c8799de3d889dfb029c",
        "previous commit hash": "a8f6a28d20bdefae25a6d9bcd921b2a5d9080379",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.4.1</version>\n+    <version>1.2.5-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.2.4.1</tag>\n+        <tag>mbassador-1.2.2</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n     </scm>\n     <developers>\n"
    },
    {
        "commit hash": "a8f6a28d20bdefae25a6d9bcd921b2a5d9080379",
        "previous commit hash": "44ec003b03f209b3d3909dd5c38f2aac1cabc239",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 3,
            "deletions": 4
        },
        "diff content": "@@ -1,5 +1,4 @@\n-<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n \n     <parent>\n         <groupId>org.sonatype.oss</groupId>\n@@ -10,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.4.1-SNAPSHOT</version>\n+    <version>1.2.4.1</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -36,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.2.2</tag>\n+        <tag>mbassador-1.2.4.1</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n     </scm>\n     <developers>\n"
    },
    {
        "commit hash": "44ec003b03f209b3d3909dd5c38f2aac1cabc239",
        "previous commit hash": "2163a530c4cdad3a3fea87c841ad902a7efbc099",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 3,
            "deletions": 35
        },
        "diff content": "@@ -50,10 +50,7 @@\n     </developers>\n \n     <properties>\n-        <nazgul-codestyle.version>2.0.1</nazgul-codestyle.version>\n         <jdk.version>1.6</jdk.version>\n-        <pmd.plugin.version>3.0.1</pmd.plugin.version>\n-        <nazgul.codestyle.version>4.1.1</nazgul.codestyle.version>\n         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n         <project.build.java.version>1.6</project.build.java.version>\n         <github.url>file://${project.basedir}/mvn-local-repo</github.url>\n@@ -119,6 +116,9 @@\n \n \n     </dependencies>\n+    <distributionManagement>\n+\n+    </distributionManagement>\n \n     <!--  Local repository (for testing)\n     <distributionManagement>\n@@ -131,38 +131,6 @@\n \n     <build>\n         <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-pmd-plugin</artifactId>\n-                <version>${pmd.plugin.version}</version>\n-                <configuration>\n-                    <excludeRoots>\n-                        <excludeRoot>src/main/generated</excludeRoot>\n-                        <excludeRoot>src/test</excludeRoot>\n-                    </excludeRoots>\n-                    <rulesets>\n-                        <ruleset>/codestyle/pmd-rules.xml</ruleset>\n-                    </rulesets>\n-                    <targetJdk>${jdk.version}</targetJdk>\n-                    <sourceEncoding>${project.build.sourceEncoding}</sourceEncoding>\n-                </configuration>\n-                <executions>\n-                    <execution>\n-                        <goals>\n-                            <goal>check</goal>\n-                            <goal>cpd-check</goal>\n-                        </goals>\n-                    </execution>\n-                </executions>\n-                <dependencies>\n-                    <dependency>\n-                        <groupId>se.jguru.nazgul.tools.codestyle</groupId>\n-                        <artifactId>nazgul-codestyle</artifactId>\n-                        <version>${nazgul.codestyle.version}</version>\n-                    </dependency>\n-                </dependencies>\n-            </plugin>\n-\n             <plugin>\n                 <groupId>org.apache.felix</groupId>\n                 <artifactId>maven-bundle-plugin</artifactId>\n"
    },
    {
        "commit hash": "2163a530c4cdad3a3fea87c841ad902a7efbc099",
        "previous commit hash": "6a0ca6039c8ad6ce04f01ac1bf3c50fe1dadf57e",
        "diff stats": {
            "file_path": "changelog/README.md",
            "additions": 4,
            "deletions": 0
        },
        "diff content": "@@ -1,3 +1,7 @@\n+### 1.2.4.1\n+ + Updated maven plugins\n+ + Fixed #133\n+\n ### [1.2.4](http://github.com/bennidi/mbassador/milestones/1.2.4)\n  + API-Changes:\n    + Remove IBusConfiguration.{handleError,addConfigurationErrorHandler} => Configuration errors are communicated as RuntimeExceptions\n"
    },
    {
        "commit hash": "2163a530c4cdad3a3fea87c841ad902a7efbc099",
        "previous commit hash": "6a0ca6039c8ad6ce04f01ac1bf3c50fe1dadf57e",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -10,7 +10,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.5-SNAPSHOT</version>\n+    <version>1.2.4.1-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -189,7 +189,7 @@\n             <plugin>\n                 <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-release-plugin</artifactId>\n-                <version>2.5.2</version>\n+                <version>2.5.3</version>\n                 <configuration>\n                     <mavenExecutorId>forked-path</mavenExecutorId>\n                 </configuration>\n@@ -257,7 +257,7 @@\n             <plugin>\n                 <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-scm-publish-plugin</artifactId>\n-                <version>1.0-beta-2</version>\n+                <version>1.1</version>\n                 <configuration>\n                     <checkoutDirectory>${project.build.directory}/scmpublish</checkoutDirectory>\n                     <checkinComment>Publishing javadoc for ${project.artifactId}:${project.version}</checkinComment>\n"
    },
    {
        "commit hash": "bf8a2b0873c187855322da7effbc9a21160e97c3",
        "previous commit hash": "94d8ffcb5d47b606b20a83da24844c942ba0368c",
        "diff stats": {
            "file_path": "build.gradle",
            "additions": 2,
            "deletions": 3
        },
        "diff content": "@@ -13,10 +13,9 @@ repositories {\n \n dependencies {\n \n-    testCompile \"junit:junit:4.10\"\n-    testCompile 'org.assertj:assertj-core:2.0.0'\n+    testCompile \"junit:junit:4.12\"\n+    testCompile 'org.assertj:assertj-core:3.3.0'\n     testCompile 'org.mockito:mockito-core:1.10.19'\n-    testCompile 'com.mycila.testing.plugins:mycila-testing-mockito:2.8'\n \n     testCompile 'org.slf4j:slf4j-api:1.7.5'\n \n"
    },
    {
        "commit hash": "bf8a2b0873c187855322da7effbc9a21160e97c3",
        "previous commit hash": "94d8ffcb5d47b606b20a83da24844c942ba0368c",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 4,
            "deletions": 10
        },
        "diff content": "@@ -1,4 +1,5 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n \n     <parent>\n         <groupId>org.sonatype.oss</groupId>\n@@ -63,14 +64,14 @@\n         <dependency>\n             <groupId>junit</groupId>\n             <artifactId>junit</artifactId>\n-            <version>4.10</version>\n+            <version>4.12</version>\n             <scope>test</scope>\n         </dependency>\n \n         <dependency>\n             <groupId>org.assertj</groupId>\n             <artifactId>assertj-core</artifactId>\n-            <version>2.0.0</version>\n+            <version>3.3.0</version>\n             <scope>test</scope>\n         </dependency>\n \n@@ -81,13 +82,6 @@\n             <scope>test</scope>\n         </dependency>\n \n-        <dependency>\n-            <groupId>com.mycila.testing.plugins</groupId>\n-            <artifactId>mycila-testing-mockito</artifactId>\n-            <version>2.8</version>\n-            <scope>test</scope>\n-        </dependency>\n-\n         <dependency>\n             <groupId>org.slf4j</groupId>\n             <artifactId>slf4j-api</artifactId>\n"
    },
    {
        "commit hash": "bf8a2b0873c187855322da7effbc9a21160e97c3",
        "previous commit hash": "94d8ffcb5d47b606b20a83da24844c942ba0368c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/bus/AbstractPubSubSupportTest.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,5 @@\n package net.engio.mbassy.bus;\n \n-import com.mycila.testing.junit.MycilaJunitRunner;\n import junit.framework.Assert;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n@@ -10,6 +9,7 @@ import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.Mock;\n+import org.mockito.runners.MockitoJUnitRunner;\n \n import java.io.ByteArrayOutputStream;\n import java.io.PrintStream;\n@@ -24,7 +24,7 @@ import static org.mockito.Mockito.when;\n  * <p/>\n  * Created by David Sowerby on 13/04/15.\n  */\n-@RunWith(MycilaJunitRunner.class)\n+@RunWith(MockitoJUnitRunner.class)\n public class AbstractPubSubSupportTest {\n \n     IBusConfiguration configuration;\n"
    },
    {
        "commit hash": "2c8fd206f9b39d690b953ddb8e2216bfd018d76c",
        "previous commit hash": "ed9e396f914e8399509a9cf4f05b5b16fe355ef3",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -244,6 +244,7 @@\n                     <header>mbassador, ${project.version}</header>\n                     <footer>mbassador, ${project.version}</footer>\n                     <doctitle>mbassador, ${project.version}</doctitle>\n+                    <additionalparam>-Xdoclint:none</additionalparam>\n                 </configuration>\n                 <executions>\n                     <execution>\n"
    },
    {
        "commit hash": "b6db6d26d908536b481b2e9ad41686b4de71f1d1",
        "previous commit hash": "683f1d3cc1510a88af9172dba72a4c62fbf1c9db",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java",
            "additions": 8,
            "deletions": 1
        },
        "diff content": "@@ -101,7 +101,14 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n \n     protected void handlePublicationError(PublicationError error) {\n         for (IPublicationErrorHandler errorHandler : errorHandlers) {\n-            errorHandler.handleError(error);\n+            try\n+            {\n+                errorHandler.handleError(error);\n+            }\n+            catch (Throwable ex)\n+            {\n+                ex.printStackTrace();\n+            }\n         }\n     }\n \n"
    },
    {
        "commit hash": "b6db6d26d908536b481b2e9ad41686b4de71f1d1",
        "previous commit hash": "683f1d3cc1510a88af9172dba72a4c62fbf1c9db",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MethodDispatchTest.java",
            "additions": 24,
            "deletions": 3
        },
        "diff content": "@@ -1,11 +1,14 @@\n package net.engio.mbassy;\n \n import net.engio.mbassy.bus.common.IMessageBus;\n-import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.listener.Handler;\n+import org.junit.Assert;\n import org.junit.Test;\n \n+import java.util.concurrent.atomic.AtomicInteger;\n+\n /**\n  * Very simple test to verify dispatch to correct message handler\n  *\n@@ -17,8 +20,6 @@ public class MethodDispatchTest extends MessageBusTest{\n    private boolean listener1Called = false;\n    private boolean listener2Called = false;\n \n-\n-\n     // a simple event listener\n     public class EventListener1 {\n \n@@ -54,4 +55,24 @@ public class MethodDispatchTest extends MessageBusTest{\n         assertTrue(listener1Called);\n     }\n \n+    @Test\n+    public void testAsyncDispatchAfterExceptionInErrorHandler() throws InterruptedException\n+    {\n+        IMessageBus bus = createBus(SyncAsync(true /*configures an error handler that throws exception*/).addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1)));\n+        final AtomicInteger msgHandlerCounter=new AtomicInteger(0);\n+        bus.subscribe(new Object()\n+        {\n+            @Handler\n+            public void handleAndThrowException(String s) throws Exception\n+            {\n+                msgHandlerCounter.incrementAndGet();\n+                throw new Exception(\"error in msg handler on call no. \" + msgHandlerCounter.get());\n+            }\n+        });\n+        bus.post(\"first event - event handler will raise exception followed by another exception in the error handler\").asynchronously();\n+        bus.post(\"second event - expecting that msg dispatcher will still dispatch this after encountering exception in error handler\").asynchronously();\n+        pause(200);\n+        Assert.assertEquals(\"msg handler is called also on the 2nd event after an exception in error handler following 1st event error\", 2, msgHandlerCounter.get());\n+        Assert.assertFalse(\"no more messages left to process\", bus.hasPendingMessages());\n+    }\n }\n"
    },
    {
        "commit hash": "b6db6d26d908536b481b2e9ad41686b4de71f1d1",
        "previous commit hash": "683f1d3cc1510a88af9172dba72a4c62fbf1c9db",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/bus/AbstractPubSubSupportTest.java",
            "additions": 15,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.bus;\n \n import com.mycila.testing.junit.MycilaJunitRunner;\n+import junit.framework.Assert;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n import net.engio.mbassy.bus.error.PublicationError;\n@@ -12,6 +13,7 @@ import org.mockito.Mock;\n \n import java.io.ByteArrayOutputStream;\n import java.io.PrintStream;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.mockito.Mockito.verify;\n@@ -183,5 +185,17 @@ public class AbstractPubSubSupportTest {\n \n     }\n \n-\n+    @Test\n+    public void testHandlePublicationError_raises_exception() {\n+        final AtomicInteger invocationCounter = new AtomicInteger(0);\n+        SyncMessageBus<String> bus = new SyncMessageBus<String>(new IPublicationErrorHandler() {\n+            @Override\n+            public void handleError(PublicationError error) {\n+                invocationCounter.incrementAndGet();\n+                throw new RuntimeException(\"exception encountered in error handler\");\n+            }\n+        });\n+        bus.handlePublicationError(publicationError);\n+        Assert.assertEquals(1, invocationCounter.get());\n+    }\n }\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "683f1d3cc1510a88af9172dba72a4c62fbf1c9db",
        "previous commit hash": "4872d5131452f9d982e9e1b533b3ed3938ed9132",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 3
        },
        "diff content": "@@ -10,9 +10,8 @@ Read this introduction to get an overview of MBassadors features. There is also\n There is a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. This is a good example of integration with other frameworks.\n \n >  ################   NOTE #################### \n-> [15.10.2015] My spare time programming efforts have shifted to another open source project - [openmediaid](http://www.openmediaid.org). I will not be able to actively push development of this library anymore. Any developers interested in becoming co-maintainers of this library... you are very welcome!\n \n-> However, the code base has matured over the past years and I think it is fairly safe to use this library in your production code. \n+> [15.10.2015] My spare time programming efforts have shifted to another open source project - [openmediaid](http://www.openmediaid.org). I will not be able to actively push development of this library anymore. Any developers interested in becoming co-maintainers of this library... you are very welcome! \n \n Table of contents:\n   *  [Usage](#usage)\n@@ -100,7 +99,7 @@ MBassador is available from the Maven Central Repository using the following coo\n     <dependency>\n         <groupId>net.engio</groupId>\n         <artifactId>mbassador</artifactId>\n-        <version>{your.desired.version}</version>\n+        <version>{see.git.tags.for.latest.version}</version>\n     </dependency>\n ```\n \n"
    },
    {
        "commit hash": "683f1d3cc1510a88af9172dba72a4c62fbf1c9db",
        "previous commit hash": "4872d5131452f9d982e9e1b533b3ed3938ed9132",
        "diff stats": {
            "file_path": "changelog/README.md",
            "additions": 2,
            "deletions": 3
        },
        "diff content": "@@ -2,7 +2,7 @@\n  + API-Changes:\n    + Remove IBusConfiguration.{handleError,addConfigurationErrorHandler} => Configuration errors are communicated as RuntimeExceptions\n    + Removed BusFactory => Use explicit feature based construction with BusConfiguration \n- + Integrated JaCoCo into build =>   \n+ + Integrated JaCoCo test coverage report => run `mvn clean test -Djacoco`  \n \n \n ### [1.2.3](http://github.com/bennidi/mbassador/milestones/1.2.2)\n@@ -18,8 +18,7 @@\n \n ### [1.2.2](http://github.com/bennidi/mbassador/milestones/1.2.2)\n  + Due to technical problems during release creation this version had to be skipped (git tag not removable)\n- + The respective release is 1.2.3\n- \n+ + The respective release is 1.2.3 \n \n \n ### [1.2.1](http://github.com/bennidi/mbassador/milestones/1.2.1)\n"
    },
    {
        "commit hash": "4872d5131452f9d982e9e1b533b3ed3938ed9132",
        "previous commit hash": "4503962ae0208c4027244b3eb98b6abd0c9a31de",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.4</version>\n+    <version>1.2.5-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.2.4</tag>\n+        <tag>mbassador-1.2.2</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n     </scm>\n     <developers>\n"
    },
    {
        "commit hash": "4503962ae0208c4027244b3eb98b6abd0c9a31de",
        "previous commit hash": "edee5e13a3684394e574ca8a38c6a958b68c1e4e",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.4-SNAPSHOT</version>\n+    <version>1.2.4</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.2.2</tag>\n+        <tag>mbassador-1.2.4</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n     </scm>\n     <developers>\n"
    },
    {
        "commit hash": "edee5e13a3684394e574ca8a38c6a958b68c1e4e",
        "previous commit hash": "7fff229e628a0f8018b64435f0541fe7f5b88e06",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -11,7 +11,6 @@ public class BusConfiguration implements IBusConfiguration {\n \n     // the registered properties\n     private final Map<Object, Object> properties = new HashMap<Object, Object>();\n-    private final List<ConfigurationErrorHandler> configurationErrorHandlers = new LinkedList<ConfigurationErrorHandler>();\n     // these are transferred to the bus to receive all errors that occur during message dispatch or message handling\n     private final List<IPublicationErrorHandler> publicationErrorHandlers = new ArrayList<IPublicationErrorHandler>();\n \n"
    },
    {
        "commit hash": "7fff229e628a0f8018b64435f0541fe7f5b88e06",
        "previous commit hash": "85606fe8ea27f1a636143ee6052fdc242bffa3b2",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -10,7 +10,7 @@ Read this introduction to get an overview of MBassadors features. There is also\n There is a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. This is a good example of integration with other frameworks.\n \n >  ################   NOTE #################### \n-> [15.10.2015] My spare time programming efforts have shifted to another open source project - [openmediaid](www.openmediaid.org). I will not be able to actively push development of this library anymore. Any developers interested in becoming co-maintainers of this library... you are very welcome!\n+> [15.10.2015] My spare time programming efforts have shifted to another open source project - [openmediaid](http://www.openmediaid.org). I will not be able to actively push development of this library anymore. Any developers interested in becoming co-maintainers of this library... you are very welcome!\n \n > However, the code base has matured over the past years and I think it is fairly safe to use this library in your production code. \n \n"
    },
    {
        "commit hash": "85606fe8ea27f1a636143ee6052fdc242bffa3b2",
        "previous commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "diff stats": {
            "file_path": "README.md",
            "additions": 9,
            "deletions": 19
        },
        "diff content": "@@ -9,10 +9,10 @@ Read this introduction to get an overview of MBassadors features. There is also\n \n There is a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. This is a good example of integration with other frameworks.\n \n-> NOTICE: \n-> [15.10.2015] My spare time programming efforts have shifted to another open source project - [openmediaid](www.openmediaid.org)\n-> I will not be able to actively push development of this library beyond providing bug fixes. The code base has matured over the past years and I think it is fairly safe to use this library in your production code. Any developers interested in becoming co-maintainers of this library... you are very welcome!  \n-> I do not make any effort in hosting documentation for various versions. Therefore, I recommend you always upgrade to the latest version. API-Changes or documented in the [changelog](changelog)\n+>  ################   NOTE #################### \n+> [15.10.2015] My spare time programming efforts have shifted to another open source project - [openmediaid](www.openmediaid.org). I will not be able to actively push development of this library anymore. Any developers interested in becoming co-maintainers of this library... you are very welcome!\n+\n+> However, the code base has matured over the past years and I think it is fairly safe to use this library in your production code. \n \n Table of contents:\n   *  [Usage](#usage)\n@@ -20,7 +20,6 @@ Table of contents:\n   *  [Installation](#installation)\n   *  [Wiki](#wiki)\n   *  [Release Notes](#release-notes)\n-  *  [Roadmap](#roadmap)\n   *  [Integrations](#integrations)\n   *  [Credits](#credits)\n   *  [Contribute](#contribute)\n@@ -30,7 +29,7 @@ Table of contents:\n \n Using MBassador in your project is very easy. Create as many instances of MBassador as you like (usually a singleton will do) ` bus = new MBassador()`, mark and configure your message handlers with `@Handler` annotations and finally register the listeners at any MBassador instance `bus.subscribe(aListener)`. Start sending messages to your listeners using one of MBassador's publication methods `bus.post(message).now()` or `bus.post(message).asynchronously()`.\n \n-As a first reference, consider this illustrative example. You might want to have a look at the collection of [examples](examples) to get an understanding of more advanced features.\n+As a first reference, consider this illustrative example. You might want to have a look at the collection of [examples](./examples) to see its features on more detail.\n \n       // Define your listener\n      class SimpleFileListener{\n@@ -115,27 +114,18 @@ There is ongoing effort to extend documentation and provide code samples and det\n Release notes moved to the [changelog](./changelog).\n \n \n-##Roadmap\n-There is no roadmap planning going on that deserves the name. However, there is a collection of useful features that might be implemented in the future. Check the issues labeled with [enhancement](https://github.com/bennidi/mbassador/labels/enhancement) or the available milestones. Comment if you would like to see the feature in a future release and/or want to share your ideas on the feature (or a variation thereof).\n-\n-Pull requests for any feature/enhancement are always welcome. I will try to integrate them sooner than later. Please understand that code reviews take time and that new code needs to be tested thoroughly before its integration.\n-\n-Also understand that I have limited time to include new features and that I will focus on stability and cleaner APIs. Adding features only works with well designed and thoroughly tested components. This is especially true for multi-threaded code and I am still not 100 percent convinced by the existing test design and some parts of the internal code layout.\n-\n-\n <h2>Credits</h2>\n The initial inspiration for creating this component comes from Google Guava's event bus implementation.\n I liked the simplicity of its design and I trust in the code quality of google libraries. The main reason it proved to be unusable for our scenario was that it uses strong references to the listeners.\n \n I want to thank the development team from [friendsurance](http://www.friendsurance.de) for their support and feedback on the bus implementation and the management for allowing me to publish the component as an open source project.\n \n-I also want to thank all of the githubbers who have made [contributions](https://github.com/bennidi/mbassador/pulls?q=is%3Apr+is%3Aclosed) - it is awesome to see\n-the open source idea working. Special thanks go to\n+I also want to thank all githubbers who have made [contributions](https://github.com/bennidi/mbassador/pulls?q=is%3Apr+is%3Aclosed). It was always a pleasure to see how users got engaged into the libraries development and support. Special thanks go to\n + [arne-vandamme](http://github.com/arne-vandamme) for adding support for [meta-annotations](https://github.com/bennidi/mbassador/pull/74)\n + [Bernd Rosstauscher](http://github.com/Rossi1337) for providing an initial integration with JUEL\n-+ [David Sowerby](http://github.com/davidsowerby) for answering user questions, for his tutorial on [guice integration](bennidi/mbassador/wiki/guice-integration) and his various PRs\n++ [David Sowerby](http://github.com/davidsowerby) for answering user questions, his tutorial on [guice integration](bennidi/mbassador/wiki/guice-integration) and his various PRs\n + [dorkbox](http://github.com/dorkbox) for various PRs and his incredible [work on performance tuning](http://github.com/bennidi/eventbus-performance/issues/1) which is still to be integrated\n-+ [durron597](http://github.com/durron597) for his many PRs and the help he offered by answering user questions\n++ [durron597](http://github.com/durron597) for his many PRs and the help he offered to other users\n \n Many thanks also to ej-technologies for providing me with an open source license of \n [![JProfiler](http://www.ej-technologies.com/images/banners/jprofiler_small.png)](http://www.ej-technologies.com/products/jprofiler/overview.html) and Jetbrains for a license of [IntelliJ IDEA](http://www.jetbrains.com/idea/)\n@@ -153,7 +143,7 @@ Special thanks also to [Sonatype](http://www.sonatype.com/) for the hosting of t\n \n ##Contribute\n \n- Following a hands-on mentality please feel invited to contribute by by forking the repo and creating a pull request to submit the code you would like to be included. Make your PRs small and provide test code! Take a look at [this issue](bennidi/mbassador#109) for a good example.\n+Please feel invited to contribute by creating a pull request to submit the code you would like to be included. Make your PRs small and provide test code! Take a look at [this issue](bennidi/mbassador#109) for a good example.\n \n Sample code and documentation are both very appreciated contributions. Especially integration with different frameworks is of great value. Feel free and welcome to create Wiki pages to share your code and ideas. Example: [Guice integration](https://github.com/bennidi/mbassador/wiki/Guice-Integration)\n \n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "README.md",
            "additions": 58,
            "deletions": 138
        },
        "diff content": "@@ -1,28 +1,57 @@\n MBassador\n =========\n \n-MBassador is a very light-weight message (event) bus implementation following the publish subscribe pattern. It is designed for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. The core of MBassador's high performance is a specialized data structure that minimizes lock contention such that performance degradation of concurrent access is minimal. The performance win of this design is illustrated in <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a> and more recently in the [eventbus-performance](https://github.com/bennidi/eventbus-performance) github repository.\n+MBassador is a light-weight, high-performance message (event) bus implementation based on the [publish subscribe pattern](https://en.wikipedia.org/wiki/Publish-subscribe_pattern). It is designed for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. \n \n-Using MBassador in your project is very easy. Create as many instances of MBassador as you like (usually a singleton will do) ` bus = new MBassador()`, mark and configure your message handlers with `@Handler` annotations and finally register the listeners at any MBassador instance `bus.subscribe(aListener)`. Start sending messages to your listeners using one of MBassador's publication methods `bus.post(message).now()` or `bus.post(message).asynchronously()`. Done!\n+The core of MBassador's high performance is a specialized data structure that minimizes lock contention such that performance degradation of concurrent read/write access is minimal. The advantages of this design are illustrated in the [eventbus-performance](https://github.com/bennidi/eventbus-performance) github repository.\n \n-Read this documentation to get an overview of MBassadors features. There is also some documentation in the Wiki - although admittedly not enough to make a developer happy (work is in progress). Additionally, you can browse the [javadoc](http://bennidi.github.io/mbassador/)\n+Read this introduction to get an overview of MBassadors features. There is also some documentation in the Wiki - although admittedly not enough to make a developer happy. Additionally, you can browse the [javadoc](http://bennidi.github.io/mbassador/)\n \n-There is a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. It's beta but stable enough to give it a try.\n+There is a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. This is a good example of integration with other frameworks.\n+\n+> NOTICE: \n+> [15.10.2015] My spare time programming efforts have shifted to another open source project - [openmediaid](www.openmediaid.org)\n+> I will not be able to actively push development of this library beyond providing bug fixes. The code base has matured over the past years and I think it is fairly safe to use this library in your production code. Any developers interested in becoming co-maintainers of this library... you are very welcome!  \n+> I do not make any effort in hosting documentation for various versions. Therefore, I recommend you always upgrade to the latest version. API-Changes or documented in the [changelog](changelog)\n \n Table of contents:\n-+ [Features](#features)\n-+ [Usage](#usage)\n-+ [Installation](#installation)\n-+ [Wiki](#wiki)\n-+ [Release Notes](#release-notes)\n-+ [Roadmap](#roadmap)\n-+ [Integrations](#integrations)\n-+ [Credits](#credits)\n-+ [Contribute](#contribute)\n-+ [License](#license)\n+  *  [Usage](#usage)\n+  *  [Features](#features)\n+  *  [Installation](#installation)\n+  *  [Wiki](#wiki)\n+  *  [Release Notes](#release-notes)\n+  *  [Roadmap](#roadmap)\n+  *  [Integrations](#integrations)\n+  *  [Credits](#credits)\n+  *  [Contribute](#contribute)\n+  *  [License](#license)\n+\n+<h2>Usage</h2>\n+\n+Using MBassador in your project is very easy. Create as many instances of MBassador as you like (usually a singleton will do) ` bus = new MBassador()`, mark and configure your message handlers with `@Handler` annotations and finally register the listeners at any MBassador instance `bus.subscribe(aListener)`. Start sending messages to your listeners using one of MBassador's publication methods `bus.post(message).now()` or `bus.post(message).asynchronously()`.\n+\n+As a first reference, consider this illustrative example. You might want to have a look at the collection of [examples](examples) to get an understanding of more advanced features.\n \n+      // Define your listener\n+     class SimpleFileListener{\n+     \n+       @Handler\n+       public void handle(File msg){\n+          // do something with the file\n+       }\n+     \n+     }\n+  \n+      // somewhere else in your code\n+  \n+     MBassador bus = new MBassador();\n+     Object listener = new SimpleFileListener();\n+     bus.subscribe (listener);\n+     bus.post(new File(\"/tmp/smallfile.csv\")).now();\n+     bus.post(new File(\"/tmp/bigfile.csv\")).asynchronously();\n+   \n \n-<h2 name=\"features\">Features</h2>\n+##Features\n \n \n > Annotation driven\n@@ -36,7 +65,7 @@ Table of contents:\n \n > Delivers everything\n \n-Messages do not need to implement any interface and can be of any type. It is possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery, such that handlers will also receive subtypes of the message type they consume for - e.g. a handler of Object.class receives everything. Messages that do not match any handler result in the publication of a `DeadMessage` object which wraps the original message. DeadMessage events can be handled by registering listeners that handle DeadMessage.\n+Messages do not need to implement any interface and can be of any type. The class hierarchy of a message is considered during message delivery, such that handlers will also receive subtypes of the message type they consume for - e.g. a handler of Object.class receives everything. Messages that do not match any handler result in the publication of a `DeadMessage` object which wraps the original message. DeadMessage events can be handled by registering listeners that handle DeadMessage.\n \n > Synchronous and asynchronous message delivery\n \n@@ -66,111 +95,13 @@ Errors during message delivery are sent to all registered error handlers which c\n \n MBassador is designed to be extensible with custom implementations of various components like message dispatchers and handler invocations (using the decorator pattern), metadata reader (you can add your own annotations) and factories for different kinds of objects. A configuration object is used to customize the different configurable parts, see [Features](https://github.com/bennidi/mbassador/wiki/Components#Feature)\n \n-\n-<h2>Usage</h2>\n-\n-### Handler definition\n-\n-Message handlers are defined via annotations added to instance methods. The simplest definition is to just use `@Handler` without changing any parameters or adding of any other annotations.\n-> NOTE: MBassador uses WEAK REFERENCES by default. If you do not hold references to your listeners somewhere else they will be garbage collected! This can be changed by adding `@Listener(references=References.Strong)` to the defining class\n-\n-\n-        // every message of type TestMessage or any subtype will be delivered\n-        // to this handler\n-        @Handler\n-\t\tpublic void handleTestMessage(TestMessage message) {\n-\t\t\t// do something\n-\t\t}\n-\n-\t\t// every message of type TestMessage or any subtype will be delivered\n-        // to this handler\n-        @Handler\n-        public void handleTestMessageStrong(TestMessage message) {\n-            // do something\n-        }\n-\n-        // this handler will be invoked asynchronously (in a different thread)\n-\t\t@Handler(delivery = Invoke.Asynchronously)\n-\t\tpublic void handleSubTestMessage(SubTestMessage message) {\n-            // do something more expensive here\n-\t\t}\n-\n-\t\t// this handler will receive messages of type SubTestMessage\n-        // or any of its sub types that passe the given filter(s)\n-        @Handler(priority = 10,\n-                  delivery = Invoke.Synchronously,\n-                  filters = {@Filter(Filters.SpecialMessage.class)})\n-        public void handleFiltered(SubTestMessage message) {\n-           //do something special here\n-        }\n-\n-        @Handler(delivery = Invoke.Synchronously, rejectSubtypes = true)\n-        @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n-        public void handleUnrelatedMessageTypes(MessageEnvelope envelope) {\n-            // the envelope will contain either an instance of TestMessage or TestMessage2\n-            // if rejectSubtypes were set to 'false' (default) also subtypes of TestMessage or TestMessage2 would be allowed\n-        }\n-\n-\n-        // configure a listener to be stored using strong instead of weak references\n-        @Listener(references = References.Strong)\n-        public class MessageListener{\n-\n-            // any handler definitions\n-\n-        }\n-\n-        // conditional handler using Java EL expressions\n-        @Handler(condition = \"msg.getType().equals('XYZ') && msg.getSize() == 1\")\n-        public void handleMethodAccessEL(TestEvent message) {\n-            message.handledBy(\"handleMethodAccessEL\");\n-        }\n-\n-\n-### Message bus creation\n-\n-        // Use a default constructor for convenience and create as many instances as you like\n-        MBassador<TestMessage> bus = new MBassador<TestMessage>();\n-        MBassador<String> bus2 = new MBassador<String>();\n-       \n-        // Use feature driven configuration to have more control over the configuration details\n-        MBassador globalBus = new MBassador(new BusConfiguration()\n-             .addFeature(Feature.SyncPubSub.Default())\n-             .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n-             .addFeature(Feature.AsynchronousMessageDispatch.Default())\n-             .addPublicationErrorHandler(new IPublicationErrorHandler{...})\n-             .setProperty(Properties.Common.Id, \"global bus\")); // this is used for identification in #toString\n-        \n-### Listener subscription\n-        ListeningBean listener = new ListeningBean();\n-        // the listener will be registered using a weak-reference if not configured otherwise with @Listener\n-        bus.subscribe(listener);\n-        // objects without handlers will be ignored\n-        bus.subscribe(new ClassWithoutAnyDefinedHandlers());\n-\n-\n-### Message publication\n-\n-        TestMessage message = new TestMessage();\n-        TestMessage subMessage = new SubTestMessage();\n-\n-Messages can be published asynchronously in another thread (fire and forget):\n-\n-        bus.publishAsync(message); //returns immediately, publication will continue asynchronously\n-        bus.post(message).asynchronously(); // same as above\n-        \n-Message can be published synchronously in the same thread:        \n-\n-        bus.publish(subMessage);   // will return after each handler has been invoked\n-        bus.post(subMessage).now(); // same as above\n-\n <h2>Installation</h2>\n MBassador is available from the Maven Central Repository using the following coordinates:\n ```xml\n     <dependency>\n         <groupId>net.engio</groupId>\n         <artifactId>mbassador</artifactId>\n-        <version>1.2.1</version>\n+        <version>{your.desired.version}</version>\n     </dependency>\n ```\n \n@@ -183,16 +114,13 @@ There is ongoing effort to extend documentation and provide code samples and det\n \n Release notes moved to the [changelog](./changelog).\n \n-##Integrations\n \n+##Roadmap\n+There is no roadmap planning going on that deserves the name. However, there is a collection of useful features that might be implemented in the future. Check the issues labeled with [enhancement](https://github.com/bennidi/mbassador/labels/enhancement) or the available milestones. Comment if you would like to see the feature in a future release and/or want to share your ideas on the feature (or a variation thereof).\n \n+Pull requests for any feature/enhancement are always welcome. I will try to integrate them sooner than later. Please understand that code reviews take time and that new code needs to be tested thoroughly before its integration.\n \n-<h2>Roadmap</h2>\n-There is no roadmap planning going on that deserves the name. There is a collection of useful features though. Check the issues labeled with [enhancement](https://github.com/bennidi/mbassador/labels/enhancement) or the available milestones. Comment if you would like to see the feature in a future release and/or want to share your ideas on the feature (or a variation thereof).\n-\n-Please understand that I have limited time to include new features and that I will focus on stability and cleaner APIs. Adding features only works with well designed and thoroughly tested components. This is especially true for multi-threaded code and I am still not 100 percent convinced by the existing test design and some parts of the internal code layout.\n-\n-Planned for release: [Spring integration](bennidi/mbassador-spring) (currently in beta state) with support for conditional message dispatch in transactional context (dispatch only after successful transaction commit etc.).\n+Also understand that I have limited time to include new features and that I will focus on stability and cleaner APIs. Adding features only works with well designed and thoroughly tested components. This is especially true for multi-threaded code and I am still not 100 percent convinced by the existing test design and some parts of the internal code layout.\n \n \n <h2>Credits</h2>\n@@ -204,16 +132,15 @@ I want to thank the development team from [friendsurance](http://www.friendsuran\n I also want to thank all of the githubbers who have made [contributions](https://github.com/bennidi/mbassador/pulls?q=is%3Apr+is%3Aclosed) - it is awesome to see\n the open source idea working. Special thanks go to\n + [arne-vandamme](http://github.com/arne-vandamme) for adding support for [meta-annotations](https://github.com/bennidi/mbassador/pull/74)\n- + [Bernd Rosstauscher](http://github.com/Rossi1337) for providing an initial integration with JUEL\n- + [David Sowerby](http://github.com/davidsowerby) for answering user questions, for his tutorial on [guice integration](bennidi/mbassador/wiki/guice-integration) and his various PRs\n- + [dorkbox](http://github.com/dorkbox) for various PRs and his incredible [work on performance tuning](http://github.com/bennidi/eventbus-performance/issues/1) which is still to be integrated\n- + [durron597](http://github.com/durron597) for his many PRs and the help he offered by answering user questions\n++ [Bernd Rosstauscher](http://github.com/Rossi1337) for providing an initial integration with JUEL\n++ [David Sowerby](http://github.com/davidsowerby) for answering user questions, for his tutorial on [guice integration](bennidi/mbassador/wiki/guice-integration) and his various PRs\n++ [dorkbox](http://github.com/dorkbox) for various PRs and his incredible [work on performance tuning](http://github.com/bennidi/eventbus-performance/issues/1) which is still to be integrated\n++ [durron597](http://github.com/durron597) for his many PRs and the help he offered by answering user questions\n \n Many thanks also to ej-technologies for providing me with an open source license of \n-[![JProfiler](http://www.ej-technologies.com/images/banners/jprofiler_small.png)](http://www.ej-technologies.com/products/jprofiler/overview.html) \n-and Jetbrains for a license of [IntelliJ IDEA](http://www.jetbrains.com/idea/)\n+[![JProfiler](http://www.ej-technologies.com/images/banners/jprofiler_small.png)](http://www.ej-technologies.com/products/jprofiler/overview.html) and Jetbrains for a license of [IntelliJ IDEA](http://www.jetbrains.com/idea/)\n \n-Mbassador makes use of the following open source projects:\n+Mbassador uses the following open source projects:\n \n * [jUnit](http://www.junit.org)\n * [maven](http://www.maven.org)\n@@ -224,8 +151,7 @@ Mbassador makes use of the following open source projects:\n Special thanks also to [Sonatype](http://www.sonatype.com/) for the hosting of their [oss nexus repository](https://oss.sonatype.org/).\n \n \n-<h2>Contribute</h2>\n-\n+##Contribute\n \n  Following a hands-on mentality please feel invited to contribute by by forking the repo and creating a pull request to submit the code you would like to be included. Make your PRs small and provide test code! Take a look at [this issue](bennidi/mbassador#109) for a good example.\n \n@@ -233,10 +159,4 @@ Sample code and documentation are both very appreciated contributions. Especiall\n \n <h2>License</h2>\n \n-This project is distributed under the terms of the MIT License. See file \"LICENSE\" for further reference.\n-\n-\n-\n-\n-\n-\n+This project is distributed under the terms of the MIT License. See file \"LICENSE\" for further reference.\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "build.gradle",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -2,7 +2,7 @@ apply plugin: 'java'\n apply plugin: 'war' // needed for providedCompile\n \n group=\"org.mbassy\"\n-version=\"1.2.2-SNAPSHOT\"\n+version=\"1.2.4-SNAPSHOT\"\n \n \n \n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "changelog/README.md",
            "additions": 8,
            "deletions": 1
        },
        "diff content": "@@ -1,3 +1,10 @@\n+### [1.2.4](http://github.com/bennidi/mbassador/milestones/1.2.4)\n+ + API-Changes:\n+   + Remove IBusConfiguration.{handleError,addConfigurationErrorHandler} => Configuration errors are communicated as RuntimeExceptions\n+   + Removed BusFactory => Use explicit feature based construction with BusConfiguration \n+ + Integrated JaCoCo into build =>   \n+\n+\n ### [1.2.3](http://github.com/bennidi/mbassador/milestones/1.2.2)\n  + Upgraded to Maven 3\n    + Upgraded all plugins to most recent version\n@@ -16,7 +23,7 @@\n \n \n ### [1.2.1](http://github.com/bennidi/mbassador/milestones/1.2.1)\n- + Centralized handling of common (and arbitrary) properties (see `BusConfiguration#setProperty` and `net.engio.mbassy.bus.common.Properties`)\n+ + Centralized handling of common (and arbitrary) properties (see `BusConfiguration#setProperty` and `net.engio.mbassy.bus.config.IBusConfiguration.Properties`)\n  + Each bus now has a configurable id and respective #toString() implementation (useful for debugging)\n  + Each bus now has a default logger (System.out) for publication errors (exception in handlers) which can be replaced with BusConfiguration#setProperty \n  + __API-Changes:__\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "examples/BusConstruction.java",
            "additions": 45,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,45 @@\n+import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.bus.SyncMessageBus;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.config.Feature;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n+import net.engio.mbassy.bus.error.PublicationError;\n+\n+/**\n+ * These examples show how to create instances of a message bus using its different constructors.\n+ *\n+ */\n+public class BusConstruction {\n+\n+\n+\n+    public static void main(String[] args){\n+\n+        // Create a bus instance configured with reasonable defaults\n+        // NOTE: Since there is no publication error handler provided, the bus will fall back to\n+        // ConsoleLogger and print a hint about how to add publication error handlers\n+        MBassador unboundBus = new MBassador();\n+\n+        // Create a bus bound to handle messages of type String.class only\n+        // with a custom publication error handler\n+        MBassador<String> stringOnlyBus = new MBassador<String>(new IPublicationErrorHandler() {\n+            @Override\n+            public void handleError(PublicationError error) {\n+                // custom error handling logic here\n+            }\n+        });\n+\n+\n+        // Use feature driven configuration to have more control over the configuration details\n+        MBassador featureDrivenBus = new MBassador(new BusConfiguration()\n+                .addFeature(Feature.SyncPubSub.Default())\n+                .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n+                .addFeature(Feature.AsynchronousMessageDispatch.Default())\n+                .addPublicationErrorHandler(new IPublicationErrorHandler.ConsoleLogger())\n+                .setProperty(IBusConfiguration.Properties.BusId, \"global bus\")); // this is used for identification in #toString\n+\n+        // The same construction patterns work for the synchronous message bus\n+        SyncMessageBus synchronousOnly = new SyncMessageBus();\n+    }\n+}\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "examples/ErrorHandling.java",
            "additions": 42,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,42 @@\n+import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.config.Feature;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n+import net.engio.mbassy.bus.error.PublicationError;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 07.10.15\n+ */\n+public class ErrorHandling {\n+\n+    static final IPublicationErrorHandler illustrativeHandler =  new IPublicationErrorHandler() {\n+        @Override\n+        public void handleError(PublicationError error) {\n+            error.getMessage(); // An error message to describe what went wrong\n+            error.getCause(); // The underlying exception\n+            error.getPublishedMessage(); // The message that was published (can be null)\n+            error.getListener(); // The listener that was invoked when the execption was thrown (can be null)\n+            error.getHandler(); // The message handler (Method) that was invoked when the execption was thrown (can be null)\n+        }\n+    };\n+\n+\n+    public static void main(String[] args){\n+\n+        // An error handler can be passed as constructor argument\n+        MBassador bus =  new MBassador<String>(illustrativeHandler);\n+\n+\n+        // ...or as part of a configuration object\n+        MBassador featureDrivenBus = new MBassador(new BusConfiguration()\n+                .addFeature(Feature.SyncPubSub.Default())\n+                .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n+                .addFeature(Feature.AsynchronousMessageDispatch.Default())\n+                .addPublicationErrorHandler(new IPublicationErrorHandler.ConsoleLogger()) // <-- This is a default handlers\n+                .addPublicationErrorHandler(illustrativeHandler) // <-- It is possible to add multiple handlers\n+                .setProperty(IBusConfiguration.Properties.BusId, \"global bus\")); // this is used for identification in #toString\n+    }\n+}\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "examples/ListenerDefinition.java",
            "additions": 169,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,169 @@\n+import net.engio.mbassy.dispatch.HandlerInvocation;\n+import net.engio.mbassy.listener.*;\n+import net.engio.mbassy.subscription.MessageEnvelope;\n+import net.engio.mbassy.subscription.SubscriptionContext;\n+\n+import java.io.File;\n+import java.lang.annotation.*;\n+\n+/**\n+ * These examples show how to configure listeners and handlers based on the available configuration options.\n+ *\n+ * NOTE: The presented handler configurations compose very well because they are implemented using decorator pattern.\n+ *\n+ */\n+public class ListenerDefinition {\n+\n+\n+    /**\n+     * By default any listener will be stored using weak references {@link java.lang.ref.WeakReference}.\n+     * This implies that at any give point in time, listeners might be GC'ed if no other alive object holds a reference to it.\n+     *\n+     * In managed environments where object lifecycle is controlled\n+     * by a framework  (Spring, Guice etc.) this is a very handy feature because no attentions needs\n+     * to be paid to proper unsubscription of listeners that have ended their life (session scoped beans etc.)\n+     *\n+     * NOTE: There is no dedicated maintenance task running to take care of GC'ed listeners.\n+     * Automatic cleanup of orphaned weak references is an embedded process done during message publication.\n+     *\n+     */\n+    static class WeaklyReferencedListener{\n+        // Handler definitions go here\n+    }\n+\n+\n+    /**\n+     * In case that there is no other mechanism managing references to the listeners and they should\n+     * just stick around until explicitly unsubscribed, listener classes need to be annotated accordingly.\n+     */\n+    @Listener(references = References.Strong)\n+    static class StronglyReferencedListener{\n+        // This listener will stay subscribed until explicitly unsubscribed\n+    }\n+\n+\n+    /**\n+     * This listeners demonstrates the very basic use cases of synchronous and asynchronous handler definitions.\n+     *\n+     */\n+    static class SyncAsyncListener{\n+\n+        /**\n+         * Any published message will be delivered to this handler (as it consumes any object of type Object.class)\n+         * Delivery is done using synchronous invocation, i.e. the handler is called from the thread running the message\n+         * publication.\n+         *\n+         */\n+        @Handler\n+        public void synchronousHandler(Object message) {\n+            // do something\n+        }\n+\n+        /**\n+         * According to the handler configuration, this handler is invoked asynchronously, meaning that each handler\n+         * invocation runs in a thread different from the one that runs the initial message publication.\n+         *\n+         * This feature is useful for computationally expensive or IO-bound tasks.\n+         *\n+         */\n+        @Handler(delivery = Invoke.Asynchronously)\n+        public void asynchronousHandler(File message) {\n+            // do something more expensive here\n+        }\n+\n+    }\n+\n+    static class FilteringListener{\n+\n+\n+        /**\n+         * This handler consumes only strings (as there are no subtypes of final String.class).\n+         * Furthermore, each string is passed through the list of defined filters and the handler is\n+         * invoked only if all filters pass. In this case, only strings starting with 'http' will be handled.\n+         *\n+         */\n+        @Handler(delivery = Invoke.Synchronously,\n+                filters = {@Filter(Urlfilter.class)})\n+        public void httpUrlsOnly(String message) {\n+\n+        }\n+\n+        /**\n+         * Another way of controlling which messages are delivered to handlers is by using JUEL expressions.\n+         * These can be specified as conditions (no type checking etc.) and will be evaluated on the msg.\n+         * This particular condition will filter out all empty strings\n+         */\n+        @Handler(condition = \"!msg.isEmpty()\")\n+        public void handleNonEmptyStrings(String msg) {\n+        }\n+\n+        /**\n+         *\n+         */\n+        @Handler(delivery = Invoke.Synchronously, rejectSubtypes = true)\n+        @Enveloped(messages = {Object.class, String.class})\n+        public void handleUnrelatedMessageTypes(MessageEnvelope envelope) {\n+            // the envelope will contain either an instance of Object.class or String.class\n+            // if rejectSubtypes were set to 'false' (default) also subtypes of TestMessage or TestMessage2 would be allowed\n+        }\n+\n+        static class Urlfilter implements IMessageFilter<String>{\n+            public boolean accepts(String message, SubscriptionContext context){\n+                return message.startsWith(\"http\");\n+            }\n+        }\n+\n+    }\n+\n+\n+\n+    /**\n+     *  Listeners can use custom code to invoke their handlers. Custom invocation logic is defined on a per-handler\n+     *  basis (as the signature requires knowledge about concrete handler and message type).\n+     */\n+    @Listener(references = References.Strong)\n+    static class CustomInvocationListener {\n+\n+        @Handler(invocation = TimingInvocation.class)\n+        public void handle(File message) {\n+            // do timed operation here\n+        }\n+\n+        public static class TimingInvocation extends HandlerInvocation<CustomInvocationListener, File> {\n+\n+            public TimingInvocation(SubscriptionContext context) {\n+                super(context);\n+            }\n+\n+            @Override\n+            public void invoke(CustomInvocationListener listener, File message) {\n+                long start = System.currentTimeMillis();\n+                listener.handle(message);\n+                long duration = System.currentTimeMillis() - start;\n+                System.out.println(\"Time takes for handler invocation: \" + duration + \" ms\");\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Handler annotation that adds a condition checking for positive integers only\n+     */\n+    @Retention(value = RetentionPolicy.RUNTIME)\n+    @Inherited\n+    @Handler(condition = \"msg.getClass() == Integer.class && msg > 0\")\n+    @Synchronized\n+    @Target(value = { ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n+    @interface SynchronizedPositiveIntegers{}\n+\n+    static class ListenerWithCustomAnnotation{\n+\n+        @SynchronizedPositiveIntegers\n+        public void handlePositiveIntegers(Integer msg){\n+\n+        }\n+\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "examples/SubscriptionAndPublication.java",
            "additions": 45,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,45 @@\n+import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.config.Feature;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n+\n+import java.io.File;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 07.10.15\n+ */\n+public class SubscriptionAndPublication {\n+\n+    static MBassador bus = new MBassador(new BusConfiguration()\n+            .addFeature(Feature.SyncPubSub.Default())\n+            .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n+            .addFeature(Feature.AsynchronousMessageDispatch.Default())\n+            .addPublicationErrorHandler(new IPublicationErrorHandler.ConsoleLogger())\n+            .setProperty(IBusConfiguration.Properties.BusId, \"global bus\")); // this is used for identification in #toString\n+\n+    public static void main(String[] args){\n+\n+        // Listeners are subscribed by passing them to the #subscribe() method\n+        bus.subscribe(new ListenerDefinition.SyncAsyncListener());\n+\n+        // #subscribe() is idem-potent => Multiple calls to subscribe do NOT add the listener more than once (set semantics)\n+        Object listener = new ListenerDefinition.SyncAsyncListener();\n+        bus.subscribe(listener);\n+        bus.subscribe(listener);\n+\n+        // Classes without handlers will be silently ignored\n+        bus.subscribe(new Object());\n+        bus.subscribe(new String());\n+\n+        bus.publishAsync(new File(\"/tmp/random.csv\")); //returns immediately, publication will continue asynchronously\n+        bus.post(new File(\"/tmp/random.csv\")).asynchronously(); // same as above\n+\n+        bus.publish(\"some message\");   // will return after each handler has been invoked\n+        bus.post(\"some message\").now(); // same as above\n+\n+\n+    }\n+}\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 5,
            "deletions": 0
        },
        "diff content": "@@ -278,6 +278,11 @@\n \n     <profiles>\n \n+        <!-- Profile to run full test suite with coverage reporting engine JaCoCo\n+\n+        mvn clean test -Djacoco\n+\n+        -->\n         <profile>\n             <id>jacoco-coverage</id>\n \n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/docs/TODO.md",
            "additions": 0,
            "deletions": 25
        },
        "diff content": "@@ -1,25 +0,0 @@\n-#Tests\n-Asyncbus.shutdown() -> no test coverage\n-EnvelopedMessageDispatcher -> not tested at all\n-\n-\n-#Refactorings\n-+ split up IMessagePublication into two separate interfaces (internal and external)\n-+ create MessagePublicationFactory\n-\n-#Improvements\n-Prio 1: Validation of handlers\n-    ERROR:Handler with mismatching parameter types\n-    ERROR:Interfaces/Abstract + rejectSubtypes\n-    WARN:@Synchronized only for some handlers of a given listener\n-Prio 2: Lifecycle Callbacks = Implement in MessagePublication (BeforeStart,AfterCompletion)\n-\n-\n-#Documentation\n-Add code examples Javadoc of main classes\n-Describe 1-Thread FIFO scheme with async dispatch\n-Explain how MBassador can be extended easily using delegation\n-Refer to Spring integration component\n-Creating bus hierarchies\n-How to make sender part of the message publication\n-How to add global filtering by means of delegation\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/docs/wiki-bus-overview.md",
            "additions": 0,
            "deletions": 29
        },
        "diff content": "@@ -1,29 +0,0 @@\n-Note: Please refer to the terminology wiki page before reading the following explanations..\n-\n-A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n-synchronously or asynchronously and the dispatch mechanism can by controlled for each message handler and per message publication.\n-\n-Each message publication is isolated from all other running publications such that it does not interfere with them.\n-Hence, the bus expects message handlers to be stateless as they may be invoked concurrently if multiple\n-messages of the same type get published asynchronously.\n-\n-Messages are published to all listeners that accept the type or super type of the published message. Additionally\n-a message handler may define filters to narrow the set of messages that it accepts.\n-\n-Subscribed listeners are available to all pending message publications that have not yet started processing.\n-Any message listener may only be subscribed once - subsequent subscriptions of an already subscribed message listener\n-will be silently ignored.\n-\n-The basic contract of the bus is that it will deliver a specific message exactly once to each of the subscribed message handlers.\n-Currently, message handlers will be invoked in inverse sequence of subscription but any\n-client using this bus should not rely on this assumption.\n-\n-By default, the bus uses weak references to all listeners such that registered listeners do not need to\n-be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n-removed on-the-fly as messages get published. It is possible to enable the use of strong references on the message handler\n-level.\n-\n-Unsubscribing a listener means removing all subscribed message handlers of that listener. This remove operation\n-immediately effects all running publications processes -> A removed listener will under no circumstances receive any message publications.\n-A listener is considered removed after the unsubscribe(Object) call returned.Any running message publication that has not yet delivered\n-the message to the recently removed listener will not see the listener after the remove operation completed.\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/docs/wiki-listener-def.md",
            "additions": 0,
            "deletions": 143
        },
        "diff content": "@@ -1,143 +0,0 @@\n-MBassador understands a variety of message handler configurations that will affect how a message\n-is delivered to a specific listener. There are properties to control the handling of subclasses\n-of the specified message (the method parameter), the execution order of handlers for the same message type,\n-filters, delivery modes etc.\n-\n-<h2>Message handler properties</h2>\n-\n-<table>\n-  <tr> <td>Property</td> <td>Description</td> <td>Default</td> </tr>\n-\n-  <tr>\n-        <td>delivery</td>\n-        <td>Message handler invocation can be configured to run\n-            <ul>\n-                <li>Synchronously: One handler at a time within a given message publication. Each invocation occurs from the same thread</li>\n-                <li>Asynchronously: Multiple threads are used within a given message publication. Each handler invocation\n-                runs in a separate thread.Note:The number of parallel threads is configurable per instance using the BusConfiguration</li>\n-            </ul>\n-            Note: Use @Synchronized if your handler does not allow multiple, concurrent message publications, i.e.\n-            handlers that are not thread-safe but are used in a multi-threaded environment where asynchronous message publication\n-            is possible.\n-        </td>\n-        <td>Synchronously</td>\n-  </tr>\n-\n-  <tr>\n-        <td>priority</td>\n-        <td>The priority is used to determine the order in which a message is delivered to\n-            different message handlers that consume the same message type. Higher priority means\n-            higher precedence in message delivery.</td>\n-        <td>0</td>\n-  </tr>\n-\n-  <tr>\n-      <td>rejectSubtypes</td>\n-      <td>The primary message type consumed by a message handler is determined by the type of\n-          its parameter.Polymorphism does allow any sub type of that message type to be delivered\n-          to the handler as well, which is the default behaviour of any message handler.\n-          The handler can be configured to not receiving any sub types by specifying thus using this\n-          property.\n-      </td>\n-      <td>false</td>\n-  </tr>\n-\n-    <tr>\n-        <td>enabled</td>\n-        <td>A handler can be explicitly disabled to not take part in message delivery.\n-        </td>\n-        <td>true</td>\n-    </tr>\n-\n-    <tr>\n-        <td>strongReferencess</td>\n-        <td>Whether the bus should use storng references to the listeners instead of weak references\n-        </td>\n-        <td>false</td>\n-        </tr>\n-    <tr>\n-        <td>invocation</td>\n-        <td>Specify a custom implementation for the handler invocation. By default, a generic implementation\n-        that uses reflection will be used. Note: A custom implementation will not be faster than the generic one\n-        since there are heavy optimizations by the JVM using JIT-Compiler and more.\n-        </td>\n-        <td>false</td>\n-    </tr>\n-\n-\n-</table>\n-\n-<h2>Message handler definition</h2>\n-\n-The standard message handler definition looks like the following.It will\n-receive all messages of type TestEvent or any subtype sequentially.\n-\n-        // every message of type TestEvent or any subtype will be delivered\n-        // to this handler\n-        @Handler\n-\t\tpublic void handleTestEvent(TestEvent event) {\n-\t\t\t// do something\n-\t\t}\n-\n-\n-\n-This handler will receive all messages of type SubTestEvent or any subtype\n-\n-        // handler invocation will occur in a different thread\n-\t\t@Handler(delivery = Invoke.Asynchronously)\n-\t\tpublic void handleSubTestEvent(SubTestEvent event) {\n-            // do something more expensive here\n-\t\t}\n-\n-This handler will receive all messages of type SubTestEvent or any subtype,\n-given that they pass the specified filters. This handler will be invoked before the formerly\n-defined one, since it specifies a higher priority\n-\n-\t\t// this handler will receive messages of type SubTestEvent\n-        // or any of its sub types that passe the given filter(s)\n-        @Handler(priority = 10,\n-                  dispatch = Invoke.Synchronously,\n-                  filters = {@Filter(Filters.SpecialEvent.class)})\n-        public void handleFiltered(SubTestEvent event) {\n-           //do something special here\n-        }\n-\n-\n-        @Handler(dispatch = Mode.Synchronous, rejectSubtypes = true)\n-        @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n-        public void handleVariousEvents(MessageEnvelope envelope) {\n-            // the envelope will contain either an instance of TestEvent or TestEvent2\n-            // if rejectSubtypes were set to 'false' (default) also subtypes of TestEvent or TestEvent2 would be allowed\n-        }\n-\n-\n-\n-<h2>Enveloped message handlers</h2>\n-\n-Since one parameter (the message) does not offer a great deal of flexibility if different types\n-of messages should be consumed, there exists the possibility to wrap a message inside an envelope.\n-An enveloped message handler specifies the message type it consumes by using the @Enveloped annotation\n-in addition to the @Handler annotation. All configurations of @Handler apply to each of the specified\n-message types.\n-\n-        @Handler(dispatch = Mode.Synchronous, rejectSubtypes = true)\n-        @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n-        public void handleVariousEvents(MessageEnvelope envelope) {\n-            // the envelope will contain either an instance of TestEvent or TestEvent2\n-            // if rejectSubtypes were set to 'false' (default) also subtypes of TestEvent or TestEvent2 would be allowed\n-        }\n-\n-\n-<h2>Inheritance</h2>\n-\n-Message handler inheritance corresponds to inheritance of methods as defined in the Java language itself.\n-A subclass of any class that defines message handlers will inherit these handler and their configuration.\n-It is possible to change (override) the configuration simply by overriding the super class' method and\n-specifying a different configuration. This way, it is also possible to deactivate a message handler of\n-a super class by setting the \"enabled\" property to \"false\" on the overridden method.\n-If a class overrides a method that is already configured as a message handler\n-it is still considered a message handler but of course the implementation of the overriding class\n-will be used.\n-\n-\n-\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/docs/wiki-terminology.md",
            "additions": 0,
            "deletions": 34
        },
        "diff content": "@@ -1,34 +0,0 @@\n-<h2>Terminology</h2>\n-To avoid confusion and increase precision of the available documentation a common vocabulary of the most relevant concepts is necessary. Specifically, the terms \"event\" and \"message\" have their own definition within the context of the message bus system and as such require\n-some clarification.\n-\n-<h3>Message</h3>\n-A message is an object used for communication between a sender and a set of receivers. Other libraries established the term \"event\" which essentially refers to the same idea (an event occurs at some point in the system and is published to other components such that they might react to it).  \n-MBassador uses the term `message` instead of `event` since the object sent over the wire does not necessarily represent an event. It might merely represent data to be processed, e.g. stored or transformed.\n-\n-A message can be any object, no restrictions or assumptions are made. A message can be sent by any object that has access to the bus\n-and is delivered to all registered handlers consuming that type of message.\n-\n-<h3>Message handler</h3>\n-A message handler is a method that defines exactly one parameter (the message or a message envelope) and is marked with @Handler. A handler has a message type that is implicitly defined in the method signature (the parameter type). A message handler will be invoked for each message that has a compatible type.\n-\n-<h3>Message listener</h3>\n-A class defining one or more message handlers and that has been subscribed at the message bus is referred to as (message) listener.\n-\n-<h3>Subscription</h3>\n-Subscription is the process of adding a listener to the message bus, such that it might receive messages. It is used interchangeably with the\n-term \"registration\"\n-\n-<h3>Message publication|Message dispatch</h3>\n-The process of delivering a message from the sender to all registered listeners is called message publication.\n-The initial phase of this process, that lasts until the message is actually delivered to the handlers is called message dispatch.\n-The distinction is necessarily drawn as all method publications share a common scheme but may vary in the way how the dispatching works.\n-\n-<h3>Event</h3>\n-The term \"event\" refers to events that can occur during message publication. Currently there are two types of events:\n-\n- + DeadMessage: Whenever a message is published and no listeners exist that defined matching handlers, a DeadMessage event will be created and published\n- using the common message publication mechanism. Listeners with handlers for DeadEvent can be subscribed to listen for and react to dead\n- + FilteredMessage: Since handlers can define filters to narrow the set of messages it consumes, it is possible that a message is not delivered\n- to any handler. In such a case the FilteredMessage event is published,\n-\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java",
            "additions": 12,
            "deletions": 7
        },
        "diff content": "@@ -1,8 +1,8 @@\n package net.engio.mbassy.bus;\n \n import net.engio.mbassy.bus.common.DeadMessage;\n-import net.engio.mbassy.bus.common.Properties;\n import net.engio.mbassy.bus.common.PubSubSupport;\n+import net.engio.mbassy.bus.config.ConfigurationError;\n import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n@@ -12,7 +12,8 @@ import net.engio.mbassy.subscription.SubscriptionManager;\n \n import java.util.*;\n \n-import static net.engio.mbassy.bus.common.Properties.Handler.PublicationErrorHandlers;\n+import static net.engio.mbassy.bus.config.IBusConfiguration.Properties.BusId;\n+import static net.engio.mbassy.bus.config.IBusConfiguration.Properties.PublicationErrorHandlers;\n \n /**\n  * The base class for all message bus implementations.\n@@ -43,11 +44,15 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n             System.out.println(ERROR_HANDLER_MSG);\n         }\n         this.runtime = new BusRuntime(this)\n-                .add(PublicationErrorHandlers, configuration.getRegisteredPublicationErrorHandlers());\n+                .add(PublicationErrorHandlers, configuration.getRegisteredPublicationErrorHandlers())\n+                .add(BusId, configuration.getProperty(BusId, UUID.randomUUID().toString()));\n         // configure the pub sub feature\n         Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);\n+        if(pubSubFeature == null){\n+            throw ConfigurationError.MissingFeature(Feature.SyncPubSub.class);\n+        }\n         this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()\n-                                                .createManager(pubSubFeature.getMetadataReader(), pubSubFeature.getSubscriptionFactory(), runtime);\n+                .createManager(pubSubFeature.getMetadataReader(), pubSubFeature.getSubscriptionFactory(), runtime);\n         this.publicationFactory = pubSubFeature.getPublicationFactory();\n     }\n \n@@ -78,8 +83,8 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n     protected IMessagePublication createMessagePublication(T message) {\n         Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n         if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass()\n-                                                                          .equals(DeadMessage.class)) {\n-            // Dead Event\n+                .equals(DeadMessage.class)) {\n+            // DeadMessage Event\n             subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n             return getPublicationFactory().createPublication(runtime, subscriptions, new DeadMessage(message));\n         } else {\n@@ -102,6 +107,6 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n \n     @Override\n     public String toString() {\n-        return getClass().getSimpleName() + \"{ \" + runtime.get(Properties.Common.Id) + \"}\";\n+        return getClass().getSimpleName() + \"(\" + runtime.get(IBusConfiguration.Properties.BusId) + \")\";\n     }\n }\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java",
            "additions": 8,
            "deletions": 9
        },
        "diff content": "@@ -1,11 +1,10 @@\n package net.engio.mbassy.bus;\n \n import net.engio.mbassy.bus.common.IMessageBus;\n-import net.engio.mbassy.bus.common.Properties;\n import net.engio.mbassy.bus.config.ConfigurationError;\n import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n-import net.engio.mbassy.bus.error.PublicationError;\n+import net.engio.mbassy.bus.error.InternalPublicationError;\n import net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n \n import java.util.ArrayList;\n@@ -38,19 +37,19 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n         // configure asynchronous message dispatch\n         Feature.AsynchronousMessageDispatch asyncDispatch = configuration.getFeature(Feature.AsynchronousMessageDispatch.class);\n         if(asyncDispatch == null){\n-            configuration.handleError(ConfigurationError.Missing(Feature.AsynchronousMessageDispatch.class));\n+            throw ConfigurationError.MissingFeature(Feature.AsynchronousMessageDispatch.class);\n         }\n-        pendingMessages = asyncDispatch.getPendingMessages();\n+        pendingMessages = asyncDispatch.getMessageQueue();\n         dispatchers = new ArrayList<Thread>(asyncDispatch.getNumberOfMessageDispatchers());\n         initDispatcherThreads(asyncDispatch);\n \n         // configure asynchronous handler invocation\n         Feature.AsynchronousHandlerInvocation asyncInvocation = configuration.getFeature(Feature.AsynchronousHandlerInvocation.class);\n         if(asyncInvocation == null){\n-            configuration.handleError(ConfigurationError.Missing(Feature.AsynchronousHandlerInvocation.class));\n+            throw ConfigurationError.MissingFeature(Feature.AsynchronousHandlerInvocation.class);\n         }\n         this.executor = asyncInvocation.getExecutor();\n-        getRuntime().add(Properties.Handler.AsynchronousHandlerExecutor, executor);\n+        getRuntime().add(IBusConfiguration.Properties.AsynchronousHandlerExecutor, executor);\n \n     }\n \n@@ -70,7 +69,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n                             Thread.currentThread().interrupt();\n                             return;\n                         } catch(Throwable t){\n-                            handlePublicationError(new PublicationError(t, \"Error in asynchronous dispatch\",publication));\n+                            handlePublicationError(new InternalPublicationError(t, \"Error in asynchronous dispatch\",publication));\n                         }\n                     }\n                 }\n@@ -88,7 +87,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n             pendingMessages.put(publication);\n             return publication.markScheduled();\n         } catch (InterruptedException e) {\n-            handlePublicationError(new PublicationError(e, \"Error while adding an asynchronous message publication\", publication));\n+            handlePublicationError(new InternalPublicationError(e, \"Error while adding an asynchronous message publication\", publication));\n             return publication;\n         }\n     }\n@@ -100,7 +99,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n                     ? publication.markScheduled()\n                     : publication;\n         } catch (InterruptedException e) {\n-            handlePublicationError(new PublicationError(e, \"Error while adding an asynchronous message publication\", publication));\n+            handlePublicationError(new InternalPublicationError(e, \"Error while adding an asynchronous message publication\", publication));\n             return publication;\n         }\n     }\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/BusFactory.java",
            "additions": 0,
            "deletions": 38
        },
        "diff content": "@@ -1,38 +0,0 @@\n-package net.engio.mbassy.bus;\n-\n-import net.engio.mbassy.bus.common.IMessageBus;\n-import net.engio.mbassy.bus.config.BusConfiguration;\n-import net.engio.mbassy.bus.config.Feature;\n-\n-/**\n- * The bus factory provides convenient factory methods for the most common bus use cases.\n- *\n- * @author bennidi\n- *         Date: 3/30/14\n- */\n-public class BusFactory {\n-\n-    /**\n-     * Create a message bus supporting only synchronous message publication.\n-     * All message publications will run in the calling thread, no bus internal\n-     * multi-threading will occur.\n-     */\n-    public static SyncMessageBus SynchronousOnly(){\n-        BusConfiguration syncPubSubCfg = new BusConfiguration();\n-        syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());\n-        return new SyncMessageBus(syncPubSubCfg);\n-    }\n-\n-    /**\n-     * Create a message bus with support for synchronous and asynchronous message publication.\n-     * Asynchronous message publication will be handled by a single thread such that FIFO\n-     * order of message processing is guaranteed.\n-     */\n-    public static IMessageBus AsynchronousSequentialFIFO(){\n-        BusConfiguration asyncFIFOConfig = new BusConfiguration();\n-        asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n-        asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n-        asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n-        return new MBassador(asyncFIFOConfig);\n-    }\n-}\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/BusRuntime.java",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.bus;\n \n-import net.engio.mbassy.bus.common.Properties;\n import net.engio.mbassy.bus.common.PubSubSupport;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.MissingPropertyException;\n \n import java.util.Collection;\n@@ -26,7 +26,6 @@ public class BusRuntime {\n \n     public BusRuntime(PubSubSupport provider) {\n         this.provider = provider;\n-        properties.put(Properties.Common.Id, UUID.randomUUID().toString());\n     }\n \n     public <T> T get(String key){\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/Properties.java",
            "additions": 0,
            "deletions": 25
        },
        "diff content": "@@ -1,25 +0,0 @@\n-package net.engio.mbassy.bus.common;\n-\n-/**\n- * A collection of properties commonly used by different parts of the library.\n- *\n- * @author bennidi\n- *         Date: 22.02.15\n- */\n-public final class Properties {\n-\n-    public static final class Handler {\n-\n-        public static final String PublicationErrorHandlers = \"bus.handlers.error\";\n-        public static final String AsynchronousHandlerExecutor = \"bus.handlers.async-executor\";\n-    }\n-\n-    public static final class Common {\n-\n-        public static final String Id = \"bus.id\";\n-    }\n-\n-\n-\n-\n-}\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java",
            "additions": 2,
            "deletions": 15
        },
        "diff content": "@@ -47,22 +47,9 @@ public class BusConfiguration implements IBusConfiguration {\n     }\n \n     @Override\n-    public IBusConfiguration addConfigurationErrorHandler(ConfigurationErrorHandler handler) {\n-        configurationErrorHandlers.add(handler);\n-        return this;\n-    }\n-\n-    @Override\n-    public void handleError(ConfigurationError error) {\n-        for(ConfigurationErrorHandler errorHandler : configurationErrorHandlers){\n-            errorHandler.handle(error);\n-        }\n-    }\n-\n-@Override\n     public final BusConfiguration addPublicationErrorHandler(IPublicationErrorHandler handler) {\n-            publicationErrorHandlers.add(handler);\n-    return this;\n+        publicationErrorHandlers.add(handler);\n+        return this;\n     }\n \n     @Override\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/ConfigurationError.java",
            "additions": 7,
            "deletions": 11
        },
        "diff content": "@@ -1,30 +1,26 @@\n package net.engio.mbassy.bus.config;\n \n /**\n- * Configuration errors represent specific misconfigurations of features in a {@link net.engio.mbassy.bus.config.IBusConfiguration}\n+ * Configuration errors represent specific invalid configurations of a feature in a {@link net.engio.mbassy.bus.config.IBusConfiguration}\n+ * An invalid feature configuration is assumed to render the bus dysfunctional and as such is thrown as an unchecked exception.\n  *\n  * @author bennidi\n  *         Date: 8/29/14\n  */\n-public class ConfigurationError {\n+public class ConfigurationError extends RuntimeException{\n \n-    private Class<? extends Feature> featureType;\n-    private Feature feature;\n     private String message;\n \n-    public ConfigurationError(Class<? extends Feature> featureType, Feature feature, String message) {\n-        this.featureType = featureType;\n-        this.feature = feature;\n+    private ConfigurationError(String message) {\n         this.message = message;\n     }\n \n-    public static ConfigurationError Missing(Class<? extends Feature> featureType){\n-        return new ConfigurationError(featureType, null, \"An expected feature was missing. Use addFeature() in IBusConfiguration to add features.\");\n+    public static ConfigurationError MissingFeature(Class<? extends Feature> featureType){\n+        return new ConfigurationError(\"The expected feature \" + featureType +  \" was missing. Use addFeature() in IBusConfiguration to add features.\");\n     }\n \n     @Override\n     public String toString() {\n-        return \"Error for \" + featureType + \":\" + message +\n-                \", (\" + feature + \")\";\n+        return message;\n     }\n }\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/Feature.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -137,7 +137,7 @@ public interface Feature {\n \n \n         private int numberOfMessageDispatchers;\n-        private BlockingQueue<IMessagePublication> pendingMessages;\n+        private BlockingQueue<IMessagePublication> messageQueue;\n         private ThreadFactory dispatcherThreadFactory;\n \n         public int getNumberOfMessageDispatchers() {\n@@ -149,12 +149,12 @@ public interface Feature {\n             return this;\n         }\n \n-        public BlockingQueue<IMessagePublication> getPendingMessages() {\n-            return pendingMessages;\n+        public BlockingQueue<IMessagePublication> getMessageQueue() {\n+            return messageQueue;\n         }\n \n         public AsynchronousMessageDispatch setMessageQueue(BlockingQueue<IMessagePublication> pendingMessages) {\n-            this.pendingMessages = pendingMessages;\n+            this.messageQueue = pendingMessages;\n             return this;\n         }\n \n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/IBusConfiguration.java",
            "additions": 21,
            "deletions": 9
        },
        "diff content": "@@ -8,8 +8,8 @@ import java.util.Collection;\n  * The configuration of message bus instances is feature driven, e.g. configuration parameters\n  * are grouped into {@link Feature}.\n  *\n- * Features can be added to a bus configuration to be used later in the instantiation process of the message bus.\n- * Each bus will look for the features it requires and configure them according to the provided configuration. If a required feature is not found the bus will publish a {@link ConfigurationError}\n+ * Each bus will look for the features it requires and configure them according to the provided configuration.\n+ * If a required feature is not found the bus will publish a {@link ConfigurationError}\n  * to the {@link ConfigurationErrorHandler}\n  *\n  * @author bennidi.\n@@ -60,19 +60,31 @@ public interface IBusConfiguration{\n     IBusConfiguration addFeature(Feature feature);\n \n     /**\n-     * Add a handler that is called when a misconfiguration is detected.\n-     * Note: Not fully implemented, yet.\n+     * Add a handler that will be called whenever a publication error occurs.\n+     * See {@link net.engio.mbassy.bus.error.PublicationError}\n+     *\n+     * @param handler  The handler to be added to the list of handlers\n+     * @return A reference to <code>this</code> bus configuration.\n      */\n-    IBusConfiguration addConfigurationErrorHandler(ConfigurationErrorHandler handler);\n+    BusConfiguration addPublicationErrorHandler(IPublicationErrorHandler handler);\n \n     /**\n-     * Calls all ConfigurationErrorHandlers\n+     * Get an unmodifiable collection of all registered publication error handlers\n      */\n-    void handleError(ConfigurationError error);\n+    Collection<IPublicationErrorHandler> getRegisteredPublicationErrorHandlers();\n \n-    BusConfiguration addPublicationErrorHandler(IPublicationErrorHandler handler);\n \n-    Collection<IPublicationErrorHandler> getRegisteredPublicationErrorHandlers();\n+    /**\n+     * A collection of properties commonly used by different parts of the library.\n+     *\n+     * @author bennidi\n+     *         Date: 22.02.15\n+     */\n+    final class Properties {\n \n+        public static final String BusId = \"bus.id\";\n+        public static final String PublicationErrorHandlers = \"bus.handlers.error\";\n+        public static final String AsynchronousHandlerExecutor = \"bus.handlers.async-executor\";\n \n+    }\n }\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/error/IPublicationErrorHandler.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -24,7 +24,7 @@ public interface IPublicationErrorHandler {\n      * The default error handler will simply log to standard out and\n      * print the stack trace if available.\n      */\n-    static final class ConsoleLogger implements IPublicationErrorHandler {\n+    final class ConsoleLogger implements IPublicationErrorHandler {\n \n         private final boolean printStackTrace;\n \n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/error/InternalPublicationError.java",
            "additions": 21,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,21 @@\n+package net.engio.mbassy.bus.error;\n+\n+import net.engio.mbassy.bus.IMessagePublication;\n+\n+/**\n+ * This type of publication error is used to communicate technical/library related errors as opposed to errors in client code, i.e. message handlers)\n+ *\n+ * @author bennidi\n+ *         Date: 15.10.15\n+ */\n+public class InternalPublicationError extends PublicationError{\n+\n+    public InternalPublicationError(Throwable cause, String message, IMessagePublication publication) {\n+        super(cause, message, publication);\n+    }\n+\n+    public InternalPublicationError(Throwable cause, String message) {\n+        super(cause, message);\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/error/PublicationError.java",
            "additions": 11,
            "deletions": 4
        },
        "diff content": "@@ -6,10 +6,12 @@ import net.engio.mbassy.subscription.SubscriptionContext;\n import java.lang.reflect.Method;\n \n /**\n- * Publication errors are created when object publication fails\n- * for some reason and contain details as to the cause and location\n- * where they occurred.\n- * <p/>\n+ * Publication errors are used to communicate exceptions that occur during message publication.\n+ * The most common reason is most likely an exception thrown during the execution of a message handler.\n+ *\n+ * The publication error contains details about to the cause and location where error occurred.\n+ * They are passed to all registered instances of {@link IPublicationErrorHandler} configured within\n+ * the {@link net.engio.mbassy.bus.config.IBusConfiguration}\n  *\n  * @author bennidi\n  *         Date: 2/22/12\n@@ -63,6 +65,11 @@ public class PublicationError{\n         this.handler = context.getHandler().getMethod();\n     }\n \n+    public PublicationError(Throwable cause, String message) {\n+        this.cause = cause;\n+        this.message = message;\n+    }\n+\n \n     /**\n      * Default constructor.\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java",
            "additions": 0,
            "deletions": 2
        },
        "diff content": "@@ -105,7 +105,6 @@ public abstract class AbstractConcurrentSet<T> implements Set<T> {\n     @Override\n     public boolean remove(Object element) {\n         if (!contains(element)) {\n-            // return quickly\n             return false;\n         } else {\n             Lock writeLock = lock.writeLock();\n@@ -118,7 +117,6 @@ public abstract class AbstractConcurrentSet<T> implements Set<T> {\n                 if (listelement != head) {\n                     listelement.remove();\n                 } else {\n-                    // if it was second, now it's first\n                     head = head.next();\n                     //oldHead.clear(); // optimize for GC not possible because of potentially running iterators\n                 }\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.bus.common.Properties;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n \n import java.util.concurrent.ExecutorService;\n@@ -20,7 +20,7 @@ public class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAw\n     public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n         super(delegate.getContext());\n         this.delegate = delegate;\n-        this.executor = delegate.getContext().getRuntime().get(Properties.Handler.AsynchronousHandlerExecutor);\n+        this.executor = delegate.getContext().getRuntime().get(IBusConfiguration.Properties.AsynchronousHandlerExecutor);\n     }\n \n     /**\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/IMessageFilter.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -4,7 +4,7 @@ import net.engio.mbassy.subscription.SubscriptionContext;\n \n /**\n  * Message filters can be used to control what messages are delivered to a specific message handler.\n- * Filters are attached to message handler using the @Listener annotation.\n+ * Filters are attached to message handler using the @Handler annotation.\n  * If a message handler specifies filters, the filters accepts(...) method will be checked before the actual handler is invoked.\n  * The handler will be invoked only if each filter accepted the message.\n  *\n@@ -17,7 +17,7 @@ import net.engio.mbassy.subscription.SubscriptionContext;\n  * public void someHandler(String message){...}\n  *\n  * class Urlfilter implements IMessageFilter<String>{\n- *     public boolean accepts(String message, MessageHandler metadata){\n+ *     public boolean accepts(String message, SubscriptionContext context){\n  *         return message.startsWith(\"http\");\n  *     }\n  * }\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.subscription;\n \n import net.engio.mbassy.bus.BusRuntime;\n-import net.engio.mbassy.bus.common.Properties;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n import net.engio.mbassy.bus.error.MessageBusException;\n import net.engio.mbassy.common.StrongConcurrentSet;\n@@ -21,7 +21,7 @@ public class SubscriptionFactory {\n \n     public Subscription createSubscription(BusRuntime runtime, MessageHandler handlerMetadata) throws MessageBusException{\n         try {\n-            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(Properties.Handler.PublicationErrorHandlers);\n+            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(IBusConfiguration.Properties.PublicationErrorHandlers);\n             SubscriptionContext context = new SubscriptionContext(runtime, handlerMetadata, errorHandlers);\n             IHandlerInvocation invocation = buildInvocationForHandler(context);\n             IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AsyncFIFOBusTest.java",
            "additions": 13,
            "deletions": 50
        },
        "diff content": "@@ -1,9 +1,11 @@\n package net.engio.mbassy;\n \n import junit.framework.Assert;\n-import net.engio.mbassy.bus.BusFactory;\n import net.engio.mbassy.bus.IMessagePublication;\n+import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.bus.common.IMessageBus;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Invoke;\n@@ -21,8 +23,11 @@ public class AsyncFIFOBusTest extends MessageBusTest {\n \n     @Test\n     public void testSingleThreadedSyncFIFO(){\n-        // create a fifo bus with 1000 concurrently subscribed listeners\n-        IMessageBus fifoBUs = BusFactory.AsynchronousSequentialFIFO();\n+        BusConfiguration asyncFIFOConfig = new BusConfiguration();\n+        asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n+        asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n+        asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n+        IMessageBus fifoBUs = new MBassador(asyncFIFOConfig);\n \n         List<SyncListener> listeners = new LinkedList<SyncListener>();\n         for(int i = 0; i < 1000 ; i++){\n@@ -52,11 +57,13 @@ public class AsyncFIFOBusTest extends MessageBusTest {\n \n     }\n \n-    // NOTE: Can fail due to timing issues.\n     @Test\n     public void testSingleThreadedSyncAsyncFIFO(){\n-        // create a fifo bus with 1000 concurrently subscribed listeners\n-        IMessageBus fifoBUs = BusFactory.AsynchronousSequentialFIFO();\n+        BusConfiguration asyncFIFOConfig = new BusConfiguration();\n+        asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n+        asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n+        asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n+        IMessageBus fifoBUs = new MBassador(asyncFIFOConfig);\n \n         List<SyncAsyncListener> listeners = new LinkedList<SyncAsyncListener>();\n         for(int i = 0; i < 1000 ; i++){\n@@ -101,50 +108,6 @@ public class AsyncFIFOBusTest extends MessageBusTest {\n \n     }\n \n-    /*\n-    @Test\n-    public void testMultiThreadedSyncFIFO(){\n-        // create a fifo bus with 1000 concurrently subscribed listeners\n-        final IMessageBus fifoBUs = BusFactory.AsynchronousSequentialFIFO();\n-\n-        List<SyncListener> listeners = new LinkedList<SyncListener>();\n-        for(int i = 0; i < 1000 ; i++){\n-            SyncListener listener = new SyncListener();\n-            listeners.add(listener);\n-            fifoBUs.subscribe(listener);\n-        }\n-\n-        // prepare set of messages in increasing order\n-        final int[] messages = new int[10000];\n-        for(int i = 0; i < messages.length ; i++){\n-            messages[i] = i;\n-        }\n-        final AtomicInteger messageIndex = new AtomicInteger(0);\n-        // publish in ascending order\n-        ConcurrentExecutor.runConcurrent(new Runnable() {\n-            @Override\n-            public void run() {\n-                int idx;\n-                while((idx = messageIndex.getAndIncrement()) < messages.length){\n-                    fifoBUs.post(messages[idx]).asynchronously();\n-                }\n-            }\n-        }, 5);\n-\n-        while(fifoBUs.hasPendingMessages())\n-            pause(1000);\n-\n-        for(SyncListener listener : listeners){\n-            assertEquals(messages.length, listener.receivedSync.size());\n-            for(int i=0; i < messages.length; i++){\n-                assertEquals(messages[i], listener.receivedSync.get(i));\n-            }\n-        }\n-\n-    }  */\n-\n-\n-\n     public static class SyncListener {\n \n         private List<Integer> receivedSync = new LinkedList<Integer>();\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/BusConstructionTest.java",
            "additions": 77,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,77 @@\n+package net.engio.mbassy;\n+\n+import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.config.ConfigurationError;\n+import net.engio.mbassy.bus.config.Feature;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n+import net.engio.mbassy.common.AssertSupport;\n+import org.junit.Test;\n+\n+/**\n+ * Testing different ways of construction\n+ *\n+ * @author bennidi\n+ *         Date: 13.09.15\n+ */\n+public class BusConstructionTest extends AssertSupport {\n+\n+    @Test\n+    public void testMBassadorDefaultConstructor(){\n+        assertNotNull(new MBassador());\n+    }\n+\n+    @Test(expected = ConfigurationError.class)\n+    public void testEmptyBusConfiguration(){\n+        new MBassador(new BusConfiguration());\n+    }\n+\n+\n+    @Test(expected = ConfigurationError.class)\n+    public void testMissingMessageDispatch(){\n+        assertNotNull(new MBassador(new BusConfiguration()\n+                .addFeature(Feature.SyncPubSub.Default())\n+                .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n+                .addPublicationErrorHandler(new IPublicationErrorHandler.ConsoleLogger())\n+                .setProperty(IBusConfiguration.Properties.BusId, \"global bus\")));\n+    }\n+\n+    @Test(expected = ConfigurationError.class)\n+    public void testMissingPubSub(){\n+        assertNotNull(new MBassador(new BusConfiguration()\n+                .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n+                .addFeature(Feature.AsynchronousMessageDispatch.Default())\n+                .addPublicationErrorHandler(new IPublicationErrorHandler.ConsoleLogger())\n+                .setProperty(IBusConfiguration.Properties.BusId, \"global bus\")));\n+    }\n+\n+    @Test(expected = ConfigurationError.class)\n+    public void testMissingAsyncInvocation(){\n+        assertNotNull(new MBassador(new BusConfiguration()\n+                .addFeature(Feature.SyncPubSub.Default())\n+                .addFeature(Feature.AsynchronousMessageDispatch.Default())\n+                .addPublicationErrorHandler(new IPublicationErrorHandler.ConsoleLogger())\n+                .setProperty(IBusConfiguration.Properties.BusId, \"global bus\")));\n+    }\n+\n+\n+    @Test\n+    public void testValidBusConfiguration(){\n+        MBassador bus = new MBassador(new BusConfiguration()\n+                .addFeature(Feature.SyncPubSub.Default())\n+                .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n+                .addFeature(Feature.AsynchronousMessageDispatch.Default())\n+                .addPublicationErrorHandler(new IPublicationErrorHandler.ConsoleLogger())\n+                .setProperty(IBusConfiguration.Properties.BusId, \"global bus\"));\n+        assertNotNull(bus);\n+        assertEquals(1, bus.getRegisteredErrorHandlers().size());\n+        System.out.println(bus.toString());\n+        assertTrue(bus.toString().contains(\"global bus\"));\n+    }\n+\n+\n+\n+\n+\n+}\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/CustomHandlerAnnotationTest.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -26,7 +26,7 @@ public class CustomHandlerAnnotationTest extends MessageBusTest\n \t@Handler(filters = { @Filter(NamedMessageFilter.class) })\n \t@Synchronized\n \t@Target(value = { ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n-\tstatic @interface NamedMessageHandler\n+\t@interface NamedMessageHandler\n \t{\n \t\t/**\n \t\t * @return The message names supported.\n@@ -41,7 +41,7 @@ public class CustomHandlerAnnotationTest extends MessageBusTest\n     @Retention(value = RetentionPolicy.RUNTIME)\n     @Inherited\n     @NamedMessageHandler(\"messageThree\")\n-    static @interface MessageThree {}\n+    @interface MessageThree {}\n \n \n \n@@ -53,7 +53,7 @@ public class CustomHandlerAnnotationTest extends MessageBusTest\n \t@Inherited\n \t@Handler(filters = { @Filter(NamedMessageFilter.class) })\n \t@Enveloped(messages = NamedMessage.class)\n-\tstatic @interface EnvelopedNamedMessageHandler\n+\t@interface EnvelopedNamedMessageHandler\n \t{\n \t\t/**\n \t\t * @return The message names supported.\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/StrongConcurrentSetTest.java",
            "additions": 43,
            "deletions": 5
        },
        "diff content": "@@ -1,19 +1,57 @@\n package net.engio.mbassy;\n \n-import java.util.Collection;\n-\n import net.engio.mbassy.common.StrongConcurrentSet;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n \n /**\n- * Todo: Add javadoc\n- *\n  * @author bennidi\n  *         Date: 3/29/13\n  */\n public class StrongConcurrentSetTest extends ConcurrentSetTest{\n \n-    @Override\n     protected Collection createSet() {\n         return new StrongConcurrentSet();\n     }\n+\n+\n+    @Test\n+    public void testToArray() {\n+        Collection<Integer> set = createSet();\n+        assertFalse(set.contains(1));\n+        set.add(1);\n+        set.add(3);\n+        set.add(5);\n+        Object [] asArray = set.toArray();\n+        // TODO: To array returns set of entries?!\n+    }\n+\n+    @Test(expected = UnsupportedOperationException.class)\n+    public void testContainsAll() {\n+        createSet().containsAll(new HashSet<Object>());\n+    }\n+\n+    @Test(expected = UnsupportedOperationException.class)\n+    public void testRemoveAll() {\n+        createSet().removeAll(new HashSet<Object>());\n+    }\n+\n+    @Test(expected = UnsupportedOperationException.class)\n+    public void testRetainAll() {\n+        createSet().retainAll(new HashSet<Object>());\n+    }\n+\n+    @Test\n+    public void testClear() {\n+        Collection set = createSet();\n+        assertFalse(set.contains(1));\n+        set.add(1);\n+        assertTrue(set.contains(1));\n+        assertEquals(1, set.size());\n+        set.clear();\n+        assertFalse(set.contains(1));\n+        assertEquals(0, set.size());\n+    }\n }\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 28,
            "deletions": 29
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy;\n \n import net.engio.mbassy.bus.BusRuntime;\n-import net.engio.mbassy.bus.common.Properties;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.common.*;\n import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.listeners.*;\n@@ -15,7 +15,6 @@ import java.util.Collection;\n import java.util.Collections;\n \n /**\n- *\n  * Test the subscriptions as generated and organized by the subscription manager. Tests use different sets of listeners\n  * and corresponding expected set of subscriptions that should result from subscribing the listeners. The subscriptions\n  * are tested for the type of messages they should handle and\n@@ -29,7 +28,7 @@ public class SubscriptionManagerTest extends AssertSupport {\n     private static final int ConcurrentUnits = 10;\n \n     @Test\n-    public void testIMessageListener(){\n+    public void testIMessageListener() {\n         ListenerFactory listeners = listeners(\n                 IMessageListener.DefaultListener.class,\n                 IMessageListener.AsyncListener.class,\n@@ -47,7 +46,7 @@ public class SubscriptionManagerTest extends AssertSupport {\n     }\n \n     @Test\n-    public void testAbstractMessageListener(){\n+    public void testAbstractMessageListener() {\n         ListenerFactory listeners = listeners(\n                 AbstractMessageListener.DefaultListener.class,\n                 AbstractMessageListener.AsyncListener.class,\n@@ -63,7 +62,7 @@ public class SubscriptionManagerTest extends AssertSupport {\n     }\n \n     @Test\n-    public void testMessagesListener(){\n+    public void testMessagesListener() {\n         ListenerFactory listeners = listeners(\n                 MessagesTypeListener.DefaultListener.class,\n                 MessagesTypeListener.AsyncListener.class,\n@@ -79,7 +78,7 @@ public class SubscriptionManagerTest extends AssertSupport {\n     }\n \n     @Test\n-    public void testMultipartMessageListener(){\n+    public void testMultipartMessageListener() {\n         ListenerFactory listeners = listeners(\n                 MultipartMessageListener.DefaultListener.class,\n                 MultipartMessageListener.AsyncListener.class,\n@@ -95,7 +94,7 @@ public class SubscriptionManagerTest extends AssertSupport {\n     }\n \n     @Test\n-    public void testIMultipartMessageListener(){\n+    public void testIMultipartMessageListener() {\n         ListenerFactory listeners = listeners(\n                 IMultipartMessageListener.DefaultListener.class,\n                 IMultipartMessageListener.AsyncListener.class,\n@@ -111,7 +110,7 @@ public class SubscriptionManagerTest extends AssertSupport {\n     }\n \n     @Test\n-    public void testStandardMessageListener(){\n+    public void testStandardMessageListener() {\n         ListenerFactory listeners = listeners(\n                 StandardMessageListener.DefaultListener.class,\n                 StandardMessageListener.AsyncListener.class,\n@@ -127,7 +126,7 @@ public class SubscriptionManagerTest extends AssertSupport {\n     }\n \n     @Test\n-    public void testICountableListener(){\n+    public void testICountableListener() {\n         ListenerFactory listeners = listeners(\n                 ICountableListener.DefaultListener.class,\n                 ICountableListener.AsyncListener.class,\n@@ -137,13 +136,13 @@ public class SubscriptionManagerTest extends AssertSupport {\n         SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                 .listener(ICountableListener.DefaultListener.class).handles(ICountable.class)\n                 .listener(ICountableListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n-                .listener(ICountableListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class);\n+                .listener(ICountableListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class);\n \n         runTestWith(listeners, expectedSubscriptions);\n     }\n \n     @Test\n-    public void testMultipleMessageListeners(){\n+    public void testMultipleMessageListeners() {\n         ListenerFactory listeners = listeners(\n                 ICountableListener.DefaultListener.class,\n                 ICountableListener.AsyncListener.class,\n@@ -159,7 +158,7 @@ public class SubscriptionManagerTest extends AssertSupport {\n                 .listener(ICountableListener.DefaultListener.class)\n                 .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                 .listener(ICountableListener.AsyncListener.class)\n-                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class)\n+                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                 .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                 .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                 .listener(MessagesTypeListener.DefaultListener.class).handles(MessageTypes.class)\n@@ -179,12 +178,12 @@ public class SubscriptionManagerTest extends AssertSupport {\n \n         Collection<Subscription> subscriptions = subscriptionManager.getSubscriptionsByMessageType(StandardMessage.class);\n         assertEquals(1, subscriptions.size());\n-        for(Subscription sub : subscriptions)\n-            assertEquals(InstancesPerListener,  sub.size());\n+        for (Subscription sub : subscriptions)\n+            assertEquals(InstancesPerListener, sub.size());\n     }\n \n     @Test\n-    public void testOverloadedMessageHandlers(){\n+    public void testOverloadedMessageHandlers() {\n         ListenerFactory listeners = listeners(\n                 Overloading.ListenerBase.class,\n                 Overloading.ListenerSub.class);\n@@ -200,7 +199,7 @@ public class SubscriptionManagerTest extends AssertSupport {\n     }\n \n     @Test\n-    public void testPrioritizedMessageHandlers(){\n+    public void testPrioritizedMessageHandlers() {\n         ListenerFactory listeners = listeners(PrioritizedListener.class);\n \n         SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n@@ -212,21 +211,21 @@ public class SubscriptionManagerTest extends AssertSupport {\n         runTestWith(listeners, expectedSubscriptions);\n     }\n \n-    private BusRuntime mockedRuntime(){\n+    private BusRuntime mockedRuntime() {\n         return new BusRuntime(null)\n-                .add(Properties.Handler.PublicationErrorHandlers, Collections.EMPTY_SET)\n-                .add(Properties.Handler.AsynchronousHandlerExecutor, null);\n+                .add(IBusConfiguration.Properties.PublicationErrorHandlers, Collections.EMPTY_SET)\n+                .add(IBusConfiguration.Properties.AsynchronousHandlerExecutor, null);\n     }\n \n-    private ListenerFactory listeners(Class ...listeners){\n+    private ListenerFactory listeners(Class... listeners) {\n         ListenerFactory factory = new ListenerFactory();\n-        for(Class listener : listeners){\n+        for (Class listener : listeners) {\n             factory.create(InstancesPerListener, listener);\n         }\n         return factory;\n     }\n \n-    private void runTestWith(final ListenerFactory listeners, final SubscriptionValidator validator){\n+    private void runTestWith(final ListenerFactory listeners, final SubscriptionValidator validator) {\n         final SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n \n         ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n@@ -242,29 +241,29 @@ public class SubscriptionManagerTest extends AssertSupport {\n \n \n     /**\n-     *  define handlers with different priorities which need to be executed\n-     *  in their respective order\n+     * define handlers with different priorities which need to be executed\n+     * in their respective order\n      */\n-    public static class PrioritizedListener{\n+    public static class PrioritizedListener {\n \n \n         @net.engio.mbassy.listener.Handler(priority = 1)\n-        public void handlePrio1(IMessage message){\n+        public void handlePrio1(IMessage message) {\n             message.handled(this.getClass());\n         }\n \n         @net.engio.mbassy.listener.Handler(priority = 2)\n-        public void handlePrio2(IMessage message){\n+        public void handlePrio2(IMessage message) {\n             message.handled(this.getClass());\n         }\n \n         @net.engio.mbassy.listener.Handler(priority = 3)\n-        public void handlePrio3(IMessage message){\n+        public void handlePrio3(IMessage message) {\n             message.handled(this.getClass());\n         }\n \n         @net.engio.mbassy.listener.Handler(priority = 4)\n-        public void handlePrio4(IMessage message){\n+        public void handlePrio4(IMessage message) {\n             message.handled(this.getClass());\n         }\n     }\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncAsyncTest.java",
            "additions": 15,
            "deletions": 1
        },
        "diff content": "@@ -11,6 +11,7 @@ import net.engio.mbassy.messages.MultipartMessage;\n import net.engio.mbassy.messages.StandardMessage;\n import org.junit.Test;\n \n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n@@ -22,6 +23,7 @@ import java.util.concurrent.atomic.AtomicInteger;\n public class SyncAsyncTest extends MessageBusTest {\n \n \n+\n     @Test\n     public void testSyncPublicationSyncHandlers() throws Exception {\n \n@@ -54,6 +56,9 @@ public class SyncAsyncTest extends MessageBusTest {\n         ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n         assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n         assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesTypeListener.DefaultListener.class));\n+\n+        bus.shutdown();\n+        pause(200);\n     }\n \n \n@@ -92,6 +97,9 @@ public class SyncAsyncTest extends MessageBusTest {\n         messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesTypeListener.AsyncListener.class);\n         ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n         messageManager.waitForMessages(waitForMessageTimeout);\n+\n+        bus.shutdown();\n+        pause(200);\n     }\n \n     @Test\n@@ -111,7 +119,7 @@ public class SyncAsyncTest extends MessageBusTest {\n                 StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n                 MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n \n-                bus.post(standardMessage).asynchronously();\n+                bus.post(standardMessage).asynchronously(1, TimeUnit.MILLISECONDS);\n                 bus.post(multipartMessage).asynchronously();\n                 bus.post(MessageTypes.Simple).asynchronously();\n \n@@ -125,6 +133,9 @@ public class SyncAsyncTest extends MessageBusTest {\n         ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n         messageManager.waitForMessages(waitForMessageTimeout);\n \n+        bus.shutdown();\n+        pause(200);\n+\n     }\n \n \n@@ -166,6 +177,9 @@ public class SyncAsyncTest extends MessageBusTest {\n         pause(processingTimeInMS);\n         assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n \n+        bus.shutdown();\n+        pause(200);\n+\n     }\n \n \n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 35,
            "deletions": 0
        },
        "diff content": "@@ -115,6 +115,41 @@ public abstract class SyncBusTest extends MessageBusTest {\n         assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n     }\n \n+    @Test\n+    public void testExceptionInHandlerInvocation2(){\n+        final AtomicInteger exceptionCount = new AtomicInteger(0);\n+        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n+            @Override\n+            public void handleError(PublicationError error) {\n+                exceptionCount.incrementAndGet();\n+            }\n+        };\n+\n+        //DS: modified to pass ExceptionCounter via the configuration object\n+        final GenericMessagePublicationSupport bus = getSyncMessageBus(false,ExceptionCounter);\n+        ListenerFactory listeners = new ListenerFactory()\n+                .create(InstancesPerListener, ExceptionThrowingListener.class);\n+\n+        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n+\n+        Runnable publish = new Runnable() {\n+            @Override\n+            public void run() {\n+                bus.post(new Object()).now();\n+            }\n+        };\n+\n+        // single threaded\n+        ConcurrentExecutor.runConcurrent(publish, 1);\n+        assertEquals(InstancesPerListener, exceptionCount.get());\n+        exceptionCount.set(0); // reset for next test\n+\n+        // multi threaded\n+        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n+        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n+    }\n+\n+\n     @Test\n     public void testCustomHandlerInvocation(){\n         final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -15,7 +15,6 @@ import java.util.LinkedList;\n import java.util.List;\n \n /**\n- * Todo: Add javadoc\n  *\n  * @author bennidi\n  *         Date: 3/31/13\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/CustomInvocationListener.java",
            "additions": 0,
            "deletions": 2
        },
        "diff content": "@@ -14,8 +14,6 @@ import net.engio.mbassy.subscription.SubscriptionContext;\n @Listener(references = References.Strong)\n public class CustomInvocationListener {\n \n-\n-    // this handler will be invoked asynchronously\n     @Handler(invocation = HandleSubTestEventInvocation.class)\n     public void handle(StandardMessage message) {\n         message.handled(this.getClass());\n"
    },
    {
        "commit hash": "c5715acdd65c9be3cc4313579f027e2b55b37cd6",
        "previous commit hash": "24164c34ff338dc841b65f1daf97d23c2b9bdfc2",
        "diff stats": {
            "file_path": "src/test/resources/log4j.xml",
            "additions": 0,
            "deletions": 15
        },
        "diff content": "@@ -9,21 +9,6 @@\n \t\t</layout>\n \t</appender>\n \n-\t<category name=\"org.springframework\" additivity=\"false\">\n-\t\t<priority value=\"info\"/>\n-\t\t<appender-ref ref=\"console\"/>\n-\t</category>\n-\n-\t<category name=\"de.safetynet\" additivity=\"false\">\n-\t\t<priority value=\"info\"/>\n-\t\t<appender-ref ref=\"console\"/>\n-\t</category>\n-\n-\t<category name=\"de.safetynet.tracking\" additivity=\"false\">\n-\t\t<priority value=\"debug\"/>\n-\t\t<appender-ref ref=\"console\"/>\n-\t</category>\n-\n \t<root>\n \t\t<priority value =\"info\" />\n \t\t<appender-ref ref=\"console\"/>\n"
    },
    {
        "commit hash": "7e0aa0566fee335d20100e2044d99ad88ae9332c",
        "previous commit hash": "483d6401a2a3ef2155ee939372f1b41a1110a6c2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -75,7 +75,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n                     }\n                 }\n             });\n-            dispatcher.setName(\"Message dispatcher\");\n+            dispatcher.setName(\"MsgDispatcher-\"+i);\n             dispatchers.add(dispatcher);\n             dispatcher.start();\n         }\n"
    },
    {
        "commit hash": "483d6401a2a3ef2155ee939372f1b41a1110a6c2",
        "previous commit hash": "24e0d52b1a875af11d5e8b332d4248936592ba39",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.3</version>\n+    <version>1.2.4-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.2.3</tag>\n+        <tag>mbassador-1.2.2</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n     </scm>\n     <developers>\n"
    },
    {
        "commit hash": "24e0d52b1a875af11d5e8b332d4248936592ba39",
        "previous commit hash": "07d0cf528df537b389d20ecd00fcf73c37f17a63",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.3-SNAPSHOT</version>\n+    <version>1.2.3</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.2.2</tag>\n+        <tag>mbassador-1.2.3</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n     </scm>\n     <developers>\n"
    },
    {
        "commit hash": "07d0cf528df537b389d20ecd00fcf73c37f17a63",
        "previous commit hash": "44150e217d1cc1714ac15dca7ddfda51c3abe661",
        "diff stats": {
            "file_path": "changelog/README.md",
            "additions": 6,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-### [1.2.2](http://github.com/bennidi/mbassador/milestones/1.2.2)\n+### [1.2.3](http://github.com/bennidi/mbassador/milestones/1.2.2)\n  + Upgraded to Maven 3\n    + Upgraded all plugins to most recent version\n    + Fixed all issues that produced warnings on build output\n@@ -9,6 +9,11 @@\n    + Default constructor of `MBassador` has no `IPublicationErrorHandler` registered and will \n    fall back to console logging. See [#106](http://github.com/bennidi/mbassador/issues/106), [#107](http://github.com/bennidi/mbassador/issues/107) \n \n+### [1.2.2](http://github.com/bennidi/mbassador/milestones/1.2.2)\n+ + Due to technical problems during release creation this version had to be skipped (git tag not removable)\n+ + The respective release is 1.2.3\n+ \n+\n \n ### [1.2.1](http://github.com/bennidi/mbassador/milestones/1.2.1)\n  + Centralized handling of common (and arbitrary) properties (see `BusConfiguration#setProperty` and `net.engio.mbassy.bus.common.Properties`)\n"
    },
    {
        "commit hash": "07d0cf528df537b389d20ecd00fcf73c37f17a63",
        "previous commit hash": "44150e217d1cc1714ac15dca7ddfda51c3abe661",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.2</version>\n+    <version>1.2.3-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n"
    },
    {
        "commit hash": "44150e217d1cc1714ac15dca7ddfda51c3abe661",
        "previous commit hash": "a950b62a7391873cec1c2d9ad57b9428b0e979e7",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.2-SNAPSHOT</version>\n+    <version>1.2.2</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n"
    },
    {
        "commit hash": "a950b62a7391873cec1c2d9ad57b9428b0e979e7",
        "previous commit hash": "4b7eadce6f3f24c5ea149d09a8f5bbd7fb867f77",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.2</version>\n+    <version>1.2.2-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n"
    },
    {
        "commit hash": "4b7eadce6f3f24c5ea149d09a8f5bbd7fb867f77",
        "previous commit hash": "b15ad227f315aa2bc327f39a0fc7778192811ebe",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 3,
            "deletions": 4
        },
        "diff content": "@@ -1,5 +1,4 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n \n     <parent>\n         <groupId>org.sonatype.oss</groupId>\n@@ -10,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.2-SNAPSHOT</version>\n+    <version>1.2.2</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -36,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.2.0</tag>\n+        <tag>mbassador-1.2.2</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n     </scm>\n     <developers>\n"
    },
    {
        "commit hash": "b15ad227f315aa2bc327f39a0fc7778192811ebe",
        "previous commit hash": "35886bb3b5ad1a9cdc773aa61954aca960ab89f2",
        "diff stats": {
            "file_path": "README.md",
            "additions": 6,
            "deletions": 7
        },
        "diff content": "@@ -199,11 +199,10 @@ Planned for release: [Spring integration](bennidi/mbassador-spring) (currently i\n The initial inspiration for creating this component comes from Google Guava's event bus implementation.\n I liked the simplicity of its design and I trust in the code quality of google libraries. The main reason it proved to be unusable for our scenario was that it uses strong references to the listeners.\n \n-I want to thank the development team from [friendsurance](www.friendsurance.de) for their support and feedback on the bus implementation and the management for allowing me to publish the component as an open source project.\n+I want to thank the development team from [friendsurance](http://www.friendsurance.de) for their support and feedback on the bus implementation and the management for allowing me to publish the component as an open source project.\n \n-I also want to thank all of the github users who have made little or larger [contributions](https://github.com/bennidi/mbassador/pulls?q=is%3Apr+is%3Aclosed). Thank you boys and girls, it is awesome to see\n-the open source idea working.\n-Special thanks go to\n+I also want to thank all of the githubbers who have made [contributions](https://github.com/bennidi/mbassador/pulls?q=is%3Apr+is%3Aclosed) - it is awesome to see\n+the open source idea working. Special thanks go to\n + [arne-vandamme](http://github.com/arne-vandamme) for adding support for [meta-annotations](https://github.com/bennidi/mbassador/pull/74)\n  + [Bernd Rosstauscher](http://github.com/Rossi1337) for providing an initial integration with JUEL\n  + [David Sowerby](http://github.com/davidsowerby) for answering user questions, for his tutorial on [guice integration](bennidi/mbassador/wiki/guice-integration) and his various PRs\n@@ -214,7 +213,7 @@ Many thanks also to ej-technologies for providing me with an open source license\n [![JProfiler](http://www.ej-technologies.com/images/banners/jprofiler_small.png)](http://www.ej-technologies.com/products/jprofiler/overview.html) \n and Jetbrains for a license of [IntelliJ IDEA](http://www.jetbrains.com/idea/)\n \n-And all the other open source projects that make this kind of development possible:\n+Mbassador makes use of the following open source projects:\n \n * [jUnit](http://www.junit.org)\n * [maven](http://www.maven.org)\n@@ -222,13 +221,13 @@ And all the other open source projects that make this kind of development possib\n * [slf4j](http://www.slf4j.org)\n * [Odysseus JUEL](http://juel.sourceforge.net/guide/start.html)\n \n-\n Special thanks also to [Sonatype](http://www.sonatype.com/) for the hosting of their [oss nexus repository](https://oss.sonatype.org/).\n \n \n <h2>Contribute</h2>\n \n-Any feature requests and feedback are more than welcome. You may suggest improvements or report bugs either by submitting an issue - I will try to respond as quickly as possible. Please try to be precise in the description of your requirements. Following a hands-on mentality please feel invited to contribute by by forking the repo and creating a pull request to submit the code you would like to be included. Make your PRs small and provide test code! Take a look at [this issue](bennidi/mbassador#109) for a good example.\n+\n+ Following a hands-on mentality please feel invited to contribute by by forking the repo and creating a pull request to submit the code you would like to be included. Make your PRs small and provide test code! Take a look at [this issue](bennidi/mbassador#109) for a good example.\n \n Sample code and documentation are both very appreciated contributions. Especially integration with different frameworks is of great value. Feel free and welcome to create Wiki pages to share your code and ideas. Example: [Guice integration](https://github.com/bennidi/mbassador/wiki/Guice-Integration)\n \n"
    },
    {
        "commit hash": "b15ad227f315aa2bc327f39a0fc7778192811ebe",
        "previous commit hash": "35886bb3b5ad1a9cdc773aa61954aca960ab89f2",
        "diff stats": {
            "file_path": "changelog/README.md",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -3,6 +3,7 @@\n    + Upgraded all plugins to most recent version\n    + Fixed all issues that produced warnings on build output\n  + reduced visibility of `AbstractPubSubSupport.handlePublication` error from `public` to `protected`\n+ + Integrated [performance improvements](https://github.com/bennidi/mbassador/pull/125) made by dorkbox\n + __API-Changes:__\n    + Moved method addPublicationErrorHandler from `IMessageBus` to `IBusConfiguration`\n    + Default constructor of `MBassador` has no `IPublicationErrorHandler` registered and will \n"
    },
    {
        "commit hash": "b15ad227f315aa2bc327f39a0fc7778192811ebe",
        "previous commit hash": "35886bb3b5ad1a9cdc773aa61954aca960ab89f2",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 116,
            "deletions": 34
        },
        "diff content": "@@ -1,4 +1,5 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n \n     <parent>\n         <groupId>org.sonatype.oss</groupId>\n@@ -14,7 +15,8 @@\n     <name>mbassador</name>\n     <description>\n         Mbassador is a fast and flexible event bus system following the publish subscribe pattern.\n-        It is designed for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance.\n+        It is designed for ease of use and aims to be feature rich and extensible while preserving resource efficiency\n+        and performance.\n         It provides non-blocking iterators and minimal write contention with low memory footprint.\n \n         Some features:\n@@ -36,7 +38,7 @@\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n         <tag>mbassador-1.2.0</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n-  </scm>\n+    </scm>\n     <developers>\n \n         <developer>\n@@ -102,24 +104,24 @@\n         </dependency>\n \n         <dependency>\n-        \t<groupId>javax.el</groupId>\n-        \t<artifactId>el-api</artifactId>\n-        \t<scope>provided</scope>\n+            <groupId>javax.el</groupId>\n+            <artifactId>el-api</artifactId>\n+            <scope>provided</scope>\n             <version>2.2</version>\n         </dependency>\n         <dependency>\n-        \t<groupId>de.odysseus.juel</groupId>\n-        \t<artifactId>juel-impl</artifactId>\n-        \t<version>2.2.7</version>\n-        \t<scope>runtime</scope>\n-        \t<optional>true</optional>\n+            <groupId>de.odysseus.juel</groupId>\n+            <artifactId>juel-impl</artifactId>\n+            <version>2.2.7</version>\n+            <scope>runtime</scope>\n+            <optional>true</optional>\n         </dependency>\n         <dependency>\n-        \t<groupId>de.odysseus.juel</groupId>\n-        \t<artifactId>juel-spi</artifactId>\n-        \t<version>2.2.7</version>\n-        \t<scope>runtime</scope>\n-        \t<optional>true</optional>\n+            <groupId>de.odysseus.juel</groupId>\n+            <artifactId>juel-spi</artifactId>\n+            <version>2.2.7</version>\n+            <scope>runtime</scope>\n+            <optional>true</optional>\n         </dependency>\n \n \n@@ -205,14 +207,18 @@\n                 <artifactId>maven-surefire-plugin</artifactId>\n                 <version>2.18.1</version>\n                 <configuration>\n+                    <!-- Sets the VM argument line used when unit tests are run.-->\n+                    <argLine>${surefireArgLine}</argLine>\n                     <skipTests>false</skipTests>\n                     <excludes>\n-                        <!-- exclude the suite which is a convenience class for running all tests from IDE or using scripts -->\n+                        <!-- exclude the suite which is a convenience class\n+                        for running all tests from IDE or using scripts -->\n                         <exclude>AllTests.java</exclude>\n                     </excludes>\n                 </configuration>\n             </plugin>\n \n+\n             <!-- bind the source attaching to package phase -->\n             <plugin>\n                 <groupId>org.apache.maven.plugins</groupId>\n@@ -250,27 +256,103 @@\n                 </executions>\n             </plugin>\n \n-\t<!-- \n-\tTo build and publish the javadoc run\n-\t\tmvn clean javadoc:javadoc scm-publish:publish-scm\n-\t --> \n-\t<plugin>\n-\t    <groupId>org.apache.maven.plugins</groupId>\n-\t    <artifactId>maven-scm-publish-plugin</artifactId>\n-\t    <version>1.0-beta-2</version>\n-\t    <configuration>\n-\t\t<checkoutDirectory>${project.build.directory}/scmpublish</checkoutDirectory>\n-\t\t<checkinComment>Publishing javadoc for ${project.artifactId}:${project.version}</checkinComment>\n-\t\t<content>${project.reporting.outputDirectory}/apidocs</content>\n-\t\t<skipDeletedFiles>true</skipDeletedFiles>\n-\t\t<pubScmUrl>scm:git:git@github.com:bennidi/mbassador.git</pubScmUrl>\n-\t\t<scmBranch>gh-pages</scmBranch> <!-- branch with static site on github-->\n-\t    </configuration>\n-\t</plugin>\n+            <!--\n+            To build and publish the javadoc run\n+                mvn clean javadoc:javadoc scm-publish:publish-scm\n+             -->\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-scm-publish-plugin</artifactId>\n+                <version>1.0-beta-2</version>\n+                <configuration>\n+                    <checkoutDirectory>${project.build.directory}/scmpublish</checkoutDirectory>\n+                    <checkinComment>Publishing javadoc for ${project.artifactId}:${project.version}</checkinComment>\n+                    <content>${project.reporting.outputDirectory}/apidocs</content>\n+                    <skipDeletedFiles>true</skipDeletedFiles>\n+                    <pubScmUrl>scm:git:git@github.com:bennidi/mbassador.git</pubScmUrl>\n+                    <scmBranch>gh-pages</scmBranch>\n+                    <!-- branch with static site on github-->\n+                </configuration>\n+            </plugin>\n         </plugins>\n     </build>\n \n     <profiles>\n+\n+        <profile>\n+            <id>jacoco-coverage</id>\n+\n+            <activation>\n+                <property>\n+                    <name>jacoco</name>\n+                </property>\n+            </activation>\n+            <build>\n+                <plugins>\n+\n+                    <!-- JaCoCo integration for code coverage reports\n+\n+               To receive a full list of goals and available parameters you can use maven-help-plugin:\n+               mvn help:describe -Dplugin=org.jacoco:jacoco-maven-plugin -Ddetail\n+              -->\n+                    <plugin>\n+                        <groupId>org.jacoco</groupId>\n+                        <artifactId>jacoco-maven-plugin</artifactId>\n+                        <version>0.7.5.201505241946</version>\n+                        <executions>\n+                            <!--\n+                                Prepares the property pointing to the JaCoCo runtime agent which\n+                                is passed as VM argument when Maven the Surefire plugin is executed.\n+                            -->\n+                            <execution>\n+                                <id>pre-unit-test</id>\n+                                <goals>\n+                                    <goal>prepare-agent</goal>\n+                                </goals>\n+                                <configuration>\n+                                    <!-- Sets the path to the file which contains the execution data. -->\n+                                    <destFile>${project.build.directory}/coverage-reports/jacoco-ut.exec</destFile>\n+                                    <!--\n+                                        Sets the name of the property containing the settings\n+                                        for JaCoCo runtime agent.\n+                                    -->\n+                                    <propertyName>surefireArgLine</propertyName>\n+                                </configuration>\n+                            </execution>\n+                            <!--\n+                                Ensures that the code coverage report for unit tests is created after\n+                                unit tests have been run.\n+                            -->\n+                            <execution>\n+                                <id>post-unit-test</id>\n+                                <phase>test</phase>\n+                                <goals>\n+                                    <goal>report</goal>\n+                                </goals>\n+                                <configuration>\n+                                    <!-- Sets the path to the file which contains the execution data. -->\n+                                    <dataFile>${project.build.directory}/coverage-reports/jacoco-ut.exec</dataFile>\n+                                    <!-- Sets the output directory for the code coverage report. -->\n+                                    <outputDirectory>${project.reporting.outputDirectory}/jacoco-ut</outputDirectory>\n+                                </configuration>\n+                            </execution>\n+                        </executions>\n+                    </plugin>\n+\n+                </plugins>\n+            </build>\n+        </profile>\n+\n+\n+        <!-- Configure the signing of the artefact when the release is performed\n+\n+        mvn clean deploy\n+        mvn release:clean\n+        mvn release:prepare\n+        mvn release:perform\n+\n+\n+        -->\n         <profile>\n             <id>release-sign-artifacts</id>\n             <activation>\n"
    },
    {
        "commit hash": "b15ad227f315aa2bc327f39a0fc7778192811ebe",
        "previous commit hash": "35886bb3b5ad1a9cdc773aa61954aca960ab89f2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/IMessagePublication.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -32,9 +32,9 @@ public interface IMessagePublication {\n \n     IMessagePublication markScheduled(); // TODO: this method should not be part of the interface\n \n-    boolean isDeadEvent();\n+    boolean isDeadMessage();\n \n-    boolean isFilteredEvent();\n+    boolean isFilteredMessage();\n \n     Object getMessage();\n \n"
    },
    {
        "commit hash": "b15ad227f315aa2bc327f39a0fc7778192811ebe",
        "previous commit hash": "35886bb3b5ad1a9cdc773aa61954aca960ab89f2",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MessagePublication.java",
            "additions": 9,
            "deletions": 5
        },
        "diff content": "@@ -46,11 +46,15 @@ public class MessagePublication implements IMessagePublication {\n            sub.publish(this, message);\n         }\n         state = State.Finished;\n-        // if the message has not been marked delivered by the dispatcher\n+        // This part is necessary to support the feature of publishing a DeadMessage or FilteredMessage\n+        // in case that the original message has not made it to any listener.\n+        // This happens if subscriptions are empty (due to GC of weak listeners or explicit desubscription)\n+        // or if configured filters do not let a message pass. The flag is set by the dispatchers.\n+        // META: This seems to be a suboptimal design\n         if (!delivered) {\n-            if (!isFilteredEvent() && !isDeadEvent()) {\n+            if (!isFilteredMessage() && !isDeadMessage()) {\n                 runtime.getProvider().publish(new FilteredMessage(message));\n-            } else if (!isDeadEvent()) {\n+            } else if (!isDeadMessage()) {\n                 runtime.getProvider().publish(new DeadMessage(message));\n             }\n \n@@ -81,11 +85,11 @@ public class MessagePublication implements IMessagePublication {\n     }\n \n \n-    public boolean isDeadEvent() {\n+    public boolean isDeadMessage() {\n         return DeadMessage.class.equals(message.getClass());\n     }\n \n-    public boolean isFilteredEvent() {\n+    public boolean isFilteredMessage() {\n         return FilteredMessage.class.equals(message.getClass());\n     }\n \n"
    },
    {
        "commit hash": "b15ad227f315aa2bc327f39a0fc7778192811ebe",
        "previous commit hash": "35886bb3b5ad1a9cdc773aa61954aca960ab89f2",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AsyncFIFOBusTest.java",
            "additions": 21,
            "deletions": 7
        },
        "diff content": "@@ -1,6 +1,8 @@\n package net.engio.mbassy;\n \n+import junit.framework.Assert;\n import net.engio.mbassy.bus.BusFactory;\n+import net.engio.mbassy.bus.IMessagePublication;\n import net.engio.mbassy.bus.common.IMessageBus;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.listener.Handler;\n@@ -68,22 +70,34 @@ public class AsyncFIFOBusTest extends MessageBusTest {\n         for(int i = 0; i < messages.length ; i++){\n             messages[i] = i;\n         }\n+        IMessagePublication publication = null;\n         // publish in ascending order\n         for(Integer message : messages)\n-            fifoBUs.post(message).asynchronously();\n+            publication = fifoBUs.post(message).asynchronously();\n \n-        while(fifoBUs.hasPendingMessages())\n-            pause(2000);\n+        while(fifoBUs.hasPendingMessages() && ! publication.isFinished())\n+            pause(200);\n \n+        // Check the handlers processing status\n+        // Define timeframe in which processing should be finished\n+        // If not then an error is assumed\n+        long timeElapsed = 0;\n+        long timeOut = 30000; // 30 seconds\n+        long begin =  System.currentTimeMillis();\n         for(SyncAsyncListener listener : listeners){\n-            assertEquals(messages.length, listener.receivedSync.size());\n-            assertEquals(listener.receivedSync.size(), listener.receivedAsync.size());\n+            boolean successful = true;\n+            successful &= messages.length == listener.receivedSync.size();\n+            successful &=  listener.receivedSync.size() ==listener.receivedAsync.size();\n             for(int i=0; i < listener.receivedAsync.size(); i++){\n-                assertEquals(messages[i], listener.receivedSync.get(i));\n+                successful &= messages[i] == listener.receivedSync.get(i);\n                 // sync and async in same order\n-                assertEquals(listener.receivedSync.get(i), listener.receivedAsync.get(i));\n+                successful &= listener.receivedSync.get(i) == listener.receivedAsync.get(i);\n             }\n+            if(successful)\n+                break;\n+            timeElapsed = System.currentTimeMillis() - begin;\n         }\n+        if(timeElapsed >= timeOut) Assert.fail(\"Processing of handlers unfinished after timeout\");\n \n     }\n \n"
    },
    {
        "commit hash": "b15ad227f315aa2bc327f39a0fc7778192811ebe",
        "previous commit hash": "35886bb3b5ad1a9cdc773aa61954aca960ab89f2",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java",
            "additions": 17,
            "deletions": 5
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy;\n \n+import junit.framework.Assert;\n import net.engio.mbassy.bus.IMessagePublication;\n import net.engio.mbassy.bus.common.IMessageBus;\n import net.engio.mbassy.bus.config.Feature;\n@@ -22,7 +23,7 @@ import java.util.List;\n public class SynchronizedHandlerTest extends MessageBusTest {\n \n \n-    private static int incrementsPerMessage = 10000;\n+    private static int incrementsPerMessage = 1000;\n     private static int numberOfMessages = 1000;\n     private static int numberOfListeners = 1000;\n \n@@ -71,11 +72,22 @@ public class SynchronizedHandlerTest extends MessageBusTest {\n             track(bus.post(new Object()).asynchronously());\n         }\n \n-        pause(10000);\n-\n-        for(SynchronizedWithAsynchronousDelivery handler : handlers){\n-            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n+        // Check the handlers processing status\n+        // Define timeframe in which processing should be finished\n+        // If not then an error is assumed\n+        long timeElapsed = 0;\n+        long timeOut = 30000; // 30 seconds\n+        long begin =  System.currentTimeMillis();\n+        while (timeElapsed < timeOut) {\n+            boolean successful = true;\n+            for (SynchronizedWithAsynchronousDelivery handler : handlers) {\n+                successful &= incrementsPerMessage * numberOfMessages ==  handler.counter;\n+            }\n+            if(successful)\n+                break;\n+            timeElapsed = System.currentTimeMillis() - begin;\n         }\n+        if(timeElapsed >= timeOut) Assert.fail(\"Processing of handlers unfinished after timeout\");\n \n     }\n \n"
    },
    {
        "commit hash": "b15ad227f315aa2bc327f39a0fc7778192811ebe",
        "previous commit hash": "35886bb3b5ad1a9cdc773aa61954aca960ab89f2",
        "diff stats": {
            "file_path": "testNTimes.sh",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -1,5 +1,6 @@\n #!/bin/bash\n-for (( i = 1; i < $1 ; i++ ))\n+mvn clean\n+for (( i = 1; i < $1 + 1 ; i++ ))\n do\n   echo \"Round $i\"\n   mvn test -o -Dtest=$2\n"
    },
    {
        "commit hash": "dfc1421229a344fe692e7de4313b2e974fd0bcb4",
        "previous commit hash": "22e9becc73841c2b53615e4388f514ea1832b12e",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageListener.java",
            "additions": 2,
            "deletions": 0
        },
        "diff content": "@@ -69,6 +69,7 @@ public class MessageListener<T> {\n         return handlers.toArray(asArray);\n     }\n \n+    // used by unit tests\n     public List<MessageHandler> getHandlers(IPredicate<MessageHandler> filter) {\n         List<MessageHandler> matching = new ArrayList<MessageHandler>();\n         for (MessageHandler handler : handlers) {\n@@ -79,6 +80,7 @@ public class MessageListener<T> {\n         return matching;\n     }\n \n+    // used by unit tests\n     public boolean handles(Class<?> messageType) {\n         return !getHandlers(ForMessage(messageType)).isEmpty();\n     }\n"
    },
    {
        "commit hash": "22e9becc73841c2b53615e4388f514ea1832b12e",
        "previous commit hash": "c31467da32150ea54b6eafa90f1973ef6ad0345c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java",
            "additions": 10,
            "deletions": 7
        },
        "diff content": "@@ -142,7 +142,8 @@ public class SubscriptionManager {\n             Subscription[] subscriptionsByListener = getSubscriptionsByListener(listener);\n \n             if (subscriptionsByListener == null) {\n-                for (Subscription subscription : subscriptions) {\n+                for (int i=0, n=subscriptions.length; i<n; i++) {\n+                    Subscription subscription = subscriptions[i];\n                     subscription.subscribe(listener);\n \n                     for (Class<?> messageType : subscription.getHandledMessageTypes()) {\n@@ -161,15 +162,14 @@ public class SubscriptionManager {\n             // the rare case when multiple threads concurrently subscribed the same class for the first time\n             // one will be first, all others will have to subscribe to the existing instead the generated subscriptions\n             else {\n-                for (Subscription existingSubscription : subscriptionsByListener) {\n+                for (int i=0, n=subscriptionsByListener.length; i<n; i++) {\n+                    Subscription existingSubscription = subscriptionsByListener[i];\n                     existingSubscription.subscribe(listener);\n                 }\n             }\n         } finally {\n             writeLock.unlock();\n         }\n-\n-\n     }\n \n     // obtain the set of subscriptions for the given message type\n@@ -187,11 +187,14 @@ public class SubscriptionManager {\n                 subscriptions.addAll(subsPerMessage);\n             }\n \n-            for (Class eventSuperType : ReflectionUtils.getSuperTypes(messageType)) {\n+            Class[] types = ReflectionUtils.getSuperTypes(messageType);\n+            for (int i=0, n=types.length; i<n; i++) {\n+                Class eventSuperType = types[i];\n+                \n                 ArrayList<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n                 if (subs != null) {\n-                    for (int i = 0; i < subs.size(); i++) {\n-                        subscription = subs.get(i);\n+                    for (int j = 0,m=subs.size(); j<m; j++) {\n+                        subscription = subs.get(j);\n \n                         if (subscription.handlesMessageType(messageType)) {\n                             subscriptions.add(subscription);\n"
    },
    {
        "commit hash": "fda940c2d232ffcdc862a0cf415ceee2561cfa8d",
        "previous commit hash": "d7201d536c1051dce9cf789b159bd378988ba678",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java",
            "additions": 13,
            "deletions": 6
        },
        "diff content": "@@ -25,7 +25,7 @@ public abstract class AbstractConcurrentSet<T> implements Set<T> {\n \n     // Internal state\n     protected final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n-    private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(log n) lookup\n+    private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(1) lookup\n     protected Entry<T> head; // reference to the first element\n \n     protected AbstractConcurrentSet(Map<T, ISetEntry<T>> entries) {\n@@ -38,9 +38,13 @@ public abstract class AbstractConcurrentSet<T> implements Set<T> {\n     public boolean add(T element) {\n         if (element == null) return false;\n         Lock writeLock = lock.writeLock();\n-        writeLock.lock();\n-        boolean changed = insert(element);\n-        writeLock.unlock();\n+        boolean changed;\n+        try {\n+            writeLock.lock();\n+            changed = insert(element);\n+        } finally {\n+            writeLock.unlock();\n+        }\n         return changed;\n     }\n \n@@ -51,13 +55,17 @@ public abstract class AbstractConcurrentSet<T> implements Set<T> {\n         try {\n             readLock.lock();\n             entry = entries.get(element);\n-\n         } finally {\n             readLock.unlock();\n         }\n         return entry != null && entry.getValue() != null;\n     }\n \n+\n+    /**\n+     * Inserts a new element at the head of the set.\n+     * Note: This method is expected to be synchronized by the calling code\n+     */\n     private boolean insert(T element) {\n         if (!entries.containsKey(element)) {\n             head = createEntry(element, head);\n@@ -80,7 +88,6 @@ public abstract class AbstractConcurrentSet<T> implements Set<T> {\n     @Override\n     public boolean addAll(Collection<? extends T> elements) {\n         boolean changed = false;\n-\n         Lock writeLock = lock.writeLock();\n         try {\n             writeLock.lock();\n"
    },
    {
        "commit hash": "fda940c2d232ffcdc862a0cf415ceee2561cfa8d",
        "previous commit hash": "d7201d536c1051dce9cf789b159bd378988ba678",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/StrongConcurrentSet.java",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -15,7 +15,6 @@ public class StrongConcurrentSet<T> extends AbstractConcurrentSet<T>{\n \n \n     public StrongConcurrentSet() {\n-        // ConcurrentHashMapV8 is 15%-20% faster than regular ConcurrentHashMap, which is also faster than HashMap.\n         super(new HashMap<T, ISetEntry<T>>());\n     }\n \n"
    },
    {
        "commit hash": "fda940c2d232ffcdc862a0cf415ceee2561cfa8d",
        "previous commit hash": "d7201d536c1051dce9cf789b159bd378988ba678",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 31,
            "deletions": 1
        },
        "diff content": "@@ -3,9 +3,11 @@ package net.engio.mbassy.subscription;\n import net.engio.mbassy.bus.IMessagePublication;\n import net.engio.mbassy.dispatch.IMessageDispatcher;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Comparator;\n import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n \n /**\n  * A subscription is a thread-safe container that manages exactly one message handler of all registered\n@@ -29,6 +31,9 @@ public class Subscription {\n \n     private final SubscriptionContext context;\n \n+    private final CopyOnWriteArrayList<Runnable> onSubscription = new CopyOnWriteArrayList<Runnable>();\n+\n+\n     Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, Collection<Object> listeners) {\n         this.context = context;\n         this.dispatcher = dispatcher;\n@@ -73,9 +78,11 @@ public class Subscription {\n \n     public void subscribe(Object o) {\n         listeners.add(o);\n+        for(Runnable callback : onSubscription.toArray(new Runnable[]{})){\n+            callback.run();\n+        }\n     }\n \n-\n     public boolean unsubscribe(Object existingListener) {\n         return listeners.remove(existingListener);\n     }\n@@ -85,6 +92,10 @@ public class Subscription {\n     }\n \n \n+    public Handle getHandle(){\n+        return new Handle();\n+    }\n+\n     public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n         @Override\n         public int compare(Subscription o1, Subscription o2) {\n@@ -94,5 +105,24 @@ public class Subscription {\n     };\n \n \n+    /**\n+     *  A handle exposes specific functionality of a subscription to be used by clients.\n+     *\n+     */\n+    public class Handle {\n+\n+        /**\n+         * Add a runnable that is invoked after a new listener is subscribed to the corresponding subscription.\n+         * The runnable does not receive any information on the event to prevent clients from untroducing coupling\n+         * between senders/receivers.\n+         *\n+         * @param handler The code to be run after each subscription\n+         */\n+        void onSubscription(Runnable handler){\n+            Subscription.this.onSubscription.add(handler);\n+        }\n+\n+    }\n+\n \n }\n"
    },
    {
        "commit hash": "fda940c2d232ffcdc862a0cf415ceee2561cfa8d",
        "previous commit hash": "d7201d536c1051dce9cf789b159bd378988ba678",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java",
            "additions": 23,
            "deletions": 24
        },
        "diff content": "@@ -22,29 +22,29 @@ import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;\n  */\n public class SubscriptionManager {\n \n-    // the metadata reader that is used to inspect objects passed to the subscribe method\n+    // The metadata reader that is used to inspect objects passed to the subscribe method\n     private final MetadataReader metadataReader;\n \n-    // all subscriptions per message type\n-    // this is the primary list for dispatching a specific message\n+    // All subscriptions per message type\n+    // This is the primary list for dispatching a specific message\n     // write access is synchronized and happens only when a listener of a specific class is registered the first time\n     private final Map<Class, Collection<Subscription>> subscriptionsPerMessage;\n \n-    // all subscriptions per messageHandler type\n-    // this map provides fast access for subscribing and unsubscribing\n+    // All subscriptions per messageHandler type\n+    // This map provides fast access for subscribing and unsubscribing\n     // write access is synchronized and happens very infrequently\n-    // once a collection of subscriptions is stored it does not change\n+    // Once a collection of subscriptions is stored it does not change\n     private final Map<Class, Collection<Subscription>> subscriptionsPerListener;\n \n \n-    // remember already processed classes that do not contain any message handlers\n+    // Remember already processed classes that do not contain any message handlers\n     private final StrongConcurrentSet<Class> nonListeners = new StrongConcurrentSet<Class>();\n \n-    // this factory is used to create specialized subscriptions based on the given message handler configuration\n-    // it can be customized by implementing the getSubscriptionFactory() method\n+    // This factory is used to create specialized subscriptions based on the given message handler configuration\n+    // It can be customized by implementing the getSubscriptionFactory() method\n     private final SubscriptionFactory subscriptionFactory;\n \n-    // synchronize read/write acces to the subscription maps\n+    // Synchronize read/write access to the subscription maps\n     private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n \n     private final BusRuntime runtime;\n@@ -54,9 +54,8 @@ public class SubscriptionManager {\n         this.subscriptionFactory = subscriptionFactory;\n         this.runtime = runtime;\n \n-        // ConcurrentHashMapV8 is 15%-20% faster than regular ConcurrentHashMap, which is also faster than HashMap.\n-        subscriptionsPerMessage = new HashMap<Class, Collection<Subscription>>(64);\n-        subscriptionsPerListener = new HashMap<Class, Collection<Subscription>>(64);\n+        subscriptionsPerMessage = new HashMap<Class, Collection<Subscription>>(256);\n+        subscriptionsPerListener = new HashMap<Class, Collection<Subscription>>(256);\n     }\n \n \n@@ -97,7 +96,7 @@ public class SubscriptionManager {\n             }\n             \n             Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n-            // a listener is either subscribed for the first time\n+            // A listener is either subscribed for the first time [1]\n             if (subscriptionsByListener == null) {\n                 List<MessageHandler> messageHandlers = metadataReader.getMessageListener(listenerClass).getHandlers();\n                 if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n@@ -105,15 +104,15 @@ public class SubscriptionManager {\n                     return;\n                 }\n                 subscriptionsByListener = new ArrayDeque<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n-                // create subscriptions for all detected message handlers\n+                // Create subscriptions for all detected message handlers\n                 for (MessageHandler messageHandler : messageHandlers) {\n-                    // create the subscription\n+                    // Create the subscription\n                     subscriptionsByListener.add(subscriptionFactory.createSubscription(runtime, messageHandler));\n                 }\n-                // this will acquire a write lock and handle the case when another thread already subscribed\n+                // This will acquire a write lock and handle the case when another thread already subscribed\n                 // this particular listener in the mean-time\n                 subscribe(listener, subscriptionsByListener);\n-            } // or the subscriptions already exist and must only be updated\n+            } // [1]...or the subscriptions already exists and must only be updated\n             else {\n                 for (Subscription sub : subscriptionsByListener) {\n                     sub.subscribe(listener);\n@@ -130,11 +129,11 @@ public class SubscriptionManager {\n         WriteLock writeLock = readWriteLock.writeLock();\n         try {\n             writeLock.lock();\n-            // basically this is a deferred double check\n-            // it's an ugly pattern but necessary because atomic upgrade from read to write lock\n-            // is not possible\n-            // the alternative of using a write lock from the beginning would decrease performance dramatically\n-            // because of the huge number of reads compared to writes\n+            // Basically this is a deferred double check.\n+            // It's an ugly pattern but necessary because atomic upgrade from read to write lock\n+            // is not possible.\n+            // The alternative of using a write lock from the beginning would decrease performance dramatically\n+            // due to the read heavy read:write ratio\n             Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n \n             if (subscriptionsByListener == null) {\n@@ -147,7 +146,7 @@ public class SubscriptionManager {\n                 subscriptionsPerListener.put(listener.getClass(), subscriptions);\n             }\n             // the rare case when multiple threads concurrently subscribed the same class for the first time\n-            // one will be first, all others will have to subscribe to the existing instead the generated subscriptions\n+            // one will be first, all others will subscribe to the newly created subscriptions\n             else {\n                 for (Subscription existingSubscription : subscriptionsByListener) {\n                     existingSubscription.subscribe(listener);\n"
    },
    {
        "commit hash": "6df0bae0c1b5025321813a7e06562b2a0d5df634",
        "previous commit hash": "5bc924c11dd339fb288c69128d7d2faba58e3d07",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -228,9 +228,9 @@ Special thanks also to [Sonatype](http://www.sonatype.com/) for the hosting of t\n \n <h2>Contribute</h2>\n \n-Any feature requests and feedback are more than welcome. You may suggest improvements or report bugs either by submitting an issue - I will try to respond as quickly as possible. Please try to be precise in the description of your requirements. Following a hands-on mentality please feel invited to contribute by by forking the repo and creating a pull request to submit the code you would like to be included. Make your PRs small and provide test code! Take a look at [this issue](bennidi/mbassador#106) for a good example.\n+Any feature requests and feedback are more than welcome. You may suggest improvements or report bugs either by submitting an issue - I will try to respond as quickly as possible. Please try to be precise in the description of your requirements. Following a hands-on mentality please feel invited to contribute by by forking the repo and creating a pull request to submit the code you would like to be included. Make your PRs small and provide test code! Take a look at [this issue](bennidi/mbassador#109) for a good example.\n \n-Sample code and documentation are both very appreciated contributions. Especially integration with different frameworks is of great value. Feel free and welcome to create Wiki pages to share your code and ideas. Example: [Guice integration](bennidi/mbassador/wiki/guice-integration)\n+Sample code and documentation are both very appreciated contributions. Especially integration with different frameworks is of great value. Feel free and welcome to create Wiki pages to share your code and ideas. Example: [Guice integration](https://github.com/bennidi/mbassador/wiki/Guice-Integration)\n \n <h2>License</h2>\n \n"
    },
    {
        "commit hash": "c31467da32150ea54b6eafa90f1973ef6ad0345c",
        "previous commit hash": "017f52a3c9593e6294db4059eb643a8e07de9440",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ReflectionUtils.java",
            "additions": 116,
            "deletions": 97
        },
        "diff content": "@@ -3,6 +3,8 @@ package net.engio.mbassy.common;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.AnnotatedElement;\n import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.List;\n@@ -16,44 +18,53 @@ import java.util.Set;\n public class ReflectionUtils\n {\n \n-\tpublic static List<Method> getMethods( IPredicate<Method> condition, Class<?> target ) {\n-\t\tList<Method> methods = new LinkedList<Method>();\n-\t\ttry {\n-\t\t\tfor ( Method method : target.getDeclaredMethods() ) {\n-\t\t\t\tif ( condition.apply( method ) ) {\n-\t\t\t\t\tmethods.add( method );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tcatch ( Exception e ) {\n-\t\t\t//nop\n-\t\t}\n-\t\tif ( !target.equals( Object.class ) ) {\n-\t\t\tmethods.addAll( getMethods( condition, target.getSuperclass() ) );\n-\t\t}\n-\t\treturn methods;\n-\t}\n-\n-\t/**\n-\t * Traverses the class hierarchy upwards, starting at the given subclass, looking\n-\t * for an override of the given methods -> finds the bottom most override of the given\n-\t * method if any exists\n-\t *\n-\t * @param overridingMethod\n-\t * @param subclass\n-\t */\n-\tpublic static Method getOverridingMethod( final Method overridingMethod, final Class subclass ) {\n-\t\tClass current = subclass;\n-\t\twhile ( !current.equals( overridingMethod.getDeclaringClass() ) ) {\n-\t\t\ttry {\n-\t\t\t\treturn current.getDeclaredMethod( overridingMethod.getName(), overridingMethod.getParameterTypes() );\n-\t\t\t}\n-\t\t\tcatch ( NoSuchMethodException e ) {\n-\t\t\t\tcurrent = current.getSuperclass();\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n+    public static Method[] getMethods(IPredicate<Method> condition, Class<?> target) {\n+        ArrayList<Method> methods = new ArrayList<Method>();\n+\n+        getMethods(condition, target, methods);\n+\n+        final Method[] array = new Method[methods.size()];\n+        methods.toArray(array);\n+        return array;\n+    }\n+\n+\n+    public static void getMethods(IPredicate<Method> condition, Class<?> target, ArrayList<Method> methods) {\n+        try {\n+            for ( Method method : target.getDeclaredMethods() ) {\n+                if ( condition.apply( method ) ) {\n+                    methods.add( method );\n+                }\n+            }\n+        }\n+        catch ( Exception e ) {\n+            //nop\n+        }\n+        if ( !target.equals( Object.class ) ) {\n+            getMethods(condition, target.getSuperclass(), methods);\n+        }\n+    }\n+\n+    /**\n+    * Traverses the class hierarchy upwards, starting at the given subclass, looking\n+    * for an override of the given methods -> finds the bottom most override of the given\n+    * method if any exists\n+    *\n+    * @param overridingMethod\n+    * @param subclass\n+    */\n+    public static Method getOverridingMethod( final Method overridingMethod, final Class subclass ) {\n+        Class current = subclass;\n+        while ( !current.equals( overridingMethod.getDeclaringClass() ) ) {\n+            try {\n+                return current.getDeclaredMethod( overridingMethod.getName(), overridingMethod.getParameterTypes() );\n+            }\n+            catch ( NoSuchMethodException e ) {\n+                current = current.getSuperclass();\n+            }\n+        }\n+        return null;\n+    }\n \n     /**\n      * Collect all directly and indirectly related super types (classes and interfaces) of\n@@ -62,45 +73,53 @@ public class ReflectionUtils\n      * @param from The root class to start with\n      * @return A set of classes, each representing a super type of the root class\n      */\n-\tpublic static Set<Class> getSuperTypes(Class from) {\n-\t\tSet<Class> superclasses = new HashSet<Class>();\n-\t\tcollectInterfaces( from, superclasses );\n-\t\twhile ( !from.equals( Object.class ) && !from.isInterface() ) {\n-\t\t\tsuperclasses.add( from.getSuperclass() );\n-\t\t\tfrom = from.getSuperclass();\n-\t\t\tcollectInterfaces( from, superclasses );\n-\t\t}\n-\t\treturn superclasses;\n-\t}\n-\n-\tpublic static void collectInterfaces( Class from, Set<Class> accumulator ) {\n-\t\tfor ( Class intface : from.getInterfaces() ) {\n-\t\t\taccumulator.add( intface );\n-\t\t\tcollectInterfaces( intface, accumulator );\n-\t\t}\n-\t}\n-\n-\tpublic static boolean containsOverridingMethod( final List<Method> allMethods, final Method methodToCheck ) {\n-\t\tfor ( Method method : allMethods ) {\n-\t\t\tif ( isOverriddenBy( methodToCheck, method ) ) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\n-\n-\t/**\n-\t * Searches for an Annotation of the given type on the class.  Supports meta annotations.\n-\t *\n-\t * @param from AnnotatedElement (class, method...)\n-\t * @param annotationType Annotation class to look for.\n-\t * @param <A> Class of annotation type\n-\t * @return Annotation instance or null\n-\t */\n-\tprivate static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType, Set<AnnotatedElement> visited) {\n-\t\tif( visited.contains(from) ) return null;\n+    public static Class[] getSuperTypes(Class from) {\n+        ArrayList<Class> superclasses = new ArrayList<Class>();\n+\n+        collectInterfaces( from, superclasses );\n+        while ( !from.equals( Object.class ) && !from.isInterface() ) {\n+            superclasses.add( from.getSuperclass() );\n+            from = from.getSuperclass();\n+            collectInterfaces( from, superclasses );\n+        }\n+\n+        final Class[] classes = new Class[superclasses.size()];\n+        superclasses.toArray(classes);\n+        return classes;\n+    }\n+\n+    public static void collectInterfaces( Class from, Collection<Class> accumulator ) {\n+        for ( Class intface : from.getInterfaces() ) {\n+            accumulator.add( intface );\n+            collectInterfaces( intface, accumulator );\n+        }\n+    }\n+\n+    public static boolean containsOverridingMethod( final Method[] allMethods, final Method methodToCheck ) {\n+        final int length = allMethods.length;\n+        Method method;\n+        for (int i = 0; i < length; i++) {\n+            method = allMethods[i];\n+\n+            if ( isOverriddenBy( methodToCheck, method ) ) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+\n+\n+    /**\n+    * Searches for an Annotation of the given type on the class.  Supports meta annotations.\n+    *\n+    * @param from AnnotatedElement (class, method...)\n+    * @param annotationType Annotation class to look for.\n+    * @param <A> Class of annotation type\n+    * @return Annotation instance or null\n+    */\n+    private static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType, Set<AnnotatedElement> visited) {\n+        if( visited.contains(from) ) return null;\n         visited.add(from);\n         A ann = from.getAnnotation( annotationType );\n         if( ann != null) return ann;\n@@ -111,32 +130,32 @@ public class ReflectionUtils\n             }\n         }\n         return null;\n-\t}\n+    }\n \n     public static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType){\n        return getAnnotation(from, annotationType, new HashSet<AnnotatedElement>());\n     }\n \n-\tprivate static boolean isOverriddenBy( Method superclassMethod, Method subclassMethod ) {\n-\t\t// if the declaring classes are the same or the subclass method is not defined in the subclass\n-\t\t// hierarchy of the given superclass method or the method names are not the same then\n-\t\t// subclassMethod does not override superclassMethod\n-\t\tif ( superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass() )\n+    private static boolean isOverriddenBy( Method superclassMethod, Method subclassMethod ) {\n+        // if the declaring classes are the same or the subclass method is not defined in the subclass\n+        // hierarchy of the given superclass method or the method names are not the same then\n+        // subclassMethod does not override superclassMethod\n+        if ( superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass() )\n                 || !superclassMethod.getDeclaringClass().isAssignableFrom( subclassMethod.getDeclaringClass() )\n                 || !superclassMethod.getName().equals(subclassMethod.getName())) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tClass[] superClassMethodParameters = superclassMethod.getParameterTypes();\n-\t\tClass[] subClassMethodParameters = subclassMethod.getParameterTypes();\n-\t\t// method must specify the same number of parameters\n-\t\t//the parameters must occur in the exact same order\n-\t\tfor ( int i = 0; i < subClassMethodParameters.length; i++ ) {\n-\t\t\tif ( !superClassMethodParameters[i].equals( subClassMethodParameters[i] ) ) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\treturn true;\n-\t}\n+            return false;\n+        }\n+\n+        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n+        Class[] subClassMethodParameters = subclassMethod.getParameterTypes();\n+        // method must specify the same number of parameters\n+        //the parameters must occur in the exact same order\n+        for ( int i = 0; i < subClassMethodParameters.length; i++ ) {\n+            if ( !superClassMethodParameters[i].equals( subClassMethodParameters[i] ) ) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n \n }\n"
    },
    {
        "commit hash": "c31467da32150ea54b6eafa90f1973ef6ad0345c",
        "previous commit hash": "017f52a3c9593e6294db4059eb643a8e07de9440",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageListener.java",
            "additions": 5,
            "deletions": 4
        },
        "diff content": "@@ -35,7 +35,7 @@ public class MessageListener<T> {\n         };\n     }\n \n-    private List<MessageHandler> handlers = new ArrayList<MessageHandler>();\n+    private ArrayList<MessageHandler> handlers = new ArrayList<MessageHandler>();\n \n     private Class<T> listenerDefinition;\n \n@@ -64,12 +64,13 @@ public class MessageListener<T> {\n         return handlers.add(messageHandler);\n     }\n \n-    public List<MessageHandler> getHandlers(){\n-        return handlers;\n+    public MessageHandler[] getHandlers(){\n+        MessageHandler[] asArray = new MessageHandler[handlers.size()];\n+        return handlers.toArray(asArray);\n     }\n \n     public List<MessageHandler> getHandlers(IPredicate<MessageHandler> filter) {\n-        List<MessageHandler> matching = new LinkedList<MessageHandler>();\n+        List<MessageHandler> matching = new ArrayList<MessageHandler>();\n         for (MessageHandler handler : handlers) {\n             if (filter.apply(handler)) {\n                 matching.add(handler);\n"
    },
    {
        "commit hash": "c31467da32150ea54b6eafa90f1973ef6ad0345c",
        "previous commit hash": "017f52a3c9593e6294db4059eb643a8e07de9440",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MetadataReader.java",
            "additions": 26,
            "deletions": 24
        },
        "diff content": "@@ -5,6 +5,7 @@ import net.engio.mbassy.common.ReflectionUtils;\n import net.engio.mbassy.subscription.MessageEnvelope;\n \n import java.lang.reflect.Method;\n+import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n@@ -22,7 +23,7 @@ public class MetadataReader {\n     private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n         @Override\n         public boolean apply(Method target) {\n-\t        return ReflectionUtils.getAnnotation(target, Handler.class) != null;\n+            return ReflectionUtils.getAnnotation(target, Handler.class) != null;\n         }\n     };\n \n@@ -57,36 +58,38 @@ public class MetadataReader {\n     public MessageListener getMessageListener(Class target) {\n         MessageListener listenerMetadata = new MessageListener(target);\n         // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n-        List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n+        Method[] allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n+        final int length = allHandlers.length;\n+\n         // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n-        List<Method> bottomMostHandlers = new LinkedList<Method>();\n-        for (Method handler : allHandlers) {\n+        List<Method> bottomMostHandlers = new ArrayList<Method>(length);\n+\n+        Method handler;\n+        for (int i = 0; i < length; i++) {\n+            handler = allHandlers[i];\n+\n             if (!ReflectionUtils.containsOverridingMethod(allHandlers, handler)) {\n-                bottomMostHandlers.add(handler);\n-            }\n-        }\n+                // for each handler there will be no overriding method that specifies @Handler annotation\n+                // but an overriding method does inherit the listener configuration of the overwritten method\n \n-        // for each handler there will be no overriding method that specifies @Handler annotation\n-        // but an overriding method does inherit the listener configuration of the overwritten method\n-        for (Method handler : bottomMostHandlers) {\n-            Handler handlerConfig = ReflectionUtils.getAnnotation( handler, Handler.class);\n-            if (!handlerConfig.enabled() || !isValidMessageHandler(handler)) {\n-                continue; // disabled or invalid listeners are ignored\n+                Handler handlerConfig = ReflectionUtils.getAnnotation( handler, Handler.class);\n+                if (!handlerConfig.enabled() || !isValidMessageHandler(handler)) {\n+                    continue; // disabled or invalid listeners are ignored\n+                }\n+                Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n+                // if a handler is overwritten it inherits the configuration of its parent method\n+                Map<String, Object> handlerProperties = MessageHandler.Properties.Create(overriddenHandler == null ? handler : overriddenHandler,\n+                                                                                         handlerConfig,\n+                                                                                         getFilter(handlerConfig),\n+                                                                                         listenerMetadata);\n+                MessageHandler handlerMetadata = new MessageHandler(handlerProperties);\n+                listenerMetadata.addHandler(handlerMetadata);\n             }\n-            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n-            // if a handler is overwritten it inherits the configuration of its parent method\n-            Map<String, Object> handlerProperties = MessageHandler.Properties.Create(overriddenHandler == null ? handler : overriddenHandler,\n-                    handlerConfig, getFilter(handlerConfig), listenerMetadata);\n-            MessageHandler handlerMetadata = new MessageHandler(handlerProperties);\n-            listenerMetadata.addHandler(handlerMetadata);\n-\n         }\n+\n         return listenerMetadata;\n     }\n \n-\n-\n-\n     private boolean isValidMessageHandler(Method handler) {\n         if (handler == null || ReflectionUtils.getAnnotation( handler, Handler.class) == null) {\n             return false;\n@@ -108,5 +111,4 @@ public class MetadataReader {\n         }\n         return true;\n     }\n-\n }\n"
    },
    {
        "commit hash": "c31467da32150ea54b6eafa90f1973ef6ad0345c",
        "previous commit hash": "017f52a3c9593e6294db4059eb643a8e07de9440",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java",
            "additions": 43,
            "deletions": 37
        },
        "diff content": "@@ -28,13 +28,13 @@ public class SubscriptionManager {\n     // all subscriptions per message type\n     // this is the primary list for dispatching a specific message\n     // write access is synchronized and happens only when a listener of a specific class is registered the first time\n-    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage;\n+    private final Map<Class, ArrayList<Subscription>> subscriptionsPerMessage;\n \n     // all subscriptions per messageHandler type\n     // this map provides fast access for subscribing and unsubscribing\n     // write access is synchronized and happens very infrequently\n     // once a collection of subscriptions is stored it does not change\n-    private final Map<Class, Collection<Subscription>> subscriptionsPerListener;\n+    private final Map<Class, Subscription[]> subscriptionsPerListener;\n \n \n     // remember already processed classes that do not contain any message handlers\n@@ -54,9 +54,8 @@ public class SubscriptionManager {\n         this.subscriptionFactory = subscriptionFactory;\n         this.runtime = runtime;\n \n-        // ConcurrentHashMapV8 is 15%-20% faster than regular ConcurrentHashMap, which is also faster than HashMap.\n-        subscriptionsPerMessage = new HashMap<Class, Collection<Subscription>>(64);\n-        subscriptionsPerListener = new HashMap<Class, Collection<Subscription>>(64);\n+        subscriptionsPerMessage = new HashMap<Class, ArrayList<Subscription>>(64);\n+        subscriptionsPerListener = new HashMap<Class, Subscription[]>(64);\n     }\n \n \n@@ -64,7 +63,7 @@ public class SubscriptionManager {\n         if (listener == null) {\n             return false;\n         }\n-        Collection<Subscription> subscriptions = getSubscriptionsByListener(listener);\n+        Subscription[] subscriptions = getSubscriptionsByListener(listener);\n         if (subscriptions == null) {\n             return false;\n         }\n@@ -76,8 +75,8 @@ public class SubscriptionManager {\n     }\n \n \n-    private Collection<Subscription> getSubscriptionsByListener(Object listener) {\n-        Collection<Subscription> subscriptions;\n+    private Subscription[] getSubscriptionsByListener(Object listener) {\n+        Subscription[] subscriptions;\n         ReadLock readLock = readWriteLock.readLock();\n         try {\n             readLock.lock();\n@@ -95,21 +94,26 @@ public class SubscriptionManager {\n             if (nonListeners.contains(listenerClass)) {\n                 return; // early reject of known classes that do not define message handlers\n             }\n-            \n-            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n+\n+            Subscription[] subscriptionsByListener = getSubscriptionsByListener(listener);\n             // a listener is either subscribed for the first time\n             if (subscriptionsByListener == null) {\n-                List<MessageHandler> messageHandlers = metadataReader.getMessageListener(listenerClass).getHandlers();\n-                if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n+                MessageHandler[] messageHandlers = metadataReader.getMessageListener(listenerClass).getHandlers();\n+                int length = messageHandlers.length;\n+\n+                if (length == 0) {  // remember the class as non listening class if no handlers are found\n                     nonListeners.add(listenerClass);\n                     return;\n                 }\n-                subscriptionsByListener = new ArrayDeque<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n+                subscriptionsByListener = new Subscription[length]; // it's safe to use non-concurrent collection here (read only)\n+\n                 // create subscriptions for all detected message handlers\n-                for (MessageHandler messageHandler : messageHandlers) {\n-                    // create the subscription\n-                    subscriptionsByListener.add(subscriptionFactory.createSubscription(runtime, messageHandler));\n+                MessageHandler messageHandler;\n+                for (int i=0; i<length; i++) {\n+                    messageHandler = messageHandlers[i];\n+                    subscriptionsByListener[i] = subscriptionFactory.createSubscription(runtime, messageHandler);\n                 }\n+\n                 // this will acquire a write lock and handle the case when another thread already subscribed\n                 // this particular listener in the mean-time\n                 subscribe(listener, subscriptionsByListener);\n@@ -126,7 +130,7 @@ public class SubscriptionManager {\n     }\n \n \n-    private void subscribe(Object listener, Collection<Subscription> subscriptions) {\n+    private void subscribe(Object listener, Subscription[] subscriptions) {\n         WriteLock writeLock = readWriteLock.writeLock();\n         try {\n             writeLock.lock();\n@@ -135,15 +139,23 @@ public class SubscriptionManager {\n             // is not possible\n             // the alternative of using a write lock from the beginning would decrease performance dramatically\n             // because of the huge number of reads compared to writes\n-            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n+            Subscription[] subscriptionsByListener = getSubscriptionsByListener(listener);\n \n             if (subscriptionsByListener == null) {\n                 for (Subscription subscription : subscriptions) {\n                     subscription.subscribe(listener);\n+\n                     for (Class<?> messageType : subscription.getHandledMessageTypes()) {\n-                        addMessageTypeSubscription(messageType, subscription);\n+                        // associate a subscription with a message type\n+                        ArrayList<Subscription> subscriptions2 = subscriptionsPerMessage.get(messageType);\n+                        if (subscriptions2 == null) {\n+                            subscriptions2 = new ArrayList<Subscription>(8);\n+                            subscriptionsPerMessage.put(messageType, subscriptions2);\n+                        }\n+                        subscriptions2.add(subscription);\n                     }\n                 }\n+\n                 subscriptionsPerListener.put(listener.getClass(), subscriptions);\n             }\n             // the rare case when multiple threads concurrently subscribed the same class for the first time\n@@ -168,15 +180,21 @@ public class SubscriptionManager {\n         try {\n             readLock.lock();\n \n-            if (subscriptionsPerMessage.get(messageType) != null) {\n-                subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n+            Subscription subscription;\n+            ArrayList<Subscription> subsPerMessage = subscriptionsPerMessage.get(messageType);\n+\n+            if (subsPerMessage != null) {\n+                subscriptions.addAll(subsPerMessage);\n             }\n+\n             for (Class eventSuperType : ReflectionUtils.getSuperTypes(messageType)) {\n-                Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n+                ArrayList<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n                 if (subs != null) {\n-                    for (Subscription sub : subs) {\n-                        if (sub.handlesMessageType(messageType)) {\n-                            subscriptions.add(sub);\n+                    for (int i = 0; i < subs.size(); i++) {\n+                        subscription = subs.get(i);\n+\n+                        if (subscription.handlesMessageType(messageType)) {\n+                            subscriptions.add(subscription);\n                         }\n                     }\n                 }\n@@ -186,16 +204,4 @@ public class SubscriptionManager {\n         }\n         return subscriptions;\n     }\n-\n-\n-    // associate a subscription with a message type\n-    // NOTE: Not thread-safe! must be synchronized in outer scope\n-    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n-        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n-        if (subscriptions == null) {\n-            subscriptions = new LinkedList<Subscription>();\n-            subscriptionsPerMessage.put(messageType, subscriptions);\n-        }\n-        subscriptions.add(subscription);\n-    }\n }\n"
    },
    {
        "commit hash": "d8c2bba93365a941c5c7495df171d59db699f76d",
        "previous commit hash": "5bc924c11dd339fb288c69128d7d2faba58e3d07",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -188,7 +188,7 @@ Release notes moved to the [changelog](./changelog).\n \n \n <h2>Roadmap</h2>\n-There is no roadmap planning going on that deserves hte name. There is a collection of useful features though. Check the issues labeled with [enhancement](https://github.com/bennidi/mbassador/labels/enhancement) or the available milestones. Comment if you would like to see the feature in a future release and/or want to share your ideas on the feature (or a variation thereof).\n+There is no roadmap planning going on that deserves the name. There is a collection of useful features though. Check the issues labeled with [enhancement](https://github.com/bennidi/mbassador/labels/enhancement) or the available milestones. Comment if you would like to see the feature in a future release and/or want to share your ideas on the feature (or a variation thereof).\n \n Please understand that I have limited time to include new features and that I will focus on stability and cleaner APIs. Adding features only works with well designed and thoroughly tested components. This is especially true for multi-threaded code and I am still not 100 percent convinced by the existing test design and some parts of the internal code layout.\n \n"
    },
    {
        "commit hash": "5bc924c11dd339fb288c69128d7d2faba58e3d07",
        "previous commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "diff stats": {
            "file_path": "README.md",
            "additions": 28,
            "deletions": 22
        },
        "diff content": "@@ -16,6 +16,7 @@ Table of contents:\n + [Wiki](#wiki)\n + [Release Notes](#release-notes)\n + [Roadmap](#roadmap)\n++ [Integrations](#integrations)\n + [Credits](#credits)\n + [Contribute](#contribute)\n + [License](#license)\n@@ -137,8 +138,8 @@ Message handlers are defined via annotations added to instance methods. The simp\n              .addFeature(Feature.SyncPubSub.Default())\n              .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n              .addFeature(Feature.AsynchronousMessageDispatch.Default())\n-             .setProperty(Properties.Common.Id, \"global bus\")\n-             .setProperty(Properties.Handler.PublicationError, new IPublicationErrorHandler{...}));\n+             .addPublicationErrorHandler(new IPublicationErrorHandler{...})\n+             .setProperty(Properties.Common.Id, \"global bus\")); // this is used for identification in #toString\n         \n ### Listener subscription\n         ListeningBean listener = new ListeningBean();\n@@ -180,51 +181,56 @@ There is ongoing effort to extend documentation and provide code samples and det\n \n <h2>Release Notes</h2>\n \n-Release notes have been moved to the [changelog](changelog)\n+Release notes moved to the [changelog](./changelog).\n+\n+##Integrations\n+\n \n \n <h2>Roadmap</h2>\n-Check the issues labeled 'enhancement'. Comment if you would like to see the feature in a future release and/or want to share\n-your ideas on the feature (or a variation thereof).\n-Please understand that I have limited time to include new features and that I will focus on stability and cleaner APIs.\n-Adding features only works with well designed and thoroughly tested components. This is especially true for multi-threaded code\n-and I am still not 100 percent happy with the existing test design and some parts of the internal code layout.\n+There is no roadmap planning going on that deserves hte name. There is a collection of useful features though. Check the issues labeled with [enhancement](https://github.com/bennidi/mbassador/labels/enhancement) or the available milestones. Comment if you would like to see the feature in a future release and/or want to share your ideas on the feature (or a variation thereof).\n+\n+Please understand that I have limited time to include new features and that I will focus on stability and cleaner APIs. Adding features only works with well designed and thoroughly tested components. This is especially true for multi-threaded code and I am still not 100 percent convinced by the existing test design and some parts of the internal code layout.\n \n-Planned for release:Spring integration with support for conditional message dispatch in transactional context (dispatch only after\n-successful transaction commit etc.). Currently in beta, see <a href=\"https://github.com/bennidi/mbassador-spring\">this</a> repository\n+Planned for release: [Spring integration](bennidi/mbassador-spring) (currently in beta state) with support for conditional message dispatch in transactional context (dispatch only after successful transaction commit etc.).\n \n \n <h2>Credits</h2>\n The initial inspiration for creating this component comes from Google Guava's event bus implementation.\n-I liked the simplicity of its design and I do trust the developers at Google a lot, so I was happy to find that they also\n-provided an event bus system. The main reason it proved to be unusable for our scenario was that it uses strong references\n-to the listeners such that every object has to be explicitly unsubscribed.\n+I liked the simplicity of its design and I trust in the code quality of google libraries. The main reason it proved to be unusable for our scenario was that it uses strong references to the listeners.\n \n-I want to thank the development team from [friendsurance](www.friendsurance.de) for their support and feedback on the bus \n-implementation and the management of friendsurance for allowing me to publish the component as an open source project.\n+I want to thank the development team from [friendsurance](www.friendsurance.de) for their support and feedback on the bus implementation and the management for allowing me to publish the component as an open source project.\n \n I also want to thank all of the github users who have made little or larger [contributions](https://github.com/bennidi/mbassador/pulls?q=is%3Apr+is%3Aclosed). Thank you boys and girls, it is awesome to see\n the open source idea working.\n Special thanks go to\n++ [arne-vandamme](http://github.com/arne-vandamme) for adding support for [meta-annotations](https://github.com/bennidi/mbassador/pull/74)\n  + [Bernd Rosstauscher](http://github.com/Rossi1337) for providing an initial integration with JUEL\n- + [David Sowerby](http://github.com/davidsowerby) for providing guidance for other users and his various PR on better error handling\n- + [dorkbox](http://github.com/dorkbox) for various PRs and his incredible [work on performance tuning](http://github.com/bennidi/eventbus-performance/issues/1) which is still to be integrated.\n-\n+ + [David Sowerby](http://github.com/davidsowerby) for answering user questions, for his tutorial on [guice integration](bennidi/mbassador/wiki/guice-integration) and his various PRs\n+ + [dorkbox](http://github.com/dorkbox) for various PRs and his incredible [work on performance tuning](http://github.com/bennidi/eventbus-performance/issues/1) which is still to be integrated\n+ + [durron597](http://github.com/durron597) for his many PRs and the help he offered by answering user questions\n \n Many thanks also to ej-technologies for providing me with an open source license of \n [![JProfiler](http://www.ej-technologies.com/images/banners/jprofiler_small.png)](http://www.ej-technologies.com/products/jprofiler/overview.html) \n and Jetbrains for a license of [IntelliJ IDEA](http://www.jetbrains.com/idea/)\n \n+And all the other open source projects that make this kind of development possible:\n+\n+* [jUnit](http://www.junit.org)\n+* [maven](http://www.maven.org)\n+* [mockito](http://www.mockito.org)\n+* [slf4j](http://www.slf4j.org)\n+* [Odysseus JUEL](http://juel.sourceforge.net/guide/start.html)\n+\n \n+Special thanks also to [Sonatype](http://www.sonatype.com/) for the hosting of their [oss nexus repository](https://oss.sonatype.org/).\n \n \n <h2>Contribute</h2>\n \n-Any feature requests and feedback are more than welcome. You may suggest improvements either by submitting an\n-issue or by forking the repo and creating a pull request. I will try to respond as quickly as possible.\n+Any feature requests and feedback are more than welcome. You may suggest improvements or report bugs either by submitting an issue - I will try to respond as quickly as possible. Please try to be precise in the description of your requirements. Following a hands-on mentality please feel invited to contribute by by forking the repo and creating a pull request to submit the code you would like to be included. Make your PRs small and provide test code! Take a look at [this issue](bennidi/mbassador#106) for a good example.\n \n-Sample code and documentation are both very appreciated contributions. Especially integration with different frameworks\n-such as Spring, Guice or other is of great value. Feel free and welcome to create Wiki pages to share your code and ideas.\n+Sample code and documentation are both very appreciated contributions. Especially integration with different frameworks is of great value. Feel free and welcome to create Wiki pages to share your code and ideas. Example: [Guice integration](bennidi/mbassador/wiki/guice-integration)\n \n <h2>License</h2>\n \n"
    },
    {
        "commit hash": "5bc924c11dd339fb288c69128d7d2faba58e3d07",
        "previous commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -5,7 +5,7 @@ import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n import java.util.*;\n \n /**\n- * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n+ * {@inheritDoc}\n  */\n public class BusConfiguration implements IBusConfiguration {\n \n"
    },
    {
        "commit hash": "5bc924c11dd339fb288c69128d7d2faba58e3d07",
        "previous commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/IBusConfiguration.java",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -61,6 +61,7 @@ public interface IBusConfiguration{\n \n     /**\n      * Add a handler that is called when a misconfiguration is detected.\n+     * Note: Not fully implemented, yet.\n      */\n     IBusConfiguration addConfigurationErrorHandler(ConfigurationErrorHandler handler);\n \n"
    },
    {
        "commit hash": "5bc924c11dd339fb288c69128d7d2faba58e3d07",
        "previous commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/DeadMessageTest.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -8,7 +8,7 @@ import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.common.TestUtil;\n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listeners.IMessageListener;\n-import net.engio.mbassy.listeners.MessagesListener;\n+import net.engio.mbassy.listeners.MessagesTypeListener;\n import net.engio.mbassy.listeners.ObjectListener;\n import org.junit.Before;\n import org.junit.Test;\n@@ -36,9 +36,9 @@ public class DeadMessageTest extends MessageBusTest{\n                 .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                 .create(InstancesPerListener, IMessageListener.AsyncListener.class)\n                 .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n-                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n-                .create(InstancesPerListener, MessagesListener.AsyncListener.class)\n-                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n+                .create(InstancesPerListener, MessagesTypeListener.DefaultListener.class)\n+                .create(InstancesPerListener, MessagesTypeListener.AsyncListener.class)\n+                .create(InstancesPerListener, MessagesTypeListener.DisabledListener.class)\n                 .create(InstancesPerListener, DeadMessagHandler.class)\n                 .create(InstancesPerListener, Object.class);\n \n"
    },
    {
        "commit hash": "5bc924c11dd339fb288c69128d7d2faba58e3d07",
        "previous commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 12,
            "deletions": 12
        },
        "diff content": "@@ -65,15 +65,15 @@ public class SubscriptionManagerTest extends AssertSupport {\n     @Test\n     public void testMessagesListener(){\n         ListenerFactory listeners = listeners(\n-                MessagesListener.DefaultListener.class,\n-                MessagesListener.AsyncListener.class,\n-                MessagesListener.DisabledListener.class,\n-                MessagesListener.NoSubtypesListener.class);\n+                MessagesTypeListener.DefaultListener.class,\n+                MessagesTypeListener.AsyncListener.class,\n+                MessagesTypeListener.DisabledListener.class,\n+                MessagesTypeListener.NoSubtypesListener.class);\n \n         SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n-                .listener(MessagesListener.NoSubtypesListener.class).handles(MessageTypes.class)\n-                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)\n-                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);\n+                .listener(MessagesTypeListener.NoSubtypesListener.class).handles(MessageTypes.class)\n+                .listener(MessagesTypeListener.DefaultListener.class).handles(MessageTypes.class)\n+                .listener(MessagesTypeListener.AsyncListener.class).handles(MessageTypes.class);\n \n         runTestWith(listeners, expectedSubscriptions);\n     }\n@@ -151,9 +151,9 @@ public class SubscriptionManagerTest extends AssertSupport {\n                 IMultipartMessageListener.DefaultListener.class,\n                 IMultipartMessageListener.AsyncListener.class,\n                 IMultipartMessageListener.DisabledListener.class,\n-                MessagesListener.DefaultListener.class,\n-                MessagesListener.AsyncListener.class,\n-                MessagesListener.DisabledListener.class);\n+                MessagesTypeListener.DefaultListener.class,\n+                MessagesTypeListener.AsyncListener.class,\n+                MessagesTypeListener.DisabledListener.class);\n \n         SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                 .listener(ICountableListener.DefaultListener.class)\n@@ -162,8 +162,8 @@ public class SubscriptionManagerTest extends AssertSupport {\n                 .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class)\n                 .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                 .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n-                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)\n-                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);\n+                .listener(MessagesTypeListener.DefaultListener.class).handles(MessageTypes.class)\n+                .listener(MessagesTypeListener.AsyncListener.class).handles(MessageTypes.class);\n \n         runTestWith(listeners, expectedSubscriptions);\n     }\n"
    },
    {
        "commit hash": "5bc924c11dd339fb288c69128d7d2faba58e3d07",
        "previous commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncAsyncTest.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -53,7 +53,7 @@ public class SyncAsyncTest extends MessageBusTest {\n         MessageTypes.resetAll();\n         ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n         assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n-        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n+        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesTypeListener.DefaultListener.class));\n     }\n \n \n@@ -89,7 +89,7 @@ public class SyncAsyncTest extends MessageBusTest {\n         messageManager.waitForMessages(waitForMessageTimeout);\n \n         MessageTypes.resetAll();\n-        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesListener.AsyncListener.class);\n+        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesTypeListener.AsyncListener.class);\n         ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n         messageManager.waitForMessages(waitForMessageTimeout);\n     }\n"
    },
    {
        "commit hash": "5bc924c11dd339fb288c69128d7d2faba58e3d07",
        "previous commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 5,
            "deletions": 5
        },
        "diff content": "@@ -16,7 +16,7 @@ import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listeners.CustomInvocationListener;\n import net.engio.mbassy.listeners.ExceptionThrowingListener;\n import net.engio.mbassy.listeners.IMessageListener;\n-import net.engio.mbassy.listeners.MessagesListener;\n+import net.engio.mbassy.listeners.MessagesTypeListener;\n import net.engio.mbassy.messages.MessageTypes;\n import net.engio.mbassy.messages.MultipartMessage;\n import net.engio.mbassy.messages.StandardMessage;\n@@ -44,8 +44,8 @@ public abstract class SyncBusTest extends MessageBusTest {\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                 .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n-                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n-                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n+                .create(InstancesPerListener, MessagesTypeListener.DefaultListener.class)\n+                .create(InstancesPerListener, MessagesTypeListener.DisabledListener.class)\n                 .create(InstancesPerListener, Object.class);\n \n \n@@ -75,8 +75,8 @@ public abstract class SyncBusTest extends MessageBusTest {\n         ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n         assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n         assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));\n-        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n-        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesListener.DefaultListener.class));\n+        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesTypeListener.DefaultListener.class));\n+        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesTypeListener.DefaultListener.class));\n     }\n \n \n"
    },
    {
        "commit hash": "5bc924c11dd339fb288c69128d7d2faba58e3d07",
        "previous commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/Listeners.java",
            "additions": 8,
            "deletions": 12
        },
        "diff content": "@@ -3,16 +3,12 @@ package net.engio.mbassy.listeners;\n import java.util.*;\n \n /**\n- * Created with IntelliJ IDEA.\n- * User: benjamin\n- * Date: 6/26/13\n- * Time: 11:48 AM\n- * To change this template use File | Settings | File Templates.\n+ * Convenience class to create sets of listeners that can be reused on different test scenarios.\n  */\n public class Listeners {\n \n     private static final List<Class> Synchronous = Collections.unmodifiableList(Arrays.asList(new Class[]{\n-            MessagesListener.DefaultListener.class,\n+            MessagesTypeListener.DefaultListener.class,\n             IMessageListener.DefaultListener.class,\n             StandardMessageListener.DefaultListener.class,\n             MultipartMessageListener.DefaultListener.class,\n@@ -20,7 +16,7 @@ public class Listeners {\n             IMultipartMessageListener.DefaultListener.class}));\n \n     private static final List<Class> Asynchronous = Collections.unmodifiableList(Arrays.asList(new Class[]{\n-            MessagesListener.AsyncListener.class,\n+            MessagesTypeListener.AsyncListener.class,\n             IMessageListener.AsyncListener.class,\n             StandardMessageListener.AsyncListener.class,\n             MultipartMessageListener.AsyncListener.class,\n@@ -28,7 +24,7 @@ public class Listeners {\n             IMultipartMessageListener.AsyncListener.class}));\n \n     private static final List<Class> SubtypeRejecting = Collections.unmodifiableList(Arrays.asList(new Class[]{\n-            MessagesListener.NoSubtypesListener.class,\n+            MessagesTypeListener.NoSubtypesListener.class,\n             IMessageListener.NoSubtypesListener.class,\n             StandardMessageListener.NoSubtypesListener.class,\n             MultipartMessageListener.NoSubtypesListener.class,\n@@ -36,7 +32,7 @@ public class Listeners {\n             IMultipartMessageListener.NoSubtypesListener.class}));\n \n     private static final List<Class> NoHandlers = Collections.unmodifiableList(Arrays.asList(new Class[]{\n-            MessagesListener.DisabledListener.class,\n+            MessagesTypeListener.DisabledListener.class,\n             IMessageListener.DisabledListener.class,\n             StandardMessageListener.DisabledListener.class,\n             MultipartMessageListener.DisabledListener.class,\n@@ -52,9 +48,9 @@ public class Listeners {\n             IMultipartMessageListener.DefaultListener.class,\n             IMultipartMessageListener.AsyncListener.class,\n             IMultipartMessageListener.NoSubtypesListener.class,\n-            MessagesListener.DefaultListener.class,\n-            MessagesListener.AsyncListener.class,\n-            MessagesListener.NoSubtypesListener.class,\n+            MessagesTypeListener.DefaultListener.class,\n+            MessagesTypeListener.AsyncListener.class,\n+            MessagesTypeListener.NoSubtypesListener.class,\n             StandardMessageListener.DefaultListener.class,\n             StandardMessageListener.AsyncListener.class,\n             StandardMessageListener.NoSubtypesListener.class,\n"
    },
    {
        "commit hash": "5bc924c11dd339fb288c69128d7d2faba58e3d07",
        "previous commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/MessagesTypeListener.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@ import net.engio.mbassy.messages.MessageTypes;\n  * @author bennidi\n  *         Date: 5/24/13\n  */\n-public class MessagesListener {\n+public class MessagesTypeListener {\n \n     private static abstract class BaseListener {\n \n"
    },
    {
        "commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "previous commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 10,
            "deletions": 11
        },
        "diff content": "@@ -13,16 +13,15 @@\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n-        Mbassador is a fast and flexible message bus system following the publish subscribe pattern.\n-        It is designed for ease of use and aims to be feature rich and extensible\n-        while preserving resource efficiency and performance.\n+        Mbassador is a fast and flexible event bus system following the publish subscribe pattern.\n+        It is designed for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance.\n+        It provides non-blocking iterators and minimal write contention with low memory footprint.\n \n-        It features:\n+        Some features:\n         declarative handler definition via annotations,\n         sync and/or async message delivery,\n-        weak-references,\n-        message filtering,\n-        ordering of message handlers etc.\n+        weak or strong references,\n+        configurable message filters,\n     </description>\n \n     <url>https://github.com/bennidi/mbassador</url>\n@@ -52,7 +51,7 @@\n         <nazgul-codestyle.version>2.0.1</nazgul-codestyle.version>\n         <jdk.version>1.6</jdk.version>\n         <pmd.plugin.version>3.0.1</pmd.plugin.version>\n-\n+        <nazgul.codestyle.version>4.1.1</nazgul.codestyle.version>\n         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n         <project.build.java.version>1.6</project.build.java.version>\n         <github.url>file://${project.basedir}/mvn-local-repo</github.url>\n@@ -137,7 +136,7 @@\n \n     <build>\n         <plugins>\n-            <!-- plugin>\n+            <plugin>\n                 <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-pmd-plugin</artifactId>\n                 <version>${pmd.plugin.version}</version>\n@@ -164,10 +163,10 @@\n                     <dependency>\n                         <groupId>se.jguru.nazgul.tools.codestyle</groupId>\n                         <artifactId>nazgul-codestyle</artifactId>\n-                        <version>${nazgul-codestyle.version}</version>\n+                        <version>${nazgul.codestyle.version}</version>\n                     </dependency>\n                 </dependencies>\n-            </plugin -->\n+            </plugin>\n \n             <plugin>\n                 <groupId>org.apache.felix</groupId>\n"
    },
    {
        "commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "previous commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java",
            "additions": 2,
            "deletions": 7
        },
        "diff content": "@@ -35,20 +35,15 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n             \"Publication error handlers can be added by IBusConfiguration.addPublicationErrorHandler()\\n\" +\n             \"Falling back to console logger.\";\n \n-\n-\n-\n     public AbstractPubSubSupport(IBusConfiguration configuration) {\n-\n         //transfer publication error handlers from the config object\n         this.errorHandlers.addAll(configuration.getRegisteredPublicationErrorHandlers());\n         if (errorHandlers.isEmpty()) {\n             errorHandlers.add(new IPublicationErrorHandler.ConsoleLogger());\n             System.out.println(ERROR_HANDLER_MSG);\n         }\n-        this.runtime = new BusRuntime(this).add(PublicationErrorHandlers, getRegisteredErrorHandlers())\n-                                           .add(Properties.Common.Id, UUID.randomUUID()\n-                                                                          .toString());\n+        this.runtime = new BusRuntime(this)\n+                .add(PublicationErrorHandlers, configuration.getRegisteredPublicationErrorHandlers());\n         // configure the pub sub feature\n         Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);\n         this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()\n"
    },
    {
        "commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "previous commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/BusRuntime.java",
            "additions": 3,
            "deletions": 0
        },
        "diff content": "@@ -1,11 +1,13 @@\n package net.engio.mbassy.bus;\n \n+import net.engio.mbassy.bus.common.Properties;\n import net.engio.mbassy.bus.common.PubSubSupport;\n import net.engio.mbassy.bus.error.MissingPropertyException;\n \n import java.util.Collection;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.UUID;\n \n /**\n  * Message bus implementations potentially vary in the features they provide and consequently in the components and properties\n@@ -24,6 +26,7 @@ public class BusRuntime {\n \n     public BusRuntime(PubSubSupport provider) {\n         this.provider = provider;\n+        properties.put(Properties.Common.Id, UUID.randomUUID().toString());\n     }\n \n     public <T> T get(String key){\n"
    },
    {
        "commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "previous commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/IMessagePublication.java",
            "additions": 14,
            "deletions": 10
        },
        "diff content": "@@ -15,26 +15,30 @@ import net.engio.mbassy.subscription.Subscription;\n  */\n public interface IMessagePublication {\n \n-    public boolean add(Subscription subscription);\n+    boolean add(Subscription subscription);  // TODO: this method should not be part of the interface\n \n     /*\n     TODO: document state transitions\n      */\n-    public void execute();\n+    void execute();\n \n-    public boolean isFinished();\n+    boolean isFinished();\n \n-    public boolean isRunning();\n+    boolean isRunning();\n \n-    public boolean isScheduled();\n+    boolean isScheduled();\n \n-    public void markDelivered();\n+    void markDelivered(); // TODO: this method should not be part of the interface\n \n-    public IMessagePublication markScheduled();\n+    IMessagePublication markScheduled(); // TODO: this method should not be part of the interface\n \n-    public boolean isDeadEvent();\n+    boolean isDeadEvent();\n \n-    public boolean isFilteredEvent();\n+    boolean isFilteredEvent();\n \n-    public Object getMessage();\n+    Object getMessage();\n+\n+\n+    // TODO: This interface should only be used as return type to public API calls (clients). Internally the implementation\n+    // of the interface should be used. This would allow to remove the unwanted methods from this interface.\n }\n"
    },
    {
        "commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "previous commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/HandlerInvocation.java",
            "additions": 2,
            "deletions": 6
        },
        "diff content": "@@ -16,15 +16,11 @@ import java.util.Collection;\n public abstract class HandlerInvocation<HANDLER, MESSAGE> extends AbstractSubscriptionContextAware implements IHandlerInvocation<HANDLER, MESSAGE>{\n \n \n-    private final Collection<IPublicationErrorHandler> errorHandlers;\n-\n     public HandlerInvocation(SubscriptionContext context) {\n         super(context);\n-        errorHandlers = context.getErrorHandlers();\n     }\n \n-    protected void handlePublicationError(PublicationError error){\n-        for(IPublicationErrorHandler handler : errorHandlers)\n-            handler.handleError(error);\n+    protected final void handlePublicationError(PublicationError error){\n+        getContext().handleError(error);\n     }\n }\n"
    },
    {
        "commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "previous commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/el/ElFilter.java",
            "additions": 2,
            "deletions": 6
        },
        "diff content": "@@ -1,6 +1,5 @@\n package net.engio.mbassy.dispatch.el;\r\n \r\n-import net.engio.mbassy.bus.error.IPublicationErrorHandler;\r\n import net.engio.mbassy.bus.error.PublicationError;\r\n import net.engio.mbassy.listener.IMessageFilter;\r\n import net.engio.mbassy.listener.MessageHandler;\r\n@@ -62,14 +61,11 @@ public class ElFilter implements IMessageFilter {\n                                    final Object message) {\r\n         ValueExpression ve = ELFactory().createValueExpression(resolutionContext, expression, Boolean.class);\r\n         try {\r\n-            Object result = ve.getValue(resolutionContext);\r\n-            return (Boolean) result;\r\n+            return (Boolean)ve.getValue(resolutionContext);\r\n         } catch (Throwable exception) {\r\n             PublicationError publicationError = new PublicationError(exception, \"Error while evaluating EL expression on message\", context)\r\n                     .setPublishedMessage(message);\r\n-            for (IPublicationErrorHandler errorHandler : context.getErrorHandlers()) {\r\n-                errorHandler.handleError(publicationError);\r\n-            }\r\n+            context.handleError(publicationError);\r\n             return false;\r\n         }\r\n     }\r\n"
    },
    {
        "commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "previous commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -14,7 +14,7 @@ public class AbstractSubscriptionContextAware implements ISubscriptionContextAwa\n         this.context = context;\n     }\n \n-    public SubscriptionContext getContext() {\n+    public final SubscriptionContext getContext() {\n         return context;\n     }\n \n"
    },
    {
        "commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "previous commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java",
            "additions": 7,
            "deletions": 0
        },
        "diff content": "@@ -3,6 +3,7 @@ package net.engio.mbassy.subscription;\n import net.engio.mbassy.bus.BusRuntime;\n import net.engio.mbassy.bus.common.RuntimeProvider;\n import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n+import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.listener.MessageHandler;\n \n import java.util.Collection;\n@@ -53,4 +54,10 @@ public class SubscriptionContext implements RuntimeProvider {\n         return runtime;\n     }\n \n+    public final void handleError(PublicationError error){\n+        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n+            errorHandler.handleError(error);\n+        }\n+    }\n+\n }\n"
    },
    {
        "commit hash": "005915b42e2486f5095893a4429db32fcc5341ec",
        "previous commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AllTests.java",
            "additions": 9,
            "deletions": 8
        },
        "diff content": "@@ -11,19 +11,20 @@ import org.junit.runners.Suite;\n  */\n @RunWith(Suite.class)\n @Suite.SuiteClasses({\n+        AsyncFIFOBusTest.class,\n+        ConditionalHandlerTest.class,\n+        CustomHandlerAnnotationTest.class,\n+        DeadMessageTest.class,\n+        FilterTest.class,\n+        MetadataReaderTest.class,\n+        MethodDispatchTest.class,\n         StrongConcurrentSetTest.class,\n-        WeakConcurrentSetTest.class,\n+        SubscriptionManagerTest.class,\n         SyncAsyncTest.class,\n         SyncBusTest.MBassadorTest.class,\n         SyncBusTest.SyncMessageBusTest.class,\n-        FilterTest.class,\n-        MetadataReaderTest.class,\n-        MethodDispatchTest.class,\n-        DeadMessageTest.class,\n         SynchronizedHandlerTest.class,\n-        SubscriptionManagerTest.class,\n-        AsyncFIFOBusTest.class,\n-        ConditionalHandlerTest.class\n+        WeakConcurrentSetTest.class\n })\n public class AllTests {\n }\n"
    },
    {
        "commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "previous commit hash": "261cab2dc5eb57bc3a915d5c89dbf771bf375be5",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -201,7 +201,7 @@ public abstract class AbstractConcurrentSet<T> implements Set<T> {\n         protected Entry() {\n         }\n \n-        // not thread-safe! must be synchronized in enclosing context\n+        // Not thread-safe! must be synchronized in enclosing context\n         @Override\n         public void remove() {\n             if (predecessor != null) {\n@@ -212,7 +212,7 @@ public abstract class AbstractConcurrentSet<T> implements Set<T> {\n             } else if (next != null) {\n                 next.predecessor = null;\n             }\n-            // can not nullify references to help GC since running iterators might not see the entire set\n+            // Can not nullify references to help GC because running iterators might not see the entire set\n             // if this element is their current element\n             //next = null;\n             //predecessor = null;\n"
    },
    {
        "commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "previous commit hash": "261cab2dc5eb57bc3a915d5c89dbf771bf375be5",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/WeakConcurrentSet.java",
            "additions": 3,
            "deletions": 0
        },
        "diff content": "@@ -40,6 +40,9 @@ public class WeakConcurrentSet<T> extends AbstractConcurrentSet<T>{\n                     do {\n                         ISetEntry orphaned = current;\n                         current = current.next();\n+                        if (orphaned  == head) {\n+                            head = head.next();\n+                        }\n                         orphaned.remove();\n                     } while(current != null && current.getValue() == null);\n                 }\n"
    },
    {
        "commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "previous commit hash": "261cab2dc5eb57bc3a915d5c89dbf771bf375be5",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageListener.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@ import java.util.LinkedList;\n import java.util.List;\n \n /**\n- * All instances of any class that defines at least one message handler (see @MessageHandler) are message listeners. Thus,\n+ * All instances of any class defining at least one message handler @link MessageHandler are message listeners. Thus,\n  * a message listener is any object capable of receiving messages by means of defined message handlers.\n  * There are no restrictions about the number of allowed message handlers in a message listener.\n  *\n"
    },
    {
        "commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "previous commit hash": "261cab2dc5eb57bc3a915d5c89dbf771bf375be5",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MetadataReaderTest.java",
            "additions": 19,
            "deletions": 2
        },
        "diff content": "@@ -2,6 +2,7 @@ package net.engio.mbassy;\n \n import net.engio.mbassy.common.AssertSupport;\n import net.engio.mbassy.listener.MessageListener;\n+import net.engio.mbassy.listeners.SimpleHandler;\n import org.junit.Test;\n import net.engio.mbassy.listener.Enveloped;\n import net.engio.mbassy.listener.Handler;\n@@ -89,7 +90,25 @@ public class MetadataReaderTest extends AssertSupport {\n         validator.check(listener);\n     }\n \n+    @Test\n+    public void testAnonymousListener() {\n+       SimpleHandler anonymousSimpleHandler = new SimpleHandler() {\n+           @Override\n+           @Handler\n+           public void onMessage(Object msg) {\n+               // nop\n+           }\n+       };\n+        MessageListener<EnvelopedListenerSubclass> listener = reader.getMessageListener(anonymousSimpleHandler.getClass());\n+        ListenerValidator validator = new ListenerValidator()\n+                .expectHandlers(1, Object.class);\n+        validator.check(listener);\n+\n \n+    }\n+\n+\n+    // Define and assert expectations on handlers in a listener\n     private class ListenerValidator {\n \n         private Map<Class<?>, Integer> handlers = new HashMap<Class<?>, Integer>();\n@@ -114,8 +133,6 @@ public class MetadataReaderTest extends AssertSupport {\n     }\n \n \n-\n-\n     // a simple event listener\n     public class MessageListener1 {\n \n"
    },
    {
        "commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "previous commit hash": "261cab2dc5eb57bc3a915d5c89dbf771bf375be5",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncAsyncTest.java",
            "additions": 12,
            "deletions": 6
        },
        "diff content": "@@ -69,8 +69,14 @@ public class SyncAsyncTest extends MessageBusTest {\n             @Override\n             public void run() {\n \n-                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, Listeners.join(Listeners.asynchronous(), Listeners.handlesStandardMessage()));\n-                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);\n+                StandardMessage standardMessage = messageManager.createAndTrack(\n+                        StandardMessage.class,\n+                        InstancesPerListener,\n+                        Listeners.join(Listeners.asynchronous(),Listeners.handlesStandardMessage()));\n+                MultipartMessage multipartMessage = messageManager.create(\n+                        MultipartMessage.class,\n+                        InstancesPerListener,\n+                        IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);\n \n                 bus.post(standardMessage).now();\n                 bus.post(multipartMessage).now();\n@@ -80,12 +86,12 @@ public class SyncAsyncTest extends MessageBusTest {\n         };\n \n         ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n-        messageManager.waitForMessages(processingTimeInMS);\n+        messageManager.waitForMessages(waitForMessageTimeout);\n \n         MessageTypes.resetAll();\n         messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesListener.AsyncListener.class);\n         ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n-        messageManager.waitForMessages(processingTimeInMS);\n+        messageManager.waitForMessages(waitForMessageTimeout);\n     }\n \n     @Test\n@@ -113,11 +119,11 @@ public class SyncAsyncTest extends MessageBusTest {\n         };\n \n         ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n-        messageManager.waitForMessages(processingTimeInMS);\n+        messageManager.waitForMessages(waitForMessageTimeout);\n \n         MessageTypes.resetAll();\n         ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n-        messageManager.waitForMessages(processingTimeInMS);\n+        messageManager.waitForMessages(waitForMessageTimeout);\n \n     }\n \n"
    },
    {
        "commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "previous commit hash": "261cab2dc5eb57bc3a915d5c89dbf771bf375be5",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 3,
            "deletions": 2
        },
        "diff content": "@@ -19,10 +19,11 @@ import org.junit.Before;\n  */\n public abstract class MessageBusTest extends AssertSupport {\n \n-    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n+    // this value probably needs to be adjusted depending on the performance of the underlying platform\n     // otherwise the tests will fail since asynchronous processing might not have finished when\n     // evaluation is run\n-    protected static final int processingTimeInMS = 6000;\n+    protected static final int waitForMessageTimeout = 60000;\n+    protected static final int processingTimeInMS = 2000;\n     protected static final int InstancesPerListener = 5000;\n     protected static final int ConcurrentUnits = 10;\n     protected static final int IterationsPerThread = 100;\n"
    },
    {
        "commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "previous commit hash": "261cab2dc5eb57bc3a915d5c89dbf771bf375be5",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageManager.java",
            "additions": 3,
            "deletions": 7
        },
        "diff content": "@@ -7,11 +7,7 @@ import org.slf4j.LoggerFactory;\n import java.util.Collection;\n \n /**\n- * Created with IntelliJ IDEA.\n- * User: benjamin\n- * Date: 6/26/13\n- * Time: 12:23 PM\n- * To change this template use File | Settings | File Templates.\n+ *\n  */\n public class MessageManager {\n \tprivate static final Logger LOG =\n@@ -32,7 +28,7 @@ public class MessageManager {\n         return message;\n     }\n \n-    public <T extends IMessage> T create(Class<T> messageType, int expectedCount, Collection<Class> listeners){\n+    public <T extends IMessage> T createAndTrack(Class<T> messageType, int expectedCount, Collection<Class> listeners){\n         T message;\n         try {\n             message = messageType.newInstance();\n@@ -79,7 +75,7 @@ public class MessageManager {\n         }\n         if(messages.size() > 0){\n             logFailingMessages(messages);\n-            throw new RuntimeException(\"Message were not fully processed in given time\");\n+            org.junit.Assert.fail(\"Message were not fully processed in given time\");\n         }\n \n \n"
    },
    {
        "commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "previous commit hash": "261cab2dc5eb57bc3a915d5c89dbf771bf375be5",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/IMessageListener.java",
            "additions": 2,
            "deletions": 0
        },
        "diff content": "@@ -5,6 +5,8 @@ import net.engio.mbassy.listener.Invoke;\n import net.engio.mbassy.messages.IMessage;\n \n /**\n+ * A collection of different listener flavours meant for convenient reuse in different\n+ * test scenarios.\n  *\n  * @author bennidi\n  *         Date: 5/24/13\n"
    },
    {
        "commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "previous commit hash": "261cab2dc5eb57bc3a915d5c89dbf771bf375be5",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/Listeners.java",
            "additions": 0,
            "deletions": 2
        },
        "diff content": "@@ -107,6 +107,4 @@ public class Listeners {\n     }\n \n \n-\n-\n }\n"
    },
    {
        "commit hash": "4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e",
        "previous commit hash": "261cab2dc5eb57bc3a915d5c89dbf771bf375be5",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/SimpleHandler.java",
            "additions": 5,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,5 @@\n+package net.engio.mbassy.listeners;\n+\n+public interface SimpleHandler {\n+    void onMessage(Object msg);\n+}\n"
    },
    {
        "commit hash": "261cab2dc5eb57bc3a915d5c89dbf771bf375be5",
        "previous commit hash": "ba301c7aec7cda5d8538fec7f8daad5c15aa0ae9",
        "diff stats": {
            "file_path": "README.md",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -203,12 +203,12 @@ to the listeners such that every object has to be explicitly unsubscribed.\n I want to thank the development team from [friendsurance](www.friendsurance.de) for their support and feedback on the bus \n implementation and the management of friendsurance for allowing me to publish the component as an open source project.\n \n-I also want to thank all of the github users who have made little or larger contributions. Thank you boys and girls, it is awesome to see\n+I also want to thank all of the github users who have made little or larger [contributions](https://github.com/bennidi/mbassador/pulls?q=is%3Apr+is%3Aclosed). Thank you boys and girls, it is awesome to see\n the open source idea working.\n Special thanks go to\n  + [Bernd Rosstauscher](http://github.com/Rossi1337) for providing an initial integration with JUEL\n- + [David Sowerby](http://github.com/davidsowerby) for providing guidance for other users and his PR on better error handling\n- + [dorkbox](http://github.com/dorkbox) for his incredible [work on performance tuning](http://github.com/bennidi/eventbus-performance/issues/1) which is still to be integrated.\n+ + [David Sowerby](http://github.com/davidsowerby) for providing guidance for other users and his various PR on better error handling\n+ + [dorkbox](http://github.com/dorkbox) for various PRs and his incredible [work on performance tuning](http://github.com/bennidi/eventbus-performance/issues/1) which is still to be integrated.\n \n \n Many thanks also to ej-technologies for providing me with an open source license of \n"
    },
    {
        "commit hash": "ba301c7aec7cda5d8538fec7f8daad5c15aa0ae9",
        "previous commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "diff stats": {
            "file_path": "README.md",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -206,9 +206,9 @@ implementation and the management of friendsurance for allowing me to publish th\n I also want to thank all of the github users who have made little or larger contributions. Thank you boys and girls, it is awesome to see\n the open source idea working.\n Special thanks go to\n- + [Bernd Rosstauscher](/Rossi1337) for providing an initial integration with JUEL\n- + [David Sowerby](/davidsowerby) for providing guidance for other users and his PR on better error handling\n- + [dorkbox](/dorkbox) for his incredible [work on performance tuning](/bennidi/eventbus-performance/issues/1) which is still to be integrated.\n+ + [Bernd Rosstauscher](http://github.com/Rossi1337) for providing an initial integration with JUEL\n+ + [David Sowerby](http://github.com/davidsowerby) for providing guidance for other users and his PR on better error handling\n+ + [dorkbox](http://github.com/dorkbox) for his incredible [work on performance tuning](http://github.com/bennidi/eventbus-performance/issues/1) which is still to be integrated.\n \n \n Many thanks also to ej-technologies for providing me with an open source license of \n"
    },
    {
        "commit hash": "ba301c7aec7cda5d8538fec7f8daad5c15aa0ae9",
        "previous commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "diff stats": {
            "file_path": "changelog/README.md",
            "additions": 6,
            "deletions": 6
        },
        "diff content": "@@ -1,4 +1,4 @@\n-### [1.2.2](../milestones/1.2.2)\n+### [1.2.2](http://github.com/bennidi/mbassador/milestones/1.2.2)\n  + Upgraded to Maven 3\n    + Upgraded all plugins to most recent version\n    + Fixed all issues that produced warnings on build output\n@@ -6,10 +6,10 @@\n + __API-Changes:__\n    + Moved method addPublicationErrorHandler from `IMessageBus` to `IBusConfiguration`\n    + Default constructor of `MBassador` has no `IPublicationErrorHandler` registered and will \n-   fall back to console logging. See [#106](../issues/106), [#107](../issues/107) \n+   fall back to console logging. See [#106](http://github.com/bennidi/mbassador/issues/106), [#107](http://github.com/bennidi/mbassador/issues/107) \n \n \n-### [1.2.1](../milestones/1.2.1)\n+### [1.2.1](http://github.com/bennidi/mbassador/milestones/1.2.1)\n  + Centralized handling of common (and arbitrary) properties (see `BusConfiguration#setProperty` and `net.engio.mbassy.bus.common.Properties`)\n  + Each bus now has a configurable id and respective #toString() implementation (useful for debugging)\n  + Each bus now has a default logger (System.out) for publication errors (exception in handlers) which can be replaced with BusConfiguration#setProperty \n@@ -29,7 +29,7 @@\n \n \n ### 1.1.10\n- + Fixed broken sort order of prioritized handlers (see [#58](../issues/58))\n+ + Fixed broken sort order of prioritized handlers (see [#58](http://github.com/bennidi/mbassador/issues/58))\n  + Addressed issue #63 by making the constructor of `MessageHandler` use a map of properties and by replacing dependencies to\n   all MBassador specific annotations with Java primitives and simple interfaces\n  + Small refactorings (moved stuff around to have cleaner packaging)\n@@ -40,12 +40,12 @@\n \n ### 1.1.9\n \n- + Fixed memory leak reported in [#53](../issues/53)\n+ + Fixed memory leak reported in [#53](http://github.com/bennidi/mbassador/issues/53)\n \n ### 1.1.8\n \n  + Internal refactorings and code improvements\n- + Fixed [#44](../issues/44) [#45](../issues/45) [#47](../issues/47)\n+ + Fixed [#44](http://github.com/bennidi/mbassador/issues/44) [#45](http://github.com/bennidi/mbassador/issues/45) [#47](http://github.com/bennidi/mbassador/issues/47)\n  + NOTE: This release has a known issue with weak references which introduces a memory leak and is fixed in 1.1.9. The\n  version 1.1.8 is not available from the central repository\n \n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "README.md",
            "additions": 20,
            "deletions": 111
        },
        "diff content": "@@ -14,7 +14,7 @@ Table of contents:\n + [Usage](#usage)\n + [Installation](#installation)\n + [Wiki](#wiki)\n-+ [Release Notes](#releasenotes)\n++ [Release Notes](#release-notes)\n + [Roadmap](#roadmap)\n + [Credits](#credits)\n + [Contribute](#contribute)\n@@ -180,111 +180,7 @@ There is ongoing effort to extend documentation and provide code samples and det\n \n <h2>Release Notes</h2>\n \n-### [1.2.1](milestones/1.2.1)\n- + Centralized handling of common (and arbitrary) properties (see BusConfiguration#setProperty and net.engio.mbassy.bus.common.Properties)\n- + Each bus now has a configurable id and respective #toString() implementation (useful for debugging)\n- + Each bus now has a default logger (System.out) for publication errors (exception in handlers) which can be replaced with BusConfiguration#setProperty \n- + __API-Changes:__\n-   + Interface `IMessageFilter` now receives the SubscriptionContext as second parameter. This gives access to the bus runtime within filter logic (useful for error propagation). -> Change your filters signature. You can access the `MessageHandler` object directly from the context. \n-   + Removed deprecated method BusConfiguration.SyncAsync() -> Use default constructor or feature based configuration instead\n-   + Deleted interface ISyncMessageBus since it was merely an aggregation of existing interfaces -> Replace with GenericMessagePublicationSupport\n-\n-### 1.2.0\n- + Added support for conditional handlers using Java EL. Thanks to Bernd Rosstauscher for the initial implementation.\n- + BREAKING CHANGES in BusConfiguration\n-   + Complete redesign of configuration setup using Features instead of simple get/set parameters. This will allow\n- to flexibly combine features and still be able to exclude those not available in certain environments,for example, threading and reflection in GWT (this will be part of future releases)\n-   + Properties formerly located in BusConfiguration now moved to their respective Feature class\n-   + Removed all SyncXX related interfaces and config implementations. There is now only one `BusConfiguration`\n- with its corresponding interface which will be used for all types of message bus implementations\n-\n-\n-### 1.1.10\n- + Fixed broken sort order of prioritized handlers (see #58)\n- + Addressed issue #63 by making the constructor of `MessageHandler` use a map of properties and by replacing dependencies to\n-  all MBassador specific annotations with Java primitives and simple interfaces\n- + Small refactorings (moved stuff around to have cleaner packaging)\n- + MessageBus.getExecutor() is now deprecated and will be removed with next release -> use the runtime to get access to it.\n- + Introduced BusFactory with convenience methods for creating bus instances for different message dispatching scenarios like\n- asynchronous FIFO (asynchronous message publications guaranteed to be delivered in the order they occurred)\n- + Renamed runtime property of `BusRuntime` \"handler.async-service\" to \"handler.async.executor\"\n-\n-### 1.1.9\n-\n- + Fixed memory leak reported in issue #53\n-\n-### 1.1.8\n-\n- + Internal refactorings and code improvements\n- + Fixed #44 #45 #47\n- + NOTE: This release has a known issue with weak references which introduces a memory leak and is fixed in 1.1.9. The\n- version 1.1.8 is not available from the central repository\n-\n-\n-### 1.1.7\n-\n- + Console Logger not added to message bus instances by default -> use addErrorHandler(IPublicationErrorHandler.ConsoleLogger)\n- + Fixed race conditions in net.engio.mbassy.subscription.Subscription and of WeakConcurrentSet.contains()\n- + Improved message hierarchy handling: Now interfaces, enums , (abstract) classes should work in all combinations\n- + Prevented dispatcher threads from dying on exceptions\n- + Improved test-infrastructure and increased test-coverage\n- + Thanks for your feedback!\n-\n-### 1.1.6\n-\n- + Added support for choosing between strong and weak references using the new @Listener annotation. @Listener can be\n- added to any class that defines message handlers and allows to configure which reference type is used\n- + Custom handler invocations: It is possible to provide a custom handler invocation for each message handler, see \"invocation\"\n- property of @Handler\n- + Changed packaging to \"bundle\" to support OSGI environments\n- + Synchronization of message handlers via @Synchronized: Handlers that are not thread-safe can be synchronized to guarantee\n-  that only one thread at a time can invoke that handler\n- + Created a message bus implementation that does not use threading to support use in non-multi-threaded environments like GWT,\n- see ISyncMessageBus\n-\n-### 1.1.3\n-\n- + Added support for FilteredMessage event\n- + Renamed @Listener to @Handler and DeadEvent to DeadMessage to increase alignment with the established terminology.\n- Sorry for the inconvenience since this will lead to compile errors but good old find&replace will do\n- + Repackaging and refactoring of some parts\n- + Introduced message publication factories as configurable components to make MBassador more extensible/customizable\n- + Added more documentation and unit tests\n-\n-### 1.1.1\n-\n- + Added support for DeadMessage event\n- + Introduced new property to @Handler annotation that allows to activate/deactivate any message handler\n- + Full support of proxies created by cglib\n- + Message handler inheritance changed! See wiki page about handler definition for more details.\n- + Changed @Handler property \"dispatch\" to \"delivery\" and renamed the associated enumeration values to\n-   more precisely indicate their meaning\n- + Added more unit tests\n-\n-### 1.1.0\n-\n-First stable release!\n-\n- + Refactoring and repackaging\n- + More exhaustive unit tests\n- + Installation from the central repository\n-\n-### 1.0.6.RC\n-\n- + Fixed behaviour with capacity bound blocking queue such that there now are two methods to schedule a message\n- asynchronously. One will block until capacity becomes available, the other will timeout after a specified amount of\n- time.\n- +  Additional unit tests\n-\n-### 1.0.5.RC\n-\n- + Added MessageEnvelope and @Enveloped annotation to configure handlers that might receive arbitrary message type\n- + Added handler configuration property to @Handler annotation to move from message filtering to more specific implementation\n- of this feature\n-\n-### 1.0.4.RC\n-\n-  + Introduced BusConfiguration as a central class to encapsulate configurational aspects\n+Release notes have been moved to the [changelog](changelog)\n \n \n <h2>Roadmap</h2>\n@@ -299,15 +195,28 @@ successful transaction commit etc.). Currently in beta, see <a href=\"https://git\n \n \n <h2>Credits</h2>\n-The initial inspiration for creating this component came from trying out Google Guava's event bus implementation.\n+The initial inspiration for creating this component comes from Google Guava's event bus implementation.\n I liked the simplicity of its design and I do trust the developers at Google a lot, so I was happy to find that they also\n provided an event bus system. The main reason it proved to be unusable for our scenario was that it uses strong references\n-to the listeners such that every object has to be explicitly unsubscribed. This was difficult in our Spring managed environment.\n-Finally, I decided to create a custom implementation, which then matured to be stable, extensible and yet very efficient.\n+to the listeners such that every object has to be explicitly unsubscribed.\n+\n+I want to thank the development team from [friendsurance](www.friendsurance.de) for their support and feedback on the bus \n+implementation and the management of friendsurance for allowing me to publish the component as an open source project.\n+\n+I also want to thank all of the github users who have made little or larger contributions. Thank you boys and girls, it is awesome to see\n+the open source idea working.\n+Special thanks go to\n+ + [Bernd Rosstauscher](/Rossi1337) for providing an initial integration with JUEL\n+ + [David Sowerby](/davidsowerby) for providing guidance for other users and his PR on better error handling\n+ + [dorkbox](/dorkbox) for his incredible [work on performance tuning](/bennidi/eventbus-performance/issues/1) which is still to be integrated.\n+\n+\n+Many thanks also to ej-technologies for providing me with an open source license of \n+[![JProfiler](http://www.ej-technologies.com/images/banners/jprofiler_small.png)](http://www.ej-technologies.com/products/jprofiler/overview.html) \n+and Jetbrains for a license of [IntelliJ IDEA](http://www.jetbrains.com/idea/)\n+\n \n-I want to thank the development team from friendsurance (www.friendsurance.de) for their support and feedback on the bus implementation and the management of friendsurance for allowing me to publish the component as an open source project.\n \n-Many thanks also to ej-technologies for providing me with an open source license of [![JProfiler](http://www.ej-technologies.com/images/banners/jprofiler_small.png)](http://www.ej-technologies.com/products/jprofiler/overview.html) and Jetbrains for a license of [IntelliJ IDEA](http://www.jetbrains.com/idea/)\n \n <h2>Contribute</h2>\n \n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "changelog/README.md",
            "additions": 116,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,116 @@\n+### [1.2.2](../milestones/1.2.2)\n+ + Upgraded to Maven 3\n+   + Upgraded all plugins to most recent version\n+   + Fixed all issues that produced warnings on build output\n+ + reduced visibility of `AbstractPubSubSupport.handlePublication` error from `public` to `protected`\n++ __API-Changes:__\n+   + Moved method addPublicationErrorHandler from `IMessageBus` to `IBusConfiguration`\n+   + Default constructor of `MBassador` has no `IPublicationErrorHandler` registered and will \n+   fall back to console logging. See [#106](../issues/106), [#107](../issues/107) \n+\n+\n+### [1.2.1](../milestones/1.2.1)\n+ + Centralized handling of common (and arbitrary) properties (see `BusConfiguration#setProperty` and `net.engio.mbassy.bus.common.Properties`)\n+ + Each bus now has a configurable id and respective #toString() implementation (useful for debugging)\n+ + Each bus now has a default logger (System.out) for publication errors (exception in handlers) which can be replaced with BusConfiguration#setProperty \n+ + __API-Changes:__\n+   + Interface `IMessageFilter` now receives the SubscriptionContext as second parameter. This gives access to the bus runtime within filter logic (useful for error propagation). -> Change your filters signature. You can access the `MessageHandler` object directly from the context. \n+   + Removed deprecated method `BusConfiguration.SyncAsync()` -> Use default constructor or feature based configuration instead\n+   + Deleted interface `ISyncMessageBus` since it was merely an aggregation of existing interfaces -> Replace with GenericMessagePublicationSupport\n+\n+### 1.2.0\n+ + Added support for conditional handlers using Java EL. Thanks to Bernd Rosstauscher for the initial implementation.\n+ + __BREAKING CHANGES__ in BusConfiguration\n+   + Complete redesign of configuration setup using Features instead of simple get/set parameters. This will allow\n+ to flexibly combine features and still be able to exclude those not available in certain environments,for example, threading and reflection in GWT (this will be part of future releases)\n+   + Properties formerly located in BusConfiguration now moved to their respective Feature class\n+   + Removed all SyncXX related interfaces and config implementations. There is now only one `BusConfiguration`\n+ with its corresponding interface which will be used for all types of message bus implementations\n+\n+\n+### 1.1.10\n+ + Fixed broken sort order of prioritized handlers (see [#58](../issues/58))\n+ + Addressed issue #63 by making the constructor of `MessageHandler` use a map of properties and by replacing dependencies to\n+  all MBassador specific annotations with Java primitives and simple interfaces\n+ + Small refactorings (moved stuff around to have cleaner packaging)\n+ + MessageBus.getExecutor() is now deprecated and will be removed with next release -> use the runtime to get access to it.\n+ + Introduced BusFactory with convenience methods for creating bus instances for different message dispatching scenarios like\n+ asynchronous FIFO (asynchronous message publications guaranteed to be delivered in the order they occurred)\n+ + Renamed runtime property of `BusRuntime` \"handler.async-service\" to \"handler.async.executor\"\n+\n+### 1.1.9\n+\n+ + Fixed memory leak reported in [#53](../issues/53)\n+\n+### 1.1.8\n+\n+ + Internal refactorings and code improvements\n+ + Fixed [#44](../issues/44) [#45](../issues/45) [#47](../issues/47)\n+ + NOTE: This release has a known issue with weak references which introduces a memory leak and is fixed in 1.1.9. The\n+ version 1.1.8 is not available from the central repository\n+\n+\n+### 1.1.7\n+\n+ + Console Logger not added to message bus instances by default -> use addErrorHandler(IPublicationErrorHandler.ConsoleLogger)\n+ + Fixed race conditions in net.engio.mbassy.subscription.Subscription and of WeakConcurrentSet.contains()\n+ + Improved message hierarchy handling: Now interfaces, enums , (abstract) classes should work in all combinations\n+ + Prevented dispatcher threads from dying on exceptions\n+ + Improved test-infrastructure and increased test-coverage\n+ + Thanks for your feedback!\n+\n+### 1.1.6\n+\n+ + Added support for choosing between strong and weak references using the new @Listener annotation. @Listener can be\n+ added to any class that defines message handlers and allows to configure which reference type is used\n+ + Custom handler invocations: It is possible to provide a custom handler invocation for each message handler, see \"invocation\"\n+ property of @Handler\n+ + Changed packaging to \"bundle\" to support OSGI environments\n+ + Synchronization of message handlers via @Synchronized: Handlers that are not thread-safe can be synchronized to guarantee\n+  that only one thread at a time can invoke that handler\n+ + Created a message bus implementation that does not use threading to support use in non-multi-threaded environments like GWT,\n+ see ISyncMessageBus\n+\n+### 1.1.3\n+\n+ + Added support for FilteredMessage event\n+ + Renamed @Listener to @Handler and DeadEvent to DeadMessage to increase alignment with the established terminology.\n+ Sorry for the inconvenience since this will lead to compile errors but good old find&replace will do\n+ + Repackaging and refactoring of some parts\n+ + Introduced message publication factories as configurable components to make MBassador more extensible/customizable\n+ + Added more documentation and unit tests\n+\n+### 1.1.1\n+\n+ + Added support for DeadMessage event\n+ + Introduced new property to @Handler annotation that allows to activate/deactivate any message handler\n+ + Full support of proxies created by cglib\n+ + Message handler inheritance changed! See wiki page about handler definition for more details.\n+ + Changed @Handler property \"dispatch\" to \"delivery\" and renamed the associated enumeration values to\n+   more precisely indicate their meaning\n+ + Added more unit tests\n+\n+### 1.1.0\n+\n+First stable release!\n+\n+ + Refactoring and repackaging\n+ + More exhaustive unit tests\n+ + Installation from the central repository\n+\n+### 1.0.6.RC\n+\n+ + Fixed behaviour with capacity bound blocking queue such that there now are two methods to schedule a message\n+ asynchronously. One will block until capacity becomes available, the other will timeout after a specified amount of\n+ time.\n+ +  Additional unit tests\n+\n+### 1.0.5.RC\n+\n+ + Added MessageEnvelope and @Enveloped annotation to configure handlers that might receive arbitrary message type\n+ + Added handler configuration property to @Handler annotation to move from message filtering to more specific implementation\n+ of this feature\n+\n+### 1.0.4.RC\n+\n+  + Introduced BusConfiguration as a central class to encapsulate configurational aspects\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 17,
            "deletions": 16
        },
        "diff content": "@@ -122,6 +122,8 @@\n         \t<scope>runtime</scope>\n         \t<optional>true</optional>\n         </dependency>\n+\n+\n     </dependencies>\n \n     <!--  Local repository (for testing)\n@@ -183,6 +185,7 @@\n             <plugin>\n                 <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-compiler-plugin</artifactId>\n+                <version>3.3</version>\n                 <configuration>\n                     <source>${project.build.java.version}</source>\n                     <target>${project.build.java.version}</target>\n@@ -192,7 +195,7 @@\n             <plugin>\n                 <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-release-plugin</artifactId>\n-                <version>2.4</version>\n+                <version>2.5.2</version>\n                 <configuration>\n                     <mavenExecutorId>forked-path</mavenExecutorId>\n                 </configuration>\n@@ -201,6 +204,7 @@\n             <plugin>\n                 <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-surefire-plugin</artifactId>\n+                <version>2.18.1</version>\n                 <configuration>\n                     <skipTests>false</skipTests>\n                     <excludes>\n@@ -214,6 +218,7 @@\n             <plugin>\n                 <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-source-plugin</artifactId>\n+                <version>2.4</version>\n                 <executions>\n                     <execution>\n                         <id>attach-sources</id>\n@@ -227,6 +232,15 @@\n             <plugin>\n                 <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-javadoc-plugin</artifactId>\n+                <version>2.10.3</version>\n+                <configuration>\n+                    <aggregate>true</aggregate>\n+                    <show>public</show>\n+                    <nohelp>true</nohelp>\n+                    <header>mbassador, ${project.version}</header>\n+                    <footer>mbassador, ${project.version}</footer>\n+                    <doctitle>mbassador, ${project.version}</doctitle>\n+                </configuration>\n                 <executions>\n                     <execution>\n                         <id>attach-javadocs</id>\n@@ -238,22 +252,9 @@\n             </plugin>\n \n \t<!-- \n-\tThese two plugins take care of building and publishing the javadoc, using\n+\tTo build and publish the javadoc run\n \t\tmvn clean javadoc:javadoc scm-publish:publish-scm\n \t --> \n-\t<plugin>\n-\t    <groupId>org.apache.maven.plugins</groupId>\n-\t    <artifactId>maven-javadoc-plugin</artifactId>\n-\t    <version>2.9.1</version>\n-\t    <configuration>\n-\t\t<aggregate>true</aggregate>\n-\t\t<show>public</show>\n-\t\t<nohelp>true</nohelp>\n-\t\t<header>mbassador, ${project.version}</header>\n-\t\t<footer>mbassador, ${project.version}</footer>\n-\t\t<doctitle>mbassador, ${project.version}</doctitle>\n-\t    </configuration>\n-\t</plugin>\n \t<plugin>\n \t    <groupId>org.apache.maven.plugins</groupId>\n \t    <artifactId>maven-scm-publish-plugin</artifactId>\n@@ -284,7 +285,7 @@\n                     <plugin>\n                         <groupId>org.apache.maven.plugins</groupId>\n                         <artifactId>maven-gpg-plugin</artifactId>\n-                        <version>1.4</version>\n+                        <version>1.6</version>\n                         <executions>\n                             <execution>\n                                 <id>sign-artifacts</id>\n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -12,7 +12,7 @@ import net.engio.mbassy.subscription.SubscriptionManager;\n \n import java.util.*;\n \n-import static net.engio.mbassy.bus.common.Properties.Handler.PublicationError;\n+import static net.engio.mbassy.bus.common.Properties.Handler.PublicationErrorHandlers;\n \n /**\n  * The base class for all message bus implementations.\n@@ -46,7 +46,7 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n             errorHandlers.add(new IPublicationErrorHandler.ConsoleLogger());\n             System.out.println(ERROR_HANDLER_MSG);\n         }\n-        this.runtime = new BusRuntime(this).add(PublicationError, getRegisteredErrorHandlers())\n+        this.runtime = new BusRuntime(this).add(PublicationErrorHandlers, getRegisteredErrorHandlers())\n                                            .add(Properties.Common.Id, UUID.randomUUID()\n                                                                           .toString());\n         // configure the pub sub feature\n@@ -99,7 +99,7 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n     }\n \n \n-    public void handlePublicationError(PublicationError error) {\n+    protected void handlePublicationError(PublicationError error) {\n         for (IPublicationErrorHandler errorHandler : errorHandlers) {\n             errorHandler.handleError(error);\n         }\n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/ErrorHandlingSupport.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -17,9 +17,9 @@ public interface ErrorHandlingSupport {\n \n \n     /**\n-     * Returns an immutable collection containing all the registered error handlers\n+     * Get all registered instance of {@link IPublicationErrorHandler}\n      *\n-     * @return\n+     * @return  an immutable collection containing all the registered error handlers\n      */\n     Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n \n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/IMessageBus.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -52,7 +52,7 @@ import net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n  * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n  * get dispatched to all message handlers that take an instance of List as their parameter\n  *\n- * @Author bennidi\n+ * @author bennidi\n  * Date: 2/8/12\n  */\n public interface IMessageBus<T, P extends ISyncAsyncPublicationCommand>\n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/Properties.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -10,7 +10,7 @@ public final class Properties {\n \n     public static final class Handler {\n \n-        public static final String PublicationError = \"bus.handlers.error\";\n+        public static final String PublicationErrorHandlers = \"bus.handlers.error\";\n         public static final String AsynchronousHandlerExecutor = \"bus.handlers.async-executor\";\n     }\n \n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/el/StandardELResolutionContext.java",
            "additions": 5,
            "deletions": 3
        },
        "diff content": "@@ -7,10 +7,12 @@ import java.lang.reflect.Method;\n  *  This ELContext implementation provides support for standard BeanEL resolution in conditional message handlers.\n  *  The message parameter of the message handlers is bound to 'msg' such that it can be referenced int the EL expressions.\n  *\n- *  Example:\n- *  @Handler(condition = \"msg.type == 'onClick'\")\n+ *  <pre>\n+ *  <code>\n+ *  {@literal @}Handler(condition = \"msg.type == 'onClick'\")\n  *  public void handle(ButtonEvent event)\n- *\n+ *  </code>\n+ *  </pre>\n  */\n public class StandardELResolutionContext extends ELContext {\n \n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/IMessageFilter.java",
            "additions": 8,
            "deletions": 4
        },
        "diff content": "@@ -10,9 +10,10 @@ import net.engio.mbassy.subscription.SubscriptionContext;\n  *\n  * Example:\n  *\n- * {@code\n- * @Lister\n- * @Filters(Urlfilter.class)\n+ * <pre>\n+ * <code>\n+ * {@literal @}Listener\n+ * {@literal @}Filters(Urlfilter.class)\n  * public void someHandler(String message){...}\n  *\n  * class Urlfilter implements IMessageFilter<String>{\n@@ -24,8 +25,11 @@ import net.engio.mbassy.subscription.SubscriptionContext;\n  * bus.post(\"http://www.infoq.com\"); // will be delivered\n  * bus.post(\"www.stackoverflow.com\"); // will not be delivered\n  *\n+ * </code>\n+ * </pre>\n+ *\n  * NOTE: A message filter must provide a no-arg constructor!!!\n- * }\n+ *\n  *\n  * @author bennidi\n  *         Date: 2/8/12\n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -21,7 +21,7 @@ public class SubscriptionFactory {\n \n     public Subscription createSubscription(BusRuntime runtime, MessageHandler handlerMetadata) throws MessageBusException{\n         try {\n-            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(Properties.Handler.PublicationError);\n+            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(Properties.Handler.PublicationErrorHandlers);\n             SubscriptionContext context = new SubscriptionContext(runtime, handlerMetadata, errorHandlers);\n             IHandlerInvocation invocation = buildInvocationForHandler(context);\n             IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AllTests.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -23,7 +23,7 @@ import org.junit.runners.Suite;\n         SynchronizedHandlerTest.class,\n         SubscriptionManagerTest.class,\n         AsyncFIFOBusTest.class,\n-        ConditionalHandlers.class\n+        ConditionalHandlerTest.class\n })\n public class AllTests {\n }\n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConditionalHandlerTest.java",
            "additions": 91,
            "deletions": 99
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy;\n \n import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.listener.Enveloped;\n import net.engio.mbassy.listener.Handler;\n@@ -16,84 +17,12 @@ import java.util.Set;\n  * Some unit tests for the \"condition\" filter.\n  ****************************************************************************/\n \n-public class ConditionalHandlers extends MessageBusTest {\n+public class ConditionalHandlerTest extends MessageBusTest {\n \n-\tpublic static class TestEvent {\n \n-\t\tprivate Set<String> handledBy = new HashSet<String>();\n-\t\tprivate String type;\n-\t\tprivate int size;\n-\n-\t\tpublic TestEvent(String type, int size) {\n-\t\t\tsuper();\n-\t\t\tthis.type = type;\n-\t\t\tthis.size = size;\n-\t\t}\n-\t\t\n-\t\tpublic String getType() {\n-\t\t\treturn type;\n-\t\t}\n-\n-\t\tpublic int getSize() {\n-\t\t\treturn size;\n-\t\t}\n-\n-        public boolean wasHandledBy(String ...handlers){\n-            for(String handler : handlers){\n-                if (!handledBy.contains(handler)) return false;\n-            }\n-            return true;\n-        }\n-\n-        public void handledBy(String handler){\n-            handledBy.add(handler);\n-        }\n-\t\t\n-\t}\n-\n-    @Listener(references = References.Strong)\n-\tpublic static class ConditionalMessageListener {\n-\n-\t\t@Handler(condition = \"msg.type == 'TEST'\")\n-\t\tpublic void handleTypeMessage(TestEvent message) {\n-\t\t\tmessage.handledBy(\"handleTypeMessage\");\n-\t\t}\n-\n-\t\t@Handler(condition = \"msg.size > 4\")\n-\t\tpublic void handleSizeMessage(TestEvent message) {\n-\t\t\tmessage.handledBy(\"handleSizeMessage\");\n-\t\t}\n-\n-        @Handler(condition = \"msg.foo > 4\")\n-        public void handleInvalidEL(TestEvent message) {\n-            message.handledBy(\"handleInvalidEL\");\n-        }\n-\t\t\n-\t\t@Handler(condition = \"msg.size > 2 && msg.size < 4\")\n-\t\tpublic void handleCombinedEL(TestEvent message) {\n-\t\t\tmessage.handledBy( \"handleCombinedEL\");\n-\t\t}\n-\t\t\n-\t\t@Handler(condition = \"msg.getType().equals('XYZ') && msg.getSize() == 1\")\n-\t\tpublic void handleMethodAccessEL(TestEvent message) {\n-\t\t\tmessage.handledBy(\"handleMethodAccessEL\");\n-\t\t}\n-\n-        @Handler(condition = \"msg.type == 'TEST'\")\n-        @Enveloped(messages = {TestEvent.class, Object.class})\n-        public void handleEnvelopedMessage(MessageEnvelope envelope) {\n-            envelope.<TestEvent>getMessage().handledBy(\"handleEnvelopedMessage\");\n-        }\n-\t\t\n-\t}\n-\n-\n-\t/*************************************************************************\n-\t * @throws Exception\n-\t ************************************************************************/\n \t@Test\n-\tpublic void testSimpleStringCondition() throws Exception {\n-\t\tMBassador bus = createBus(SyncAsync(false));\n+\tpublic void testSimpleStringCondition(){\n+\t\tMBassador bus = createBus(SyncAsync());\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"TEST\", 0);\n@@ -103,13 +32,9 @@ public class ConditionalHandlers extends MessageBusTest {\n         assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n \t}\n \n-\n-\t/*************************************************************************\n-\t * @throws Exception\n-\t ************************************************************************/\n \t@Test\n-\tpublic void testSimpleNumberCondition() throws Exception {\n-\t\tMBassador bus =  createBus(SyncAsync(false));\n+\tpublic void testSimpleNumberCondition(){\n+\t\tMBassador bus =  createBus(SyncAsync());\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"\", 5);\n@@ -118,13 +43,10 @@ public class ConditionalHandlers extends MessageBusTest {\n \t\tassertTrue(message.wasHandledBy(\"handleSizeMessage\"));\n         assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n \t}\n-\t\n-\t/*************************************************************************\n-\t * @throws Exception\n-\t ************************************************************************/\n+\n \t@Test\n-\tpublic void testHandleCombinedEL() throws Exception {\n-\t\tMBassador bus = createBus(SyncAsync(false));\n+\tpublic void testHandleCombinedEL(){\n+\t\tMBassador bus = createBus(SyncAsync());\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"\", 3);\n@@ -133,13 +55,10 @@ public class ConditionalHandlers extends MessageBusTest {\n         assertTrue(message.wasHandledBy(\"handleCombinedEL\"));\n         assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n \t}\n-\t\n-\t/*************************************************************************\n-\t * @throws Exception\n-\t ************************************************************************/\n+\n \t@Test\n-\tpublic void testNotMatchingAnyCondition() throws Exception {\n-\t\tMBassador bus = createBus(SyncAsync(false));\n+\tpublic void testNotMatchingAnyCondition(){\n+\t\tMBassador bus = createBus(SyncAsync());\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"\", 0);\n@@ -147,13 +66,10 @@ public class ConditionalHandlers extends MessageBusTest {\n \n \t\tassertTrue(message.handledBy.isEmpty());\n \t}\n-\t\n-\t/*************************************************************************\n-\t * @throws Exception\n-\t ************************************************************************/\n+\n \t@Test\n-\tpublic void testHandleMethodAccessEL() throws Exception {\n-\t\tMBassador bus = createBus(SyncAsync(false));\n+\tpublic void testHandleMethodAccessEL(){\n+\t\tMBassador bus = createBus(SyncAsync());\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"XYZ\", 1);\n@@ -164,4 +80,80 @@ public class ConditionalHandlers extends MessageBusTest {\n \n     }\n \n+    public static class TestEvent {\n+\n+        private Set<String> handledBy = new HashSet<String>();\n+        private String type;\n+        private int size;\n+\n+        public TestEvent(String type, int size) {\n+            super();\n+            this.type = type;\n+            this.size = size;\n+        }\n+\n+        public String getType() {\n+            return type;\n+        }\n+\n+        public int getSize() {\n+            return size;\n+        }\n+\n+        public boolean wasHandledBy(String ...handlers){\n+            for(String handler : handlers){\n+                if (!handledBy.contains(handler)) return false;\n+            }\n+            return true;\n+        }\n+\n+        public void handledBy(String handler){\n+            handledBy.add(handler);\n+        }\n+\n+    }\n+\n+    @Listener(references = References.Strong)\n+    public static class ConditionalMessageListener {\n+\n+        @Handler(condition = \"msg.type == 'TEST'\")\n+        public void handleTypeMessage(TestEvent message) {\n+            message.handledBy(\"handleTypeMessage\");\n+        }\n+\n+        @Handler(condition = \"msg.size > 4\")\n+        public void handleSizeMessage(TestEvent message) {\n+            message.handledBy(\"handleSizeMessage\");\n+        }\n+\n+        @Handler(condition = \"msg.foo > 4\")\n+        public void handleInvalidEL(TestEvent message) {\n+            message.handledBy(\"handleInvalidEL\");\n+        }\n+\n+        @Handler(condition = \"msg.size > 2 && msg.size < 4\")\n+        public void handleCombinedEL(TestEvent message) {\n+            message.handledBy( \"handleCombinedEL\");\n+        }\n+\n+        @Handler(condition = \"msg.getType().equals('XYZ') && msg.getSize() == 1\")\n+        public void handleMethodAccessEL(TestEvent message) {\n+            message.handledBy(\"handleMethodAccessEL\");\n+        }\n+\n+        @Handler(condition = \"msg.type == 'TEST'\")\n+        @Enveloped(messages = {TestEvent.class, Object.class})\n+        public void handleEnvelopedMessage(MessageEnvelope envelope) {\n+            envelope.<TestEvent>getMessage().handledBy(\"handleEnvelopedMessage\");\n+        }\n+\n+    }\n+\n+    public static IBusConfiguration SyncAsync() {\n+        return MessageBusTest.SyncAsync(false)\n+                .addPublicationErrorHandler(new EmptyErrorHandler());\n+    }\n+\n+\n+\n }\n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -214,7 +214,7 @@ public class SubscriptionManagerTest extends AssertSupport {\n \n     private BusRuntime mockedRuntime(){\n         return new BusRuntime(null)\n-                .add(Properties.Handler.PublicationError, Collections.EMPTY_SET)\n+                .add(Properties.Handler.PublicationErrorHandlers, Collections.EMPTY_SET)\n                 .add(Properties.Handler.AsynchronousHandlerExecutor, null);\n     }\n \n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncAsyncTest.java",
            "additions": 7,
            "deletions": 8
        },
        "diff content": "@@ -133,31 +133,30 @@ public class SyncAsyncTest extends MessageBusTest {\n         };\n \n         //DS: Exception counter added via config\n-        IBusConfiguration config = SyncAsync();\n-        config.addPublicationErrorHandler(ExceptionCounter);\n-        final MBassador bus = new MBassador(config);\n+        IBusConfiguration config = SyncAsync(false)\n+            .addPublicationErrorHandler(ExceptionCounter);\n \n+        final MBassador bus = new MBassador(config);\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, ExceptionThrowingListener.class);\n         ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n \n-        Runnable publishAndCheck = new Runnable() {\n+        Runnable asynchronousPublication = new Runnable() {\n             @Override\n             public void run() {\n-                bus.post(new StandardMessage()).asynchronously();\n-\n+                bus.post(new Object()).asynchronously();\n             }\n         };\n \n         // single threaded\n-        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n+        ConcurrentExecutor.runConcurrent(asynchronousPublication, 1);\n         pause(processingTimeInMS);\n         assertEquals(InstancesPerListener, exceptionCount.get());\n \n \n         // multi threaded\n         exceptionCount.set(0);\n-        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n+        ConcurrentExecutor.runConcurrent(asynchronousPublication, ConcurrentUnits);\n         pause(processingTimeInMS);\n         assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n \n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -101,14 +101,14 @@ public abstract class SyncBusTest extends MessageBusTest {\n         Runnable publish = new Runnable() {\n             @Override\n             public void run() {\n-                bus.post(new StandardMessage()).now();\n+                bus.post(new Object()).now();\n             }\n         };\n \n         // single threaded\n         ConcurrentExecutor.runConcurrent(publish, 1);\n-\n-        exceptionCount.set(0);\n+        assertEquals(InstancesPerListener, exceptionCount.get());\n+        exceptionCount.set(0); // reset for next test\n \n         // multi threaded\n         ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/bus/AbstractPubSubSupportTest.java",
            "additions": 7,
            "deletions": 9
        },
        "diff content": "@@ -42,7 +42,7 @@ public class AbstractPubSubSupportTest {\n \n     @Before\n     public void setup() {\n-        configuration = MessageBusTest.SyncAsync();\n+        configuration = MessageBusTest.SyncAsync(false);\n     }\n \n \n@@ -102,25 +102,23 @@ public class AbstractPubSubSupportTest {\n         verify(handler1).handleError(publicationError);\n     }\n \n+    /**\n+     * Test configuration that does not provide a publication error handler.\n+     * This should print a warning message and fallback to STDOUT handler\n+     */\n     @Test\n     public void testHandlePublicationError_no_handlers_present_construct_with_config_async() {\n         //given\n-        final String errorMsg = \"Test error\";\n-        when(publicationError.toString()).thenReturn(errorMsg);\n         PrintStream old = null;\n-\n         try {\n             ByteArrayOutputStream baos = new ByteArrayOutputStream();\n             PrintStream ps = new PrintStream(baos);\n             old = System.out;\n             System.setOut(ps);\n-            //when\n+            //when no publication error handler is provided\n             MBassador<String> bus = new MBassador<String>(configuration);\n+            // then we see the warning on the console\n             assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);\n-            bus.handlePublicationError(publicationError);\n-            //then\n-            assertThat(baos.toString()).contains(errorMsg);\n-\n         } finally {\n             System.out.flush();\n             if (old != null) {\n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 11,
            "deletions": 3
        },
        "diff content": "@@ -42,6 +42,13 @@ public abstract class MessageBusTest extends AssertSupport {\n         }\n     }\n \n+    public static final class EmptyErrorHandler implements IPublicationErrorHandler{\n+\n+        @Override\n+        public void handleError(PublicationError error) {\n+        }\n+    }\n+\n     private StrongConcurrentSet<IMessagePublication> issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n \n     @Before\n@@ -56,12 +63,13 @@ public abstract class MessageBusTest extends AssertSupport {\n     }\n \n     public static IBusConfiguration SyncAsync(boolean failOnError) {\n-        return new BusConfiguration()\n+        IBusConfiguration config = new BusConfiguration()\n             .addFeature(Feature.SyncPubSub.Default())\n             .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n             .addFeature(Feature.AsynchronousMessageDispatch.Default());\n-        //DS: removed as publication error handlers now in configuration object\n-//            .setProperty(net.engio.mbassy.bus.common.Properties.Handler.PublicationError, new AssertionErrorHandler(failOnError));\n+        if(failOnError)\n+            config.addPublicationErrorHandler(new AssertionErrorHandler(failOnError));\n+        return config;\n     }\n \n     public MBassador createBus(IBusConfiguration configuration) {\n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageManager.java",
            "additions": 3,
            "deletions": 4
        },
        "diff content": "@@ -1,12 +1,11 @@\n package net.engio.mbassy.common;\n \n import net.engio.mbassy.messages.IMessage;\n-\n-import java.util.Collection;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.Collection;\n+\n /**\n  * Created with IntelliJ IDEA.\n  * User: benjamin\n@@ -95,7 +94,7 @@ public class MessageManager {\n     }\n \n    private void logSuccess(MessageContext mCtx){\n-       LOG.info(\"Message \" + mCtx.getMessage() + \" was successfully handled \" + mCtx.getExpectedCount() + \" times by \" + mCtx.printListeners());\n+       LOG.info(mCtx.getMessage().getClass().getSimpleName() + \" successfully handled \" + mCtx.getExpectedCount() + \" times by \" + mCtx.printListeners());\n    }\n \n \n"
    },
    {
        "commit hash": "40e41d11d7847d660bba6691859b0506514bd0ac",
        "previous commit hash": "2a50396de29dc54a9149f6b678d4882d1c06457f",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/ExceptionThrowingListener.java",
            "additions": 1,
            "deletions": 3
        },
        "diff content": "@@ -3,7 +3,6 @@ package net.engio.mbassy.listeners;\n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Listener;\n import net.engio.mbassy.listener.References;\n-import net.engio.mbassy.messages.StandardMessage;\n \n /**\n  * @author bennidi\n@@ -13,9 +12,8 @@ import net.engio.mbassy.messages.StandardMessage;\n public class ExceptionThrowingListener {\n \n \n-    // this handler will be invoked asynchronously\n     @Handler()\n-    public void handle(StandardMessage message) {\n+    public void handle(Object message) {\n         throw new RuntimeException(\"This is an expected exception\");\n     }\n \n"
    },
    {
        "commit hash": "cca88c367be8fac8440527a36cb818af80bb3bc9",
        "previous commit hash": "017f52a3c9593e6294db4059eb643a8e07de9440",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ReflectionUtils.java",
            "additions": 12,
            "deletions": 5
        },
        "diff content": "@@ -3,9 +3,12 @@ package net.engio.mbassy.common;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.AnnotatedElement;\n import java.lang.reflect.Method;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.List;\n+import java.util.Queue;\n import java.util.Set;\n \n /**\n@@ -16,8 +19,13 @@ import java.util.Set;\n public class ReflectionUtils\n {\n \n-\tpublic static List<Method> getMethods( IPredicate<Method> condition, Class<?> target ) {\n-\t\tList<Method> methods = new LinkedList<Method>();\n+    public static Collection<Method> getMethods( IPredicate<Method> condition, Class<?> target ) {\n+        Collection<Method> methods = new ArrayDeque<Method>();\n+        getMethods(condition, target, methods);\n+        return methods;\n+    }\n+\n+    private static void getMethods( IPredicate<Method> condition, Class<?> target, Collection<Method> methods ) {\n \t\ttry {\n \t\t\tfor ( Method method : target.getDeclaredMethods() ) {\n \t\t\t\tif ( condition.apply( method ) ) {\n@@ -29,9 +37,8 @@ public class ReflectionUtils\n \t\t\t//nop\n \t\t}\n \t\tif ( !target.equals( Object.class ) ) {\n-\t\t\tmethods.addAll( getMethods( condition, target.getSuperclass() ) );\n+            getMethods( condition, target.getSuperclass(), methods );\n \t\t}\n-\t\treturn methods;\n \t}\n \n \t/**\n@@ -80,7 +87,7 @@ public class ReflectionUtils\n \t\t}\n \t}\n \n-\tpublic static boolean containsOverridingMethod( final List<Method> allMethods, final Method methodToCheck ) {\n+    public static boolean containsOverridingMethod( final Collection<Method> allMethods, final Method methodToCheck ) {\n \t\tfor ( Method method : allMethods ) {\n \t\t\tif ( isOverriddenBy( methodToCheck, method ) ) {\n \t\t\t\treturn true;\n"
    },
    {
        "commit hash": "cca88c367be8fac8440527a36cb818af80bb3bc9",
        "previous commit hash": "017f52a3c9593e6294db4059eb643a8e07de9440",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MetadataReader.java",
            "additions": 3,
            "deletions": 1
        },
        "diff content": "@@ -5,10 +5,12 @@ import net.engio.mbassy.common.ReflectionUtils;\n import net.engio.mbassy.subscription.MessageEnvelope;\n \n import java.lang.reflect.Method;\n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n+import java.util.Queue;\n \n /**\n  * The meta data reader is responsible for parsing and validating message handler configurations.\n@@ -57,7 +59,7 @@ public class MetadataReader {\n     public MessageListener getMessageListener(Class target) {\n         MessageListener listenerMetadata = new MessageListener(target);\n         // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n-        List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n+        Collection<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n         // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n         List<Method> bottomMostHandlers = new LinkedList<Method>();\n         for (Method handler : allHandlers) {\n"
    },
    {
        "commit hash": "6c19fd3bd9c7005c3f329fb43586db6ea7f45ad9",
        "previous commit hash": "bccc4496f65611a359ab4740fdfde0bed9f135d7",
        "diff stats": {
            "file_path": "build.gradle",
            "additions": 4,
            "deletions": 0
        },
        "diff content": "@@ -14,6 +14,10 @@ repositories {\n dependencies {\n \n     testCompile \"junit:junit:4.10\"\n+    testCompile 'org.assertj:assertj-core:2.0.0'\n+    testCompile 'org.mockito:mockito-core:1.10.19'\n+    testCompile 'com.mycila.testing.plugins:mycila-testing-mockito:2.8'\n+\n     testCompile 'org.slf4j:slf4j-api:1.7.5'\n \n \n"
    },
    {
        "commit hash": "6c19fd3bd9c7005c3f329fb43586db6ea7f45ad9",
        "previous commit hash": "bccc4496f65611a359ab4740fdfde0bed9f135d7",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 21,
            "deletions": 0
        },
        "diff content": "@@ -67,6 +67,27 @@\n             <scope>test</scope>\n         </dependency>\n \n+        <dependency>\n+            <groupId>org.assertj</groupId>\n+            <artifactId>assertj-core</artifactId>\n+            <version>2.0.0</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.mockito</groupId>\n+            <artifactId>mockito-core</artifactId>\n+            <version>1.10.19</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>com.mycila.testing.plugins</groupId>\n+            <artifactId>mycila-testing-mockito</artifactId>\n+            <version>2.8</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n         <dependency>\n             <groupId>org.slf4j</groupId>\n             <artifactId>slf4j-api</artifactId>\n"
    },
    {
        "commit hash": "6c19fd3bd9c7005c3f329fb43586db6ea7f45ad9",
        "previous commit hash": "bccc4496f65611a359ab4740fdfde0bed9f135d7",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java",
            "additions": 18,
            "deletions": 18
        },
        "diff content": "@@ -31,23 +31,28 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n \n     private final BusRuntime runtime;\n \n+    public static final String ERROR_HANDLER_MSG = \"INFO: No error handler has been configured to handle exceptions during publication.\\n\" +\n+            \"Publication error handlers can be added by IBusConfiguration.addPublicationErrorHandler()\\n\" +\n+            \"Falling back to console logger.\";\n+\n+\n+\n \n     public AbstractPubSubSupport(IBusConfiguration configuration) {\n-        if(!configuration.hasProperty(Properties.Handler.PublicationError)){\n-            System.out.println(\"WARN: No error handler configured to handle exceptions during publication.\\n\" +\n-                    \"Publication error handlers can be added by AbstractPubSubSupport.addErrorHandler()\\n\" +\n-                    \"Configuration error handlers can be added by IBUsConfiguration.addConfigurationErrorHandler()\\n\" +\n-                    \"Falling back to console logger.\");\n+\n+        //transfer publication error handlers from the config object\n+        this.errorHandlers.addAll(configuration.getRegisteredPublicationErrorHandlers());\n+        if (errorHandlers.isEmpty()) {\n+            errorHandlers.add(new IPublicationErrorHandler.ConsoleLogger());\n+            System.out.println(ERROR_HANDLER_MSG);\n         }\n-        this.errorHandlers.add(configuration.getProperty(Properties.Handler.PublicationError, new IPublicationErrorHandler.ConsoleLogger()));\n-        this.runtime = new BusRuntime(this)\n-            .add(PublicationError, getRegisteredErrorHandlers())\n-            .add(Properties.Common.Id, UUID.randomUUID().toString());\n+        this.runtime = new BusRuntime(this).add(PublicationError, getRegisteredErrorHandlers())\n+                                           .add(Properties.Common.Id, UUID.randomUUID()\n+                                                                          .toString());\n         // configure the pub sub feature\n         Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);\n         this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()\n-                .createManager(pubSubFeature.getMetadataReader(),\n-                        pubSubFeature.getSubscriptionFactory(), runtime);\n+                                                .createManager(pubSubFeature.getMetadataReader(), pubSubFeature.getSubscriptionFactory(), runtime);\n         this.publicationFactory = pubSubFeature.getPublicationFactory();\n     }\n \n@@ -70,12 +75,6 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n     }\n \n \n-    public final void addErrorHandler(IPublicationErrorHandler handler) {\n-        synchronized (this){\n-            errorHandlers.add(handler);\n-        }\n-    }\n-\n     @Override\n     public BusRuntime getRuntime() {\n         return runtime;\n@@ -83,7 +82,8 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n \n     protected IMessagePublication createMessagePublication(T message) {\n         Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n-        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass().equals(DeadMessage.class)) {\n+        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass()\n+                                                                          .equals(DeadMessage.class)) {\n             // Dead Event\n             subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n             return getPublicationFactory().createPublication(runtime, subscriptions, new DeadMessage(message));\n"
    },
    {
        "commit hash": "6c19fd3bd9c7005c3f329fb43586db6ea7f45ad9",
        "previous commit hash": "bccc4496f65611a359ab4740fdfde0bed9f135d7",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/BusRuntime.java",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -49,4 +49,5 @@ public class BusRuntime {\n         return properties.containsKey(key);\n     }\n \n+\n }\n"
    },
    {
        "commit hash": "6c19fd3bd9c7005c3f329fb43586db6ea7f45ad9",
        "previous commit hash": "bccc4496f65611a359ab4740fdfde0bed9f135d7",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MBassador.java",
            "additions": 28,
            "deletions": 4
        },
        "diff content": "@@ -4,6 +4,7 @@ import net.engio.mbassy.bus.common.IMessageBus;\n import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.bus.publication.SyncAsyncPostCommand;\n \n@@ -13,10 +14,9 @@ import java.util.concurrent.TimeUnit;\n public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> implements IMessageBus<T, SyncAsyncPostCommand<T>> {\n \n \n-    public MBassador(IBusConfiguration configuration) {\n-        super(configuration);\n-    }\n-\n+    /**\n+     * Default constructor using default setup. super() will also add a default publication error logger\n+     */\n     public MBassador(){\n         this(new BusConfiguration()\n                 .addFeature(Feature.SyncPubSub.Default())\n@@ -24,6 +24,30 @@ public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCo\n                 .addFeature(Feature.AsynchronousMessageDispatch.Default()));\n     }\n \n+    /**\n+     * Construct with default settings and specified publication error handler\n+     *\n+     * @param errorHandler\n+     */\n+    public MBassador(IPublicationErrorHandler errorHandler) {\n+        super(new BusConfiguration().addFeature(Feature.SyncPubSub.Default())\n+                                    .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n+                                    .addFeature(Feature.AsynchronousMessageDispatch.Default())\n+                                    .addPublicationErrorHandler(errorHandler));\n+    }\n+\n+    /**\n+     * Construct with fully specified configuration\n+     *\n+     * @param configuration\n+     */\n+    public MBassador(IBusConfiguration configuration) {\n+        super(configuration);\n+    }\n+\n+\n+\n+\n \n     public IMessagePublication publishAsync(T message) {\n         return addAsynchronousPublication(createMessagePublication(message));\n"
    },
    {
        "commit hash": "6c19fd3bd9c7005c3f329fb43586db6ea7f45ad9",
        "previous commit hash": "bccc4496f65611a359ab4740fdfde0bed9f135d7",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/SyncMessageBus.java",
            "additions": 27,
            "deletions": 6
        },
        "diff content": "@@ -3,18 +3,40 @@ package net.engio.mbassy.bus;\n import net.engio.mbassy.bus.common.ErrorHandlingSupport;\n import net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\n import net.engio.mbassy.bus.common.PubSubSupport;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.bus.publication.IPublicationCommand;\n \n /**\n  * A message bus implementation that offers only synchronous message publication. Using this bus\n  * will not create any new threads.\n- *\n  */\n-public class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements PubSubSupport<T>, ErrorHandlingSupport, GenericMessagePublicationSupport<T, SyncMessageBus.SyncPostCommand>{\n+public class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements PubSubSupport<T>, ErrorHandlingSupport, GenericMessagePublicationSupport<T,\n+        SyncMessageBus.SyncPostCommand> {\n \n+    /**\n+     * Default constructor using default setup. super() will also add a default publication error logger\n+     */\n+    public SyncMessageBus() {\n+        super(new BusConfiguration().addFeature(Feature.SyncPubSub.Default()));\n+    }\n+\n+    /**\n+     * Construct with default settings and specified publication error handler\n+     * @param errorHandler\n+     */\n+    public SyncMessageBus(IPublicationErrorHandler errorHandler) {\n+        super(new BusConfiguration().addFeature(Feature.SyncPubSub.Default()).addPublicationErrorHandler(errorHandler));\n+    }\n \n+    /**\n+     * Construct with fully specified configuration\n+     *\n+     * @param configuration\n+     */\n     public SyncMessageBus(IBusConfiguration configuration) {\n         super(configuration);\n     }\n@@ -25,10 +47,9 @@ public class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements PubSu\n             IMessagePublication publication = createMessagePublication(message);\n             publication.execute();\n         } catch (Throwable e) {\n-            handlePublicationError(new PublicationError()\n-                    .setMessage(\"Error during publication of message\")\n-                    .setCause(e)\n-                    .setPublishedMessage(message));\n+            handlePublicationError(new PublicationError().setMessage(\"Error during publication of message\")\n+                                                         .setCause(e)\n+                                                         .setPublishedMessage(message));\n         }\n     }\n \n"
    },
    {
        "commit hash": "6c19fd3bd9c7005c3f329fb43586db6ea7f45ad9",
        "previous commit hash": "bccc4496f65611a359ab4740fdfde0bed9f135d7",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/ErrorHandlingSupport.java",
            "additions": 8,
            "deletions": 9
        },
        "diff content": "@@ -1,21 +1,20 @@\n package net.engio.mbassy.bus.common;\n \n+import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n \n import java.util.Collection;\n \n+/**\n+ * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n+ * may not be accessible due to security constraints or is not annotated properly.\n+ * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n+ * Error handlers can be added via the {@link IBusConfiguration}.\n+ *\n+ */\n \n public interface ErrorHandlingSupport {\n \n-    /**\n-     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n-     * may not be accessible due to security constraints or is not annotated properly.\n-     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n-     * A call to this method will add the given error handler to the chain\n-     *\n-     * @param errorHandler\n-     */\n-    void addErrorHandler(IPublicationErrorHandler errorHandler);\n \n     /**\n      * Returns an immutable collection containing all the registered error handlers\n"
    },
    {
        "commit hash": "6c19fd3bd9c7005c3f329fb43586db6ea7f45ad9",
        "previous commit hash": "bccc4496f65611a359ab4740fdfde0bed9f135d7",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java",
            "additions": 19,
            "deletions": 7
        },
        "diff content": "@@ -1,9 +1,8 @@\n package net.engio.mbassy.bus.config;\n \n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n+\n+import java.util.*;\n \n /**\n  * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n@@ -12,7 +11,9 @@ public class BusConfiguration implements IBusConfiguration {\n \n     // the registered properties\n     private final Map<Object, Object> properties = new HashMap<Object, Object>();\n-    private final List<ConfigurationErrorHandler> errorHandlerList = new LinkedList<ConfigurationErrorHandler>();\n+    private final List<ConfigurationErrorHandler> configurationErrorHandlers = new LinkedList<ConfigurationErrorHandler>();\n+    // these are transferred to the bus to receive all errors that occur during message dispatch or message handling\n+    private final List<IPublicationErrorHandler> publicationErrorHandlers = new ArrayList<IPublicationErrorHandler>();\n \n     public BusConfiguration() {\n         super();\n@@ -47,14 +48,25 @@ public class BusConfiguration implements IBusConfiguration {\n \n     @Override\n     public IBusConfiguration addConfigurationErrorHandler(ConfigurationErrorHandler handler) {\n-        errorHandlerList.add(handler);\n+        configurationErrorHandlers.add(handler);\n         return this;\n     }\n \n     @Override\n     public void handleError(ConfigurationError error) {\n-        for(ConfigurationErrorHandler errorHandler : errorHandlerList){\n+        for(ConfigurationErrorHandler errorHandler : configurationErrorHandlers){\n             errorHandler.handle(error);\n         }\n     }\n+\n+@Override\n+    public final BusConfiguration addPublicationErrorHandler(IPublicationErrorHandler handler) {\n+            publicationErrorHandlers.add(handler);\n+    return this;\n+    }\n+\n+    @Override\n+    public Collection<IPublicationErrorHandler> getRegisteredPublicationErrorHandlers() {\n+        return Collections.unmodifiableCollection(publicationErrorHandlers);\n+    }\n }\n"
    },
    {
        "commit hash": "6c19fd3bd9c7005c3f329fb43586db6ea7f45ad9",
        "previous commit hash": "bccc4496f65611a359ab4740fdfde0bed9f135d7",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/IBusConfiguration.java",
            "additions": 9,
            "deletions": 0
        },
        "diff content": "@@ -1,5 +1,9 @@\n package net.engio.mbassy.bus.config;\n \n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n+\n+import java.util.Collection;\n+\n /**\n  * The configuration of message bus instances is feature driven, e.g. configuration parameters\n  * are grouped into {@link Feature}.\n@@ -65,4 +69,9 @@ public interface IBusConfiguration{\n      */\n     void handleError(ConfigurationError error);\n \n+    BusConfiguration addPublicationErrorHandler(IPublicationErrorHandler handler);\n+\n+    Collection<IPublicationErrorHandler> getRegisteredPublicationErrorHandlers();\n+\n+\n }\n"
    },
    {
        "commit hash": "6c19fd3bd9c7005c3f329fb43586db6ea7f45ad9",
        "previous commit hash": "bccc4496f65611a359ab4740fdfde0bed9f135d7",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncAsyncTest.java",
            "additions": 6,
            "deletions": 3
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy;\n \n import net.engio.mbassy.bus.MBassador;\n-import net.engio.mbassy.bus.common.Properties;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.common.*;\n@@ -132,8 +132,11 @@ public class SyncAsyncTest extends MessageBusTest {\n             }\n         };\n \n-        final MBassador bus = new MBassador(SyncAsync()\n-                .setProperty(Properties.Handler.PublicationError, ExceptionCounter));\n+        //DS: Exception counter added via config\n+        IBusConfiguration config = SyncAsync();\n+        config.addPublicationErrorHandler(ExceptionCounter);\n+        final MBassador bus = new MBassador(config);\n+\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, ExceptionThrowingListener.class);\n         ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n"
    },
    {
        "commit hash": "6c19fd3bd9c7005c3f329fb43586db6ea7f45ad9",
        "previous commit hash": "bccc4496f65611a359ab4740fdfde0bed9f135d7",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 27,
            "deletions": 10
        },
        "diff content": "@@ -3,7 +3,6 @@ package net.engio.mbassy;\n import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.bus.SyncMessageBus;\n import net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\n-import net.engio.mbassy.bus.common.Properties;\n import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n@@ -34,6 +33,8 @@ import java.util.concurrent.atomic.AtomicInteger;\n public abstract class SyncBusTest extends MessageBusTest {\n \n \n+    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler);\n+\n     protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException);\n \n     @Test\n@@ -90,8 +91,8 @@ public abstract class SyncBusTest extends MessageBusTest {\n             }\n         };\n \n-        final GenericMessagePublicationSupport bus = getSyncMessageBus(false);\n-        bus.addErrorHandler(ExceptionCounter);\n+        //DS: modified to pass ExceptionCounter via the configuration object\n+        final GenericMessagePublicationSupport bus = getSyncMessageBus(false,ExceptionCounter);\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, ExceptionThrowingListener.class);\n \n@@ -175,15 +176,24 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n     public static class MBassadorTest extends SyncBusTest {\n \n-\n+        //DS: added errorHandler parameter to allow adding handler from caller\n         @Override\n-        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n-            IBusConfiguration asyncFIFOConfig = new BusConfiguration()\n-                    .setProperty(Properties.Handler.PublicationError, new AssertionErrorHandler(failOnException));\n+        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {\n+            IBusConfiguration asyncFIFOConfig = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));\n             asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n             asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n             asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n+            if (errorHandler != null) {\n+                asyncFIFOConfig.addPublicationErrorHandler(errorHandler);\n+            }\n             return new MBassador(asyncFIFOConfig);\n+\n+        }\n+\n+\n+        @Override\n+        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n+            return getSyncMessageBus(failOnException, null);\n         }\n \n     }\n@@ -192,12 +202,19 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n \n         @Override\n-        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n-            IBusConfiguration syncPubSubCfg = new BusConfiguration()\n-                    .setProperty(Properties.Handler.PublicationError, new AssertionErrorHandler(failOnException));\n+        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {\n+            IBusConfiguration syncPubSubCfg = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));\n             syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());\n+            if (errorHandler != null) {\n+                syncPubSubCfg.addPublicationErrorHandler(errorHandler);\n+            }\n             return new SyncMessageBus(syncPubSubCfg);\n         }\n+\n+        @Override\n+        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n+            return getSyncMessageBus(failOnException, null);\n+        }\n     }\n \n \n"
    },
    {
        "commit hash": "6c19fd3bd9c7005c3f329fb43586db6ea7f45ad9",
        "previous commit hash": "bccc4496f65611a359ab4740fdfde0bed9f135d7",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/bus/AbstractPubSubSupportTest.java",
            "additions": 189,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,189 @@\n+package net.engio.mbassy.bus;\n+\n+import com.mycila.testing.junit.MycilaJunitRunner;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n+import net.engio.mbassy.bus.error.PublicationError;\n+import net.engio.mbassy.common.MessageBusTest;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Added for changes proposed under https://github.com/bennidi/mbassador/issues/106\n+ * <p/>\n+ * Created by David Sowerby on 13/04/15.\n+ */\n+@RunWith(MycilaJunitRunner.class)\n+public class AbstractPubSubSupportTest {\n+\n+    IBusConfiguration configuration;\n+\n+    @Mock\n+    IPublicationErrorHandler handler1;\n+\n+    @Mock\n+    IPublicationErrorHandler handler2;\n+\n+    @Mock\n+    IPublicationErrorHandler handler3;\n+\n+    @Mock\n+    PublicationError publicationError;\n+\n+\n+    @Before\n+    public void setup() {\n+        configuration = MessageBusTest.SyncAsync();\n+    }\n+\n+\n+    @Test\n+    public void testHandlePublicationError_handlers_present_sync() {\n+        //given\n+\n+        configuration.addPublicationErrorHandler(handler1);\n+        configuration.addPublicationErrorHandler(handler2);\n+        configuration.addPublicationErrorHandler(handler3);\n+        //when\n+        SyncMessageBus<String> bus = new SyncMessageBus<String>(configuration);\n+        bus.handlePublicationError(publicationError);\n+        //then\n+        verify(handler1).handleError(publicationError);\n+        verify(handler2).handleError(publicationError);\n+        verify(handler3).handleError(publicationError);\n+    }\n+\n+    @Test\n+    public void testHandlePublicationError_handlers_present_async() {\n+        //given\n+\n+        configuration.addPublicationErrorHandler(handler1);\n+        configuration.addPublicationErrorHandler(handler2);\n+        configuration.addPublicationErrorHandler(handler3);\n+        //when\n+        MBassador<String> bus = new MBassador<String>(configuration);\n+        bus.handlePublicationError(publicationError);\n+        //then\n+        verify(handler1).handleError(publicationError);\n+        verify(handler2).handleError(publicationError);\n+        verify(handler3).handleError(publicationError);\n+    }\n+\n+\n+    @Test\n+    public void testHandlePublicationError_construct_with_handler_sync() {\n+        //given\n+\n+        //when\n+        SyncMessageBus<String> bus = new SyncMessageBus<String>(handler1);\n+        bus.handlePublicationError(publicationError);\n+        //then\n+        verify(handler1).handleError(publicationError);\n+    }\n+\n+    @Test\n+    public void testHandlePublicationError_constrcut_with_handler_async() {\n+        //given\n+\n+        configuration.addPublicationErrorHandler(handler1);\n+        //when\n+        MBassador<String> bus = new MBassador<String>(handler1);\n+        bus.handlePublicationError(publicationError);\n+        //then\n+        verify(handler1).handleError(publicationError);\n+    }\n+\n+    @Test\n+    public void testHandlePublicationError_no_handlers_present_construct_with_config_async() {\n+        //given\n+        final String errorMsg = \"Test error\";\n+        when(publicationError.toString()).thenReturn(errorMsg);\n+        PrintStream old = null;\n+\n+        try {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            PrintStream ps = new PrintStream(baos);\n+            old = System.out;\n+            System.setOut(ps);\n+            //when\n+            MBassador<String> bus = new MBassador<String>(configuration);\n+            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);\n+            bus.handlePublicationError(publicationError);\n+            //then\n+            assertThat(baos.toString()).contains(errorMsg);\n+\n+        } finally {\n+            System.out.flush();\n+            if (old != null) {\n+                System.setOut(old);\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testHandlePublicationError_default_construct_sync() {\n+        //given\n+        final String errorMsg = \"Test error\";\n+        when(publicationError.toString()).thenReturn(errorMsg);\n+        PrintStream old = null;\n+\n+        try {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            PrintStream ps = new PrintStream(baos);\n+            old = System.out;\n+            System.setOut(ps);\n+            //when\n+            SyncMessageBus<String> bus = new SyncMessageBus<String>();\n+            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);\n+            bus.handlePublicationError(publicationError);\n+            //then\n+            assertThat(baos.toString()).contains(errorMsg);\n+\n+        } finally {\n+            System.out.flush();\n+            if (old != null) {\n+                System.setOut(old);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testHandlePublicationError_default_construct_async() {\n+        //given\n+        final String errorMsg = \"Test error\";\n+        when(publicationError.toString()).thenReturn(errorMsg);\n+        PrintStream old = null;\n+\n+        try {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            PrintStream ps = new PrintStream(baos);\n+            old = System.out;\n+            System.setOut(ps);\n+            //when\n+            MBassador<String> bus = new MBassador<String>();\n+            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);\n+            bus.handlePublicationError(publicationError);\n+            //then\n+            assertThat(baos.toString()).contains(errorMsg);\n+\n+        } finally {\n+            System.out.flush();\n+            if (old != null) {\n+                System.setOut(old);\n+            }\n+        }\n+\n+    }\n+\n+\n+}\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "6c19fd3bd9c7005c3f329fb43586db6ea7f45ad9",
        "previous commit hash": "bccc4496f65611a359ab4740fdfde0bed9f135d7",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 3,
            "deletions": 2
        },
        "diff content": "@@ -59,8 +59,9 @@ public abstract class MessageBusTest extends AssertSupport {\n         return new BusConfiguration()\n             .addFeature(Feature.SyncPubSub.Default())\n             .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n-            .addFeature(Feature.AsynchronousMessageDispatch.Default())\n-            .setProperty(net.engio.mbassy.bus.common.Properties.Handler.PublicationError, new AssertionErrorHandler(failOnError));\n+            .addFeature(Feature.AsynchronousMessageDispatch.Default());\n+        //DS: removed as publication error handlers now in configuration object\n+//            .setProperty(net.engio.mbassy.bus.common.Properties.Handler.PublicationError, new AssertionErrorHandler(failOnError));\n     }\n \n     public MBassador createBus(IBusConfiguration configuration) {\n"
    },
    {
        "commit hash": "b86c32b876c6c8651522250ab6a41580bbf9bbb3",
        "previous commit hash": "fd70480775b4cf4b6101c630e9221e436db69271",
        "diff stats": {
            "file_path": "build.gradle",
            "additions": 18,
            "deletions": 4
        },
        "diff content": "@@ -1,10 +1,24 @@\n-usePlugin('java')\n+apply plugin: 'java'\n+apply plugin: 'war' // needed for providedCompile\n \n group=\"org.mbassy\"\n-version=\"1.1.2\"\n+version=\"1.2.2-SNAPSHOT\"\n+\n+\n+\n+repositories {\n+    jcenter()\n+    mavenCentral()\n+}\n \n dependencies {\n-    addMavenRepo()\n \n-    testCompile \"junit:junit:4.10@jar\"\n+    testCompile \"junit:junit:4.10\"\n+    testCompile 'org.slf4j:slf4j-api:1.7.5'\n+\n+\n+    testCompile 'org.slf4j:slf4j-log4j12:1.7.5'\n+    providedCompile 'javax.el:javax.el-api:2.2.5'\n+    runtime 'de.odysseus.juel:juel-impl:2.2.7'\n+    runtime 'de.odysseus.juel:juel-spi:2.2.7'\n }\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "fd70480775b4cf4b6101c630e9221e436db69271",
        "previous commit hash": "395e87210d3c28e1dcfb4c6a0044a43dacedd44d",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -35,7 +35,8 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n     public AbstractPubSubSupport(IBusConfiguration configuration) {\n         if(!configuration.hasProperty(Properties.Handler.PublicationError)){\n             System.out.println(\"WARN: No error handler configured to handle exceptions during publication.\\n\" +\n-                    \"Error handlers can be added to any instance of  AbstractPubSubSupport or via BusConfiguration. \\n\" +\n+                    \"Publication error handlers can be added by AbstractPubSubSupport.addErrorHandler()\\n\" +\n+                    \"Configuration error handlers can be added by IBUsConfiguration.addConfigurationErrorHandler()\\n\" +\n                     \"Falling back to console logger.\");\n         }\n         this.errorHandlers.add(configuration.getProperty(Properties.Handler.PublicationError, new IPublicationErrorHandler.ConsoleLogger()));\n"
    },
    {
        "commit hash": "395e87210d3c28e1dcfb4c6a0044a43dacedd44d",
        "previous commit hash": "577495b7ec050cdc75d27650b101a259453bcf65",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ConcurrentHashMapV8.java",
            "additions": 0,
            "deletions": 4349
        },
        "diff content": "@@ -1,4349 +0,0 @@\n-/*\n- * Written by Doug Lea with assistance from members of JCP JSR-166\n- * Expert Group and released to the public domain, as explained at\n- * http://creativecommons.org/publicdomain/zero/1.0/\n- */\n-package net.engio.mbassy.common;\n-\n-import java.io.ObjectStreamField;\n-import java.io.Serializable;\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Type;\n-import java.util.AbstractMap;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.ConcurrentModificationException;\n-import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.Hashtable;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.ForkJoinPool;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.locks.LockSupport;\n-import java.util.concurrent.locks.ReentrantLock;\n-\n-/*\n- * Bulk operations removed in Java 6 backport.\n- */\n-\n-/**\n- * A hash table supporting full concurrency of retrievals and\n- * high expected concurrency for updates. This class obeys the\n- * same functional specification as {@link java.util.Hashtable}, and\n- * includes versions of methods corresponding to each method of\n- * {@code Hashtable}. However, even though all operations are\n- * thread-safe, retrieval operations do <em>not</em> entail locking,\n- * and there is <em>not</em> any support for locking the entire table\n- * in a way that prevents all access.  This class is fully\n- * interoperable with {@code Hashtable} in programs that rely on its\n- * thread safety but not on its synchronization details.\n- *\n- * <p>Retrieval operations (including {@code get}) generally do not\n- * block, so may overlap with update operations (including {@code put}\n- * and {@code remove}). Retrievals reflect the results of the most\n- * recently <em>completed</em> update operations holding upon their\n- * onset. (More formally, an update operation for a given key bears a\n- * <em>happens-before</em> relation with any (non-null) retrieval for\n- * that key reporting the updated value.)  For aggregate operations\n- * such as {@code putAll} and {@code clear}, concurrent retrievals may\n- * reflect insertion or removal of only some entries.  Similarly,\n- * Iterators and Enumerations return elements reflecting the state of\n- * the hash table at some point at or since the creation of the\n- * iterator/enumeration.  They do <em>not</em> throw {@link\n- * ConcurrentModificationException}.  However, iterators are designed\n- * to be used by only one thread at a time.  Bear in mind that the\n- * results of aggregate status methods including {@code size}, {@code\n- * isEmpty}, and {@code containsValue} are typically useful only when\n- * a map is not undergoing concurrent updates in other threads.\n- * Otherwise the results of these methods reflect transient states\n- * that may be adequate for monitoring or estimation purposes, but not\n- * for program control.\n- *\n- * <p>The table is dynamically expanded when there are too many\n- * collisions (i.e., keys that have distinct hash codes but fall into\n- * the same slot modulo the table size), with the expected average\n- * effect of maintaining roughly two bins per mapping (corresponding\n- * to a 0.75 load factor threshold for resizing). There may be much\n- * variance around this average as mappings are added and removed, but\n- * overall, this maintains a commonly accepted time/space tradeoff for\n- * hash tables.  However, resizing this or any other kind of hash\n- * table may be a relatively slow operation. When possible, it is a\n- * good idea to provide a size estimate as an optional {@code\n- * initialCapacity} constructor argument. An additional optional\n- * {@code loadFactor} constructor argument provides a further means of\n- * customizing initial table capacity by specifying the table density\n- * to be used in calculating the amount of space to allocate for the\n- * given number of elements.  Also, for compatibility with previous\n- * versions of this class, constructors may optionally specify an\n- * expected {@code concurrencyLevel} as an additional hint for\n- * internal sizing.  Note that using many keys with exactly the same\n- * {@code hashCode()} is a sure way to slow down performance of any\n- * hash table. To ameliorate impact, when keys are {@link Comparable},\n- * this class may use comparison order among keys to help break ties.\n- *\n- * <p>A {@link Set} projection of a ConcurrentHashMapV8 may be created\n- * (using {@link #newKeySet()} or {@link #newKeySet(int)}), or viewed\n- * (using {@link #keySet(Object)} when only keys are of interest, and the\n- * mapped values are (perhaps transiently) not used or all take the\n- * same mapping value.\n- *\n- * <p>This class and its views and iterators implement all of the\n- * <em>optional</em> methods of the {@link Map} and {@link Iterator}\n- * interfaces.\n- *\n- * <p>Like {@link Hashtable} but unlike {@link HashMap}, this class\n- * does <em>not</em> allow {@code null} to be used as a key or value.\n- *\n- * <p>ConcurrentHashMapV8s support a set of sequential and parallel bulk\n- * operations that are designed\n- * to be safely, and often sensibly, applied even with maps that are\n- * being concurrently updated by other threads; for example, when\n- * computing a snapshot summary of the values in a shared registry.\n- * There are three kinds of operation, each with four forms, accepting\n- * functions with Keys, Values, Entries, and (Key, Value) arguments\n- * and/or return values. Because the elements of a ConcurrentHashMapV8\n- * are not ordered in any particular way, and may be processed in\n- * different orders in different parallel executions, the correctness\n- * of supplied functions should not depend on any ordering, or on any\n- * other objects or values that may transiently change while\n- * computation is in progress; and except for forEach actions, should\n- * ideally be side-effect-free. Bulk operations on {@link java.util.Map.Entry}\n- * objects do not support method {@code setValue}.\n- *\n- * <ul>\n- * <li> forEach: Perform a given action on each element.\n- * A variant form applies a given transformation on each element\n- * before performing the action.</li>\n- *\n- * <li> search: Return the first available non-null result of\n- * applying a given function on each element; skipping further\n- * search when a result is found.</li>\n- *\n- * <li> reduce: Accumulate each element.  The supplied reduction\n- * function cannot rely on ordering (more formally, it should be\n- * both associative and commutative).  There are five variants:\n- *\n- * <ul>\n- *\n- * <li> Plain reductions. (There is not a form of this method for\n- * (key, value) function arguments since there is no corresponding\n- * return type.)</li>\n- *\n- * <li> Mapped reductions that accumulate the results of a given\n- * function applied to each element.</li>\n- *\n- * <li> Reductions to scalar doubles, longs, and ints, using a\n- * given basis value.</li>\n- *\n- * </ul>\n- * </li>\n- * </ul>\n- *\n- * <p>These bulk operations accept a {@code parallelismThreshold}\n- * argument. Methods proceed sequentially if the current map size is\n- * estimated to be less than the given threshold. Using a value of\n- * {@code Long.MAX_VALUE} suppresses all parallelism.  Using a value\n- * of {@code 1} results in maximal parallelism by partitioning into\n- * enough subtasks to fully utilize the {@link\n- * ForkJoinPool#commonPool()} that is used for all parallel\n- * computations. Normally, you would initially choose one of these\n- * extreme values, and then measure performance of using in-between\n- * values that trade off overhead versus throughput.\n- *\n- * <p>The concurrency properties of bulk operations follow\n- * from those of ConcurrentHashMapV8: Any non-null result returned\n- * from {@code get(key)} and related access methods bears a\n- * happens-before relation with the associated insertion or\n- * update.  The result of any bulk operation reflects the\n- * composition of these per-element relations (but is not\n- * necessarily atomic with respect to the map as a whole unless it\n- * is somehow known to be quiescent).  Conversely, because keys\n- * and values in the map are never null, null serves as a reliable\n- * atomic indicator of the current lack of any result.  To\n- * maintain this property, null serves as an implicit basis for\n- * all non-scalar reduction operations. For the double, long, and\n- * int versions, the basis should be one that, when combined with\n- * any other value, returns that other value (more formally, it\n- * should be the identity element for the reduction). Most common\n- * reductions have these properties; for example, computing a sum\n- * with basis 0 or a minimum with basis MAX_VALUE.\n- *\n- * <p>Search and transformation functions provided as arguments\n- * should similarly return null to indicate the lack of any result\n- * (in which case it is not used). In the case of mapped\n- * reductions, this also enables transformations to serve as\n- * filters, returning null (or, in the case of primitive\n- * specializations, the identity basis) if the element should not\n- * be combined. You can create compound transformations and\n- * filterings by composing them yourself under this \"null means\n- * there is nothing there now\" rule before using them in search or\n- * reduce operations.\n- *\n- * <p>Methods accepting and/or returning Entry arguments maintain\n- * key-value associations. They may be useful for example when\n- * finding the key for the greatest value. Note that \"plain\" Entry\n- * arguments can be supplied using {@code new\n- * AbstractMap.SimpleEntry(k,v)}.\n- *\n- * <p>Bulk operations may complete abruptly, throwing an\n- * exception encountered in the application of a supplied\n- * function. Bear in mind when handling such exceptions that other\n- * concurrently executing functions could also have thrown\n- * exceptions, or would have done so if the first exception had\n- * not occurred.\n- *\n- * <p>Speedups for parallel compared to sequential forms are common\n- * but not guaranteed.  Parallel operations involving brief functions\n- * on small maps may execute more slowly than sequential forms if the\n- * underlying work to parallelize the computation is more expensive\n- * than the computation itself.  Similarly, parallelization may not\n- * lead to much actual parallelism if all processors are busy\n- * performing unrelated tasks.\n- *\n- * <p>All arguments to all task methods must be non-null.\n- *\n- * <p><em>jsr166e note: During transition, this class\n- * uses nested functional interfaces with different names but the\n- * same forms as those expected for JDK8.</em>\n- *\n- * <p>This class is a member of the\n- * <a href=\"{@docRoot}/../technotes/guides/collections/index.html\">\n- * Java Collections Framework</a>.\n- *\n- * @since 1.5\n- * @author Doug Lea\n- * @param <K> the type of keys maintained by this map\n- * @param <V> the type of mapped values\n- */\n-@SuppressWarnings(\"all\")\n-public class ConcurrentHashMapV8<K,V> extends AbstractMap<K,V>\n-    implements ConcurrentMap<K,V>, Serializable {\n-    private static final long serialVersionUID = 7249069246763182397L;\n-\n-    /**\n-     * An object for traversing and partitioning elements of a source.\n-     * This interface provides a subset of the functionality of JDK8\n-     * java.util.Spliterator.\n-     */\n-    public static interface ConcurrentHashMapSpliterator<T> {\n-        /**\n-         * If possible, returns a new spliterator covering\n-         * approximately one half of the elements, which will not be\n-         * covered by this spliterator. Returns null if cannot be\n-         * split.\n-         */\n-        ConcurrentHashMapSpliterator<T> trySplit();\n-        /**\n-         * Returns an estimate of the number of elements covered by\n-         * this Spliterator.\n-         */\n-        long estimateSize();\n-\n-        /** Applies the action to each untraversed element */\n-        void forEachRemaining(Action<? super T> action);\n-        /** If an element remains, applies the action and returns true. */\n-        boolean tryAdvance(Action<? super T> action);\n-    }\n-\n-    // Sams\n-    /** Interface describing a void action of one argument */\n-    public interface Action<A> { void apply(A a); }\n-    /** Interface describing a void action of two arguments */\n-    public interface BiAction<A,B> { void apply(A a, B b); }\n-    /** Interface describing a function of one argument */\n-    public interface Fun<A,T> { T apply(A a); }\n-    /** Interface describing a function of two arguments */\n-    public interface BiFun<A,B,T> { T apply(A a, B b); }\n-    /** Interface describing a function mapping its argument to a double */\n-    public interface ObjectToDouble<A> { double apply(A a); }\n-    /** Interface describing a function mapping its argument to a long */\n-    public interface ObjectToLong<A> { long apply(A a); }\n-    /** Interface describing a function mapping its argument to an int */\n-    public interface ObjectToInt<A> {int apply(A a); }\n-    /** Interface describing a function mapping two arguments to a double */\n-    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }\n-    /** Interface describing a function mapping two arguments to a long */\n-    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }\n-    /** Interface describing a function mapping two arguments to an int */\n-    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }\n-    /** Interface describing a function mapping two doubles to a double */\n-    public interface DoubleByDoubleToDouble { double apply(double a, double b); }\n-    /** Interface describing a function mapping two longs to a long */\n-    public interface LongByLongToLong { long apply(long a, long b); }\n-    /** Interface describing a function mapping two ints to an int */\n-    public interface IntByIntToInt { int apply(int a, int b); }\n-\n-    /*\n-     * Overview:\n-     *\n-     * The primary design goal of this hash table is to maintain\n-     * concurrent readability (typically method get(), but also\n-     * iterators and related methods) while minimizing update\n-     * contention. Secondary goals are to keep space consumption about\n-     * the same or better than java.util.HashMap, and to support high\n-     * initial insertion rates on an empty table by many threads.\n-     *\n-     * This map usually acts as a binned (bucketed) hash table.  Each\n-     * key-value mapping is held in a Node.  Most nodes are instances\n-     * of the basic Node class with hash, key, value, and next\n-     * fields. However, various subclasses exist: TreeNodes are\n-     * arranged in balanced trees, not lists.  TreeBins hold the roots\n-     * of sets of TreeNodes. ForwardingNodes are placed at the heads\n-     * of bins during resizing. ReservationNodes are used as\n-     * placeholders while establishing values in computeIfAbsent and\n-     * related methods.  The types TreeBin, ForwardingNode, and\n-     * ReservationNode do not hold normal user keys, values, or\n-     * hashes, and are readily distinguishable during search etc\n-     * because they have negative hash fields and null key and value\n-     * fields. (These special nodes are either uncommon or transient,\n-     * so the impact of carrying around some unused fields is\n-     * insignificant.)\n-     *\n-     * The table is lazily initialized to a power-of-two size upon the\n-     * first insertion.  Each bin in the table normally contains a\n-     * list of Nodes (most often, the list has only zero or one Node).\n-     * Table accesses require volatile/atomic reads, writes, and\n-     * CASes.  Because there is no other way to arrange this without\n-     * adding further indirections, we use intrinsics\n-     * (sun.misc.Unsafe) operations.\n-     *\n-     * We use the top (sign) bit of Node hash fields for control\n-     * purposes -- it is available anyway because of addressing\n-     * constraints.  Nodes with negative hash fields are specially\n-     * handled or ignored in map methods.\n-     *\n-     * Insertion (via put or its variants) of the first node in an\n-     * empty bin is performed by just CASing it to the bin.  This is\n-     * by far the most common case for put operations under most\n-     * key/hash distributions.  Other update operations (insert,\n-     * delete, and replace) require locks.  We do not want to waste\n-     * the space required to associate a distinct lock object with\n-     * each bin, so instead use the first node of a bin list itself as\n-     * a lock. Locking support for these locks relies on builtin\n-     * \"synchronized\" monitors.\n-     *\n-     * Using the first node of a list as a lock does not by itself\n-     * suffice though: When a node is locked, any update must first\n-     * validate that it is still the first node after locking it, and\n-     * retry if not. Because new nodes are always appended to lists,\n-     * once a node is first in a bin, it remains first until deleted\n-     * or the bin becomes invalidated (upon resizing).\n-     *\n-     * The main disadvantage of per-bin locks is that other update\n-     * operations on other nodes in a bin list protected by the same\n-     * lock can stall, for example when user equals() or mapping\n-     * functions take a long time.  However, statistically, under\n-     * random hash codes, this is not a common problem.  Ideally, the\n-     * frequency of nodes in bins follows a Poisson distribution\n-     * (http://en.wikipedia.org/wiki/Poisson_distribution) with a\n-     * parameter of about 0.5 on average, given the resizing threshold\n-     * of 0.75, although with a large variance because of resizing\n-     * granularity. Ignoring variance, the expected occurrences of\n-     * list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)). The\n-     * first values are:\n-     *\n-     * 0:    0.60653066\n-     * 1:    0.30326533\n-     * 2:    0.07581633\n-     * 3:    0.01263606\n-     * 4:    0.00157952\n-     * 5:    0.00015795\n-     * 6:    0.00001316\n-     * 7:    0.00000094\n-     * 8:    0.00000006\n-     * more: less than 1 in ten million\n-     *\n-     * Lock contention probability for two threads accessing distinct\n-     * elements is roughly 1 / (8 * #elements) under random hashes.\n-     *\n-     * Actual hash code distributions encountered in practice\n-     * sometimes deviate significantly from uniform randomness.  This\n-     * includes the case when N > (1<<30), so some keys MUST collide.\n-     * Similarly for dumb or hostile usages in which multiple keys are\n-     * designed to have identical hash codes or ones that differs only\n-     * in masked-out high bits. So we use a secondary strategy that\n-     * applies when the number of nodes in a bin exceeds a\n-     * threshold. These TreeBins use a balanced tree to hold nodes (a\n-     * specialized form of red-black trees), bounding search time to\n-     * O(log N).  Each search step in a TreeBin is at least twice as\n-     * slow as in a regular list, but given that N cannot exceed\n-     * (1<<64) (before running out of addresses) this bounds search\n-     * steps, lock hold times, etc, to reasonable constants (roughly\n-     * 100 nodes inspected per operation worst case) so long as keys\n-     * are Comparable (which is very common -- String, Long, etc).\n-     * TreeBin nodes (TreeNodes) also maintain the same \"next\"\n-     * traversal pointers as regular nodes, so can be traversed in\n-     * iterators in the same way.\n-     *\n-     * The table is resized when occupancy exceeds a percentage\n-     * threshold (nominally, 0.75, but see below).  Any thread\n-     * noticing an overfull bin may assist in resizing after the\n-     * initiating thread allocates and sets up the replacement\n-     * array. However, rather than stalling, these other threads may\n-     * proceed with insertions etc.  The use of TreeBins shields us\n-     * from the worst case effects of overfilling while resizes are in\n-     * progress.  Resizing proceeds by transferring bins, one by one,\n-     * from the table to the next table. To enable concurrency, the\n-     * next table must be (incrementally) prefilled with place-holders\n-     * serving as reverse forwarders to the old table.  Because we are\n-     * using power-of-two expansion, the elements from each bin must\n-     * either stay at same index, or move with a power of two\n-     * offset. We eliminate unnecessary node creation by catching\n-     * cases where old nodes can be reused because their next fields\n-     * won't change.  On average, only about one-sixth of them need\n-     * cloning when a table doubles. The nodes they replace will be\n-     * garbage collectable as soon as they are no longer referenced by\n-     * any reader thread that may be in the midst of concurrently\n-     * traversing table.  Upon transfer, the old table bin contains\n-     * only a special forwarding node (with hash field \"MOVED\") that\n-     * contains the next table as its key. On encountering a\n-     * forwarding node, access and update operations restart, using\n-     * the new table.\n-     *\n-     * Each bin transfer requires its bin lock, which can stall\n-     * waiting for locks while resizing. However, because other\n-     * threads can join in and help resize rather than contend for\n-     * locks, average aggregate waits become shorter as resizing\n-     * progresses.  The transfer operation must also ensure that all\n-     * accessible bins in both the old and new table are usable by any\n-     * traversal.  This is arranged by proceeding from the last bin\n-     * (table.length - 1) up towards the first.  Upon seeing a\n-     * forwarding node, traversals (see class Traverser) arrange to\n-     * move to the new table without revisiting nodes.  However, to\n-     * ensure that no intervening nodes are skipped, bin splitting can\n-     * only begin after the associated reverse-forwarders are in\n-     * place.\n-     *\n-     * The traversal scheme also applies to partial traversals of\n-     * ranges of bins (via an alternate Traverser constructor)\n-     * to support partitioned aggregate operations.  Also, read-only\n-     * operations give up if ever forwarded to a null table, which\n-     * provides support for shutdown-style clearing, which is also not\n-     * currently implemented.\n-     *\n-     * Lazy table initialization minimizes footprint until first use,\n-     * and also avoids resizings when the first operation is from a\n-     * putAll, constructor with map argument, or deserialization.\n-     * These cases attempt to override the initial capacity settings,\n-     * but harmlessly fail to take effect in cases of races.\n-     *\n-     * The element count is maintained using a specialization of\n-     * LongAdder. We need to incorporate a specialization rather than\n-     * just use a LongAdder in order to access implicit\n-     * contention-sensing that leads to creation of multiple\n-     * CounterCells.  The counter mechanics avoid contention on\n-     * updates but can encounter cache thrashing if read too\n-     * frequently during concurrent access. To avoid reading so often,\n-     * resizing under contention is attempted only upon adding to a\n-     * bin already holding two or more nodes. Under uniform hash\n-     * distributions, the probability of this occurring at threshold\n-     * is around 13%, meaning that only about 1 in 8 puts check\n-     * threshold (and after resizing, many fewer do so).\n-     *\n-     * TreeBins use a special form of comparison for search and\n-     * related operations (which is the main reason we cannot use\n-     * existing collections such as TreeMaps). TreeBins contain\n-     * Comparable elements, but may contain others, as well as\n-     * elements that are Comparable but not necessarily Comparable for\n-     * the same T, so we cannot invoke compareTo among them. To handle\n-     * this, the tree is ordered primarily by hash value, then by\n-     * Comparable.compareTo order if applicable.  On lookup at a node,\n-     * if elements are not comparable or compare as 0 then both left\n-     * and right children may need to be searched in the case of tied\n-     * hash values. (This corresponds to the full list search that\n-     * would be necessary if all elements were non-Comparable and had\n-     * tied hashes.) On insertion, to keep a total ordering (or as\n-     * close as is required here) across rebalancings, we compare\n-     * classes and identityHashCodes as tie-breakers. The red-black\n-     * balancing code is updated from pre-jdk-collections\n-     * (http://gee.cs.oswego.edu/dl/classes/collections/RBCell.java)\n-     * based in turn on Cormen, Leiserson, and Rivest \"Introduction to\n-     * Algorithms\" (CLR).\n-     *\n-     * TreeBins also require an additional locking mechanism.  While\n-     * list traversal is always possible by readers even during\n-     * updates, tree traversal is not, mainly because of tree-rotations\n-     * that may change the root node and/or its linkages.  TreeBins\n-     * include a simple read-write lock mechanism parasitic on the\n-     * main bin-synchronization strategy: Structural adjustments\n-     * associated with an insertion or removal are already bin-locked\n-     * (and so cannot conflict with other writers) but must wait for\n-     * ongoing readers to finish. Since there can be only one such\n-     * waiter, we use a simple scheme using a single \"waiter\" field to\n-     * block writers.  However, readers need never block.  If the root\n-     * lock is held, they proceed along the slow traversal path (via\n-     * next-pointers) until the lock becomes available or the list is\n-     * exhausted, whichever comes first. These cases are not fast, but\n-     * maximize aggregate expected throughput.\n-     *\n-     * Maintaining API and serialization compatibility with previous\n-     * versions of this class introduces several oddities. Mainly: We\n-     * leave untouched but unused constructor arguments refering to\n-     * concurrencyLevel. We accept a loadFactor constructor argument,\n-     * but apply it only to initial table capacity (which is the only\n-     * time that we can guarantee to honor it.) We also declare an\n-     * unused \"Segment\" class that is instantiated in minimal form\n-     * only when serializing.\n-     *\n-     * Also, solely for compatibility with previous versions of this\n-     * class, it extends AbstractMap, even though all of its methods\n-     * are overridden, so it is just useless baggage.\n-     *\n-     * This file is organized to make things a little easier to follow\n-     * while reading than they might otherwise: First the main static\n-     * declarations and utilities, then fields, then main public\n-     * methods (with a few factorings of multiple public methods into\n-     * internal ones), then sizing methods, trees, traversers, and\n-     * bulk operations.\n-     */\n-\n-    /* ---------------- Constants -------------- */\n-\n-    /**\n-     * The largest possible table capacity.  This value must be\n-     * exactly 1<<30 to stay within Java array allocation and indexing\n-     * bounds for power of two table sizes, and is further required\n-     * because the top two bits of 32bit hash fields are used for\n-     * control purposes.\n-     */\n-    private static final int MAXIMUM_CAPACITY = 1 << 30;\n-\n-    /**\n-     * The default initial table capacity.  Must be a power of 2\n-     * (i.e., at least 1) and at most MAXIMUM_CAPACITY.\n-     */\n-    private static final int DEFAULT_CAPACITY = 16;\n-\n-    /**\n-     * The largest possible (non-power of two) array size.\n-     * Needed by toArray and related methods.\n-     */\n-    static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n-\n-    /**\n-     * The default concurrency level for this table. Unused but\n-     * defined for compatibility with previous versions of this class.\n-     */\n-    private static final int DEFAULT_CONCURRENCY_LEVEL = 16;\n-\n-    /**\n-     * The load factor for this table. Overrides of this value in\n-     * constructors affect only the initial table capacity.  The\n-     * actual floating point value isn't normally used -- it is\n-     * simpler to use expressions such as {@code n - (n >>> 2)} for\n-     * the associated resizing threshold.\n-     */\n-    private static final float LOAD_FACTOR = 0.75f;\n-\n-    /**\n-     * The bin count threshold for using a tree rather than list for a\n-     * bin.  Bins are converted to trees when adding an element to a\n-     * bin with at least this many nodes. The value must be greater\n-     * than 2, and should be at least 8 to mesh with assumptions in\n-     * tree removal about conversion back to plain bins upon\n-     * shrinkage.\n-     */\n-    static final int TREEIFY_THRESHOLD = 8;\n-\n-    /**\n-     * The bin count threshold for untreeifying a (split) bin during a\n-     * resize operation. Should be less than TREEIFY_THRESHOLD, and at\n-     * most 6 to mesh with shrinkage detection under removal.\n-     */\n-    static final int UNTREEIFY_THRESHOLD = 6;\n-\n-    /**\n-     * The smallest table capacity for which bins may be treeified.\n-     * (Otherwise the table is resized if too many nodes in a bin.)\n-     * The value should be at least 4 * TREEIFY_THRESHOLD to avoid\n-     * conflicts between resizing and treeification thresholds.\n-     */\n-    static final int MIN_TREEIFY_CAPACITY = 64;\n-\n-    /**\n-     * Minimum number of rebinnings per transfer step. Ranges are\n-     * subdivided to allow multiple resizer threads.  This value\n-     * serves as a lower bound to avoid resizers encountering\n-     * excessive memory contention.  The value should be at least\n-     * DEFAULT_CAPACITY.\n-     */\n-    private static final int MIN_TRANSFER_STRIDE = 16;\n-\n-    /*\n-     * Encodings for Node hash fields. See above for explanation.\n-     */\n-    static final int MOVED     = -1; // hash for forwarding nodes\n-    static final int TREEBIN   = -2; // hash for roots of trees\n-    static final int RESERVED  = -3; // hash for transient reservations\n-    static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash\n-\n-    /** Number of CPUS, to place bounds on some sizings */\n-    static final int NCPU = Runtime.getRuntime().availableProcessors();\n-\n-    /** For serialization compatibility. */\n-    private static final ObjectStreamField[] serialPersistentFields = {\n-        new ObjectStreamField(\"segments\", Segment[].class),\n-        new ObjectStreamField(\"segmentMask\", Integer.TYPE),\n-        new ObjectStreamField(\"segmentShift\", Integer.TYPE)\n-    };\n-\n-    /* ---------------- Nodes -------------- */\n-\n-    /**\n-     * Key-value entry.  This class is never exported out as a\n-     * user-mutable Map.Entry (i.e., one supporting setValue; see\n-     * MapEntry below), but can be used for read-only traversals used\n-     * in bulk tasks.  Subclasses of Node with a negative hash field\n-     * are special, and contain null keys and values (but are never\n-     * exported).  Otherwise, keys and vals are never null.\n-     */\n-    static class Node<K,V> implements Map.Entry<K,V> {\n-        final int hash;\n-        final K key;\n-        volatile V val;\n-        volatile Node<K,V> next;\n-\n-        Node(int hash, K key, V val, Node<K,V> next) {\n-            this.hash = hash;\n-            this.key = key;\n-            this.val = val;\n-            this.next = next;\n-        }\n-\n-        @Override\n-        public final K getKey()       { return this.key; }\n-        @Override\n-        public final V getValue()     { return this.val; }\n-        @Override\n-        public final int hashCode()   { return this.key.hashCode() ^ this.val.hashCode(); }\n-        @Override\n-        public final String toString(){ return this.key + \"=\" + this.val; }\n-        @Override\n-        public final V setValue(V value) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public final boolean equals(Object o) {\n-            Object k, v, u; Map.Entry<?,?> e;\n-            return o instanceof Map.Entry &&\n-                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&\n-                    (v = e.getValue()) != null &&\n-                    (k == this.key || k.equals(this.key)) &&\n-                    (v == (u = this.val) || v.equals(u));\n-        }\n-\n-        /**\n-         * Virtualized support for map.get(); overridden in subclasses.\n-         */\n-        Node<K,V> find(int h, Object k) {\n-            Node<K,V> e = this;\n-            if (k != null) {\n-                do {\n-                    K ek;\n-                    if (e.hash == h &&\n-                        ((ek = e.key) == k || ek != null && k.equals(ek))) {\n-                        return e;\n-                    }\n-                } while ((e = e.next) != null);\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /* ---------------- Static utilities -------------- */\n-\n-    /**\n-     * Spreads (XORs) higher bits of hash to lower and also forces top\n-     * bit to 0. Because the table uses power-of-two masking, sets of\n-     * hashes that vary only in bits above the current mask will\n-     * always collide. (Among known examples are sets of Float keys\n-     * holding consecutive whole numbers in small tables.)  So we\n-     * apply a transform that spreads the impact of higher bits\n-     * downward. There is a tradeoff between speed, utility, and\n-     * quality of bit-spreading. Because many common sets of hashes\n-     * are already reasonably distributed (so don't benefit from\n-     * spreading), and because we use trees to handle large sets of\n-     * collisions in bins, we just XOR some shifted bits in the\n-     * cheapest possible way to reduce systematic lossage, as well as\n-     * to incorporate impact of the highest bits that would otherwise\n-     * never be used in index calculations because of table bounds.\n-     */\n-    static final int spread(int h) {\n-        return (h ^ h >>> 16) & HASH_BITS;\n-    }\n-\n-    /**\n-     * Returns a power of two table size for the given desired capacity.\n-     * See Hackers Delight, sec 3.2\n-     */\n-    private static final int tableSizeFor(int c) {\n-        int n = c - 1;\n-        n |= n >>> 1;\n-        n |= n >>> 2;\n-        n |= n >>> 4;\n-        n |= n >>> 8;\n-        n |= n >>> 16;\n-        return n < 0 ? 1 : n >= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : n + 1;\n-    }\n-\n-    /**\n-     * Returns x's Class if it is of the form \"class C implements\n-     * Comparable<C>\", else null.\n-     */\n-    static Class<?> comparableClassFor(Object x) {\n-        if (x instanceof Comparable) {\n-            Class<?> c; Type[] ts, as; Type t; ParameterizedType p;\n-            if ((c = x.getClass()) == String.class) {\n-                return c;\n-            }\n-            if ((ts = c.getGenericInterfaces()) != null) {\n-                for (int i = 0; i < ts.length; ++i) {\n-                    if ((t = ts[i]) instanceof ParameterizedType &&\n-                        (p = (ParameterizedType)t).getRawType() ==\n-                         Comparable.class &&\n-                        (as = p.getActualTypeArguments()) != null &&\n-                        as.length == 1 && as[0] == c) {\n-                        return c;\n-                    }\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Returns k.compareTo(x) if x matches kc (k's screened comparable\n-     * class), else 0.\n-     */\n-    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) // for cast to Comparable\n-    static int compareComparables(Class<?> kc, Object k, Object x) {\n-        return x == null || x.getClass() != kc ? 0 :\n-                ((Comparable)k).compareTo(x);\n-    }\n-\n-    /* ---------------- Table element access -------------- */\n-\n-    /*\n-     * Volatile access methods are used for table elements as well as\n-     * elements of in-progress next table while resizing.  All uses of\n-     * the tab arguments must be null checked by callers.  All callers\n-     * also paranoically precheck that tab's length is not zero (or an\n-     * equivalent check), thus ensuring that any index argument taking\n-     * the form of a hash value anded with (length - 1) is a valid\n-     * index.  Note that, to be correct wrt arbitrary concurrency\n-     * errors by users, these checks must operate on local variables,\n-     * which accounts for some odd-looking inline assignments below.\n-     * Note that calls to setTabAt always occur within locked regions,\n-     * and so in principle require only release ordering, not need\n-     * full volatile semantics, but are currently coded as volatile\n-     * writes to be conservative.\n-     */\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) {\n-        return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE);\n-    }\n-\n-    static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i,\n-                                        Node<K,V> c, Node<K,V> v) {\n-        return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v);\n-    }\n-\n-    static final <K,V> void setTabAt(Node<K,V>[] tab, int i, Node<K,V> v) {\n-        U.putObjectVolatile(tab, ((long)i << ASHIFT) + ABASE, v);\n-    }\n-\n-    /* ---------------- Fields -------------- */\n-\n-    /**\n-     * The array of bins. Lazily initialized upon first insertion.\n-     * Size is always a power of two. Accessed directly by iterators.\n-     */\n-    transient volatile Node<K,V>[] table;\n-\n-    /**\n-     * The next table to use; non-null only while resizing.\n-     */\n-    private transient volatile Node<K,V>[] nextTable;\n-\n-    /**\n-     * Base counter value, used mainly when there is no contention,\n-     * but also as a fallback during table initialization\n-     * races. Updated via CAS.\n-     */\n-    private transient volatile long baseCount;\n-\n-    /**\n-     * Table initialization and resizing control.  When negative, the\n-     * table is being initialized or resized: -1 for initialization,\n-     * else -(1 + the number of active resizing threads).  Otherwise,\n-     * when table is null, holds the initial table size to use upon\n-     * creation, or 0 for default. After initialization, holds the\n-     * next element count value upon which to resize the table.\n-     */\n-    private transient volatile int sizeCtl;\n-\n-    /**\n-     * The next table index (plus one) to split while resizing.\n-     */\n-    private transient volatile int transferIndex;\n-\n-    /**\n-     * The least available table index to split while resizing.\n-     */\n-    private transient volatile int transferOrigin;\n-\n-    /**\n-     * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.\n-     */\n-    private transient volatile int cellsBusy;\n-\n-    /**\n-     * Table of counter cells. When non-null, size is a power of 2.\n-     */\n-    private transient volatile CounterCell[] counterCells;\n-\n-    // views\n-    private transient KeySetView<K,V> keySet;\n-    private transient ValuesView<K,V> values;\n-    private transient EntrySetView<K,V> entrySet;\n-\n-\n-    /* ---------------- Public operations -------------- */\n-\n-    /**\n-     * Creates a new, empty map with the default initial table size (16).\n-     */\n-    public ConcurrentHashMapV8() {\n-    }\n-\n-    /**\n-     * Creates a new, empty map with an initial table size\n-     * accommodating the specified number of elements without the need\n-     * to dynamically resize.\n-     *\n-     * @param initialCapacity The implementation performs internal\n-     * sizing to accommodate this many elements.\n-     * @throws IllegalArgumentException if the initial capacity of\n-     * elements is negative\n-     */\n-    public ConcurrentHashMapV8(int initialCapacity) {\n-        if (initialCapacity < 0) {\n-            throw new IllegalArgumentException();\n-        }\n-        int cap = initialCapacity >= MAXIMUM_CAPACITY >>> 1 ?\n-                   MAXIMUM_CAPACITY :\n-                   tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1);\n-        this.sizeCtl = cap;\n-    }\n-\n-    /**\n-     * Creates a new map with the same mappings as the given map.\n-     *\n-     * @param m the map\n-     */\n-    public ConcurrentHashMapV8(Map<? extends K, ? extends V> m) {\n-        this.sizeCtl = DEFAULT_CAPACITY;\n-        putAll(m);\n-    }\n-\n-    /**\n-     * Creates a new, empty map with an initial table size based on\n-     * the given number of elements ({@code initialCapacity}) and\n-     * initial table density ({@code loadFactor}).\n-     *\n-     * @param initialCapacity the initial capacity. The implementation\n-     * performs internal sizing to accommodate this many elements,\n-     * given the specified load factor.\n-     * @param loadFactor the load factor (table density) for\n-     * establishing the initial table size\n-     * @throws IllegalArgumentException if the initial capacity of\n-     * elements is negative or the load factor is nonpositive\n-     *\n-     * @since 1.6\n-     */\n-    public ConcurrentHashMapV8(int initialCapacity, float loadFactor) {\n-        this(initialCapacity, loadFactor, 1);\n-    }\n-\n-    /**\n-     * Creates a new, empty map with an initial table size based on\n-     * the given number of elements ({@code initialCapacity}), table\n-     * density ({@code loadFactor}), and number of concurrently\n-     * updating threads ({@code concurrencyLevel}).\n-     *\n-     * @param initialCapacity the initial capacity. The implementation\n-     * performs internal sizing to accommodate this many elements,\n-     * given the specified load factor.\n-     * @param loadFactor the load factor (table density) for\n-     * establishing the initial table size\n-     * @param concurrencyLevel the estimated number of concurrently\n-     * updating threads. The implementation may use this value as\n-     * a sizing hint.\n-     * @throws IllegalArgumentException if the initial capacity is\n-     * negative or the load factor or concurrencyLevel are\n-     * nonpositive\n-     */\n-    public ConcurrentHashMapV8(int initialCapacity,\n-                             float loadFactor, int concurrencyLevel) {\n-        if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0) {\n-            throw new IllegalArgumentException();\n-        }\n-        if (initialCapacity < concurrencyLevel)\n-         {\n-            initialCapacity = concurrencyLevel;   // as estimated threads\n-        }\n-        long size = (long)(1.0 + initialCapacity / loadFactor);\n-        int cap = size >= MAXIMUM_CAPACITY ?\n-            MAXIMUM_CAPACITY : tableSizeFor((int)size);\n-        this.sizeCtl = cap;\n-    }\n-\n-    // Original (since JDK1.2) Map methods\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public int size() {\n-        long n = sumCount();\n-        return n < 0L ? 0 :\n-                n > Integer.MAX_VALUE ? Integer.MAX_VALUE :\n-                (int)n;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public boolean isEmpty() {\n-        return sumCount() <= 0L; // ignore transient negative values\n-    }\n-\n-    /**\n-     * Returns the value to which the specified key is mapped,\n-     * or {@code null} if this map contains no mapping for the key.\n-     *\n-     * <p>More formally, if this map contains a mapping from a key\n-     * {@code k} to a value {@code v} such that {@code key.equals(k)},\n-     * then this method returns {@code v}; otherwise it returns\n-     * {@code null}.  (There can be at most one such mapping.)\n-     *\n-     * @throws NullPointerException if the specified key is null\n-     */\n-    @Override\n-    public V get(Object key) {\n-        Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n-        int h = spread(key.hashCode());\n-        if ((tab = this.table) != null && (n = tab.length) > 0 &&\n-            (e = tabAt(tab, n - 1 & h)) != null) {\n-            if ((eh = e.hash) == h) {\n-                if ((ek = e.key) == key || ek != null && key.equals(ek)) {\n-                    return e.val;\n-                }\n-            }\n-            else if (eh < 0) {\n-                return (p = e.find(h, key)) != null ? p.val : null;\n-            }\n-            while ((e = e.next) != null) {\n-                if (e.hash == h &&\n-                    ((ek = e.key) == key || ek != null && key.equals(ek))) {\n-                    return e.val;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Tests if the specified object is a key in this table.\n-     *\n-     * @param  key possible key\n-     * @return {@code true} if and only if the specified object\n-     *         is a key in this table, as determined by the\n-     *         {@code equals} method; {@code false} otherwise\n-     * @throws NullPointerException if the specified key is null\n-     */\n-    @Override\n-    public boolean containsKey(Object key) {\n-        return get(key) != null;\n-    }\n-\n-    /**\n-     * Returns {@code true} if this map maps one or more keys to the\n-     * specified value. Note: This method may require a full traversal\n-     * of the map, and is much slower than method {@code containsKey}.\n-     *\n-     * @param value value whose presence in this map is to be tested\n-     * @return {@code true} if this map maps one or more keys to the\n-     *         specified value\n-     * @throws NullPointerException if the specified value is null\n-     */\n-    @Override\n-    public boolean containsValue(Object value) {\n-        if (value == null) {\n-            throw new NullPointerException();\n-        }\n-        Node<K,V>[] t;\n-        if ((t = this.table) != null) {\n-            Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n-            for (Node<K,V> p; (p = it.advance()) != null; ) {\n-                V v;\n-                if ((v = p.val) == value || v != null && value.equals(v)) {\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Maps the specified key to the specified value in this table.\n-     * Neither the key nor the value can be null.\n-     *\n-     * <p>The value can be retrieved by calling the {@code get} method\n-     * with a key that is equal to the original key.\n-     *\n-     * @param key key with which the specified value is to be associated\n-     * @param value value to be associated with the specified key\n-     * @return the previous value associated with {@code key}, or\n-     *         {@code null} if there was no mapping for {@code key}\n-     * @throws NullPointerException if the specified key or value is null\n-     */\n-    @Override\n-    public V put(K key, V value) {\n-        return putVal(key, value, false);\n-    }\n-\n-    /** Implementation for put and putIfAbsent */\n-    final V putVal(K key, V value, boolean onlyIfAbsent) {\n-        if (key == null || value == null) {\n-            throw new NullPointerException();\n-        }\n-        int hash = spread(key.hashCode());\n-        int binCount = 0;\n-        for (Node<K,V>[] tab = this.table;;) {\n-            Node<K,V> f; int n, i, fh;\n-            if (tab == null || (n = tab.length) == 0) {\n-                tab = initTable();\n-            } else if ((f = tabAt(tab, i = n - 1 & hash)) == null) {\n-                if (casTabAt(tab, i, null,\n-                             new Node<K,V>(hash, key, value, null)))\n-                 {\n-                    break;                   // no lock when adding to empty bin\n-                }\n-            }\n-            else if ((fh = f.hash) == MOVED) {\n-                tab = helpTransfer(tab, f);\n-            } else {\n-                V oldVal = null;\n-                synchronized (f) {\n-                    if (tabAt(tab, i) == f) {\n-                        if (fh >= 0) {\n-                            binCount = 1;\n-                            for (Node<K,V> e = f;; ++binCount) {\n-                                K ek;\n-                                if (e.hash == hash &&\n-                                    ((ek = e.key) == key ||\n-                                     ek != null && key.equals(ek))) {\n-                                    oldVal = e.val;\n-                                    if (!onlyIfAbsent) {\n-                                        e.val = value;\n-                                    }\n-                                    break;\n-                                }\n-                                Node<K,V> pred = e;\n-                                if ((e = e.next) == null) {\n-                                    pred.next = new Node<K,V>(hash, key,\n-                                                              value, null);\n-                                    break;\n-                                }\n-                            }\n-                        }\n-                        else if (f instanceof TreeBin) {\n-                            Node<K,V> p;\n-                            binCount = 2;\n-                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n-                                                           value)) != null) {\n-                                oldVal = p.val;\n-                                if (!onlyIfAbsent) {\n-                                    p.val = value;\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                if (binCount != 0) {\n-                    if (binCount >= TREEIFY_THRESHOLD) {\n-                        treeifyBin(tab, i);\n-                    }\n-                    if (oldVal != null) {\n-                        return oldVal;\n-                    }\n-                    break;\n-                }\n-            }\n-        }\n-        addCount(1L, binCount);\n-        return null;\n-    }\n-\n-    /**\n-     * Copies all of the mappings from the specified map to this one.\n-     * These mappings replace any mappings that this map had for any of the\n-     * keys currently in the specified map.\n-     *\n-     * @param m mappings to be stored in this map\n-     */\n-    @Override\n-    public void putAll(Map<? extends K, ? extends V> m) {\n-        tryPresize(m.size());\n-        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n-            putVal(e.getKey(), e.getValue(), false);\n-        }\n-    }\n-\n-    /**\n-     * Removes the key (and its corresponding value) from this map.\n-     * This method does nothing if the key is not in the map.\n-     *\n-     * @param  key the key that needs to be removed\n-     * @return the previous value associated with {@code key}, or\n-     *         {@code null} if there was no mapping for {@code key}\n-     * @throws NullPointerException if the specified key is null\n-     */\n-    @Override\n-    public V remove(Object key) {\n-        return replaceNode(key, null, null);\n-    }\n-\n-    /**\n-     * Implementation for the four public remove/replace methods:\n-     * Replaces node value with v, conditional upon match of cv if\n-     * non-null.  If resulting value is null, delete.\n-     */\n-    final V replaceNode(Object key, V value, Object cv) {\n-        int hash = spread(key.hashCode());\n-        for (Node<K,V>[] tab = this.table;;) {\n-            Node<K,V> f; int n, i, fh;\n-            if (tab == null || (n = tab.length) == 0 ||\n-                (f = tabAt(tab, i = n - 1 & hash)) == null) {\n-                break;\n-            } else if ((fh = f.hash) == MOVED) {\n-                tab = helpTransfer(tab, f);\n-            } else {\n-                V oldVal = null;\n-                boolean validated = false;\n-                synchronized (f) {\n-                    if (tabAt(tab, i) == f) {\n-                        if (fh >= 0) {\n-                            validated = true;\n-                            for (Node<K,V> e = f, pred = null;;) {\n-                                K ek;\n-                                if (e.hash == hash &&\n-                                    ((ek = e.key) == key ||\n-                                     ek != null && key.equals(ek))) {\n-                                    V ev = e.val;\n-                                    if (cv == null || cv == ev ||\n-                                        ev != null && cv.equals(ev)) {\n-                                        oldVal = ev;\n-                                        if (value != null) {\n-                                            e.val = value;\n-                                        } else if (pred != null) {\n-                                            pred.next = e.next;\n-                                        } else {\n-                                            setTabAt(tab, i, e.next);\n-                                        }\n-                                    }\n-                                    break;\n-                                }\n-                                pred = e;\n-                                if ((e = e.next) == null) {\n-                                    break;\n-                                }\n-                            }\n-                        }\n-                        else if (f instanceof TreeBin) {\n-                            validated = true;\n-                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n-                            TreeNode<K,V> r, p;\n-                            if ((r = t.root) != null &&\n-                                (p = r.findTreeNode(hash, key, null)) != null) {\n-                                V pv = p.val;\n-                                if (cv == null || cv == pv ||\n-                                    pv != null && cv.equals(pv)) {\n-                                    oldVal = pv;\n-                                    if (value != null) {\n-                                        p.val = value;\n-                                    } else if (t.removeTreeNode(p)) {\n-                                        setTabAt(tab, i, untreeify(t.first));\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                if (validated) {\n-                    if (oldVal != null) {\n-                        if (value == null) {\n-                            addCount(-1L, -1);\n-                        }\n-                        return oldVal;\n-                    }\n-                    break;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Removes all of the mappings from this map.\n-     */\n-    @Override\n-    public void clear() {\n-        long delta = 0L; // negative number of deletions\n-        int i = 0;\n-        Node<K,V>[] tab = this.table;\n-        while (tab != null && i < tab.length) {\n-            int fh;\n-            Node<K,V> f = tabAt(tab, i);\n-            if (f == null) {\n-                ++i;\n-            } else if ((fh = f.hash) == MOVED) {\n-                tab = helpTransfer(tab, f);\n-                i = 0; // restart\n-            }\n-            else {\n-                synchronized (f) {\n-                    if (tabAt(tab, i) == f) {\n-                        Node<K,V> p = fh >= 0 ? f :\n-                                       f instanceof TreeBin ?\n-                                       ((TreeBin<K,V>)f).first : null;\n-                        while (p != null) {\n-                            --delta;\n-                            p = p.next;\n-                        }\n-                        setTabAt(tab, i++, null);\n-                    }\n-                }\n-            }\n-        }\n-        if (delta != 0L) {\n-            addCount(delta, -1);\n-        }\n-    }\n-\n-    /**\n-     * Returns a {@link Set} view of the keys contained in this map.\n-     * The set is backed by the map, so changes to the map are\n-     * reflected in the set, and vice-versa. The set supports element\n-     * removal, which removes the corresponding mapping from this map,\n-     * via the {@code Iterator.remove}, {@code Set.remove},\n-     * {@code removeAll}, {@code retainAll}, and {@code clear}\n-     * operations.  It does not support the {@code add} or\n-     * {@code addAll} operations.\n-     *\n-     * <p>The view's {@code iterator} is a \"weakly consistent\" iterator\n-     * that will never throw {@link ConcurrentModificationException},\n-     * and guarantees to traverse elements as they existed upon\n-     * construction of the iterator, and may (but is not guaranteed to)\n-     * reflect any modifications subsequent to construction.\n-     *\n-     * @return the set view\n-     */\n-    @Override\n-    public KeySetView<K,V> keySet() {\n-        KeySetView<K,V> ks;\n-        return (ks = this.keySet) != null ? ks : (this.keySet = new KeySetView<K,V>(this, null));\n-    }\n-\n-    /**\n-     * Returns a {@link Collection} view of the values contained in this map.\n-     * The collection is backed by the map, so changes to the map are\n-     * reflected in the collection, and vice-versa.  The collection\n-     * supports element removal, which removes the corresponding\n-     * mapping from this map, via the {@code Iterator.remove},\n-     * {@code Collection.remove}, {@code removeAll},\n-     * {@code retainAll}, and {@code clear} operations.  It does not\n-     * support the {@code add} or {@code addAll} operations.\n-     *\n-     * <p>The view's {@code iterator} is a \"weakly consistent\" iterator\n-     * that will never throw {@link ConcurrentModificationException},\n-     * and guarantees to traverse elements as they existed upon\n-     * construction of the iterator, and may (but is not guaranteed to)\n-     * reflect any modifications subsequent to construction.\n-     *\n-     * @return the collection view\n-     */\n-    @Override\n-    public Collection<V> values() {\n-        ValuesView<K,V> vs;\n-        return (vs = this.values) != null ? vs : (this.values = new ValuesView<K,V>(this));\n-    }\n-\n-    /**\n-     * Returns a {@link Set} view of the mappings contained in this map.\n-     * The set is backed by the map, so changes to the map are\n-     * reflected in the set, and vice-versa.  The set supports element\n-     * removal, which removes the corresponding mapping from the map,\n-     * via the {@code Iterator.remove}, {@code Set.remove},\n-     * {@code removeAll}, {@code retainAll}, and {@code clear}\n-     * operations.\n-     *\n-     * <p>The view's {@code iterator} is a \"weakly consistent\" iterator\n-     * that will never throw {@link ConcurrentModificationException},\n-     * and guarantees to traverse elements as they existed upon\n-     * construction of the iterator, and may (but is not guaranteed to)\n-     * reflect any modifications subsequent to construction.\n-     *\n-     * @return the set view\n-     */\n-    @Override\n-    public Set<Map.Entry<K,V>> entrySet() {\n-        EntrySetView<K,V> es;\n-        return (es = this.entrySet) != null ? es : (this.entrySet = new EntrySetView<K,V>(this));\n-    }\n-\n-    /**\n-     * Returns the hash code value for this {@link Map}, i.e.,\n-     * the sum of, for each key-value pair in the map,\n-     * {@code key.hashCode() ^ value.hashCode()}.\n-     *\n-     * @return the hash code value for this map\n-     */\n-    @Override\n-    public int hashCode() {\n-        int h = 0;\n-        Node<K,V>[] t;\n-        if ((t = this.table) != null) {\n-            Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n-            for (Node<K,V> p; (p = it.advance()) != null; ) {\n-                h += p.key.hashCode() ^ p.val.hashCode();\n-            }\n-        }\n-        return h;\n-    }\n-\n-    /**\n-     * Returns a string representation of this map.  The string\n-     * representation consists of a list of key-value mappings (in no\n-     * particular order) enclosed in braces (\"{@code {}}\").  Adjacent\n-     * mappings are separated by the characters {@code \", \"} (comma\n-     * and space).  Each key-value mapping is rendered as the key\n-     * followed by an equals sign (\"{@code =}\") followed by the\n-     * associated value.\n-     *\n-     * @return a string representation of this map\n-     */\n-    @Override\n-    public String toString() {\n-        Node<K,V>[] t;\n-        int f = (t = this.table) == null ? 0 : t.length;\n-        Traverser<K,V> it = new Traverser<K,V>(t, f, 0, f);\n-        StringBuilder sb = new StringBuilder();\n-        sb.append('{');\n-        Node<K,V> p;\n-        if ((p = it.advance()) != null) {\n-            for (;;) {\n-                K k = p.key;\n-                V v = p.val;\n-                sb.append(k == this ? \"(this Map)\" : k);\n-                sb.append('=');\n-                sb.append(v == this ? \"(this Map)\" : v);\n-                if ((p = it.advance()) == null) {\n-                    break;\n-                }\n-                sb.append(',').append(' ');\n-            }\n-        }\n-        return sb.append('}').toString();\n-    }\n-\n-    /**\n-     * Compares the specified object with this map for equality.\n-     * Returns {@code true} if the given object is a map with the same\n-     * mappings as this map.  This operation may return misleading\n-     * results if either map is concurrently modified during execution\n-     * of this method.\n-     *\n-     * @param o object to be compared for equality with this map\n-     * @return {@code true} if the specified object is equal to this map\n-     */\n-    @Override\n-    public boolean equals(Object o) {\n-        if (o != this) {\n-            if (!(o instanceof Map)) {\n-                return false;\n-            }\n-            Map<?,?> m = (Map<?,?>) o;\n-            Node<K,V>[] t;\n-            int f = (t = this.table) == null ? 0 : t.length;\n-            Traverser<K,V> it = new Traverser<K,V>(t, f, 0, f);\n-            for (Node<K,V> p; (p = it.advance()) != null; ) {\n-                V val = p.val;\n-                Object v = m.get(p.key);\n-                if (v == null || v != val && !v.equals(val)) {\n-                    return false;\n-                }\n-            }\n-            for (Map.Entry<?,?> e : m.entrySet()) {\n-                Object mk, mv, v;\n-                if ((mk = e.getKey()) == null ||\n-                    (mv = e.getValue()) == null ||\n-                    (v = get(mk)) == null ||\n-                    mv != v && !mv.equals(v)) {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Stripped-down version of helper class used in previous version,\n-     * declared for the sake of serialization compatibility\n-     */\n-    static class Segment<K,V> extends ReentrantLock implements Serializable {\n-        private static final long serialVersionUID = 2249069246763182397L;\n-        final float loadFactor;\n-        Segment(float lf) { this.loadFactor = lf; }\n-    }\n-\n-    /**\n-     * Saves the state of the {@code ConcurrentHashMapV8} instance to a\n-     * stream (i.e., serializes it).\n-     * @param s the stream\n-     * @throws java.io.IOException if an I/O error occurs\n-     * @serialData\n-     * the key (Object) and value (Object)\n-     * for each key-value mapping, followed by a null pair.\n-     * The key-value mappings are emitted in no particular order.\n-     */\n-    private void writeObject(java.io.ObjectOutputStream s)\n-        throws java.io.IOException {\n-        // For serialization compatibility\n-        // Emulate segment calculation from previous version of this class\n-        int sshift = 0;\n-        int ssize = 1;\n-        while (ssize < DEFAULT_CONCURRENCY_LEVEL) {\n-            ++sshift;\n-            ssize <<= 1;\n-        }\n-        int segmentShift = 32 - sshift;\n-        int segmentMask = ssize - 1;\n-        @SuppressWarnings(\"unchecked\") Segment<K,V>[] segments = (Segment<K,V>[])\n-            new Segment<?,?>[DEFAULT_CONCURRENCY_LEVEL];\n-        for (int i = 0; i < segments.length; ++i) {\n-            segments[i] = new Segment<K,V>(LOAD_FACTOR);\n-        }\n-        s.putFields().put(\"segments\", segments);\n-        s.putFields().put(\"segmentShift\", segmentShift);\n-        s.putFields().put(\"segmentMask\", segmentMask);\n-        s.writeFields();\n-\n-        Node<K,V>[] t;\n-        if ((t = this.table) != null) {\n-            Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n-            for (Node<K,V> p; (p = it.advance()) != null; ) {\n-                s.writeObject(p.key);\n-                s.writeObject(p.val);\n-            }\n-        }\n-        s.writeObject(null);\n-        s.writeObject(null);\n-        segments = null; // throw away\n-    }\n-\n-    /**\n-     * Reconstitutes the instance from a stream (that is, deserializes it).\n-     * @param s the stream\n-     * @throws ClassNotFoundException if the class of a serialized object\n-     *         could not be found\n-     * @throws java.io.IOException if an I/O error occurs\n-     */\n-    private void readObject(java.io.ObjectInputStream s)\n-        throws java.io.IOException, ClassNotFoundException {\n-        /*\n-         * To improve performance in typical cases, we create nodes\n-         * while reading, then place in table once size is known.\n-         * However, we must also validate uniqueness and deal with\n-         * overpopulated bins while doing so, which requires\n-         * specialized versions of putVal mechanics.\n-         */\n-        this.sizeCtl = -1; // force exclusion for table construction\n-        s.defaultReadObject();\n-        long size = 0L;\n-        Node<K,V> p = null;\n-        for (;;) {\n-            @SuppressWarnings(\"unchecked\") K k = (K) s.readObject();\n-            @SuppressWarnings(\"unchecked\") V v = (V) s.readObject();\n-            if (k != null && v != null) {\n-                p = new Node<K,V>(spread(k.hashCode()), k, v, p);\n-                ++size;\n-            } else {\n-                break;\n-            }\n-        }\n-        if (size == 0L) {\n-            this.sizeCtl = 0;\n-        } else {\n-            int n;\n-            if (size >= MAXIMUM_CAPACITY >>> 1) {\n-                n = MAXIMUM_CAPACITY;\n-            } else {\n-                int sz = (int)size;\n-                n = tableSizeFor(sz + (sz >>> 1) + 1);\n-            }\n-            @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n-                Node<K,V>[] tab = new Node[n];\n-            int mask = n - 1;\n-            long added = 0L;\n-            while (p != null) {\n-                boolean insertAtFront;\n-                Node<K,V> next = p.next, first;\n-                int h = p.hash, j = h & mask;\n-                if ((first = tabAt(tab, j)) == null) {\n-                    insertAtFront = true;\n-                } else {\n-                    K k = p.key;\n-                    if (first.hash < 0) {\n-                        TreeBin<K,V> t = (TreeBin<K,V>)first;\n-                        if (t.putTreeVal(h, k, p.val) == null) {\n-                            ++added;\n-                        }\n-                        insertAtFront = false;\n-                    }\n-                    else {\n-                        int binCount = 0;\n-                        insertAtFront = true;\n-                        Node<K,V> q; K qk;\n-                        for (q = first; q != null; q = q.next) {\n-                            if (q.hash == h &&\n-                                ((qk = q.key) == k ||\n-                                 qk != null && k.equals(qk))) {\n-                                insertAtFront = false;\n-                                break;\n-                            }\n-                            ++binCount;\n-                        }\n-                        if (insertAtFront && binCount >= TREEIFY_THRESHOLD) {\n-                            insertAtFront = false;\n-                            ++added;\n-                            p.next = first;\n-                            TreeNode<K,V> hd = null, tl = null;\n-                            for (q = p; q != null; q = q.next) {\n-                                TreeNode<K,V> t = new TreeNode<K,V>\n-                                    (q.hash, q.key, q.val, null, null);\n-                                if ((t.prev = tl) == null) {\n-                                    hd = t;\n-                                } else {\n-                                    tl.next = t;\n-                                }\n-                                tl = t;\n-                            }\n-                            setTabAt(tab, j, new TreeBin<K,V>(hd));\n-                        }\n-                    }\n-                }\n-                if (insertAtFront) {\n-                    ++added;\n-                    p.next = first;\n-                    setTabAt(tab, j, p);\n-                }\n-                p = next;\n-            }\n-            this.table = tab;\n-            this.sizeCtl = n - (n >>> 2);\n-            this.baseCount = added;\n-        }\n-    }\n-\n-    // ConcurrentMap methods\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @return the previous value associated with the specified key,\n-     *         or {@code null} if there was no mapping for the key\n-     * @throws NullPointerException if the specified key or value is null\n-     */\n-    @Override\n-    public V putIfAbsent(K key, V value) {\n-        return putVal(key, value, true);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws NullPointerException if the specified key is null\n-     */\n-    @Override\n-    public boolean remove(Object key, Object value) {\n-        if (key == null) {\n-            throw new NullPointerException();\n-        }\n-        return value != null && replaceNode(key, null, value) != null;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws NullPointerException if any of the arguments are null\n-     */\n-    @Override\n-    public boolean replace(K key, V oldValue, V newValue) {\n-        if (key == null || oldValue == null || newValue == null) {\n-            throw new NullPointerException();\n-        }\n-        return replaceNode(key, newValue, oldValue) != null;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @return the previous value associated with the specified key,\n-     *         or {@code null} if there was no mapping for the key\n-     * @throws NullPointerException if the specified key or value is null\n-     */\n-    @Override\n-    public V replace(K key, V value) {\n-        if (key == null || value == null) {\n-            throw new NullPointerException();\n-        }\n-        return replaceNode(key, value, null);\n-    }\n-\n-    // Overrides of JDK8+ Map extension method defaults\n-\n-    /**\n-     * Returns the value to which the specified key is mapped, or the\n-     * given default value if this map contains no mapping for the\n-     * key.\n-     *\n-     * @param key the key whose associated value is to be returned\n-     * @param defaultValue the value to return if this map contains\n-     * no mapping for the given key\n-     * @return the mapping for the key, if present; else the default value\n-     * @throws NullPointerException if the specified key is null\n-     */\n-    public V getOrDefault(Object key, V defaultValue) {\n-        V v;\n-        return (v = get(key)) == null ? defaultValue : v;\n-    }\n-\n-    public void forEach(BiAction<? super K, ? super V> action) {\n-        if (action == null) {\n-            throw new NullPointerException();\n-        }\n-        Node<K,V>[] t;\n-        if ((t = this.table) != null) {\n-            Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n-            for (Node<K,V> p; (p = it.advance()) != null; ) {\n-                action.apply(p.key, p.val);\n-            }\n-        }\n-    }\n-\n-    public void replaceAll(BiFun<? super K, ? super V, ? extends V> function) {\n-        if (function == null) {\n-            throw new NullPointerException();\n-        }\n-        Node<K,V>[] t;\n-        if ((t = this.table) != null) {\n-            Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n-            for (Node<K,V> p; (p = it.advance()) != null; ) {\n-                V oldValue = p.val;\n-                for (K key = p.key;;) {\n-                    V newValue = function.apply(key, oldValue);\n-                    if (newValue == null) {\n-                        throw new NullPointerException();\n-                    }\n-                    if (replaceNode(key, newValue, oldValue) != null ||\n-                        (oldValue = get(key)) == null) {\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * If the specified key is not already associated with a value,\n-     * attempts to compute its value using the given mapping function\n-     * and enters it into this map unless {@code null}.  The entire\n-     * method invocation is performed atomically, so the function is\n-     * applied at most once per key.  Some attempted update operations\n-     * on this map by other threads may be blocked while computation\n-     * is in progress, so the computation should be short and simple,\n-     * and must not attempt to update any other mappings of this map.\n-     *\n-     * @param key key with which the specified value is to be associated\n-     * @param mappingFunction the function to compute a value\n-     * @return the current (existing or computed) value associated with\n-     *         the specified key, or null if the computed value is null\n-     * @throws NullPointerException if the specified key or mappingFunction\n-     *         is null\n-     * @throws IllegalStateException if the computation detectably\n-     *         attempts a recursive update to this map that would\n-     *         otherwise never complete\n-     * @throws RuntimeException or Error if the mappingFunction does so,\n-     *         in which case the mapping is left unestablished\n-     */\n-    public V computeIfAbsent(K key, Fun<? super K, ? extends V> mappingFunction) {\n-        if (key == null || mappingFunction == null) {\n-            throw new NullPointerException();\n-        }\n-        int h = spread(key.hashCode());\n-        V val = null;\n-        int binCount = 0;\n-        for (Node<K,V>[] tab = this.table;;) {\n-            Node<K,V> f; int n, i, fh;\n-            if (tab == null || (n = tab.length) == 0) {\n-                tab = initTable();\n-            } else if ((f = tabAt(tab, i = n - 1 & h)) == null) {\n-                Node<K,V> r = new ReservationNode<K,V>();\n-                synchronized (r) {\n-                    if (casTabAt(tab, i, null, r)) {\n-                        binCount = 1;\n-                        Node<K,V> node = null;\n-                        try {\n-                            if ((val = mappingFunction.apply(key)) != null) {\n-                                node = new Node<K,V>(h, key, val, null);\n-                            }\n-                        } finally {\n-                            setTabAt(tab, i, node);\n-                        }\n-                    }\n-                }\n-                if (binCount != 0) {\n-                    break;\n-                }\n-            }\n-            else if ((fh = f.hash) == MOVED) {\n-                tab = helpTransfer(tab, f);\n-            } else {\n-                boolean added = false;\n-                synchronized (f) {\n-                    if (tabAt(tab, i) == f) {\n-                        if (fh >= 0) {\n-                            binCount = 1;\n-                            for (Node<K,V> e = f;; ++binCount) {\n-                                K ek; V ev;\n-                                if (e.hash == h &&\n-                                    ((ek = e.key) == key ||\n-                                     ek != null && key.equals(ek))) {\n-                                    val = e.val;\n-                                    break;\n-                                }\n-                                Node<K,V> pred = e;\n-                                if ((e = e.next) == null) {\n-                                    if ((val = mappingFunction.apply(key)) != null) {\n-                                        added = true;\n-                                        pred.next = new Node<K,V>(h, key, val, null);\n-                                    }\n-                                    break;\n-                                }\n-                            }\n-                        }\n-                        else if (f instanceof TreeBin) {\n-                            binCount = 2;\n-                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n-                            TreeNode<K,V> r, p;\n-                            if ((r = t.root) != null &&\n-                                (p = r.findTreeNode(h, key, null)) != null) {\n-                                val = p.val;\n-                            } else if ((val = mappingFunction.apply(key)) != null) {\n-                                added = true;\n-                                t.putTreeVal(h, key, val);\n-                            }\n-                        }\n-                    }\n-                }\n-                if (binCount != 0) {\n-                    if (binCount >= TREEIFY_THRESHOLD) {\n-                        treeifyBin(tab, i);\n-                    }\n-                    if (!added) {\n-                        return val;\n-                    }\n-                    break;\n-                }\n-            }\n-        }\n-        if (val != null) {\n-            addCount(1L, binCount);\n-        }\n-        return val;\n-    }\n-\n-    /**\n-     * If the value for the specified key is present, attempts to\n-     * compute a new mapping given the key and its current mapped\n-     * value.  The entire method invocation is performed atomically.\n-     * Some attempted update operations on this map by other threads\n-     * may be blocked while computation is in progress, so the\n-     * computation should be short and simple, and must not attempt to\n-     * update any other mappings of this map.\n-     *\n-     * @param key key with which a value may be associated\n-     * @param remappingFunction the function to compute a value\n-     * @return the new value associated with the specified key, or null if none\n-     * @throws NullPointerException if the specified key or remappingFunction\n-     *         is null\n-     * @throws IllegalStateException if the computation detectably\n-     *         attempts a recursive update to this map that would\n-     *         otherwise never complete\n-     * @throws RuntimeException or Error if the remappingFunction does so,\n-     *         in which case the mapping is unchanged\n-     */\n-    public V computeIfPresent(K key, BiFun<? super K, ? super V, ? extends V> remappingFunction) {\n-        if (key == null || remappingFunction == null) {\n-            throw new NullPointerException();\n-        }\n-        int h = spread(key.hashCode());\n-        V val = null;\n-        int delta = 0;\n-        int binCount = 0;\n-        for (Node<K,V>[] tab = this.table;;) {\n-            Node<K,V> f; int n, i, fh;\n-            if (tab == null || (n = tab.length) == 0) {\n-                tab = initTable();\n-            } else if ((f = tabAt(tab, i = n - 1 & h)) == null) {\n-                break;\n-            } else if ((fh = f.hash) == MOVED) {\n-                tab = helpTransfer(tab, f);\n-            } else {\n-                synchronized (f) {\n-                    if (tabAt(tab, i) == f) {\n-                        if (fh >= 0) {\n-                            binCount = 1;\n-                            for (Node<K,V> e = f, pred = null;; ++binCount) {\n-                                K ek;\n-                                if (e.hash == h &&\n-                                    ((ek = e.key) == key ||\n-                                     ek != null && key.equals(ek))) {\n-                                    val = remappingFunction.apply(key, e.val);\n-                                    if (val != null) {\n-                                        e.val = val;\n-                                    } else {\n-                                        delta = -1;\n-                                        Node<K,V> en = e.next;\n-                                        if (pred != null) {\n-                                            pred.next = en;\n-                                        } else {\n-                                            setTabAt(tab, i, en);\n-                                        }\n-                                    }\n-                                    break;\n-                                }\n-                                pred = e;\n-                                if ((e = e.next) == null) {\n-                                    break;\n-                                }\n-                            }\n-                        }\n-                        else if (f instanceof TreeBin) {\n-                            binCount = 2;\n-                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n-                            TreeNode<K,V> r, p;\n-                            if ((r = t.root) != null &&\n-                                (p = r.findTreeNode(h, key, null)) != null) {\n-                                val = remappingFunction.apply(key, p.val);\n-                                if (val != null) {\n-                                    p.val = val;\n-                                } else {\n-                                    delta = -1;\n-                                    if (t.removeTreeNode(p)) {\n-                                        setTabAt(tab, i, untreeify(t.first));\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                if (binCount != 0) {\n-                    break;\n-                }\n-            }\n-        }\n-        if (delta != 0) {\n-            addCount(delta, binCount);\n-        }\n-        return val;\n-    }\n-\n-    /**\n-     * Attempts to compute a mapping for the specified key and its\n-     * current mapped value (or {@code null} if there is no current\n-     * mapping). The entire method invocation is performed atomically.\n-     * Some attempted update operations on this map by other threads\n-     * may be blocked while computation is in progress, so the\n-     * computation should be short and simple, and must not attempt to\n-     * update any other mappings of this Map.\n-     *\n-     * @param key key with which the specified value is to be associated\n-     * @param remappingFunction the function to compute a value\n-     * @return the new value associated with the specified key, or null if none\n-     * @throws NullPointerException if the specified key or remappingFunction\n-     *         is null\n-     * @throws IllegalStateException if the computation detectably\n-     *         attempts a recursive update to this map that would\n-     *         otherwise never complete\n-     * @throws RuntimeException or Error if the remappingFunction does so,\n-     *         in which case the mapping is unchanged\n-     */\n-    public V compute(K key,\n-                     BiFun<? super K, ? super V, ? extends V> remappingFunction) {\n-        if (key == null || remappingFunction == null) {\n-            throw new NullPointerException();\n-        }\n-        int h = spread(key.hashCode());\n-        V val = null;\n-        int delta = 0;\n-        int binCount = 0;\n-        for (Node<K,V>[] tab = this.table;;) {\n-            Node<K,V> f; int n, i, fh;\n-            if (tab == null || (n = tab.length) == 0) {\n-                tab = initTable();\n-            } else if ((f = tabAt(tab, i = n - 1 & h)) == null) {\n-                Node<K,V> r = new ReservationNode<K,V>();\n-                synchronized (r) {\n-                    if (casTabAt(tab, i, null, r)) {\n-                        binCount = 1;\n-                        Node<K,V> node = null;\n-                        try {\n-                            if ((val = remappingFunction.apply(key, null)) != null) {\n-                                delta = 1;\n-                                node = new Node<K,V>(h, key, val, null);\n-                            }\n-                        } finally {\n-                            setTabAt(tab, i, node);\n-                        }\n-                    }\n-                }\n-                if (binCount != 0) {\n-                    break;\n-                }\n-            }\n-            else if ((fh = f.hash) == MOVED) {\n-                tab = helpTransfer(tab, f);\n-            } else {\n-                synchronized (f) {\n-                    if (tabAt(tab, i) == f) {\n-                        if (fh >= 0) {\n-                            binCount = 1;\n-                            for (Node<K,V> e = f, pred = null;; ++binCount) {\n-                                K ek;\n-                                if (e.hash == h &&\n-                                    ((ek = e.key) == key ||\n-                                     ek != null && key.equals(ek))) {\n-                                    val = remappingFunction.apply(key, e.val);\n-                                    if (val != null) {\n-                                        e.val = val;\n-                                    } else {\n-                                        delta = -1;\n-                                        Node<K,V> en = e.next;\n-                                        if (pred != null) {\n-                                            pred.next = en;\n-                                        } else {\n-                                            setTabAt(tab, i, en);\n-                                        }\n-                                    }\n-                                    break;\n-                                }\n-                                pred = e;\n-                                if ((e = e.next) == null) {\n-                                    val = remappingFunction.apply(key, null);\n-                                    if (val != null) {\n-                                        delta = 1;\n-                                        pred.next =\n-                                            new Node<K,V>(h, key, val, null);\n-                                    }\n-                                    break;\n-                                }\n-                            }\n-                        }\n-                        else if (f instanceof TreeBin) {\n-                            binCount = 1;\n-                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n-                            TreeNode<K,V> r, p;\n-                            if ((r = t.root) != null) {\n-                                p = r.findTreeNode(h, key, null);\n-                            } else {\n-                                p = null;\n-                            }\n-                            V pv = p == null ? null : p.val;\n-                            val = remappingFunction.apply(key, pv);\n-                            if (val != null) {\n-                                if (p != null) {\n-                                    p.val = val;\n-                                } else {\n-                                    delta = 1;\n-                                    t.putTreeVal(h, key, val);\n-                                }\n-                            }\n-                            else if (p != null) {\n-                                delta = -1;\n-                                if (t.removeTreeNode(p)) {\n-                                    setTabAt(tab, i, untreeify(t.first));\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                if (binCount != 0) {\n-                    if (binCount >= TREEIFY_THRESHOLD) {\n-                        treeifyBin(tab, i);\n-                    }\n-                    break;\n-                }\n-            }\n-        }\n-        if (delta != 0) {\n-            addCount(delta, binCount);\n-        }\n-        return val;\n-    }\n-\n-    /**\n-     * If the specified key is not already associated with a\n-     * (non-null) value, associates it with the given value.\n-     * Otherwise, replaces the value with the results of the given\n-     * remapping function, or removes if {@code null}. The entire\n-     * method invocation is performed atomically.  Some attempted\n-     * update operations on this map by other threads may be blocked\n-     * while computation is in progress, so the computation should be\n-     * short and simple, and must not attempt to update any other\n-     * mappings of this Map.\n-     *\n-     * @param key key with which the specified value is to be associated\n-     * @param value the value to use if absent\n-     * @param remappingFunction the function to recompute a value if present\n-     * @return the new value associated with the specified key, or null if none\n-     * @throws NullPointerException if the specified key or the\n-     *         remappingFunction is null\n-     * @throws RuntimeException or Error if the remappingFunction does so,\n-     *         in which case the mapping is unchanged\n-     */\n-    public V merge(K key, V value, BiFun<? super V, ? super V, ? extends V> remappingFunction) {\n-        if (key == null || value == null || remappingFunction == null) {\n-            throw new NullPointerException();\n-        }\n-        int h = spread(key.hashCode());\n-        V val = null;\n-        int delta = 0;\n-        int binCount = 0;\n-        for (Node<K,V>[] tab = this.table;;) {\n-            Node<K,V> f; int n, i, fh;\n-            if (tab == null || (n = tab.length) == 0) {\n-                tab = initTable();\n-            } else if ((f = tabAt(tab, i = n - 1 & h)) == null) {\n-                if (casTabAt(tab, i, null, new Node<K,V>(h, key, value, null))) {\n-                    delta = 1;\n-                    val = value;\n-                    break;\n-                }\n-            }\n-            else if ((fh = f.hash) == MOVED) {\n-                tab = helpTransfer(tab, f);\n-            } else {\n-                synchronized (f) {\n-                    if (tabAt(tab, i) == f) {\n-                        if (fh >= 0) {\n-                            binCount = 1;\n-                            for (Node<K,V> e = f, pred = null;; ++binCount) {\n-                                K ek;\n-                                if (e.hash == h &&\n-                                    ((ek = e.key) == key ||\n-                                     ek != null && key.equals(ek))) {\n-                                    val = remappingFunction.apply(e.val, value);\n-                                    if (val != null) {\n-                                        e.val = val;\n-                                    } else {\n-                                        delta = -1;\n-                                        Node<K,V> en = e.next;\n-                                        if (pred != null) {\n-                                            pred.next = en;\n-                                        } else {\n-                                            setTabAt(tab, i, en);\n-                                        }\n-                                    }\n-                                    break;\n-                                }\n-                                pred = e;\n-                                if ((e = e.next) == null) {\n-                                    delta = 1;\n-                                    val = value;\n-                                    pred.next =\n-                                        new Node<K,V>(h, key, val, null);\n-                                    break;\n-                                }\n-                            }\n-                        }\n-                        else if (f instanceof TreeBin) {\n-                            binCount = 2;\n-                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n-                            TreeNode<K,V> r = t.root;\n-                            TreeNode<K,V> p = r == null ? null :\n-                                r.findTreeNode(h, key, null);\n-                            val = p == null ? value :\n-                                remappingFunction.apply(p.val, value);\n-                            if (val != null) {\n-                                if (p != null) {\n-                                    p.val = val;\n-                                } else {\n-                                    delta = 1;\n-                                    t.putTreeVal(h, key, val);\n-                                }\n-                            }\n-                            else if (p != null) {\n-                                delta = -1;\n-                                if (t.removeTreeNode(p)) {\n-                                    setTabAt(tab, i, untreeify(t.first));\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                if (binCount != 0) {\n-                    if (binCount >= TREEIFY_THRESHOLD) {\n-                        treeifyBin(tab, i);\n-                    }\n-                    break;\n-                }\n-            }\n-        }\n-        if (delta != 0) {\n-            addCount(delta, binCount);\n-        }\n-        return val;\n-    }\n-\n-    // Hashtable legacy methods\n-\n-    /**\n-     * Legacy method testing if some key maps into the specified value\n-     * in this table.  This method is identical in functionality to\n-     * {@link #containsValue(Object)}, and exists solely to ensure\n-     * full compatibility with class {@link java.util.Hashtable},\n-     * which supported this method prior to introduction of the\n-     * Java Collections framework.\n-     *\n-     * @param  value a value to search for\n-     * @return {@code true} if and only if some key maps to the\n-     *         {@code value} argument in this table as\n-     *         determined by the {@code equals} method;\n-     *         {@code false} otherwise\n-     * @throws NullPointerException if the specified value is null\n-     */\n-    @Deprecated public boolean contains(Object value) {\n-        return containsValue(value);\n-    }\n-\n-    /**\n-     * Returns an enumeration of the keys in this table.\n-     *\n-     * @return an enumeration of the keys in this table\n-     * @see #keySet()\n-     */\n-    public Enumeration<K> keys() {\n-        Node<K,V>[] t;\n-        int f = (t = this.table) == null ? 0 : t.length;\n-        return new KeyIterator<K,V>(t, f, 0, f, this);\n-    }\n-\n-    /**\n-     * Returns an enumeration of the values in this table.\n-     *\n-     * @return an enumeration of the values in this table\n-     * @see #values()\n-     */\n-    public Enumeration<V> elements() {\n-        Node<K,V>[] t;\n-        int f = (t = this.table) == null ? 0 : t.length;\n-        return new ValueIterator<K,V>(t, f, 0, f, this);\n-    }\n-\n-    // ConcurrentHashMapV8-only methods\n-\n-    /**\n-     * Returns the number of mappings. This method should be used\n-     * instead of {@link #size} because a ConcurrentHashMapV8 may\n-     * contain more mappings than can be represented as an int. The\n-     * value returned is an estimate; the actual count may differ if\n-     * there are concurrent insertions or removals.\n-     *\n-     * @return the number of mappings\n-     * @since 1.8\n-     */\n-    public long mappingCount() {\n-        long n = sumCount();\n-        return n < 0L ? 0L : n; // ignore transient negative values\n-    }\n-\n-    /**\n-     * Creates a new {@link Set} backed by a ConcurrentHashMapV8\n-     * from the given type to {@code Boolean.TRUE}.\n-     *\n-     * @return the new set\n-     * @since 1.8\n-     */\n-    public static <K> KeySetView<K,Boolean> newKeySet() {\n-        return new KeySetView<K,Boolean>\n-            (new ConcurrentHashMapV8<K,Boolean>(), Boolean.TRUE);\n-    }\n-\n-    /**\n-     * Creates a new {@link Set} backed by a ConcurrentHashMapV8\n-     * from the given type to {@code Boolean.TRUE}.\n-     *\n-     * @param initialCapacity The implementation performs internal\n-     * sizing to accommodate this many elements.\n-     * @return the new set\n-     * @throws IllegalArgumentException if the initial capacity of\n-     * elements is negative\n-     * @since 1.8\n-     */\n-    public static <K> KeySetView<K,Boolean> newKeySet(int initialCapacity) {\n-        return new KeySetView<K,Boolean>\n-            (new ConcurrentHashMapV8<K,Boolean>(initialCapacity), Boolean.TRUE);\n-    }\n-\n-    /**\n-     * Returns a {@link Set} view of the keys in this map, using the\n-     * given common mapped value for any additions (i.e., {@link\n-     * Collection#add} and {@link Collection#addAll(Collection)}).\n-     * This is of course only appropriate if it is acceptable to use\n-     * the same value for all additions from this view.\n-     *\n-     * @param mappedValue the mapped value to use for any additions\n-     * @return the set view\n-     * @throws NullPointerException if the mappedValue is null\n-     */\n-    public KeySetView<K,V> keySet(V mappedValue) {\n-        if (mappedValue == null) {\n-            throw new NullPointerException();\n-        }\n-        return new KeySetView<K,V>(this, mappedValue);\n-    }\n-\n-    /* ---------------- Special Nodes -------------- */\n-\n-    /**\n-     * A node inserted at head of bins during transfer operations.\n-     */\n-    static final class ForwardingNode<K,V> extends Node<K,V> {\n-        final Node<K,V>[] nextTable;\n-        ForwardingNode(Node<K,V>[] tab) {\n-            super(MOVED, null, null, null);\n-            this.nextTable = tab;\n-        }\n-\n-        @Override\n-        Node<K,V> find(int h, Object k) {\n-            // loop to avoid arbitrarily deep recursion on forwarding nodes\n-            outer: for (Node<K,V>[] tab = this.nextTable;;) {\n-                Node<K,V> e; int n;\n-                if (k == null || tab == null || (n = tab.length) == 0 ||\n-                    (e = tabAt(tab, n - 1 & h)) == null) {\n-                    return null;\n-                }\n-                for (;;) {\n-                    int eh; K ek;\n-                    if ((eh = e.hash) == h &&\n-                        ((ek = e.key) == k || ek != null && k.equals(ek))) {\n-                        return e;\n-                    }\n-                    if (eh < 0) {\n-                        if (e instanceof ForwardingNode) {\n-                            tab = ((ForwardingNode<K,V>)e).nextTable;\n-                            continue outer;\n-                        } else {\n-                            return e.find(h, k);\n-                        }\n-                    }\n-                    if ((e = e.next) == null) {\n-                        return null;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * A place-holder node used in computeIfAbsent and compute\n-     */\n-    static final class ReservationNode<K,V> extends Node<K,V> {\n-        ReservationNode() {\n-            super(RESERVED, null, null, null);\n-        }\n-\n-        @Override\n-        Node<K,V> find(int h, Object k) {\n-            return null;\n-        }\n-    }\n-\n-    /* ---------------- Table Initialization and Resizing -------------- */\n-\n-    /**\n-     * Initializes table, using the size recorded in sizeCtl.\n-     */\n-    private final Node<K,V>[] initTable() {\n-        Node<K,V>[] tab; int sc;\n-        while ((tab = this.table) == null || tab.length == 0) {\n-            if ((sc = this.sizeCtl) < 0) {\n-                Thread.yield(); // lost initialization race; just spin\n-            } else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n-                try {\n-                    if ((tab = this.table) == null || tab.length == 0) {\n-                        int n = sc > 0 ? sc : DEFAULT_CAPACITY;\n-                        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n-                            Node<K,V>[] nt = new Node[n];\n-                        this.table = tab = nt;\n-                        sc = n - (n >>> 2);\n-                    }\n-                } finally {\n-                    this.sizeCtl = sc;\n-                }\n-                break;\n-            }\n-        }\n-        return tab;\n-    }\n-\n-    /**\n-     * Adds to count, and if table is too small and not already\n-     * resizing, initiates transfer. If already resizing, helps\n-     * perform transfer if work is available.  Rechecks occupancy\n-     * after a transfer to see if another resize is already needed\n-     * because resizings are lagging additions.\n-     *\n-     * @param x the count to add\n-     * @param check if <0, don't check resize, if <= 1 only check if uncontended\n-     */\n-    private final void addCount(long x, int check) {\n-        CounterCell[] as; long b, s;\n-        if ((as = this.counterCells) != null ||\n-            !U.compareAndSwapLong(this, BASECOUNT, b = this.baseCount, s = b + x)) {\n-            CounterHashCode hc; CounterCell a; long v; int m;\n-            boolean uncontended = true;\n-            if ((hc = threadCounterHashCode.get()) == null ||\n-                as == null || (m = as.length - 1) < 0 ||\n-                (a = as[m & hc.code]) == null ||\n-                !(uncontended =\n-                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {\n-                fullAddCount(x, hc, uncontended);\n-                return;\n-            }\n-            if (check <= 1) {\n-                return;\n-            }\n-            s = sumCount();\n-        }\n-        if (check >= 0) {\n-            Node<K,V>[] tab, nt; int sc;\n-            while (s >= (sc = this.sizeCtl) && (tab = this.table) != null &&\n-                   tab.length < MAXIMUM_CAPACITY) {\n-                if (sc < 0) {\n-                    if (sc == -1 || this.transferIndex <= this.transferOrigin ||\n-                        (nt = this.nextTable) == null) {\n-                        break;\n-                    }\n-                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc - 1)) {\n-                        transfer(tab, nt);\n-                    }\n-                }\n-                else if (U.compareAndSwapInt(this, SIZECTL, sc, -2)) {\n-                    transfer(tab, null);\n-                }\n-                s = sumCount();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Helps transfer if a resize is in progress.\n-     */\n-    final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) {\n-        Node<K,V>[] nextTab; int sc;\n-        if (f instanceof ForwardingNode &&\n-            (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {\n-            if (nextTab == this.nextTable && tab == this.table &&\n-                this.transferIndex > this.transferOrigin && (sc = this.sizeCtl) < -1 &&\n-                U.compareAndSwapInt(this, SIZECTL, sc, sc - 1)) {\n-                transfer(tab, nextTab);\n-            }\n-            return nextTab;\n-        }\n-        return this.table;\n-    }\n-\n-    /**\n-     * Tries to presize table to accommodate the given number of elements.\n-     *\n-     * @param size number of elements (doesn't need to be perfectly accurate)\n-     */\n-    private final void tryPresize(int size) {\n-        int c = size >= MAXIMUM_CAPACITY >>> 1 ? MAXIMUM_CAPACITY :\n-            tableSizeFor(size + (size >>> 1) + 1);\n-        int sc;\n-        while ((sc = this.sizeCtl) >= 0) {\n-            Node<K,V>[] tab = this.table; int n;\n-            if (tab == null || (n = tab.length) == 0) {\n-                n = sc > c ? sc : c;\n-                if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n-                    try {\n-                        if (this.table == tab) {\n-                            @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n-                                Node<K,V>[] nt = new Node[n];\n-                            this.table = nt;\n-                            sc = n - (n >>> 2);\n-                        }\n-                    } finally {\n-                        this.sizeCtl = sc;\n-                    }\n-                }\n-            }\n-            else if (c <= sc || n >= MAXIMUM_CAPACITY) {\n-                break;\n-            } else if (tab == this.table &&\n-                     U.compareAndSwapInt(this, SIZECTL, sc, -2)) {\n-                transfer(tab, null);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Moves and/or copies the nodes in each bin to new table. See\n-     * above for explanation.\n-     */\n-    private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {\n-        int n = tab.length, stride;\n-        if ((stride = NCPU > 1 ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)\n-         {\n-            stride = MIN_TRANSFER_STRIDE; // subdivide range\n-        }\n-        if (nextTab == null) {            // initiating\n-            try {\n-                @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n-                    Node<K,V>[] nt = new Node[n << 1];\n-                nextTab = nt;\n-            } catch (Throwable ex) {      // try to cope with OOME\n-                this.sizeCtl = Integer.MAX_VALUE;\n-                return;\n-            }\n-            this.nextTable = nextTab;\n-            this.transferOrigin = n;\n-            this.transferIndex = n;\n-            ForwardingNode<K,V> rev = new ForwardingNode<K,V>(tab);\n-            for (int k = n; k > 0;) {    // progressively reveal ready slots\n-                int nextk = k > stride ? k - stride : 0;\n-                for (int m = nextk; m < k; ++m) {\n-                    nextTab[m] = rev;\n-                }\n-                for (int m = n + nextk; m < n + k; ++m) {\n-                    nextTab[m] = rev;\n-                }\n-                U.putOrderedInt(this, TRANSFERORIGIN, k = nextk);\n-            }\n-        }\n-        int nextn = nextTab.length;\n-        ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);\n-        boolean advance = true;\n-        boolean finishing = false; // to ensure sweep before committing nextTab\n-        for (int i = 0, bound = 0;;) {\n-            int nextIndex, nextBound, fh; Node<K,V> f;\n-            while (advance) {\n-                if (--i >= bound || finishing) {\n-                    advance = false;\n-                } else if ((nextIndex = this.transferIndex) <= this.transferOrigin) {\n-                    i = -1;\n-                    advance = false;\n-                }\n-                else if (U.compareAndSwapInt\n-                         (this, TRANSFERINDEX, nextIndex,\n-                          nextBound = nextIndex > stride ?\n-                                       nextIndex - stride : 0)) {\n-                    bound = nextBound;\n-                    i = nextIndex - 1;\n-                    advance = false;\n-                }\n-            }\n-            if (i < 0 || i >= n || i + n >= nextn) {\n-                if (finishing) {\n-                    this.nextTable = null;\n-                    this.table = nextTab;\n-                    this.sizeCtl = (n << 1) - (n >>> 1);\n-                    return;\n-                }\n-                for (int sc;;) {\n-                    if (U.compareAndSwapInt(this, SIZECTL, sc = this.sizeCtl, ++sc)) {\n-                        if (sc != -1) {\n-                            return;\n-                        }\n-                        finishing = advance = true;\n-                        i = n; // recheck before commit\n-                        break;\n-                    }\n-                }\n-            }\n-            else if ((f = tabAt(tab, i)) == null) {\n-                if (casTabAt(tab, i, null, fwd)) {\n-                    setTabAt(nextTab, i, null);\n-                    setTabAt(nextTab, i + n, null);\n-                    advance = true;\n-                }\n-            }\n-            else if ((fh = f.hash) == MOVED) {\n-                advance = true; // already processed\n-            } else {\n-                synchronized (f) {\n-                    if (tabAt(tab, i) == f) {\n-                        Node<K,V> ln, hn;\n-                        if (fh >= 0) {\n-                            int runBit = fh & n;\n-                            Node<K,V> lastRun = f;\n-                            for (Node<K,V> p = f.next; p != null; p = p.next) {\n-                                int b = p.hash & n;\n-                                if (b != runBit) {\n-                                    runBit = b;\n-                                    lastRun = p;\n-                                }\n-                            }\n-                            if (runBit == 0) {\n-                                ln = lastRun;\n-                                hn = null;\n-                            }\n-                            else {\n-                                hn = lastRun;\n-                                ln = null;\n-                            }\n-                            for (Node<K,V> p = f; p != lastRun; p = p.next) {\n-                                int ph = p.hash; K pk = p.key; V pv = p.val;\n-                                if ((ph & n) == 0) {\n-                                    ln = new Node<K,V>(ph, pk, pv, ln);\n-                                } else {\n-                                    hn = new Node<K,V>(ph, pk, pv, hn);\n-                                }\n-                            }\n-                            setTabAt(nextTab, i, ln);\n-                            setTabAt(nextTab, i + n, hn);\n-                            setTabAt(tab, i, fwd);\n-                            advance = true;\n-                        }\n-                        else if (f instanceof TreeBin) {\n-                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n-                            TreeNode<K,V> lo = null, loTail = null;\n-                            TreeNode<K,V> hi = null, hiTail = null;\n-                            int lc = 0, hc = 0;\n-                            for (Node<K,V> e = t.first; e != null; e = e.next) {\n-                                int h = e.hash;\n-                                TreeNode<K,V> p = new TreeNode<K,V>\n-                                    (h, e.key, e.val, null, null);\n-                                if ((h & n) == 0) {\n-                                    if ((p.prev = loTail) == null) {\n-                                        lo = p;\n-                                    } else {\n-                                        loTail.next = p;\n-                                    }\n-                                    loTail = p;\n-                                    ++lc;\n-                                }\n-                                else {\n-                                    if ((p.prev = hiTail) == null) {\n-                                        hi = p;\n-                                    } else {\n-                                        hiTail.next = p;\n-                                    }\n-                                    hiTail = p;\n-                                    ++hc;\n-                                }\n-                            }\n-                            ln = lc <= UNTREEIFY_THRESHOLD ? untreeify(lo) :\n-                                hc != 0 ? new TreeBin<K,V>(lo) : t;\n-                            hn = hc <= UNTREEIFY_THRESHOLD ? untreeify(hi) :\n-                                lc != 0 ? new TreeBin<K,V>(hi) : t;\n-                            setTabAt(nextTab, i, ln);\n-                            setTabAt(nextTab, i + n, hn);\n-                            setTabAt(tab, i, fwd);\n-                            advance = true;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /* ---------------- Conversion from/to TreeBins -------------- */\n-\n-    /**\n-     * Replaces all linked nodes in bin at given index unless table is\n-     * too small, in which case resizes instead.\n-     */\n-    private final void treeifyBin(Node<K,V>[] tab, int index) {\n-        Node<K,V> b; int n, sc;\n-        if (tab != null) {\n-            if ((n = tab.length) < MIN_TREEIFY_CAPACITY) {\n-                if (tab == this.table && (sc = this.sizeCtl) >= 0 &&\n-                    U.compareAndSwapInt(this, SIZECTL, sc, -2)) {\n-                    transfer(tab, null);\n-                }\n-            }\n-            else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {\n-                synchronized (b) {\n-                    if (tabAt(tab, index) == b) {\n-                        TreeNode<K,V> hd = null, tl = null;\n-                        for (Node<K,V> e = b; e != null; e = e.next) {\n-                            TreeNode<K,V> p =\n-                                new TreeNode<K,V>(e.hash, e.key, e.val,\n-                                                  null, null);\n-                            if ((p.prev = tl) == null) {\n-                                hd = p;\n-                            } else {\n-                                tl.next = p;\n-                            }\n-                            tl = p;\n-                        }\n-                        setTabAt(tab, index, new TreeBin<K,V>(hd));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Returns a list on non-TreeNodes replacing those in given list.\n-     */\n-    static <K,V> Node<K,V> untreeify(Node<K,V> b) {\n-        Node<K,V> hd = null, tl = null;\n-        for (Node<K,V> q = b; q != null; q = q.next) {\n-            Node<K,V> p = new Node<K,V>(q.hash, q.key, q.val, null);\n-            if (tl == null) {\n-                hd = p;\n-            } else {\n-                tl.next = p;\n-            }\n-            tl = p;\n-        }\n-        return hd;\n-    }\n-\n-    /* ---------------- TreeNodes -------------- */\n-\n-    /**\n-     * Nodes for use in TreeBins\n-     */\n-    static final class TreeNode<K,V> extends Node<K,V> {\n-        TreeNode<K,V> parent;  // red-black tree links\n-        TreeNode<K,V> left;\n-        TreeNode<K,V> right;\n-        TreeNode<K,V> prev;    // needed to unlink next upon deletion\n-        boolean red;\n-\n-        TreeNode(int hash, K key, V val, Node<K,V> next,\n-                 TreeNode<K,V> parent) {\n-            super(hash, key, val, next);\n-            this.parent = parent;\n-        }\n-\n-        @Override\n-        Node<K,V> find(int h, Object k) {\n-            return findTreeNode(h, k, null);\n-        }\n-\n-        /**\n-         * Returns the TreeNode (or null if not found) for the given key\n-         * starting at given root.\n-         */\n-        final TreeNode<K,V> findTreeNode(int h, Object k, Class<?> kc) {\n-            if (k != null) {\n-                TreeNode<K,V> p = this;\n-                do  {\n-                    int ph, dir; K pk; TreeNode<K,V> q;\n-                    TreeNode<K,V> pl = p.left, pr = p.right;\n-                    if ((ph = p.hash) > h) {\n-                        p = pl;\n-                    } else if (ph < h) {\n-                        p = pr;\n-                    } else if ((pk = p.key) == k || pk != null && k.equals(pk)) {\n-                        return p;\n-                    } else if (pl == null) {\n-                        p = pr;\n-                    } else if (pr == null) {\n-                        p = pl;\n-                    } else if ((kc != null ||\n-                              (kc = comparableClassFor(k)) != null) &&\n-                             (dir = compareComparables(kc, k, pk)) != 0) {\n-                        p = dir < 0 ? pl : pr;\n-                    } else if ((q = pr.findTreeNode(h, k, kc)) != null) {\n-                        return q;\n-                    } else {\n-                        p = pl;\n-                    }\n-                } while (p != null);\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /* ---------------- TreeBins -------------- */\n-\n-    /**\n-     * TreeNodes used at the heads of bins. TreeBins do not hold user\n-     * keys or values, but instead point to list of TreeNodes and\n-     * their root. They also maintain a parasitic read-write lock\n-     * forcing writers (who hold bin lock) to wait for readers (who do\n-     * not) to complete before tree restructuring operations.\n-     */\n-    static final class TreeBin<K,V> extends Node<K,V> {\n-        TreeNode<K,V> root;\n-        volatile TreeNode<K,V> first;\n-        volatile Thread waiter;\n-        volatile int lockState;\n-        // values for lockState\n-        static final int WRITER = 1; // set while holding write lock\n-        static final int WAITER = 2; // set when waiting for write lock\n-        static final int READER = 4; // increment value for setting read lock\n-\n-        /**\n-         * Tie-breaking utility for ordering insertions when equal\n-         * hashCodes and non-comparable. We don't require a total\n-         * order, just a consistent insertion rule to maintain\n-         * equivalence across rebalancings. Tie-breaking further than\n-         * necessary simplifies testing a bit.\n-         */\n-        static int tieBreakOrder(Object a, Object b) {\n-            int d;\n-            if (a == null || b == null ||\n-                (d = a.getClass().getName().\n-                 compareTo(b.getClass().getName())) == 0) {\n-                d = System.identityHashCode(a) <= System.identityHashCode(b) ?\n-                     -1 : 1;\n-            }\n-            return d;\n-        }\n-\n-        /**\n-         * Creates bin with initial set of nodes headed by b.\n-         */\n-        TreeBin(TreeNode<K,V> b) {\n-            super(TREEBIN, null, null, null);\n-            this.first = b;\n-            TreeNode<K,V> r = null;\n-            for (TreeNode<K,V> x = b, next; x != null; x = next) {\n-                next = (TreeNode<K,V>)x.next;\n-                x.left = x.right = null;\n-                if (r == null) {\n-                    x.parent = null;\n-                    x.red = false;\n-                    r = x;\n-                }\n-                else {\n-                    K k = x.key;\n-                    int h = x.hash;\n-                    Class<?> kc = null;\n-                    for (TreeNode<K,V> p = r;;) {\n-                        int dir, ph;\n-                        K pk = p.key;\n-                        if ((ph = p.hash) > h) {\n-                            dir = -1;\n-                        } else if (ph < h) {\n-                            dir = 1;\n-                        } else if (kc == null &&\n-                                  (kc = comparableClassFor(k)) == null ||\n-                                 (dir = compareComparables(kc, k, pk)) == 0) {\n-                            dir = tieBreakOrder(k, pk);\n-                        }\n-                            TreeNode<K,V> xp = p;\n-                        if ((p = dir <= 0 ? p.left : p.right) == null) {\n-                            x.parent = xp;\n-                            if (dir <= 0) {\n-                                xp.left = x;\n-                            } else {\n-                                xp.right = x;\n-                            }\n-                            r = balanceInsertion(r, x);\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-            this.root = r;\n-            assert checkInvariants(this.root);\n-        }\n-\n-        /**\n-         * Acquires write lock for tree restructuring.\n-         */\n-        private final void lockRoot() {\n-            if (!U.compareAndSwapInt(this, LOCKSTATE, 0, WRITER))\n-             {\n-                contendedLock(); // offload to separate method\n-            }\n-        }\n-\n-        /**\n-         * Releases write lock for tree restructuring.\n-         */\n-        private final void unlockRoot() {\n-            this.lockState = 0;\n-        }\n-\n-        /**\n-         * Possibly blocks awaiting root lock.\n-         */\n-        private final void contendedLock() {\n-            boolean waiting = false;\n-            for (int s;;) {\n-                if (((s = this.lockState) & WRITER) == 0) {\n-                    if (U.compareAndSwapInt(this, LOCKSTATE, s, WRITER)) {\n-                        if (waiting) {\n-                            this.waiter = null;\n-                        }\n-                        return;\n-                    }\n-                }\n-                else if ((s | WAITER) == 0) {\n-                    if (U.compareAndSwapInt(this, LOCKSTATE, s, s | WAITER)) {\n-                        waiting = true;\n-                        this.waiter = Thread.currentThread();\n-                    }\n-                }\n-                else if (waiting) {\n-                    LockSupport.park(this);\n-                }\n-            }\n-        }\n-\n-        /**\n-         * Returns matching node or null if none. Tries to search\n-         * using tree comparisons from root, but continues linear\n-         * search when lock not available.\n-         */\n-@Override\n-final Node<K,V> find(int h, Object k) {\n-            if (k != null) {\n-                for (Node<K,V> e = this.first; e != null; e = e.next) {\n-                    int s; K ek;\n-                    if (((s = this.lockState) & (WAITER|WRITER)) != 0) {\n-                        if (e.hash == h &&\n-                            ((ek = e.key) == k || ek != null && k.equals(ek))) {\n-                            return e;\n-                        }\n-                    }\n-                    else if (U.compareAndSwapInt(this, LOCKSTATE, s,\n-                                                 s + READER)) {\n-                        TreeNode<K,V> r, p;\n-                        try {\n-                            p = (r = this.root) == null ? null :\n-                                 r.findTreeNode(h, k, null);\n-                        } finally {\n-                            Thread w;\n-                            int ls;\n-                            do {} while (!U.compareAndSwapInt\n-                                         (this, LOCKSTATE,\n-                                          ls = this.lockState, ls - READER));\n-                            if (ls == (READER|WAITER) && (w = this.waiter) != null) {\n-                                LockSupport.unpark(w);\n-                            }\n-                        }\n-                        return p;\n-                    }\n-                }\n-            }\n-            return null;\n-        }\n-\n-        /**\n-         * Finds or adds a node.\n-         * @return null if added\n-         */\n-        final TreeNode<K,V> putTreeVal(int h, K k, V v) {\n-            Class<?> kc = null;\n-            boolean searched = false;\n-            for (TreeNode<K,V> p = this.root;;) {\n-                int dir, ph; K pk;\n-                if (p == null) {\n-                    this.first = this.root = new TreeNode<K,V>(h, k, v, null, null);\n-                    break;\n-                }\n-                else if ((ph = p.hash) > h) {\n-                    dir = -1;\n-                } else if (ph < h) {\n-                    dir = 1;\n-                } else if ((pk = p.key) == k || pk != null && k.equals(pk)) {\n-                    return p;\n-                } else if (kc == null &&\n-                          (kc = comparableClassFor(k)) == null ||\n-                         (dir = compareComparables(kc, k, pk)) == 0) {\n-                    if (!searched) {\n-                        TreeNode<K,V> q, ch;\n-                        searched = true;\n-                        if ((ch = p.left) != null &&\n-                             (q = ch.findTreeNode(h, k, kc)) != null ||\n-                            (ch = p.right) != null &&\n-                             (q = ch.findTreeNode(h, k, kc)) != null) {\n-                            return q;\n-                        }\n-                    }\n-                    dir = tieBreakOrder(k, pk);\n-                }\n-\n-                TreeNode<K,V> xp = p;\n-                if ((p = dir <= 0 ? p.left : p.right) == null) {\n-                    TreeNode<K,V> x, f = this.first;\n-                    this.first = x = new TreeNode<K,V>(h, k, v, f, xp);\n-                    if (f != null) {\n-                        f.prev = x;\n-                    }\n-                    if (dir <= 0) {\n-                        xp.left = x;\n-                    } else {\n-                        xp.right = x;\n-                    }\n-                    if (!xp.red) {\n-                        x.red = true;\n-                    } else {\n-                        lockRoot();\n-                        try {\n-                            this.root = balanceInsertion(this.root, x);\n-                        } finally {\n-                            unlockRoot();\n-                        }\n-                    }\n-                    break;\n-                }\n-            }\n-            assert checkInvariants(this.root);\n-            return null;\n-        }\n-\n-        /**\n-         * Removes the given node, that must be present before this\n-         * call.  This is messier than typical red-black deletion code\n-         * because we cannot swap the contents of an interior node\n-         * with a leaf successor that is pinned by \"next\" pointers\n-         * that are accessible independently of lock. So instead we\n-         * swap the tree linkages.\n-         *\n-         * @return true if now too small, so should be untreeified\n-         */\n-        final boolean removeTreeNode(TreeNode<K,V> p) {\n-            TreeNode<K,V> next = (TreeNode<K,V>)p.next;\n-            TreeNode<K,V> pred = p.prev;  // unlink traversal pointers\n-            TreeNode<K,V> r, rl;\n-            if (pred == null) {\n-                this.first = next;\n-            } else {\n-                pred.next = next;\n-            }\n-            if (next != null) {\n-                next.prev = pred;\n-            }\n-            if (this.first == null) {\n-                this.root = null;\n-                return true;\n-            }\n-            if ((r = this.root) == null || r.right == null || // too small\n-                (rl = r.left) == null || rl.left == null) {\n-                return true;\n-            }\n-            lockRoot();\n-            try {\n-                TreeNode<K,V> replacement;\n-                TreeNode<K,V> pl = p.left;\n-                TreeNode<K,V> pr = p.right;\n-                if (pl != null && pr != null) {\n-                    TreeNode<K,V> s = pr, sl;\n-                    while ((sl = s.left) != null) {\n-                        s = sl;\n-                    }\n-                    boolean c = s.red; s.red = p.red; p.red = c; // swap colors\n-                    TreeNode<K,V> sr = s.right;\n-                    TreeNode<K,V> pp = p.parent;\n-                    if (s == pr) { // p was s's direct parent\n-                        p.parent = s;\n-                        s.right = p;\n-                    }\n-                    else {\n-                        TreeNode<K,V> sp = s.parent;\n-                        if ((p.parent = sp) != null) {\n-                            if (s == sp.left) {\n-                                sp.left = p;\n-                            } else {\n-                                sp.right = p;\n-                            }\n-                        }\n-                        if ((s.right = pr) != null) {\n-                            pr.parent = s;\n-                        }\n-                    }\n-                    p.left = null;\n-                    if ((p.right = sr) != null) {\n-                        sr.parent = p;\n-                    }\n-                    if ((s.left = pl) != null) {\n-                        pl.parent = s;\n-                    }\n-                    if ((s.parent = pp) == null) {\n-                        r = s;\n-                    } else if (p == pp.left) {\n-                        pp.left = s;\n-                    } else {\n-                        pp.right = s;\n-                    }\n-                    if (sr != null) {\n-                        replacement = sr;\n-                    } else {\n-                        replacement = p;\n-                    }\n-                }\n-                else if (pl != null) {\n-                    replacement = pl;\n-                } else if (pr != null) {\n-                    replacement = pr;\n-                } else {\n-                    replacement = p;\n-                }\n-                if (replacement != p) {\n-                    TreeNode<K,V> pp = replacement.parent = p.parent;\n-                    if (pp == null) {\n-                        r = replacement;\n-                    } else if (p == pp.left) {\n-                        pp.left = replacement;\n-                    } else {\n-                        pp.right = replacement;\n-                    }\n-                    p.left = p.right = p.parent = null;\n-                }\n-\n-                this.root = p.red ? r : balanceDeletion(r, replacement);\n-\n-                if (p == replacement) {  // detach pointers\n-                    TreeNode<K,V> pp;\n-                    if ((pp = p.parent) != null) {\n-                        if (p == pp.left) {\n-                            pp.left = null;\n-                        } else if (p == pp.right) {\n-                            pp.right = null;\n-                        }\n-                        p.parent = null;\n-                    }\n-                }\n-            } finally {\n-                unlockRoot();\n-            }\n-            assert checkInvariants(this.root);\n-            return false;\n-        }\n-\n-        /* ------------------------------------------------------------ */\n-        // Red-black tree methods, all adapted from CLR\n-\n-        static <K,V> TreeNode<K,V> rotateLeft(TreeNode<K,V> root,\n-                                              TreeNode<K,V> p) {\n-            TreeNode<K,V> r, pp, rl;\n-            if (p != null && (r = p.right) != null) {\n-                if ((rl = p.right = r.left) != null) {\n-                    rl.parent = p;\n-                }\n-                if ((pp = r.parent = p.parent) == null) {\n-                    (root = r).red = false;\n-                } else if (pp.left == p) {\n-                    pp.left = r;\n-                } else {\n-                    pp.right = r;\n-                }\n-                r.left = p;\n-                p.parent = r;\n-            }\n-            return root;\n-        }\n-\n-        static <K,V> TreeNode<K,V> rotateRight(TreeNode<K,V> root,\n-                                               TreeNode<K,V> p) {\n-            TreeNode<K,V> l, pp, lr;\n-            if (p != null && (l = p.left) != null) {\n-                if ((lr = p.left = l.right) != null) {\n-                    lr.parent = p;\n-                }\n-                if ((pp = l.parent = p.parent) == null) {\n-                    (root = l).red = false;\n-                } else if (pp.right == p) {\n-                    pp.right = l;\n-                } else {\n-                    pp.left = l;\n-                }\n-                l.right = p;\n-                p.parent = l;\n-            }\n-            return root;\n-        }\n-\n-        static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root,\n-                                                    TreeNode<K,V> x) {\n-            x.red = true;\n-            for (TreeNode<K,V> xp, xpp, xppl, xppr;;) {\n-                if ((xp = x.parent) == null) {\n-                    x.red = false;\n-                    return x;\n-                }\n-                else if (!xp.red || (xpp = xp.parent) == null) {\n-                    return root;\n-                }\n-                if (xp == (xppl = xpp.left)) {\n-                    if ((xppr = xpp.right) != null && xppr.red) {\n-                        xppr.red = false;\n-                        xp.red = false;\n-                        xpp.red = true;\n-                        x = xpp;\n-                    }\n-                    else {\n-                        if (x == xp.right) {\n-                            root = rotateLeft(root, x = xp);\n-                            xpp = (xp = x.parent) == null ? null : xp.parent;\n-                        }\n-                        if (xp != null) {\n-                            xp.red = false;\n-                            if (xpp != null) {\n-                                xpp.red = true;\n-                                root = rotateRight(root, xpp);\n-                            }\n-                        }\n-                    }\n-                }\n-                else {\n-                    if (xppl != null && xppl.red) {\n-                        xppl.red = false;\n-                        xp.red = false;\n-                        xpp.red = true;\n-                        x = xpp;\n-                    }\n-                    else {\n-                        if (x == xp.left) {\n-                            root = rotateRight(root, x = xp);\n-                            xpp = (xp = x.parent) == null ? null : xp.parent;\n-                        }\n-                        if (xp != null) {\n-                            xp.red = false;\n-                            if (xpp != null) {\n-                                xpp.red = true;\n-                                root = rotateLeft(root, xpp);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        static <K,V> TreeNode<K,V> balanceDeletion(TreeNode<K,V> root,\n-                                                   TreeNode<K,V> x) {\n-            for (TreeNode<K,V> xp, xpl, xpr;;)  {\n-                if (x == null || x == root) {\n-                    return root;\n-                } else if ((xp = x.parent) == null) {\n-                    x.red = false;\n-                    return x;\n-                }\n-                else if (x.red) {\n-                    x.red = false;\n-                    return root;\n-                }\n-                else if ((xpl = xp.left) == x) {\n-                    if ((xpr = xp.right) != null && xpr.red) {\n-                        xpr.red = false;\n-                        xp.red = true;\n-                        root = rotateLeft(root, xp);\n-                        xpr = (xp = x.parent) == null ? null : xp.right;\n-                    }\n-                    if (xpr == null) {\n-                        x = xp;\n-                    } else {\n-                        TreeNode<K,V> sl = xpr.left, sr = xpr.right;\n-                        if ((sr == null || !sr.red) &&\n-                            (sl == null || !sl.red)) {\n-                            xpr.red = true;\n-                            x = xp;\n-                        }\n-                        else {\n-                            if (sr == null || !sr.red) {\n-                                if (sl != null) {\n-                                    sl.red = false;\n-                                }\n-                                xpr.red = true;\n-                                root = rotateRight(root, xpr);\n-                                xpr = (xp = x.parent) == null ?\n-                                    null : xp.right;\n-                            }\n-                            if (xpr != null) {\n-                                xpr.red = xp == null ? false : xp.red;\n-                                if ((sr = xpr.right) != null) {\n-                                    sr.red = false;\n-                                }\n-                            }\n-                            if (xp != null) {\n-                                xp.red = false;\n-                                root = rotateLeft(root, xp);\n-                            }\n-                            x = root;\n-                        }\n-                    }\n-                }\n-                else { // symmetric\n-                    if (xpl != null && xpl.red) {\n-                        xpl.red = false;\n-                        xp.red = true;\n-                        root = rotateRight(root, xp);\n-                        xpl = (xp = x.parent) == null ? null : xp.left;\n-                    }\n-                    if (xpl == null) {\n-                        x = xp;\n-                    } else {\n-                        TreeNode<K,V> sl = xpl.left, sr = xpl.right;\n-                        if ((sl == null || !sl.red) &&\n-                            (sr == null || !sr.red)) {\n-                            xpl.red = true;\n-                            x = xp;\n-                        }\n-                        else {\n-                            if (sl == null || !sl.red) {\n-                                if (sr != null) {\n-                                    sr.red = false;\n-                                }\n-                                xpl.red = true;\n-                                root = rotateLeft(root, xpl);\n-                                xpl = (xp = x.parent) == null ?\n-                                    null : xp.left;\n-                            }\n-                            if (xpl != null) {\n-                                xpl.red = xp == null ? false : xp.red;\n-                                if ((sl = xpl.left) != null) {\n-                                    sl.red = false;\n-                                }\n-                            }\n-                            if (xp != null) {\n-                                xp.red = false;\n-                                root = rotateRight(root, xp);\n-                            }\n-                            x = root;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        /**\n-         * Recursive invariant check\n-         */\n-        static <K,V> boolean checkInvariants(TreeNode<K,V> t) {\n-            TreeNode<K,V> tp = t.parent, tl = t.left, tr = t.right,\n-                tb = t.prev, tn = (TreeNode<K,V>)t.next;\n-            if (tb != null && tb.next != t) {\n-                return false;\n-            }\n-            if (tn != null && tn.prev != t) {\n-                return false;\n-            }\n-            if (tp != null && t != tp.left && t != tp.right) {\n-                return false;\n-            }\n-            if (tl != null && (tl.parent != t || tl.hash > t.hash)) {\n-                return false;\n-            }\n-            if (tr != null && (tr.parent != t || tr.hash < t.hash)) {\n-                return false;\n-            }\n-            if (t.red && tl != null && tl.red && tr != null && tr.red) {\n-                return false;\n-            }\n-            if (tl != null && !checkInvariants(tl)) {\n-                return false;\n-            }\n-            if (tr != null && !checkInvariants(tr)) {\n-                return false;\n-            }\n-            return true;\n-        }\n-\n-        private static final sun.misc.Unsafe U;\n-        private static final long LOCKSTATE;\n-        static {\n-            try {\n-                U = getUnsafe();\n-                Class<?> k = TreeBin.class;\n-                LOCKSTATE = U.objectFieldOffset\n-                    (k.getDeclaredField(\"lockState\"));\n-            } catch (Exception e) {\n-                throw new Error(e);\n-            }\n-        }\n-    }\n-\n-    /* ----------------Table Traversal -------------- */\n-\n-    /**\n-     * Encapsulates traversal for methods such as containsValue; also\n-     * serves as a base class for other iterators and spliterators.\n-     *\n-     * Method advance visits once each still-valid node that was\n-     * reachable upon iterator construction. It might miss some that\n-     * were added to a bin after the bin was visited, which is OK wrt\n-     * consistency guarantees. Maintaining this property in the face\n-     * of possible ongoing resizes requires a fair amount of\n-     * bookkeeping state that is difficult to optimize away amidst\n-     * volatile accesses.  Even so, traversal maintains reasonable\n-     * throughput.\n-     *\n-     * Normally, iteration proceeds bin-by-bin traversing lists.\n-     * However, if the table has been resized, then all future steps\n-     * must traverse both the bin at the current index as well as at\n-     * (index + baseSize); and so on for further resizings. To\n-     * paranoically cope with potential sharing by users of iterators\n-     * across threads, iteration terminates if a bounds checks fails\n-     * for a table read.\n-     */\n-    static class Traverser<K,V> {\n-        Node<K,V>[] tab;        // current table; updated if resized\n-        Node<K,V> next;         // the next entry to use\n-        int index;              // index of bin to use next\n-        int baseIndex;          // current index of initial table\n-        int baseLimit;          // index bound for initial table\n-        final int baseSize;     // initial table size\n-\n-        Traverser(Node<K,V>[] tab, int size, int index, int limit) {\n-            this.tab = tab;\n-            this.baseSize = size;\n-            this.baseIndex = this.index = index;\n-            this.baseLimit = limit;\n-            this.next = null;\n-        }\n-\n-        /**\n-         * Advances if possible, returning next valid node, or null if none.\n-         */\n-        final Node<K,V> advance() {\n-            Node<K,V> e;\n-            if ((e = this.next) != null) {\n-                e = e.next;\n-            }\n-            for (;;) {\n-                Node<K,V>[] t; int i, n; K ek;  // must use locals in checks\n-                if (e != null) {\n-                    return this.next = e;\n-                }\n-                if (this.baseIndex >= this.baseLimit || (t = this.tab) == null ||\n-                    (n = t.length) <= (i = this.index) || i < 0) {\n-                    return this.next = null;\n-                }\n-                if ((e = tabAt(t, this.index)) != null && e.hash < 0) {\n-                    if (e instanceof ForwardingNode) {\n-                        this.tab = ((ForwardingNode<K,V>)e).nextTable;\n-                        e = null;\n-                        continue;\n-                    }\n-                    else if (e instanceof TreeBin) {\n-                        e = ((TreeBin<K,V>)e).first;\n-                    } else {\n-                        e = null;\n-                    }\n-                }\n-                if ((this.index += this.baseSize) >= n)\n-                 {\n-                    this.index = ++this.baseIndex;    // visit upper slots if present\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Base of key, value, and entry Iterators. Adds fields to\n-     * Traverser to support iterator.remove.\n-     */\n-    static class BaseIterator<K,V> extends Traverser<K,V> {\n-        final ConcurrentHashMapV8<K,V> map;\n-        Node<K,V> lastReturned;\n-        BaseIterator(Node<K,V>[] tab, int size, int index, int limit,\n-                    ConcurrentHashMapV8<K,V> map) {\n-            super(tab, size, index, limit);\n-            this.map = map;\n-            advance();\n-        }\n-\n-        public final boolean hasNext() { return this.next != null; }\n-        public final boolean hasMoreElements() { return this.next != null; }\n-\n-        public final void remove() {\n-            Node<K,V> p;\n-            if ((p = this.lastReturned) == null) {\n-                throw new IllegalStateException();\n-            }\n-            this.lastReturned = null;\n-            this.map.replaceNode(p.key, null, null);\n-        }\n-    }\n-\n-    static final class KeyIterator<K,V> extends BaseIterator<K,V>\n-        implements Iterator<K>, Enumeration<K> {\n-        KeyIterator(Node<K,V>[] tab, int index, int size, int limit,\n-                    ConcurrentHashMapV8<K,V> map) {\n-            super(tab, index, size, limit, map);\n-        }\n-\n-        @Override\n-        public final K next() {\n-            Node<K,V> p;\n-            if ((p = this.next) == null) {\n-                throw new NoSuchElementException();\n-            }\n-            K k = p.key;\n-            this.lastReturned = p;\n-            advance();\n-            return k;\n-        }\n-\n-        @Override\n-        public final K nextElement() { return next(); }\n-    }\n-\n-    static final class ValueIterator<K,V> extends BaseIterator<K,V>\n-        implements Iterator<V>, Enumeration<V> {\n-        ValueIterator(Node<K,V>[] tab, int index, int size, int limit,\n-                      ConcurrentHashMapV8<K,V> map) {\n-            super(tab, index, size, limit, map);\n-        }\n-\n-        @Override\n-        public final V next() {\n-            Node<K,V> p;\n-            if ((p = this.next) == null) {\n-                throw new NoSuchElementException();\n-            }\n-            V v = p.val;\n-            this.lastReturned = p;\n-            advance();\n-            return v;\n-        }\n-\n-        @Override\n-        public final V nextElement() { return next(); }\n-    }\n-\n-    static final class EntryIterator<K,V> extends BaseIterator<K,V>\n-        implements Iterator<Map.Entry<K,V>> {\n-        EntryIterator(Node<K,V>[] tab, int index, int size, int limit,\n-                      ConcurrentHashMapV8<K,V> map) {\n-            super(tab, index, size, limit, map);\n-        }\n-\n-        @Override\n-        public final Map.Entry<K,V> next() {\n-            Node<K,V> p;\n-            if ((p = this.next) == null) {\n-                throw new NoSuchElementException();\n-            }\n-            K k = p.key;\n-            V v = p.val;\n-            this.lastReturned = p;\n-            advance();\n-            return new MapEntry<K,V>(k, v, this.map);\n-        }\n-    }\n-\n-    /**\n-     * Exported Entry for EntryIterator\n-     */\n-    static final class MapEntry<K,V> implements Map.Entry<K,V> {\n-        final K key; // non-null\n-        V val;       // non-null\n-        final ConcurrentHashMapV8<K,V> map;\n-        MapEntry(K key, V val, ConcurrentHashMapV8<K,V> map) {\n-            this.key = key;\n-            this.val = val;\n-            this.map = map;\n-        }\n-        @Override\n-        public K getKey()        { return this.key; }\n-        @Override\n-        public V getValue()      { return this.val; }\n-        @Override\n-        public int hashCode()    { return this.key.hashCode() ^ this.val.hashCode(); }\n-        @Override\n-        public String toString() { return this.key + \"=\" + this.val; }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            Object k, v; Map.Entry<?,?> e;\n-            return o instanceof Map.Entry &&\n-                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&\n-                    (v = e.getValue()) != null &&\n-                    (k == this.key || k.equals(this.key)) &&\n-                    (v == this.val || v.equals(this.val));\n-        }\n-\n-        /**\n-         * Sets our entry's value and writes through to the map. The\n-         * value to return is somewhat arbitrary here. Since we do not\n-         * necessarily track asynchronous changes, the most recent\n-         * \"previous\" value could be different from what we return (or\n-         * could even have been removed, in which case the put will\n-         * re-establish). We do not and cannot guarantee more.\n-         */\n-        @Override\n-        public V setValue(V value) {\n-            if (value == null) {\n-                throw new NullPointerException();\n-            }\n-            V v = this.val;\n-            this.val = value;\n-            this.map.put(this.key, value);\n-            return v;\n-        }\n-    }\n-\n-    static final class KeySpliterator<K,V> extends Traverser<K,V>\n-        implements ConcurrentHashMapSpliterator<K> {\n-        long est;               // size estimate\n-        KeySpliterator(Node<K,V>[] tab, int size, int index, int limit,\n-                       long est) {\n-            super(tab, size, index, limit);\n-            this.est = est;\n-        }\n-\n-        @Override\n-        public ConcurrentHashMapSpliterator<K> trySplit() {\n-            int i, f, h;\n-            return (h = (i = this.baseIndex) + (f = this.baseLimit) >>> 1) <= i ? null :\n-                new KeySpliterator<K,V>(this.tab, this.baseSize, this.baseLimit = h,\n-                                        f, this.est >>>= 1);\n-        }\n-\n-        @Override\n-        public void forEachRemaining(Action<? super K> action) {\n-            if (action == null) {\n-                throw new NullPointerException();\n-            }\n-            for (Node<K,V> p; (p = advance()) != null;) {\n-                action.apply(p.key);\n-            }\n-        }\n-\n-        @Override\n-        public boolean tryAdvance(Action<? super K> action) {\n-            if (action == null) {\n-                throw new NullPointerException();\n-            }\n-            Node<K,V> p;\n-            if ((p = advance()) == null) {\n-                return false;\n-            }\n-            action.apply(p.key);\n-            return true;\n-        }\n-\n-        @Override\n-        public long estimateSize() { return this.est; }\n-\n-    }\n-\n-    static final class ValueSpliterator<K,V> extends Traverser<K,V>\n-        implements ConcurrentHashMapSpliterator<V> {\n-        long est;               // size estimate\n-        ValueSpliterator(Node<K,V>[] tab, int size, int index, int limit,\n-                         long est) {\n-            super(tab, size, index, limit);\n-            this.est = est;\n-        }\n-\n-        @Override\n-        public ConcurrentHashMapSpliterator<V> trySplit() {\n-            int i, f, h;\n-            return (h = (i = this.baseIndex) + (f = this.baseLimit) >>> 1) <= i ? null :\n-                new ValueSpliterator<K,V>(this.tab, this.baseSize, this.baseLimit = h,\n-                                          f, this.est >>>= 1);\n-        }\n-\n-        @Override\n-        public void forEachRemaining(Action<? super V> action) {\n-            if (action == null) {\n-                throw new NullPointerException();\n-            }\n-            for (Node<K,V> p; (p = advance()) != null;) {\n-                action.apply(p.val);\n-            }\n-        }\n-\n-        @Override\n-        public boolean tryAdvance(Action<? super V> action) {\n-            if (action == null) {\n-                throw new NullPointerException();\n-            }\n-            Node<K,V> p;\n-            if ((p = advance()) == null) {\n-                return false;\n-            }\n-            action.apply(p.val);\n-            return true;\n-        }\n-\n-        @Override\n-        public long estimateSize() { return this.est; }\n-\n-    }\n-\n-    static final class EntrySpliterator<K,V> extends Traverser<K,V>\n-        implements ConcurrentHashMapSpliterator<Map.Entry<K,V>> {\n-        final ConcurrentHashMapV8<K,V> map; // To export MapEntry\n-        long est;               // size estimate\n-        EntrySpliterator(Node<K,V>[] tab, int size, int index, int limit,\n-                         long est, ConcurrentHashMapV8<K,V> map) {\n-            super(tab, size, index, limit);\n-            this.map = map;\n-            this.est = est;\n-        }\n-\n-        @Override\n-        public ConcurrentHashMapSpliterator<Map.Entry<K,V>> trySplit() {\n-            int i, f, h;\n-            return (h = (i = this.baseIndex) + (f = this.baseLimit) >>> 1) <= i ? null :\n-                new EntrySpliterator<K,V>(this.tab, this.baseSize, this.baseLimit = h,\n-                                          f, this.est >>>= 1, this.map);\n-        }\n-\n-        @Override\n-        public void forEachRemaining(Action<? super Map.Entry<K,V>> action) {\n-            if (action == null) {\n-                throw new NullPointerException();\n-            }\n-            for (Node<K,V> p; (p = advance()) != null; ) {\n-                action.apply(new MapEntry<K,V>(p.key, p.val, this.map));\n-            }\n-        }\n-\n-        @Override\n-        public boolean tryAdvance(Action<? super Map.Entry<K,V>> action) {\n-            if (action == null) {\n-                throw new NullPointerException();\n-            }\n-            Node<K,V> p;\n-            if ((p = advance()) == null) {\n-                return false;\n-            }\n-            action.apply(new MapEntry<K,V>(p.key, p.val, this.map));\n-            return true;\n-        }\n-\n-        @Override\n-        public long estimateSize() { return this.est; }\n-\n-    }\n-\n-    /* ----------------Views -------------- */\n-\n-    /**\n-     * Base class for views.\n-     */\n-    abstract static class CollectionView<K,V,E>\n-        implements Collection<E>, java.io.Serializable {\n-        private static final long serialVersionUID = 7249069246763182397L;\n-        final ConcurrentHashMapV8<K,V> map;\n-        CollectionView(ConcurrentHashMapV8<K,V> map)  { this.map = map; }\n-\n-        /**\n-         * Returns the map backing this view.\n-         *\n-         * @return the map backing this view\n-         */\n-        public ConcurrentHashMapV8<K,V> getMap() { return this.map; }\n-\n-        /**\n-         * Removes all of the elements from this view, by removing all\n-         * the mappings from the map backing this view.\n-         */\n-        @Override\n-        public final void clear()      { this.map.clear(); }\n-        @Override\n-        public final int size()        { return this.map.size(); }\n-        @Override\n-        public final boolean isEmpty() { return this.map.isEmpty(); }\n-\n-        // implementations below rely on concrete classes supplying these\n-        // abstract methods\n-        /**\n-         * Returns a \"weakly consistent\" iterator that will never\n-         * throw {@link ConcurrentModificationException}, and\n-         * guarantees to traverse elements as they existed upon\n-         * construction of the iterator, and may (but is not\n-         * guaranteed to) reflect any modifications subsequent to\n-         * construction.\n-         */\n-        @Override\n-        public abstract Iterator<E> iterator();\n-        @Override\n-        public abstract boolean contains(Object o);\n-        @Override\n-        public abstract boolean remove(Object o);\n-\n-        private static final String oomeMsg = \"Required array size too large\";\n-\n-        @Override\n-        public final Object[] toArray() {\n-            long sz = this.map.mappingCount();\n-            if (sz > MAX_ARRAY_SIZE) {\n-                throw new OutOfMemoryError(oomeMsg);\n-            }\n-            int n = (int)sz;\n-            Object[] r = new Object[n];\n-            int i = 0;\n-            for (E e : this) {\n-                if (i == n) {\n-                    if (n >= MAX_ARRAY_SIZE) {\n-                        throw new OutOfMemoryError(oomeMsg);\n-                    }\n-                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1) {\n-                        n = MAX_ARRAY_SIZE;\n-                    } else {\n-                        n += (n >>> 1) + 1;\n-                    }\n-                    r = Arrays.copyOf(r, n);\n-                }\n-                r[i++] = e;\n-            }\n-            return i == n ? r : Arrays.copyOf(r, i);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public final <T> T[] toArray(T[] a) {\n-            long sz = this.map.mappingCount();\n-            if (sz > MAX_ARRAY_SIZE) {\n-                throw new OutOfMemoryError(oomeMsg);\n-            }\n-            int m = (int)sz;\n-            T[] r = a.length >= m ? a :\n-                (T[])java.lang.reflect.Array\n-                .newInstance(a.getClass().getComponentType(), m);\n-            int n = r.length;\n-            int i = 0;\n-            for (E e : this) {\n-                if (i == n) {\n-                    if (n >= MAX_ARRAY_SIZE) {\n-                        throw new OutOfMemoryError(oomeMsg);\n-                    }\n-                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1) {\n-                        n = MAX_ARRAY_SIZE;\n-                    } else {\n-                        n += (n >>> 1) + 1;\n-                    }\n-                    r = Arrays.copyOf(r, n);\n-                }\n-                r[i++] = (T)e;\n-            }\n-            if (a == r && i < n) {\n-                r[i] = null; // null-terminate\n-                return r;\n-            }\n-            return i == n ? r : Arrays.copyOf(r, i);\n-        }\n-\n-        /**\n-         * Returns a string representation of this collection.\n-         * The string representation consists of the string representations\n-         * of the collection's elements in the order they are returned by\n-         * its iterator, enclosed in square brackets ({@code \"[]\"}).\n-         * Adjacent elements are separated by the characters {@code \", \"}\n-         * (comma and space).  Elements are converted to strings as by\n-         * {@link String#valueOf(Object)}.\n-         *\n-         * @return a string representation of this collection\n-         */\n-        @Override\n-        public final String toString() {\n-            StringBuilder sb = new StringBuilder();\n-            sb.append('[');\n-            Iterator<E> it = iterator();\n-            if (it.hasNext()) {\n-                for (;;) {\n-                    Object e = it.next();\n-                    sb.append(e == this ? \"(this Collection)\" : e);\n-                    if (!it.hasNext()) {\n-                        break;\n-                    }\n-                    sb.append(',').append(' ');\n-                }\n-            }\n-            return sb.append(']').toString();\n-        }\n-\n-        @Override\n-        public final boolean containsAll(Collection<?> c) {\n-            if (c != this) {\n-                for (Object e : c) {\n-                    if (e == null || !contains(e)) {\n-                        return false;\n-                    }\n-                }\n-            }\n-            return true;\n-        }\n-\n-        @Override\n-        public final boolean removeAll(Collection<?> c) {\n-            boolean modified = false;\n-            for (Iterator<E> it = iterator(); it.hasNext();) {\n-                if (c.contains(it.next())) {\n-                    it.remove();\n-                    modified = true;\n-                }\n-            }\n-            return modified;\n-        }\n-\n-        @Override\n-        public final boolean retainAll(Collection<?> c) {\n-            boolean modified = false;\n-            for (Iterator<E> it = iterator(); it.hasNext();) {\n-                if (!c.contains(it.next())) {\n-                    it.remove();\n-                    modified = true;\n-                }\n-            }\n-            return modified;\n-        }\n-\n-    }\n-\n-    /**\n-     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in\n-     * which additions may optionally be enabled by mapping to a\n-     * common value.  This class cannot be directly instantiated.\n-     * See {@link #keySet() keySet()},\n-     * {@link #keySet(Object) keySet(V)},\n-     * {@link #newKeySet() newKeySet()},\n-     * {@link #newKeySet(int) newKeySet(int)}.\n-     *\n-     * @since 1.8\n-     */\n-    public static class KeySetView<K,V> extends CollectionView<K,V,K>\n-        implements Set<K>, java.io.Serializable {\n-        private static final long serialVersionUID = 7249069246763182397L;\n-        private final V value;\n-        KeySetView(ConcurrentHashMapV8<K,V> map, V value) {  // non-public\n-            super(map);\n-            this.value = value;\n-        }\n-\n-        /**\n-         * Returns the default mapped value for additions,\n-         * or {@code null} if additions are not supported.\n-         *\n-         * @return the default mapped value for additions, or {@code null}\n-         * if not supported\n-         */\n-        public V getMappedValue() { return this.value; }\n-\n-        /**\n-         * {@inheritDoc}\n-         * @throws NullPointerException if the specified key is null\n-         */\n-        @Override\n-        public boolean contains(Object o) { return this.map.containsKey(o); }\n-\n-        /**\n-         * Removes the key from this map view, by removing the key (and its\n-         * corresponding value) from the backing map.  This method does\n-         * nothing if the key is not in the map.\n-         *\n-         * @param  o the key to be removed from the backing map\n-         * @return {@code true} if the backing map contained the specified key\n-         * @throws NullPointerException if the specified key is null\n-         */\n-        @Override\n-        public boolean remove(Object o) { return this.map.remove(o) != null; }\n-\n-        /**\n-         * @return an iterator over the keys of the backing map\n-         */\n-        @Override\n-        public Iterator<K> iterator() {\n-            Node<K,V>[] t;\n-            ConcurrentHashMapV8<K,V> m = this.map;\n-            int f = (t = m.table) == null ? 0 : t.length;\n-            return new KeyIterator<K,V>(t, f, 0, f, m);\n-        }\n-\n-        /**\n-         * Adds the specified key to this set view by mapping the key to\n-         * the default mapped value in the backing map, if defined.\n-         *\n-         * @param e key to be added\n-         * @return {@code true} if this set changed as a result of the call\n-         * @throws NullPointerException if the specified key is null\n-         * @throws UnsupportedOperationException if no default mapped value\n-         * for additions was provided\n-         */\n-        @Override\n-        public boolean add(K e) {\n-            V v;\n-            if ((v = this.value) == null) {\n-                throw new UnsupportedOperationException();\n-            }\n-            return this.map.putVal(e, v, true) == null;\n-        }\n-\n-        /**\n-         * Adds all of the elements in the specified collection to this set,\n-         * as if by calling {@link #add} on each one.\n-         *\n-         * @param c the elements to be inserted into this set\n-         * @return {@code true} if this set changed as a result of the call\n-         * @throws NullPointerException if the collection or any of its\n-         * elements are {@code null}\n-         * @throws UnsupportedOperationException if no default mapped value\n-         * for additions was provided\n-         */\n-        @Override\n-        public boolean addAll(Collection<? extends K> c) {\n-            boolean added = false;\n-            V v;\n-            if ((v = this.value) == null) {\n-                throw new UnsupportedOperationException();\n-            }\n-            for (K e : c) {\n-                if (this.map.putVal(e, v, true) == null) {\n-                    added = true;\n-                }\n-            }\n-            return added;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            int h = 0;\n-            for (K e : this) {\n-                h += e.hashCode();\n-            }\n-            return h;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            Set<?> c;\n-            return o instanceof Set &&\n-                    ((c = (Set<?>)o) == this ||\n-                     containsAll(c) && c.containsAll(this));\n-        }\n-\n-        public ConcurrentHashMapSpliterator<K> spliterator() {\n-            Node<K,V>[] t;\n-            ConcurrentHashMapV8<K,V> m = this.map;\n-            long n = m.sumCount();\n-            int f = (t = m.table) == null ? 0 : t.length;\n-            return new KeySpliterator<K,V>(t, f, 0, f, n < 0L ? 0L : n);\n-        }\n-\n-        public void forEach(Action<? super K> action) {\n-            if (action == null) {\n-                throw new NullPointerException();\n-            }\n-            Node<K,V>[] t;\n-            if ((t = this.map.table) != null) {\n-                Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n-                for (Node<K,V> p; (p = it.advance()) != null; ) {\n-                    action.apply(p.key);\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * A view of a ConcurrentHashMapV8 as a {@link Collection} of\n-     * values, in which additions are disabled. This class cannot be\n-     * directly instantiated. See {@link #values()}.\n-     */\n-    static final class ValuesView<K,V> extends CollectionView<K,V,V>\n-        implements Collection<V>, java.io.Serializable {\n-        private static final long serialVersionUID = 2249069246763182397L;\n-        ValuesView(ConcurrentHashMapV8<K,V> map) { super(map); }\n-        @Override\n-        public final boolean contains(Object o) {\n-            return this.map.containsValue(o);\n-        }\n-\n-        @Override\n-        public final boolean remove(Object o) {\n-            if (o != null) {\n-                for (Iterator<V> it = iterator(); it.hasNext();) {\n-                    if (o.equals(it.next())) {\n-                        it.remove();\n-                        return true;\n-                    }\n-                }\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        public final Iterator<V> iterator() {\n-            ConcurrentHashMapV8<K,V> m = this.map;\n-            Node<K,V>[] t;\n-            int f = (t = m.table) == null ? 0 : t.length;\n-            return new ValueIterator<K,V>(t, f, 0, f, m);\n-        }\n-\n-        @Override\n-        public final boolean add(V e) {\n-            throw new UnsupportedOperationException();\n-        }\n-        @Override\n-        public final boolean addAll(Collection<? extends V> c) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public ConcurrentHashMapSpliterator<V> spliterator() {\n-            Node<K,V>[] t;\n-            ConcurrentHashMapV8<K,V> m = this.map;\n-            long n = m.sumCount();\n-            int f = (t = m.table) == null ? 0 : t.length;\n-            return new ValueSpliterator<K,V>(t, f, 0, f, n < 0L ? 0L : n);\n-        }\n-\n-        public void forEach(Action<? super V> action) {\n-            if (action == null) {\n-                throw new NullPointerException();\n-            }\n-            Node<K,V>[] t;\n-            if ((t = this.map.table) != null) {\n-                Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n-                for (Node<K,V> p; (p = it.advance()) != null; ) {\n-                    action.apply(p.val);\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)\n-     * entries.  This class cannot be directly instantiated. See\n-     * {@link #entrySet()}.\n-     */\n-    static final class EntrySetView<K,V> extends CollectionView<K,V,Map.Entry<K,V>>\n-        implements Set<Map.Entry<K,V>>, java.io.Serializable {\n-        private static final long serialVersionUID = 2249069246763182397L;\n-        EntrySetView(ConcurrentHashMapV8<K,V> map) { super(map); }\n-\n-        @Override\n-        public boolean contains(Object o) {\n-            Object k, v, r; Map.Entry<?,?> e;\n-            return o instanceof Map.Entry &&\n-                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&\n-                    (r = this.map.get(k)) != null &&\n-                    (v = e.getValue()) != null &&\n-                    (v == r || v.equals(r));\n-        }\n-\n-        @Override\n-        public boolean remove(Object o) {\n-            Object k, v; Map.Entry<?,?> e;\n-            return o instanceof Map.Entry &&\n-                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&\n-                    (v = e.getValue()) != null &&\n-                    this.map.remove(k, v);\n-        }\n-\n-        /**\n-         * @return an iterator over the entries of the backing map\n-         */\n-        @Override\n-        public Iterator<Map.Entry<K,V>> iterator() {\n-            ConcurrentHashMapV8<K,V> m = this.map;\n-            Node<K,V>[] t;\n-            int f = (t = m.table) == null ? 0 : t.length;\n-            return new EntryIterator<K,V>(t, f, 0, f, m);\n-        }\n-\n-        @Override\n-        public boolean add(Entry<K,V> e) {\n-            return this.map.putVal(e.getKey(), e.getValue(), false) == null;\n-        }\n-\n-        @Override\n-        public boolean addAll(Collection<? extends Entry<K,V>> c) {\n-            boolean added = false;\n-            for (Entry<K,V> e : c) {\n-                if (add(e)) {\n-                    added = true;\n-                }\n-            }\n-            return added;\n-        }\n-\n-        @Override\n-        public final int hashCode() {\n-            int h = 0;\n-            Node<K,V>[] t;\n-            if ((t = this.map.table) != null) {\n-                Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n-                for (Node<K,V> p; (p = it.advance()) != null; ) {\n-                    h += p.hashCode();\n-                }\n-            }\n-            return h;\n-        }\n-\n-        @Override\n-        public final boolean equals(Object o) {\n-            Set<?> c;\n-            return o instanceof Set &&\n-                    ((c = (Set<?>)o) == this ||\n-                     containsAll(c) && c.containsAll(this));\n-        }\n-\n-        public ConcurrentHashMapSpliterator<Map.Entry<K,V>> spliterator() {\n-            Node<K,V>[] t;\n-            ConcurrentHashMapV8<K,V> m = this.map;\n-            long n = m.sumCount();\n-            int f = (t = m.table) == null ? 0 : t.length;\n-            return new EntrySpliterator<K,V>(t, f, 0, f, n < 0L ? 0L : n, m);\n-        }\n-\n-        public void forEach(Action<? super Map.Entry<K,V>> action) {\n-            if (action == null) {\n-                throw new NullPointerException();\n-            }\n-            Node<K,V>[] t;\n-            if ((t = this.map.table) != null) {\n-                Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n-                for (Node<K,V> p; (p = it.advance()) != null; ) {\n-                    action.apply(new MapEntry<K,V>(p.key, p.val, this.map));\n-                }\n-            }\n-        }\n-\n-    }\n-\n-    /* ---------------- Counters -------------- */\n-\n-    // Adapted from LongAdder and Striped64.\n-    // See their internal docs for explanation.\n-\n-    // A padded cell for distributing counts\n-    static final class CounterCell {\n-        volatile long p0, p1, p2, p3, p4, p5, p6;\n-        volatile long value;\n-        volatile long q0, q1, q2, q3, q4, q5, q6;\n-        CounterCell(long x) { this.value = x; }\n-    }\n-\n-    /**\n-     * Holder for the thread-local hash code determining which\n-     * CounterCell to use. The code is initialized via the\n-     * counterHashCodeGenerator, but may be moved upon collisions.\n-     */\n-    static final class CounterHashCode {\n-        int code;\n-    }\n-\n-    /**\n-     * Generates initial value for per-thread CounterHashCodes.\n-     */\n-    static final AtomicInteger counterHashCodeGenerator = new AtomicInteger();\n-\n-    /**\n-     * Increment for counterHashCodeGenerator. See class ThreadLocal\n-     * for explanation.\n-     */\n-    static final int SEED_INCREMENT = 0x61c88647;\n-\n-    /**\n-     * Per-thread counter hash codes. Shared across all instances.\n-     */\n-    static final ThreadLocal<CounterHashCode> threadCounterHashCode =\n-        new ThreadLocal<CounterHashCode>();\n-\n-\n-    final long sumCount() {\n-        CounterCell[] as = this.counterCells; CounterCell a;\n-        long sum = this.baseCount;\n-        if (as != null) {\n-            for (int i = 0; i < as.length; ++i) {\n-                if ((a = as[i]) != null) {\n-                    sum += a.value;\n-                }\n-            }\n-        }\n-        return sum;\n-    }\n-\n-    // See LongAdder version for explanation\n-    private final void fullAddCount(long x, CounterHashCode hc,\n-                                    boolean wasUncontended) {\n-        int h;\n-        if (hc == null) {\n-            hc = new CounterHashCode();\n-            int s = counterHashCodeGenerator.addAndGet(SEED_INCREMENT);\n-            h = hc.code = s == 0 ? 1 : s; // Avoid zero\n-            threadCounterHashCode.set(hc);\n-        } else {\n-            h = hc.code;\n-        }\n-        boolean collide = false;                // True if last slot nonempty\n-        for (;;) {\n-            CounterCell[] as; CounterCell a; int n; long v;\n-            if ((as = this.counterCells) != null && (n = as.length) > 0) {\n-                if ((a = as[n - 1 & h]) == null) {\n-                    if (this.cellsBusy == 0) {            // Try to attach new Cell\n-                        CounterCell r = new CounterCell(x); // Optimistic create\n-                        if (this.cellsBusy == 0 &&\n-                            U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {\n-                            boolean created = false;\n-                            try {               // Recheck under lock\n-                                CounterCell[] rs; int m, j;\n-                                if ((rs = this.counterCells) != null &&\n-                                    (m = rs.length) > 0 &&\n-                                    rs[j = m - 1 & h] == null) {\n-                                    rs[j] = r;\n-                                    created = true;\n-                                }\n-                            } finally {\n-                                this.cellsBusy = 0;\n-                            }\n-                            if (created) {\n-                                break;\n-                            }\n-                            continue;           // Slot is now non-empty\n-                        }\n-                    }\n-                    collide = false;\n-                }\n-                else if (!wasUncontended) {\n-                    wasUncontended = true;      // Continue after rehash\n-                } else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)) {\n-                    break;\n-                } else if (this.counterCells != as || n >= NCPU) {\n-                    collide = false;            // At max size or stale\n-                } else if (!collide) {\n-                    collide = true;\n-                } else if (this.cellsBusy == 0 &&\n-                         U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {\n-                    try {\n-                        if (this.counterCells == as) {// Expand table unless stale\n-                            CounterCell[] rs = new CounterCell[n << 1];\n-                            for (int i = 0; i < n; ++i) {\n-                                rs[i] = as[i];\n-                            }\n-                            this.counterCells = rs;\n-                        }\n-                    } finally {\n-                        this.cellsBusy = 0;\n-                    }\n-                    collide = false;\n-                    continue;                   // Retry with expanded table\n-                }\n-                h ^= h << 13;                   // Rehash\n-                h ^= h >>> 17;\n-                h ^= h << 5;\n-            }\n-            else if (this.cellsBusy == 0 && this.counterCells == as &&\n-                     U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {\n-                boolean init = false;\n-                try {                           // Initialize table\n-                    if (this.counterCells == as) {\n-                        CounterCell[] rs = new CounterCell[2];\n-                        rs[h & 1] = new CounterCell(x);\n-                        this.counterCells = rs;\n-                        init = true;\n-                    }\n-                } finally {\n-                    this.cellsBusy = 0;\n-                }\n-                if (init) {\n-                    break;\n-                }\n-            }\n-            else if (U.compareAndSwapLong(this, BASECOUNT, v = this.baseCount, v + x))\n-             {\n-                break;                          // Fall back on using base\n-            }\n-        }\n-        hc.code = h;                            // Record index for next time\n-    }\n-\n-    // Unsafe mechanics\n-    private static final sun.misc.Unsafe U;\n-    private static final long SIZECTL;\n-    private static final long TRANSFERINDEX;\n-    private static final long TRANSFERORIGIN;\n-    private static final long BASECOUNT;\n-    private static final long CELLSBUSY;\n-    private static final long CELLVALUE;\n-    private static final long ABASE;\n-    private static final int ASHIFT;\n-\n-    static {\n-        try {\n-            U = getUnsafe();\n-            Class<?> k = ConcurrentHashMapV8.class;\n-            SIZECTL = U.objectFieldOffset\n-                (k.getDeclaredField(\"sizeCtl\"));\n-            TRANSFERINDEX = U.objectFieldOffset\n-                (k.getDeclaredField(\"transferIndex\"));\n-            TRANSFERORIGIN = U.objectFieldOffset\n-                (k.getDeclaredField(\"transferOrigin\"));\n-            BASECOUNT = U.objectFieldOffset\n-                (k.getDeclaredField(\"baseCount\"));\n-            CELLSBUSY = U.objectFieldOffset\n-                (k.getDeclaredField(\"cellsBusy\"));\n-            Class<?> ck = CounterCell.class;\n-            CELLVALUE = U.objectFieldOffset\n-                (ck.getDeclaredField(\"value\"));\n-            Class<?> ak = Node[].class;\n-            ABASE = U.arrayBaseOffset(ak);\n-            int scale = U.arrayIndexScale(ak);\n-            if ((scale & scale - 1) != 0) {\n-                throw new Error(\"data type scale not a power of two\");\n-            }\n-            ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);\n-        } catch (Exception e) {\n-            throw new Error(e);\n-        }\n-    }\n-\n-    /**\n-     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.\n-     * Replace with a simple call to Unsafe.getUnsafe when integrating\n-     * into a jdk.\n-     *\n-     * @return a sun.misc.Unsafe\n-     */\n-    private static sun.misc.Unsafe getUnsafe() {\n-        try {\n-            return sun.misc.Unsafe.getUnsafe();\n-        } catch (SecurityException tryReflectionInstead) {}\n-        try {\n-            return java.security.AccessController.doPrivileged\n-            (new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {\n-                @Override\n-                public sun.misc.Unsafe run() throws Exception {\n-                    Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\n-                    for (java.lang.reflect.Field f : k.getDeclaredFields()) {\n-                        f.setAccessible(true);\n-                        Object x = f.get(null);\n-                        if (k.isInstance(x)) {\n-                            return k.cast(x);\n-                        }\n-                    }\n-                    throw new NoSuchFieldError(\"the Unsafe\");\n-                }});\n-        } catch (java.security.PrivilegedActionException e) {\n-            throw new RuntimeException(\"Could not initialize intrinsics\",\n-                                       e.getCause());\n-        }\n-    }\n-}\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "395e87210d3c28e1dcfb4c6a0044a43dacedd44d",
        "previous commit hash": "577495b7ec050cdc75d27650b101a259453bcf65",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/StrongConcurrentSet.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.common;\n \n \n+import java.util.HashMap;\n import java.util.Iterator;\n \n /**\n@@ -15,7 +16,7 @@ public class StrongConcurrentSet<T> extends AbstractConcurrentSet<T>{\n \n     public StrongConcurrentSet() {\n         // ConcurrentHashMapV8 is 15%-20% faster than regular ConcurrentHashMap, which is also faster than HashMap.\n-        super(new ConcurrentHashMapV8<T, ISetEntry<T>>());\n+        super(new HashMap<T, ISetEntry<T>>());\n     }\n \n     public Iterator<T> iterator() {\n"
    },
    {
        "commit hash": "395e87210d3c28e1dcfb4c6a0044a43dacedd44d",
        "previous commit hash": "577495b7ec050cdc75d27650b101a259453bcf65",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java",
            "additions": 2,
            "deletions": 4
        },
        "diff content": "@@ -1,14 +1,12 @@\n package net.engio.mbassy.subscription;\n \n import net.engio.mbassy.bus.BusRuntime;\n-import net.engio.mbassy.common.ConcurrentHashMapV8;\n import net.engio.mbassy.common.ReflectionUtils;\n import net.engio.mbassy.common.StrongConcurrentSet;\n import net.engio.mbassy.listener.MessageHandler;\n import net.engio.mbassy.listener.MetadataReader;\n \n import java.util.*;\n-import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;\n import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;\n@@ -57,8 +55,8 @@ public class SubscriptionManager {\n         this.runtime = runtime;\n \n         // ConcurrentHashMapV8 is 15%-20% faster than regular ConcurrentHashMap, which is also faster than HashMap.\n-        subscriptionsPerMessage = new ConcurrentHashMapV8<Class, Collection<Subscription>>(64);\n-        subscriptionsPerListener = new ConcurrentHashMapV8<Class, Collection<Subscription>>(64);\n+        subscriptionsPerMessage = new HashMap<Class, Collection<Subscription>>(64);\n+        subscriptionsPerListener = new HashMap<Class, Collection<Subscription>>(64);\n     }\n \n \n"
    },
    {
        "commit hash": "70ddc3142f86288e3430d2c56cdf21071af1ba5d",
        "previous commit hash": "fdd3a7a310410ae3c18486eeaaa433d17fee6feb",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -62,7 +62,7 @@ public class Subscription {\n \n \n     public void publish(IMessagePublication publication, Object message){\n-        if(listeners.size() > 0)\n+        if(!listeners.isEmpty())\n             dispatcher.dispatch(publication, message, listeners);\n     }\n \n"
    },
    {
        "commit hash": "fdd3a7a310410ae3c18486eeaaa433d17fee6feb",
        "previous commit hash": "0064586be24898f577c1178525b2de9c4b353743",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java",
            "additions": 8,
            "deletions": 1
        },
        "diff content": "@@ -151,7 +151,14 @@ public abstract class AbstractConcurrentSet<T> implements Set<T> {\n \n     @Override\n     public void clear() {\n-        throw new UnsupportedOperationException(\"Not implemented\");\n+        Lock writeLock = this.lock.writeLock();\n+        try {\n+            writeLock.lock();\n+                head = null;\n+                entries.clear();\n+        } finally {\n+            writeLock.unlock();\n+        }\n     }\n \n     @Override\n"
    },
    {
        "commit hash": "fdd3a7a310410ae3c18486eeaaa433d17fee6feb",
        "previous commit hash": "0064586be24898f577c1178525b2de9c4b353743",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java",
            "additions": 20,
            "deletions": 17
        },
        "diff content": "@@ -10,6 +10,8 @@ import net.engio.mbassy.listener.MetadataReader;\n import java.util.*;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;\n \n /**\n  * The subscription managers responsibility is to consistently handle and synchronize the message listener subscription process.\n@@ -55,8 +57,8 @@ public class SubscriptionManager {\n         this.runtime = runtime;\n \n         // ConcurrentHashMapV8 is 15%-20% faster than regular ConcurrentHashMap, which is also faster than HashMap.\n-        subscriptionsPerMessage = new ConcurrentHashMapV8<Class, Collection<Subscription>>(50);\n-        subscriptionsPerListener = new ConcurrentHashMapV8<Class, Collection<Subscription>>(50);\n+        subscriptionsPerMessage = new ConcurrentHashMapV8<Class, Collection<Subscription>>(64);\n+        subscriptionsPerListener = new ConcurrentHashMapV8<Class, Collection<Subscription>>(64);\n     }\n \n \n@@ -78,26 +80,30 @@ public class SubscriptionManager {\n \n     private Collection<Subscription> getSubscriptionsByListener(Object listener) {\n         Collection<Subscription> subscriptions;\n+        ReadLock readLock = readWriteLock.readLock();\n         try {\n-            readWriteLock.readLock().lock();\n+            readLock.lock();\n             subscriptions = subscriptionsPerListener.get(listener.getClass());\n         } finally {\n-            readWriteLock.readLock().unlock();\n+            readLock.unlock();\n         }\n         return subscriptions;\n     }\n \n     public void subscribe(Object listener) {\n         try {\n-            if (isKnownNonListener(listener)) {\n+            Class<?> listenerClass = listener.getClass();\n+\n+            if (nonListeners.contains(listenerClass)) {\n                 return; // early reject of known classes that do not define message handlers\n             }\n+            \n             Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n             // a listener is either subscribed for the first time\n             if (subscriptionsByListener == null) {\n-                List<MessageHandler> messageHandlers = metadataReader.getMessageListener(listener.getClass()).getHandlers();\n+                List<MessageHandler> messageHandlers = metadataReader.getMessageListener(listenerClass).getHandlers();\n                 if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n-                    nonListeners.add(listener.getClass());\n+                    nonListeners.add(listenerClass);\n                     return;\n                 }\n                 subscriptionsByListener = new ArrayDeque<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n@@ -123,8 +129,9 @@ public class SubscriptionManager {\n \n \n     private void subscribe(Object listener, Collection<Subscription> subscriptions) {\n+        WriteLock writeLock = readWriteLock.writeLock();\n         try {\n-            readWriteLock.writeLock().lock();\n+            writeLock.lock();\n             // basically this is a deferred double check\n             // it's an ugly pattern but necessary because atomic upgrade from read to write lock\n             // is not possible\n@@ -149,23 +156,19 @@ public class SubscriptionManager {\n                 }\n             }\n         } finally {\n-            readWriteLock.writeLock().unlock();\n+            writeLock.unlock();\n         }\n \n \n     }\n \n-    private boolean isKnownNonListener(Object listener) {\n-        Class listeningClass = listener.getClass();\n-        return nonListeners.contains(listeningClass);\n-    }\n-\n     // obtain the set of subscriptions for the given message type\n     // Note: never returns null!\n     public Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n         Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n-        try{\n-            readWriteLock.readLock().lock();\n+        ReadLock readLock = readWriteLock.readLock();\n+        try {\n+            readLock.lock();\n \n             if (subscriptionsPerMessage.get(messageType) != null) {\n                 subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n@@ -181,7 +184,7 @@ public class SubscriptionManager {\n                 }\n             }\n         }finally{\n-            readWriteLock.readLock().unlock();\n+            readLock.unlock();\n         }\n         return subscriptions;\n     }\n"
    },
    {
        "commit hash": "3b613c9a91cf85cb7c7ec3a7d39a9e41f14e1734",
        "previous commit hash": "c239103b901e93f88373c10f5231070df460c60c",
        "diff stats": {
            "file_path": ".settings/org.eclipse.jdt.ui.prefs",
            "additions": 0,
            "deletions": 66
        },
        "diff content": "@@ -1,66 +0,0 @@\n-eclipse.preferences.version=1\n-editor_save_participant_org.eclipse.jdt.ui.postsavelistener.cleanup=false\n-formatter_profile=_GoogleStyle\n-formatter_settings_version=12\n-org.eclipse.jdt.ui.exception.name=e\n-org.eclipse.jdt.ui.gettersetter.use.is=false\n-org.eclipse.jdt.ui.keywordthis=false\n-org.eclipse.jdt.ui.overrideannotation=false\n-sp_cleanup.add_default_serial_version_id=true\n-sp_cleanup.add_generated_serial_version_id=false\n-sp_cleanup.add_missing_annotations=true\n-sp_cleanup.add_missing_deprecated_annotations=true\n-sp_cleanup.add_missing_methods=false\n-sp_cleanup.add_missing_nls_tags=false\n-sp_cleanup.add_missing_override_annotations=true\n-sp_cleanup.add_missing_override_annotations_interface_methods=true\n-sp_cleanup.add_serial_version_id=false\n-sp_cleanup.always_use_blocks=true\n-sp_cleanup.always_use_parentheses_in_expressions=false\n-sp_cleanup.always_use_this_for_non_static_field_access=true\n-sp_cleanup.always_use_this_for_non_static_method_access=false\n-sp_cleanup.convert_functional_interfaces=false\n-sp_cleanup.convert_to_enhanced_for_loop=false\n-sp_cleanup.correct_indentation=false\n-sp_cleanup.format_source_code=false\n-sp_cleanup.format_source_code_changes_only=true\n-sp_cleanup.insert_inferred_type_arguments=false\n-sp_cleanup.make_local_variable_final=true\n-sp_cleanup.make_parameters_final=true\n-sp_cleanup.make_private_fields_final=true\n-sp_cleanup.make_type_abstract_if_missing_method=false\n-sp_cleanup.make_variable_declarations_final=false\n-sp_cleanup.never_use_blocks=false\n-sp_cleanup.never_use_parentheses_in_expressions=true\n-sp_cleanup.on_save_use_additional_actions=true\n-sp_cleanup.organize_imports=true\n-sp_cleanup.qualify_static_field_accesses_with_declaring_class=false\n-sp_cleanup.qualify_static_member_accesses_through_instances_with_declaring_class=true\n-sp_cleanup.qualify_static_member_accesses_through_subtypes_with_declaring_class=true\n-sp_cleanup.qualify_static_member_accesses_with_declaring_class=true\n-sp_cleanup.qualify_static_method_accesses_with_declaring_class=false\n-sp_cleanup.remove_private_constructors=true\n-sp_cleanup.remove_redundant_type_arguments=false\n-sp_cleanup.remove_trailing_whitespaces=true\n-sp_cleanup.remove_trailing_whitespaces_all=true\n-sp_cleanup.remove_trailing_whitespaces_ignore_empty=false\n-sp_cleanup.remove_unnecessary_casts=true\n-sp_cleanup.remove_unnecessary_nls_tags=true\n-sp_cleanup.remove_unused_imports=true\n-sp_cleanup.remove_unused_local_variables=false\n-sp_cleanup.remove_unused_private_fields=true\n-sp_cleanup.remove_unused_private_members=false\n-sp_cleanup.remove_unused_private_methods=true\n-sp_cleanup.remove_unused_private_types=true\n-sp_cleanup.sort_members=false\n-sp_cleanup.sort_members_all=false\n-sp_cleanup.use_anonymous_class_creation=false\n-sp_cleanup.use_blocks=true\n-sp_cleanup.use_blocks_only_for_return_and_throw=false\n-sp_cleanup.use_lambda=false\n-sp_cleanup.use_parentheses_in_expressions=true\n-sp_cleanup.use_this_for_non_static_field_access=true\n-sp_cleanup.use_this_for_non_static_field_access_only_if_necessary=false\n-sp_cleanup.use_this_for_non_static_method_access=true\n-sp_cleanup.use_this_for_non_static_method_access_only_if_necessary=true\n-sp_cleanup.use_type_arguments=false\n"
    },
    {
        "commit hash": "c239103b901e93f88373c10f5231070df460c60c",
        "previous commit hash": "50ae4dc05a35b30cf1dde4ee64002a7e09266774",
        "diff stats": {
            "file_path": ".gitignore",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -5,6 +5,9 @@\n .idea/*\n .idea\n \n+# eclipse settings\n+/.settings/\n+\n # Package Files #\n *.war\n *.ear\n@@ -22,6 +25,3 @@ mvn-local-repo/**/*\n release.properties\n /.classpath\n /.project\n-/.settings/org.eclipse.core.resources.prefs\n-/.settings/org.eclipse.jdt.core.prefs\n-/.settings/org.eclipse.m2e.core.prefs\n"
    },
    {
        "commit hash": "4fce93874619bd364c46186e4e335773f752c60a",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": ".settings/org.eclipse.jdt.ui.prefs",
            "additions": 66,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,66 @@\n+eclipse.preferences.version=1\n+editor_save_participant_org.eclipse.jdt.ui.postsavelistener.cleanup=false\n+formatter_profile=_GoogleStyle\n+formatter_settings_version=12\n+org.eclipse.jdt.ui.exception.name=e\n+org.eclipse.jdt.ui.gettersetter.use.is=false\n+org.eclipse.jdt.ui.keywordthis=false\n+org.eclipse.jdt.ui.overrideannotation=false\n+sp_cleanup.add_default_serial_version_id=true\n+sp_cleanup.add_generated_serial_version_id=false\n+sp_cleanup.add_missing_annotations=true\n+sp_cleanup.add_missing_deprecated_annotations=true\n+sp_cleanup.add_missing_methods=false\n+sp_cleanup.add_missing_nls_tags=false\n+sp_cleanup.add_missing_override_annotations=true\n+sp_cleanup.add_missing_override_annotations_interface_methods=true\n+sp_cleanup.add_serial_version_id=false\n+sp_cleanup.always_use_blocks=true\n+sp_cleanup.always_use_parentheses_in_expressions=false\n+sp_cleanup.always_use_this_for_non_static_field_access=true\n+sp_cleanup.always_use_this_for_non_static_method_access=false\n+sp_cleanup.convert_functional_interfaces=false\n+sp_cleanup.convert_to_enhanced_for_loop=false\n+sp_cleanup.correct_indentation=false\n+sp_cleanup.format_source_code=false\n+sp_cleanup.format_source_code_changes_only=true\n+sp_cleanup.insert_inferred_type_arguments=false\n+sp_cleanup.make_local_variable_final=true\n+sp_cleanup.make_parameters_final=true\n+sp_cleanup.make_private_fields_final=true\n+sp_cleanup.make_type_abstract_if_missing_method=false\n+sp_cleanup.make_variable_declarations_final=false\n+sp_cleanup.never_use_blocks=false\n+sp_cleanup.never_use_parentheses_in_expressions=true\n+sp_cleanup.on_save_use_additional_actions=true\n+sp_cleanup.organize_imports=true\n+sp_cleanup.qualify_static_field_accesses_with_declaring_class=false\n+sp_cleanup.qualify_static_member_accesses_through_instances_with_declaring_class=true\n+sp_cleanup.qualify_static_member_accesses_through_subtypes_with_declaring_class=true\n+sp_cleanup.qualify_static_member_accesses_with_declaring_class=true\n+sp_cleanup.qualify_static_method_accesses_with_declaring_class=false\n+sp_cleanup.remove_private_constructors=true\n+sp_cleanup.remove_redundant_type_arguments=false\n+sp_cleanup.remove_trailing_whitespaces=true\n+sp_cleanup.remove_trailing_whitespaces_all=true\n+sp_cleanup.remove_trailing_whitespaces_ignore_empty=false\n+sp_cleanup.remove_unnecessary_casts=true\n+sp_cleanup.remove_unnecessary_nls_tags=true\n+sp_cleanup.remove_unused_imports=true\n+sp_cleanup.remove_unused_local_variables=false\n+sp_cleanup.remove_unused_private_fields=true\n+sp_cleanup.remove_unused_private_members=false\n+sp_cleanup.remove_unused_private_methods=true\n+sp_cleanup.remove_unused_private_types=true\n+sp_cleanup.sort_members=false\n+sp_cleanup.sort_members_all=false\n+sp_cleanup.use_anonymous_class_creation=false\n+sp_cleanup.use_blocks=true\n+sp_cleanup.use_blocks_only_for_return_and_throw=false\n+sp_cleanup.use_lambda=false\n+sp_cleanup.use_parentheses_in_expressions=true\n+sp_cleanup.use_this_for_non_static_field_access=true\n+sp_cleanup.use_this_for_non_static_field_access_only_if_necessary=false\n+sp_cleanup.use_this_for_non_static_method_access=true\n+sp_cleanup.use_this_for_non_static_method_access_only_if_necessary=true\n+sp_cleanup.use_type_arguments=false\n"
    },
    {
        "commit hash": "4fce93874619bd364c46186e4e335773f752c60a",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java",
            "additions": 84,
            "deletions": 14
        },
        "diff content": "@@ -1,7 +1,10 @@\n package net.engio.mbassy.common;\n \n \n+import java.util.Collection;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n@@ -13,8 +16,12 @@ import java.util.concurrent.locks.ReentrantReadWriteLock;\n  *\n  * @author bennidi\n  *         Date: 2/12/12\n+ * @author dorkbox\n+ *         Date: 22/2/15\n  */\n-public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n+public abstract class AbstractConcurrentSet<T> implements Set<T> {\n+    private static final AtomicLong id = new AtomicLong();\n+    private final long ID = id.getAndIncrement();\n \n     // Internal state\n     protected final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n@@ -28,20 +35,17 @@ public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n     protected abstract Entry<T> createEntry(T value, Entry<T> next);\n \n     @Override\n-    public void add(T element) {\n-        if (element == null) return;\n+    public boolean add(T element) {\n+        if (element == null) return false;\n         Lock writeLock = lock.writeLock();\n         writeLock.lock();\n-        if (element == null || entries.containsKey(element)) {\n-            writeLock.unlock();\n-        } else {\n-            insert(element);\n-            writeLock.unlock();\n-        }\n+        boolean changed = insert(element);\n+        writeLock.unlock();\n+        return changed;\n     }\n \n     @Override\n-    public boolean contains(T element) {\n+    public boolean contains(Object element) {\n         Lock readLock = lock.readLock();\n         ISetEntry<T> entry;\n         try {\n@@ -54,11 +58,13 @@ public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n         return entry != null && entry.getValue() != null;\n     }\n \n-    private void insert(T element) {\n+    private boolean insert(T element) {\n         if (!entries.containsKey(element)) {\n             head = createEntry(element, head);\n             entries.put(element, head);\n+            return true;\n         }\n+        return false;\n     }\n \n     @Override\n@@ -67,22 +73,30 @@ public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n     }\n \n     @Override\n-    public void addAll(Iterable<T> elements) {\n+    public boolean isEmpty() {\n+        return head == null;\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends T> elements) {\n+        boolean changed = false;\n+\n         Lock writeLock = lock.writeLock();\n         try {\n             writeLock.lock();\n             for (T element : elements) {\n                 if (element != null) {\n-                    insert(element);\n+                    changed |= insert(element);\n                 }\n             }\n         } finally {\n             writeLock.unlock();\n         }\n+        return changed;\n     }\n \n     @Override\n-    public boolean remove(T element) {\n+    public boolean remove(Object element) {\n         if (!contains(element)) {\n             // return quickly\n             return false;\n@@ -109,7 +123,63 @@ public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n         }\n     }\n \n+    @Override\n+    public Object[] toArray() {\n+        return this.entries.entrySet().toArray();\n+    }\n+\n+    @SuppressWarnings(\"hiding\")\n+    @Override\n+    public <T> T[] toArray(T[] a) {\n+        return this.entries.entrySet().toArray(a);\n+    }\n+\n+    @Override\n+    public boolean containsAll(Collection<?> c) {\n+        throw new UnsupportedOperationException(\"Not implemented\");\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> c) {\n+        throw new UnsupportedOperationException(\"Not implemented\");\n+    }\n \n+    @Override\n+    public boolean retainAll(Collection<?> c) {\n+        throw new UnsupportedOperationException(\"Not implemented\");\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException(\"Not implemented\");\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + (int) (this.ID ^ this.ID >>> 32);\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        @SuppressWarnings(\"rawtypes\")\n+        AbstractConcurrentSet other = (AbstractConcurrentSet) obj;\n+        if (this.ID != other.ID) {\n+            return false;\n+        }\n+        return true;\n+    }\n     public abstract static class Entry<T> implements ISetEntry<T> {\n \n         private Entry<T> next;\n"
    },
    {
        "commit hash": "4fce93874619bd364c46186e4e335773f752c60a",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ConcurrentHashMapV8.java",
            "additions": 4349,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,4349 @@\n+/*\n+ * Written by Doug Lea with assistance from members of JCP JSR-166\n+ * Expert Group and released to the public domain, as explained at\n+ * http://creativecommons.org/publicdomain/zero/1.0/\n+ */\n+package net.engio.mbassy.common;\n+\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/*\n+ * Bulk operations removed in Java 6 backport.\n+ */\n+\n+/**\n+ * A hash table supporting full concurrency of retrievals and\n+ * high expected concurrency for updates. This class obeys the\n+ * same functional specification as {@link java.util.Hashtable}, and\n+ * includes versions of methods corresponding to each method of\n+ * {@code Hashtable}. However, even though all operations are\n+ * thread-safe, retrieval operations do <em>not</em> entail locking,\n+ * and there is <em>not</em> any support for locking the entire table\n+ * in a way that prevents all access.  This class is fully\n+ * interoperable with {@code Hashtable} in programs that rely on its\n+ * thread safety but not on its synchronization details.\n+ *\n+ * <p>Retrieval operations (including {@code get}) generally do not\n+ * block, so may overlap with update operations (including {@code put}\n+ * and {@code remove}). Retrievals reflect the results of the most\n+ * recently <em>completed</em> update operations holding upon their\n+ * onset. (More formally, an update operation for a given key bears a\n+ * <em>happens-before</em> relation with any (non-null) retrieval for\n+ * that key reporting the updated value.)  For aggregate operations\n+ * such as {@code putAll} and {@code clear}, concurrent retrievals may\n+ * reflect insertion or removal of only some entries.  Similarly,\n+ * Iterators and Enumerations return elements reflecting the state of\n+ * the hash table at some point at or since the creation of the\n+ * iterator/enumeration.  They do <em>not</em> throw {@link\n+ * ConcurrentModificationException}.  However, iterators are designed\n+ * to be used by only one thread at a time.  Bear in mind that the\n+ * results of aggregate status methods including {@code size}, {@code\n+ * isEmpty}, and {@code containsValue} are typically useful only when\n+ * a map is not undergoing concurrent updates in other threads.\n+ * Otherwise the results of these methods reflect transient states\n+ * that may be adequate for monitoring or estimation purposes, but not\n+ * for program control.\n+ *\n+ * <p>The table is dynamically expanded when there are too many\n+ * collisions (i.e., keys that have distinct hash codes but fall into\n+ * the same slot modulo the table size), with the expected average\n+ * effect of maintaining roughly two bins per mapping (corresponding\n+ * to a 0.75 load factor threshold for resizing). There may be much\n+ * variance around this average as mappings are added and removed, but\n+ * overall, this maintains a commonly accepted time/space tradeoff for\n+ * hash tables.  However, resizing this or any other kind of hash\n+ * table may be a relatively slow operation. When possible, it is a\n+ * good idea to provide a size estimate as an optional {@code\n+ * initialCapacity} constructor argument. An additional optional\n+ * {@code loadFactor} constructor argument provides a further means of\n+ * customizing initial table capacity by specifying the table density\n+ * to be used in calculating the amount of space to allocate for the\n+ * given number of elements.  Also, for compatibility with previous\n+ * versions of this class, constructors may optionally specify an\n+ * expected {@code concurrencyLevel} as an additional hint for\n+ * internal sizing.  Note that using many keys with exactly the same\n+ * {@code hashCode()} is a sure way to slow down performance of any\n+ * hash table. To ameliorate impact, when keys are {@link Comparable},\n+ * this class may use comparison order among keys to help break ties.\n+ *\n+ * <p>A {@link Set} projection of a ConcurrentHashMapV8 may be created\n+ * (using {@link #newKeySet()} or {@link #newKeySet(int)}), or viewed\n+ * (using {@link #keySet(Object)} when only keys are of interest, and the\n+ * mapped values are (perhaps transiently) not used or all take the\n+ * same mapping value.\n+ *\n+ * <p>This class and its views and iterators implement all of the\n+ * <em>optional</em> methods of the {@link Map} and {@link Iterator}\n+ * interfaces.\n+ *\n+ * <p>Like {@link Hashtable} but unlike {@link HashMap}, this class\n+ * does <em>not</em> allow {@code null} to be used as a key or value.\n+ *\n+ * <p>ConcurrentHashMapV8s support a set of sequential and parallel bulk\n+ * operations that are designed\n+ * to be safely, and often sensibly, applied even with maps that are\n+ * being concurrently updated by other threads; for example, when\n+ * computing a snapshot summary of the values in a shared registry.\n+ * There are three kinds of operation, each with four forms, accepting\n+ * functions with Keys, Values, Entries, and (Key, Value) arguments\n+ * and/or return values. Because the elements of a ConcurrentHashMapV8\n+ * are not ordered in any particular way, and may be processed in\n+ * different orders in different parallel executions, the correctness\n+ * of supplied functions should not depend on any ordering, or on any\n+ * other objects or values that may transiently change while\n+ * computation is in progress; and except for forEach actions, should\n+ * ideally be side-effect-free. Bulk operations on {@link java.util.Map.Entry}\n+ * objects do not support method {@code setValue}.\n+ *\n+ * <ul>\n+ * <li> forEach: Perform a given action on each element.\n+ * A variant form applies a given transformation on each element\n+ * before performing the action.</li>\n+ *\n+ * <li> search: Return the first available non-null result of\n+ * applying a given function on each element; skipping further\n+ * search when a result is found.</li>\n+ *\n+ * <li> reduce: Accumulate each element.  The supplied reduction\n+ * function cannot rely on ordering (more formally, it should be\n+ * both associative and commutative).  There are five variants:\n+ *\n+ * <ul>\n+ *\n+ * <li> Plain reductions. (There is not a form of this method for\n+ * (key, value) function arguments since there is no corresponding\n+ * return type.)</li>\n+ *\n+ * <li> Mapped reductions that accumulate the results of a given\n+ * function applied to each element.</li>\n+ *\n+ * <li> Reductions to scalar doubles, longs, and ints, using a\n+ * given basis value.</li>\n+ *\n+ * </ul>\n+ * </li>\n+ * </ul>\n+ *\n+ * <p>These bulk operations accept a {@code parallelismThreshold}\n+ * argument. Methods proceed sequentially if the current map size is\n+ * estimated to be less than the given threshold. Using a value of\n+ * {@code Long.MAX_VALUE} suppresses all parallelism.  Using a value\n+ * of {@code 1} results in maximal parallelism by partitioning into\n+ * enough subtasks to fully utilize the {@link\n+ * ForkJoinPool#commonPool()} that is used for all parallel\n+ * computations. Normally, you would initially choose one of these\n+ * extreme values, and then measure performance of using in-between\n+ * values that trade off overhead versus throughput.\n+ *\n+ * <p>The concurrency properties of bulk operations follow\n+ * from those of ConcurrentHashMapV8: Any non-null result returned\n+ * from {@code get(key)} and related access methods bears a\n+ * happens-before relation with the associated insertion or\n+ * update.  The result of any bulk operation reflects the\n+ * composition of these per-element relations (but is not\n+ * necessarily atomic with respect to the map as a whole unless it\n+ * is somehow known to be quiescent).  Conversely, because keys\n+ * and values in the map are never null, null serves as a reliable\n+ * atomic indicator of the current lack of any result.  To\n+ * maintain this property, null serves as an implicit basis for\n+ * all non-scalar reduction operations. For the double, long, and\n+ * int versions, the basis should be one that, when combined with\n+ * any other value, returns that other value (more formally, it\n+ * should be the identity element for the reduction). Most common\n+ * reductions have these properties; for example, computing a sum\n+ * with basis 0 or a minimum with basis MAX_VALUE.\n+ *\n+ * <p>Search and transformation functions provided as arguments\n+ * should similarly return null to indicate the lack of any result\n+ * (in which case it is not used). In the case of mapped\n+ * reductions, this also enables transformations to serve as\n+ * filters, returning null (or, in the case of primitive\n+ * specializations, the identity basis) if the element should not\n+ * be combined. You can create compound transformations and\n+ * filterings by composing them yourself under this \"null means\n+ * there is nothing there now\" rule before using them in search or\n+ * reduce operations.\n+ *\n+ * <p>Methods accepting and/or returning Entry arguments maintain\n+ * key-value associations. They may be useful for example when\n+ * finding the key for the greatest value. Note that \"plain\" Entry\n+ * arguments can be supplied using {@code new\n+ * AbstractMap.SimpleEntry(k,v)}.\n+ *\n+ * <p>Bulk operations may complete abruptly, throwing an\n+ * exception encountered in the application of a supplied\n+ * function. Bear in mind when handling such exceptions that other\n+ * concurrently executing functions could also have thrown\n+ * exceptions, or would have done so if the first exception had\n+ * not occurred.\n+ *\n+ * <p>Speedups for parallel compared to sequential forms are common\n+ * but not guaranteed.  Parallel operations involving brief functions\n+ * on small maps may execute more slowly than sequential forms if the\n+ * underlying work to parallelize the computation is more expensive\n+ * than the computation itself.  Similarly, parallelization may not\n+ * lead to much actual parallelism if all processors are busy\n+ * performing unrelated tasks.\n+ *\n+ * <p>All arguments to all task methods must be non-null.\n+ *\n+ * <p><em>jsr166e note: During transition, this class\n+ * uses nested functional interfaces with different names but the\n+ * same forms as those expected for JDK8.</em>\n+ *\n+ * <p>This class is a member of the\n+ * <a href=\"{@docRoot}/../technotes/guides/collections/index.html\">\n+ * Java Collections Framework</a>.\n+ *\n+ * @since 1.5\n+ * @author Doug Lea\n+ * @param <K> the type of keys maintained by this map\n+ * @param <V> the type of mapped values\n+ */\n+@SuppressWarnings(\"all\")\n+public class ConcurrentHashMapV8<K,V> extends AbstractMap<K,V>\n+    implements ConcurrentMap<K,V>, Serializable {\n+    private static final long serialVersionUID = 7249069246763182397L;\n+\n+    /**\n+     * An object for traversing and partitioning elements of a source.\n+     * This interface provides a subset of the functionality of JDK8\n+     * java.util.Spliterator.\n+     */\n+    public static interface ConcurrentHashMapSpliterator<T> {\n+        /**\n+         * If possible, returns a new spliterator covering\n+         * approximately one half of the elements, which will not be\n+         * covered by this spliterator. Returns null if cannot be\n+         * split.\n+         */\n+        ConcurrentHashMapSpliterator<T> trySplit();\n+        /**\n+         * Returns an estimate of the number of elements covered by\n+         * this Spliterator.\n+         */\n+        long estimateSize();\n+\n+        /** Applies the action to each untraversed element */\n+        void forEachRemaining(Action<? super T> action);\n+        /** If an element remains, applies the action and returns true. */\n+        boolean tryAdvance(Action<? super T> action);\n+    }\n+\n+    // Sams\n+    /** Interface describing a void action of one argument */\n+    public interface Action<A> { void apply(A a); }\n+    /** Interface describing a void action of two arguments */\n+    public interface BiAction<A,B> { void apply(A a, B b); }\n+    /** Interface describing a function of one argument */\n+    public interface Fun<A,T> { T apply(A a); }\n+    /** Interface describing a function of two arguments */\n+    public interface BiFun<A,B,T> { T apply(A a, B b); }\n+    /** Interface describing a function mapping its argument to a double */\n+    public interface ObjectToDouble<A> { double apply(A a); }\n+    /** Interface describing a function mapping its argument to a long */\n+    public interface ObjectToLong<A> { long apply(A a); }\n+    /** Interface describing a function mapping its argument to an int */\n+    public interface ObjectToInt<A> {int apply(A a); }\n+    /** Interface describing a function mapping two arguments to a double */\n+    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }\n+    /** Interface describing a function mapping two arguments to a long */\n+    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }\n+    /** Interface describing a function mapping two arguments to an int */\n+    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }\n+    /** Interface describing a function mapping two doubles to a double */\n+    public interface DoubleByDoubleToDouble { double apply(double a, double b); }\n+    /** Interface describing a function mapping two longs to a long */\n+    public interface LongByLongToLong { long apply(long a, long b); }\n+    /** Interface describing a function mapping two ints to an int */\n+    public interface IntByIntToInt { int apply(int a, int b); }\n+\n+    /*\n+     * Overview:\n+     *\n+     * The primary design goal of this hash table is to maintain\n+     * concurrent readability (typically method get(), but also\n+     * iterators and related methods) while minimizing update\n+     * contention. Secondary goals are to keep space consumption about\n+     * the same or better than java.util.HashMap, and to support high\n+     * initial insertion rates on an empty table by many threads.\n+     *\n+     * This map usually acts as a binned (bucketed) hash table.  Each\n+     * key-value mapping is held in a Node.  Most nodes are instances\n+     * of the basic Node class with hash, key, value, and next\n+     * fields. However, various subclasses exist: TreeNodes are\n+     * arranged in balanced trees, not lists.  TreeBins hold the roots\n+     * of sets of TreeNodes. ForwardingNodes are placed at the heads\n+     * of bins during resizing. ReservationNodes are used as\n+     * placeholders while establishing values in computeIfAbsent and\n+     * related methods.  The types TreeBin, ForwardingNode, and\n+     * ReservationNode do not hold normal user keys, values, or\n+     * hashes, and are readily distinguishable during search etc\n+     * because they have negative hash fields and null key and value\n+     * fields. (These special nodes are either uncommon or transient,\n+     * so the impact of carrying around some unused fields is\n+     * insignificant.)\n+     *\n+     * The table is lazily initialized to a power-of-two size upon the\n+     * first insertion.  Each bin in the table normally contains a\n+     * list of Nodes (most often, the list has only zero or one Node).\n+     * Table accesses require volatile/atomic reads, writes, and\n+     * CASes.  Because there is no other way to arrange this without\n+     * adding further indirections, we use intrinsics\n+     * (sun.misc.Unsafe) operations.\n+     *\n+     * We use the top (sign) bit of Node hash fields for control\n+     * purposes -- it is available anyway because of addressing\n+     * constraints.  Nodes with negative hash fields are specially\n+     * handled or ignored in map methods.\n+     *\n+     * Insertion (via put or its variants) of the first node in an\n+     * empty bin is performed by just CASing it to the bin.  This is\n+     * by far the most common case for put operations under most\n+     * key/hash distributions.  Other update operations (insert,\n+     * delete, and replace) require locks.  We do not want to waste\n+     * the space required to associate a distinct lock object with\n+     * each bin, so instead use the first node of a bin list itself as\n+     * a lock. Locking support for these locks relies on builtin\n+     * \"synchronized\" monitors.\n+     *\n+     * Using the first node of a list as a lock does not by itself\n+     * suffice though: When a node is locked, any update must first\n+     * validate that it is still the first node after locking it, and\n+     * retry if not. Because new nodes are always appended to lists,\n+     * once a node is first in a bin, it remains first until deleted\n+     * or the bin becomes invalidated (upon resizing).\n+     *\n+     * The main disadvantage of per-bin locks is that other update\n+     * operations on other nodes in a bin list protected by the same\n+     * lock can stall, for example when user equals() or mapping\n+     * functions take a long time.  However, statistically, under\n+     * random hash codes, this is not a common problem.  Ideally, the\n+     * frequency of nodes in bins follows a Poisson distribution\n+     * (http://en.wikipedia.org/wiki/Poisson_distribution) with a\n+     * parameter of about 0.5 on average, given the resizing threshold\n+     * of 0.75, although with a large variance because of resizing\n+     * granularity. Ignoring variance, the expected occurrences of\n+     * list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)). The\n+     * first values are:\n+     *\n+     * 0:    0.60653066\n+     * 1:    0.30326533\n+     * 2:    0.07581633\n+     * 3:    0.01263606\n+     * 4:    0.00157952\n+     * 5:    0.00015795\n+     * 6:    0.00001316\n+     * 7:    0.00000094\n+     * 8:    0.00000006\n+     * more: less than 1 in ten million\n+     *\n+     * Lock contention probability for two threads accessing distinct\n+     * elements is roughly 1 / (8 * #elements) under random hashes.\n+     *\n+     * Actual hash code distributions encountered in practice\n+     * sometimes deviate significantly from uniform randomness.  This\n+     * includes the case when N > (1<<30), so some keys MUST collide.\n+     * Similarly for dumb or hostile usages in which multiple keys are\n+     * designed to have identical hash codes or ones that differs only\n+     * in masked-out high bits. So we use a secondary strategy that\n+     * applies when the number of nodes in a bin exceeds a\n+     * threshold. These TreeBins use a balanced tree to hold nodes (a\n+     * specialized form of red-black trees), bounding search time to\n+     * O(log N).  Each search step in a TreeBin is at least twice as\n+     * slow as in a regular list, but given that N cannot exceed\n+     * (1<<64) (before running out of addresses) this bounds search\n+     * steps, lock hold times, etc, to reasonable constants (roughly\n+     * 100 nodes inspected per operation worst case) so long as keys\n+     * are Comparable (which is very common -- String, Long, etc).\n+     * TreeBin nodes (TreeNodes) also maintain the same \"next\"\n+     * traversal pointers as regular nodes, so can be traversed in\n+     * iterators in the same way.\n+     *\n+     * The table is resized when occupancy exceeds a percentage\n+     * threshold (nominally, 0.75, but see below).  Any thread\n+     * noticing an overfull bin may assist in resizing after the\n+     * initiating thread allocates and sets up the replacement\n+     * array. However, rather than stalling, these other threads may\n+     * proceed with insertions etc.  The use of TreeBins shields us\n+     * from the worst case effects of overfilling while resizes are in\n+     * progress.  Resizing proceeds by transferring bins, one by one,\n+     * from the table to the next table. To enable concurrency, the\n+     * next table must be (incrementally) prefilled with place-holders\n+     * serving as reverse forwarders to the old table.  Because we are\n+     * using power-of-two expansion, the elements from each bin must\n+     * either stay at same index, or move with a power of two\n+     * offset. We eliminate unnecessary node creation by catching\n+     * cases where old nodes can be reused because their next fields\n+     * won't change.  On average, only about one-sixth of them need\n+     * cloning when a table doubles. The nodes they replace will be\n+     * garbage collectable as soon as they are no longer referenced by\n+     * any reader thread that may be in the midst of concurrently\n+     * traversing table.  Upon transfer, the old table bin contains\n+     * only a special forwarding node (with hash field \"MOVED\") that\n+     * contains the next table as its key. On encountering a\n+     * forwarding node, access and update operations restart, using\n+     * the new table.\n+     *\n+     * Each bin transfer requires its bin lock, which can stall\n+     * waiting for locks while resizing. However, because other\n+     * threads can join in and help resize rather than contend for\n+     * locks, average aggregate waits become shorter as resizing\n+     * progresses.  The transfer operation must also ensure that all\n+     * accessible bins in both the old and new table are usable by any\n+     * traversal.  This is arranged by proceeding from the last bin\n+     * (table.length - 1) up towards the first.  Upon seeing a\n+     * forwarding node, traversals (see class Traverser) arrange to\n+     * move to the new table without revisiting nodes.  However, to\n+     * ensure that no intervening nodes are skipped, bin splitting can\n+     * only begin after the associated reverse-forwarders are in\n+     * place.\n+     *\n+     * The traversal scheme also applies to partial traversals of\n+     * ranges of bins (via an alternate Traverser constructor)\n+     * to support partitioned aggregate operations.  Also, read-only\n+     * operations give up if ever forwarded to a null table, which\n+     * provides support for shutdown-style clearing, which is also not\n+     * currently implemented.\n+     *\n+     * Lazy table initialization minimizes footprint until first use,\n+     * and also avoids resizings when the first operation is from a\n+     * putAll, constructor with map argument, or deserialization.\n+     * These cases attempt to override the initial capacity settings,\n+     * but harmlessly fail to take effect in cases of races.\n+     *\n+     * The element count is maintained using a specialization of\n+     * LongAdder. We need to incorporate a specialization rather than\n+     * just use a LongAdder in order to access implicit\n+     * contention-sensing that leads to creation of multiple\n+     * CounterCells.  The counter mechanics avoid contention on\n+     * updates but can encounter cache thrashing if read too\n+     * frequently during concurrent access. To avoid reading so often,\n+     * resizing under contention is attempted only upon adding to a\n+     * bin already holding two or more nodes. Under uniform hash\n+     * distributions, the probability of this occurring at threshold\n+     * is around 13%, meaning that only about 1 in 8 puts check\n+     * threshold (and after resizing, many fewer do so).\n+     *\n+     * TreeBins use a special form of comparison for search and\n+     * related operations (which is the main reason we cannot use\n+     * existing collections such as TreeMaps). TreeBins contain\n+     * Comparable elements, but may contain others, as well as\n+     * elements that are Comparable but not necessarily Comparable for\n+     * the same T, so we cannot invoke compareTo among them. To handle\n+     * this, the tree is ordered primarily by hash value, then by\n+     * Comparable.compareTo order if applicable.  On lookup at a node,\n+     * if elements are not comparable or compare as 0 then both left\n+     * and right children may need to be searched in the case of tied\n+     * hash values. (This corresponds to the full list search that\n+     * would be necessary if all elements were non-Comparable and had\n+     * tied hashes.) On insertion, to keep a total ordering (or as\n+     * close as is required here) across rebalancings, we compare\n+     * classes and identityHashCodes as tie-breakers. The red-black\n+     * balancing code is updated from pre-jdk-collections\n+     * (http://gee.cs.oswego.edu/dl/classes/collections/RBCell.java)\n+     * based in turn on Cormen, Leiserson, and Rivest \"Introduction to\n+     * Algorithms\" (CLR).\n+     *\n+     * TreeBins also require an additional locking mechanism.  While\n+     * list traversal is always possible by readers even during\n+     * updates, tree traversal is not, mainly because of tree-rotations\n+     * that may change the root node and/or its linkages.  TreeBins\n+     * include a simple read-write lock mechanism parasitic on the\n+     * main bin-synchronization strategy: Structural adjustments\n+     * associated with an insertion or removal are already bin-locked\n+     * (and so cannot conflict with other writers) but must wait for\n+     * ongoing readers to finish. Since there can be only one such\n+     * waiter, we use a simple scheme using a single \"waiter\" field to\n+     * block writers.  However, readers need never block.  If the root\n+     * lock is held, they proceed along the slow traversal path (via\n+     * next-pointers) until the lock becomes available or the list is\n+     * exhausted, whichever comes first. These cases are not fast, but\n+     * maximize aggregate expected throughput.\n+     *\n+     * Maintaining API and serialization compatibility with previous\n+     * versions of this class introduces several oddities. Mainly: We\n+     * leave untouched but unused constructor arguments refering to\n+     * concurrencyLevel. We accept a loadFactor constructor argument,\n+     * but apply it only to initial table capacity (which is the only\n+     * time that we can guarantee to honor it.) We also declare an\n+     * unused \"Segment\" class that is instantiated in minimal form\n+     * only when serializing.\n+     *\n+     * Also, solely for compatibility with previous versions of this\n+     * class, it extends AbstractMap, even though all of its methods\n+     * are overridden, so it is just useless baggage.\n+     *\n+     * This file is organized to make things a little easier to follow\n+     * while reading than they might otherwise: First the main static\n+     * declarations and utilities, then fields, then main public\n+     * methods (with a few factorings of multiple public methods into\n+     * internal ones), then sizing methods, trees, traversers, and\n+     * bulk operations.\n+     */\n+\n+    /* ---------------- Constants -------------- */\n+\n+    /**\n+     * The largest possible table capacity.  This value must be\n+     * exactly 1<<30 to stay within Java array allocation and indexing\n+     * bounds for power of two table sizes, and is further required\n+     * because the top two bits of 32bit hash fields are used for\n+     * control purposes.\n+     */\n+    private static final int MAXIMUM_CAPACITY = 1 << 30;\n+\n+    /**\n+     * The default initial table capacity.  Must be a power of 2\n+     * (i.e., at least 1) and at most MAXIMUM_CAPACITY.\n+     */\n+    private static final int DEFAULT_CAPACITY = 16;\n+\n+    /**\n+     * The largest possible (non-power of two) array size.\n+     * Needed by toArray and related methods.\n+     */\n+    static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n+\n+    /**\n+     * The default concurrency level for this table. Unused but\n+     * defined for compatibility with previous versions of this class.\n+     */\n+    private static final int DEFAULT_CONCURRENCY_LEVEL = 16;\n+\n+    /**\n+     * The load factor for this table. Overrides of this value in\n+     * constructors affect only the initial table capacity.  The\n+     * actual floating point value isn't normally used -- it is\n+     * simpler to use expressions such as {@code n - (n >>> 2)} for\n+     * the associated resizing threshold.\n+     */\n+    private static final float LOAD_FACTOR = 0.75f;\n+\n+    /**\n+     * The bin count threshold for using a tree rather than list for a\n+     * bin.  Bins are converted to trees when adding an element to a\n+     * bin with at least this many nodes. The value must be greater\n+     * than 2, and should be at least 8 to mesh with assumptions in\n+     * tree removal about conversion back to plain bins upon\n+     * shrinkage.\n+     */\n+    static final int TREEIFY_THRESHOLD = 8;\n+\n+    /**\n+     * The bin count threshold for untreeifying a (split) bin during a\n+     * resize operation. Should be less than TREEIFY_THRESHOLD, and at\n+     * most 6 to mesh with shrinkage detection under removal.\n+     */\n+    static final int UNTREEIFY_THRESHOLD = 6;\n+\n+    /**\n+     * The smallest table capacity for which bins may be treeified.\n+     * (Otherwise the table is resized if too many nodes in a bin.)\n+     * The value should be at least 4 * TREEIFY_THRESHOLD to avoid\n+     * conflicts between resizing and treeification thresholds.\n+     */\n+    static final int MIN_TREEIFY_CAPACITY = 64;\n+\n+    /**\n+     * Minimum number of rebinnings per transfer step. Ranges are\n+     * subdivided to allow multiple resizer threads.  This value\n+     * serves as a lower bound to avoid resizers encountering\n+     * excessive memory contention.  The value should be at least\n+     * DEFAULT_CAPACITY.\n+     */\n+    private static final int MIN_TRANSFER_STRIDE = 16;\n+\n+    /*\n+     * Encodings for Node hash fields. See above for explanation.\n+     */\n+    static final int MOVED     = -1; // hash for forwarding nodes\n+    static final int TREEBIN   = -2; // hash for roots of trees\n+    static final int RESERVED  = -3; // hash for transient reservations\n+    static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash\n+\n+    /** Number of CPUS, to place bounds on some sizings */\n+    static final int NCPU = Runtime.getRuntime().availableProcessors();\n+\n+    /** For serialization compatibility. */\n+    private static final ObjectStreamField[] serialPersistentFields = {\n+        new ObjectStreamField(\"segments\", Segment[].class),\n+        new ObjectStreamField(\"segmentMask\", Integer.TYPE),\n+        new ObjectStreamField(\"segmentShift\", Integer.TYPE)\n+    };\n+\n+    /* ---------------- Nodes -------------- */\n+\n+    /**\n+     * Key-value entry.  This class is never exported out as a\n+     * user-mutable Map.Entry (i.e., one supporting setValue; see\n+     * MapEntry below), but can be used for read-only traversals used\n+     * in bulk tasks.  Subclasses of Node with a negative hash field\n+     * are special, and contain null keys and values (but are never\n+     * exported).  Otherwise, keys and vals are never null.\n+     */\n+    static class Node<K,V> implements Map.Entry<K,V> {\n+        final int hash;\n+        final K key;\n+        volatile V val;\n+        volatile Node<K,V> next;\n+\n+        Node(int hash, K key, V val, Node<K,V> next) {\n+            this.hash = hash;\n+            this.key = key;\n+            this.val = val;\n+            this.next = next;\n+        }\n+\n+        @Override\n+        public final K getKey()       { return this.key; }\n+        @Override\n+        public final V getValue()     { return this.val; }\n+        @Override\n+        public final int hashCode()   { return this.key.hashCode() ^ this.val.hashCode(); }\n+        @Override\n+        public final String toString(){ return this.key + \"=\" + this.val; }\n+        @Override\n+        public final V setValue(V value) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public final boolean equals(Object o) {\n+            Object k, v, u; Map.Entry<?,?> e;\n+            return o instanceof Map.Entry &&\n+                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&\n+                    (v = e.getValue()) != null &&\n+                    (k == this.key || k.equals(this.key)) &&\n+                    (v == (u = this.val) || v.equals(u));\n+        }\n+\n+        /**\n+         * Virtualized support for map.get(); overridden in subclasses.\n+         */\n+        Node<K,V> find(int h, Object k) {\n+            Node<K,V> e = this;\n+            if (k != null) {\n+                do {\n+                    K ek;\n+                    if (e.hash == h &&\n+                        ((ek = e.key) == k || ek != null && k.equals(ek))) {\n+                        return e;\n+                    }\n+                } while ((e = e.next) != null);\n+            }\n+            return null;\n+        }\n+    }\n+\n+    /* ---------------- Static utilities -------------- */\n+\n+    /**\n+     * Spreads (XORs) higher bits of hash to lower and also forces top\n+     * bit to 0. Because the table uses power-of-two masking, sets of\n+     * hashes that vary only in bits above the current mask will\n+     * always collide. (Among known examples are sets of Float keys\n+     * holding consecutive whole numbers in small tables.)  So we\n+     * apply a transform that spreads the impact of higher bits\n+     * downward. There is a tradeoff between speed, utility, and\n+     * quality of bit-spreading. Because many common sets of hashes\n+     * are already reasonably distributed (so don't benefit from\n+     * spreading), and because we use trees to handle large sets of\n+     * collisions in bins, we just XOR some shifted bits in the\n+     * cheapest possible way to reduce systematic lossage, as well as\n+     * to incorporate impact of the highest bits that would otherwise\n+     * never be used in index calculations because of table bounds.\n+     */\n+    static final int spread(int h) {\n+        return (h ^ h >>> 16) & HASH_BITS;\n+    }\n+\n+    /**\n+     * Returns a power of two table size for the given desired capacity.\n+     * See Hackers Delight, sec 3.2\n+     */\n+    private static final int tableSizeFor(int c) {\n+        int n = c - 1;\n+        n |= n >>> 1;\n+        n |= n >>> 2;\n+        n |= n >>> 4;\n+        n |= n >>> 8;\n+        n |= n >>> 16;\n+        return n < 0 ? 1 : n >= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : n + 1;\n+    }\n+\n+    /**\n+     * Returns x's Class if it is of the form \"class C implements\n+     * Comparable<C>\", else null.\n+     */\n+    static Class<?> comparableClassFor(Object x) {\n+        if (x instanceof Comparable) {\n+            Class<?> c; Type[] ts, as; Type t; ParameterizedType p;\n+            if ((c = x.getClass()) == String.class) {\n+                return c;\n+            }\n+            if ((ts = c.getGenericInterfaces()) != null) {\n+                for (int i = 0; i < ts.length; ++i) {\n+                    if ((t = ts[i]) instanceof ParameterizedType &&\n+                        (p = (ParameterizedType)t).getRawType() ==\n+                         Comparable.class &&\n+                        (as = p.getActualTypeArguments()) != null &&\n+                        as.length == 1 && as[0] == c) {\n+                        return c;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns k.compareTo(x) if x matches kc (k's screened comparable\n+     * class), else 0.\n+     */\n+    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) // for cast to Comparable\n+    static int compareComparables(Class<?> kc, Object k, Object x) {\n+        return x == null || x.getClass() != kc ? 0 :\n+                ((Comparable)k).compareTo(x);\n+    }\n+\n+    /* ---------------- Table element access -------------- */\n+\n+    /*\n+     * Volatile access methods are used for table elements as well as\n+     * elements of in-progress next table while resizing.  All uses of\n+     * the tab arguments must be null checked by callers.  All callers\n+     * also paranoically precheck that tab's length is not zero (or an\n+     * equivalent check), thus ensuring that any index argument taking\n+     * the form of a hash value anded with (length - 1) is a valid\n+     * index.  Note that, to be correct wrt arbitrary concurrency\n+     * errors by users, these checks must operate on local variables,\n+     * which accounts for some odd-looking inline assignments below.\n+     * Note that calls to setTabAt always occur within locked regions,\n+     * and so in principle require only release ordering, not need\n+     * full volatile semantics, but are currently coded as volatile\n+     * writes to be conservative.\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) {\n+        return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE);\n+    }\n+\n+    static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i,\n+                                        Node<K,V> c, Node<K,V> v) {\n+        return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v);\n+    }\n+\n+    static final <K,V> void setTabAt(Node<K,V>[] tab, int i, Node<K,V> v) {\n+        U.putObjectVolatile(tab, ((long)i << ASHIFT) + ABASE, v);\n+    }\n+\n+    /* ---------------- Fields -------------- */\n+\n+    /**\n+     * The array of bins. Lazily initialized upon first insertion.\n+     * Size is always a power of two. Accessed directly by iterators.\n+     */\n+    transient volatile Node<K,V>[] table;\n+\n+    /**\n+     * The next table to use; non-null only while resizing.\n+     */\n+    private transient volatile Node<K,V>[] nextTable;\n+\n+    /**\n+     * Base counter value, used mainly when there is no contention,\n+     * but also as a fallback during table initialization\n+     * races. Updated via CAS.\n+     */\n+    private transient volatile long baseCount;\n+\n+    /**\n+     * Table initialization and resizing control.  When negative, the\n+     * table is being initialized or resized: -1 for initialization,\n+     * else -(1 + the number of active resizing threads).  Otherwise,\n+     * when table is null, holds the initial table size to use upon\n+     * creation, or 0 for default. After initialization, holds the\n+     * next element count value upon which to resize the table.\n+     */\n+    private transient volatile int sizeCtl;\n+\n+    /**\n+     * The next table index (plus one) to split while resizing.\n+     */\n+    private transient volatile int transferIndex;\n+\n+    /**\n+     * The least available table index to split while resizing.\n+     */\n+    private transient volatile int transferOrigin;\n+\n+    /**\n+     * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.\n+     */\n+    private transient volatile int cellsBusy;\n+\n+    /**\n+     * Table of counter cells. When non-null, size is a power of 2.\n+     */\n+    private transient volatile CounterCell[] counterCells;\n+\n+    // views\n+    private transient KeySetView<K,V> keySet;\n+    private transient ValuesView<K,V> values;\n+    private transient EntrySetView<K,V> entrySet;\n+\n+\n+    /* ---------------- Public operations -------------- */\n+\n+    /**\n+     * Creates a new, empty map with the default initial table size (16).\n+     */\n+    public ConcurrentHashMapV8() {\n+    }\n+\n+    /**\n+     * Creates a new, empty map with an initial table size\n+     * accommodating the specified number of elements without the need\n+     * to dynamically resize.\n+     *\n+     * @param initialCapacity The implementation performs internal\n+     * sizing to accommodate this many elements.\n+     * @throws IllegalArgumentException if the initial capacity of\n+     * elements is negative\n+     */\n+    public ConcurrentHashMapV8(int initialCapacity) {\n+        if (initialCapacity < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        int cap = initialCapacity >= MAXIMUM_CAPACITY >>> 1 ?\n+                   MAXIMUM_CAPACITY :\n+                   tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1);\n+        this.sizeCtl = cap;\n+    }\n+\n+    /**\n+     * Creates a new map with the same mappings as the given map.\n+     *\n+     * @param m the map\n+     */\n+    public ConcurrentHashMapV8(Map<? extends K, ? extends V> m) {\n+        this.sizeCtl = DEFAULT_CAPACITY;\n+        putAll(m);\n+    }\n+\n+    /**\n+     * Creates a new, empty map with an initial table size based on\n+     * the given number of elements ({@code initialCapacity}) and\n+     * initial table density ({@code loadFactor}).\n+     *\n+     * @param initialCapacity the initial capacity. The implementation\n+     * performs internal sizing to accommodate this many elements,\n+     * given the specified load factor.\n+     * @param loadFactor the load factor (table density) for\n+     * establishing the initial table size\n+     * @throws IllegalArgumentException if the initial capacity of\n+     * elements is negative or the load factor is nonpositive\n+     *\n+     * @since 1.6\n+     */\n+    public ConcurrentHashMapV8(int initialCapacity, float loadFactor) {\n+        this(initialCapacity, loadFactor, 1);\n+    }\n+\n+    /**\n+     * Creates a new, empty map with an initial table size based on\n+     * the given number of elements ({@code initialCapacity}), table\n+     * density ({@code loadFactor}), and number of concurrently\n+     * updating threads ({@code concurrencyLevel}).\n+     *\n+     * @param initialCapacity the initial capacity. The implementation\n+     * performs internal sizing to accommodate this many elements,\n+     * given the specified load factor.\n+     * @param loadFactor the load factor (table density) for\n+     * establishing the initial table size\n+     * @param concurrencyLevel the estimated number of concurrently\n+     * updating threads. The implementation may use this value as\n+     * a sizing hint.\n+     * @throws IllegalArgumentException if the initial capacity is\n+     * negative or the load factor or concurrencyLevel are\n+     * nonpositive\n+     */\n+    public ConcurrentHashMapV8(int initialCapacity,\n+                             float loadFactor, int concurrencyLevel) {\n+        if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (initialCapacity < concurrencyLevel)\n+         {\n+            initialCapacity = concurrencyLevel;   // as estimated threads\n+        }\n+        long size = (long)(1.0 + initialCapacity / loadFactor);\n+        int cap = size >= MAXIMUM_CAPACITY ?\n+            MAXIMUM_CAPACITY : tableSizeFor((int)size);\n+        this.sizeCtl = cap;\n+    }\n+\n+    // Original (since JDK1.2) Map methods\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int size() {\n+        long n = sumCount();\n+        return n < 0L ? 0 :\n+                n > Integer.MAX_VALUE ? Integer.MAX_VALUE :\n+                (int)n;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isEmpty() {\n+        return sumCount() <= 0L; // ignore transient negative values\n+    }\n+\n+    /**\n+     * Returns the value to which the specified key is mapped,\n+     * or {@code null} if this map contains no mapping for the key.\n+     *\n+     * <p>More formally, if this map contains a mapping from a key\n+     * {@code k} to a value {@code v} such that {@code key.equals(k)},\n+     * then this method returns {@code v}; otherwise it returns\n+     * {@code null}.  (There can be at most one such mapping.)\n+     *\n+     * @throws NullPointerException if the specified key is null\n+     */\n+    @Override\n+    public V get(Object key) {\n+        Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n+        int h = spread(key.hashCode());\n+        if ((tab = this.table) != null && (n = tab.length) > 0 &&\n+            (e = tabAt(tab, n - 1 & h)) != null) {\n+            if ((eh = e.hash) == h) {\n+                if ((ek = e.key) == key || ek != null && key.equals(ek)) {\n+                    return e.val;\n+                }\n+            }\n+            else if (eh < 0) {\n+                return (p = e.find(h, key)) != null ? p.val : null;\n+            }\n+            while ((e = e.next) != null) {\n+                if (e.hash == h &&\n+                    ((ek = e.key) == key || ek != null && key.equals(ek))) {\n+                    return e.val;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Tests if the specified object is a key in this table.\n+     *\n+     * @param  key possible key\n+     * @return {@code true} if and only if the specified object\n+     *         is a key in this table, as determined by the\n+     *         {@code equals} method; {@code false} otherwise\n+     * @throws NullPointerException if the specified key is null\n+     */\n+    @Override\n+    public boolean containsKey(Object key) {\n+        return get(key) != null;\n+    }\n+\n+    /**\n+     * Returns {@code true} if this map maps one or more keys to the\n+     * specified value. Note: This method may require a full traversal\n+     * of the map, and is much slower than method {@code containsKey}.\n+     *\n+     * @param value value whose presence in this map is to be tested\n+     * @return {@code true} if this map maps one or more keys to the\n+     *         specified value\n+     * @throws NullPointerException if the specified value is null\n+     */\n+    @Override\n+    public boolean containsValue(Object value) {\n+        if (value == null) {\n+            throw new NullPointerException();\n+        }\n+        Node<K,V>[] t;\n+        if ((t = this.table) != null) {\n+            Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n+            for (Node<K,V> p; (p = it.advance()) != null; ) {\n+                V v;\n+                if ((v = p.val) == value || v != null && value.equals(v)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Maps the specified key to the specified value in this table.\n+     * Neither the key nor the value can be null.\n+     *\n+     * <p>The value can be retrieved by calling the {@code get} method\n+     * with a key that is equal to the original key.\n+     *\n+     * @param key key with which the specified value is to be associated\n+     * @param value value to be associated with the specified key\n+     * @return the previous value associated with {@code key}, or\n+     *         {@code null} if there was no mapping for {@code key}\n+     * @throws NullPointerException if the specified key or value is null\n+     */\n+    @Override\n+    public V put(K key, V value) {\n+        return putVal(key, value, false);\n+    }\n+\n+    /** Implementation for put and putIfAbsent */\n+    final V putVal(K key, V value, boolean onlyIfAbsent) {\n+        if (key == null || value == null) {\n+            throw new NullPointerException();\n+        }\n+        int hash = spread(key.hashCode());\n+        int binCount = 0;\n+        for (Node<K,V>[] tab = this.table;;) {\n+            Node<K,V> f; int n, i, fh;\n+            if (tab == null || (n = tab.length) == 0) {\n+                tab = initTable();\n+            } else if ((f = tabAt(tab, i = n - 1 & hash)) == null) {\n+                if (casTabAt(tab, i, null,\n+                             new Node<K,V>(hash, key, value, null)))\n+                 {\n+                    break;                   // no lock when adding to empty bin\n+                }\n+            }\n+            else if ((fh = f.hash) == MOVED) {\n+                tab = helpTransfer(tab, f);\n+            } else {\n+                V oldVal = null;\n+                synchronized (f) {\n+                    if (tabAt(tab, i) == f) {\n+                        if (fh >= 0) {\n+                            binCount = 1;\n+                            for (Node<K,V> e = f;; ++binCount) {\n+                                K ek;\n+                                if (e.hash == hash &&\n+                                    ((ek = e.key) == key ||\n+                                     ek != null && key.equals(ek))) {\n+                                    oldVal = e.val;\n+                                    if (!onlyIfAbsent) {\n+                                        e.val = value;\n+                                    }\n+                                    break;\n+                                }\n+                                Node<K,V> pred = e;\n+                                if ((e = e.next) == null) {\n+                                    pred.next = new Node<K,V>(hash, key,\n+                                                              value, null);\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        else if (f instanceof TreeBin) {\n+                            Node<K,V> p;\n+                            binCount = 2;\n+                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n+                                                           value)) != null) {\n+                                oldVal = p.val;\n+                                if (!onlyIfAbsent) {\n+                                    p.val = value;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (binCount != 0) {\n+                    if (binCount >= TREEIFY_THRESHOLD) {\n+                        treeifyBin(tab, i);\n+                    }\n+                    if (oldVal != null) {\n+                        return oldVal;\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+        addCount(1L, binCount);\n+        return null;\n+    }\n+\n+    /**\n+     * Copies all of the mappings from the specified map to this one.\n+     * These mappings replace any mappings that this map had for any of the\n+     * keys currently in the specified map.\n+     *\n+     * @param m mappings to be stored in this map\n+     */\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> m) {\n+        tryPresize(m.size());\n+        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n+            putVal(e.getKey(), e.getValue(), false);\n+        }\n+    }\n+\n+    /**\n+     * Removes the key (and its corresponding value) from this map.\n+     * This method does nothing if the key is not in the map.\n+     *\n+     * @param  key the key that needs to be removed\n+     * @return the previous value associated with {@code key}, or\n+     *         {@code null} if there was no mapping for {@code key}\n+     * @throws NullPointerException if the specified key is null\n+     */\n+    @Override\n+    public V remove(Object key) {\n+        return replaceNode(key, null, null);\n+    }\n+\n+    /**\n+     * Implementation for the four public remove/replace methods:\n+     * Replaces node value with v, conditional upon match of cv if\n+     * non-null.  If resulting value is null, delete.\n+     */\n+    final V replaceNode(Object key, V value, Object cv) {\n+        int hash = spread(key.hashCode());\n+        for (Node<K,V>[] tab = this.table;;) {\n+            Node<K,V> f; int n, i, fh;\n+            if (tab == null || (n = tab.length) == 0 ||\n+                (f = tabAt(tab, i = n - 1 & hash)) == null) {\n+                break;\n+            } else if ((fh = f.hash) == MOVED) {\n+                tab = helpTransfer(tab, f);\n+            } else {\n+                V oldVal = null;\n+                boolean validated = false;\n+                synchronized (f) {\n+                    if (tabAt(tab, i) == f) {\n+                        if (fh >= 0) {\n+                            validated = true;\n+                            for (Node<K,V> e = f, pred = null;;) {\n+                                K ek;\n+                                if (e.hash == hash &&\n+                                    ((ek = e.key) == key ||\n+                                     ek != null && key.equals(ek))) {\n+                                    V ev = e.val;\n+                                    if (cv == null || cv == ev ||\n+                                        ev != null && cv.equals(ev)) {\n+                                        oldVal = ev;\n+                                        if (value != null) {\n+                                            e.val = value;\n+                                        } else if (pred != null) {\n+                                            pred.next = e.next;\n+                                        } else {\n+                                            setTabAt(tab, i, e.next);\n+                                        }\n+                                    }\n+                                    break;\n+                                }\n+                                pred = e;\n+                                if ((e = e.next) == null) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        else if (f instanceof TreeBin) {\n+                            validated = true;\n+                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n+                            TreeNode<K,V> r, p;\n+                            if ((r = t.root) != null &&\n+                                (p = r.findTreeNode(hash, key, null)) != null) {\n+                                V pv = p.val;\n+                                if (cv == null || cv == pv ||\n+                                    pv != null && cv.equals(pv)) {\n+                                    oldVal = pv;\n+                                    if (value != null) {\n+                                        p.val = value;\n+                                    } else if (t.removeTreeNode(p)) {\n+                                        setTabAt(tab, i, untreeify(t.first));\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (validated) {\n+                    if (oldVal != null) {\n+                        if (value == null) {\n+                            addCount(-1L, -1);\n+                        }\n+                        return oldVal;\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Removes all of the mappings from this map.\n+     */\n+    @Override\n+    public void clear() {\n+        long delta = 0L; // negative number of deletions\n+        int i = 0;\n+        Node<K,V>[] tab = this.table;\n+        while (tab != null && i < tab.length) {\n+            int fh;\n+            Node<K,V> f = tabAt(tab, i);\n+            if (f == null) {\n+                ++i;\n+            } else if ((fh = f.hash) == MOVED) {\n+                tab = helpTransfer(tab, f);\n+                i = 0; // restart\n+            }\n+            else {\n+                synchronized (f) {\n+                    if (tabAt(tab, i) == f) {\n+                        Node<K,V> p = fh >= 0 ? f :\n+                                       f instanceof TreeBin ?\n+                                       ((TreeBin<K,V>)f).first : null;\n+                        while (p != null) {\n+                            --delta;\n+                            p = p.next;\n+                        }\n+                        setTabAt(tab, i++, null);\n+                    }\n+                }\n+            }\n+        }\n+        if (delta != 0L) {\n+            addCount(delta, -1);\n+        }\n+    }\n+\n+    /**\n+     * Returns a {@link Set} view of the keys contained in this map.\n+     * The set is backed by the map, so changes to the map are\n+     * reflected in the set, and vice-versa. The set supports element\n+     * removal, which removes the corresponding mapping from this map,\n+     * via the {@code Iterator.remove}, {@code Set.remove},\n+     * {@code removeAll}, {@code retainAll}, and {@code clear}\n+     * operations.  It does not support the {@code add} or\n+     * {@code addAll} operations.\n+     *\n+     * <p>The view's {@code iterator} is a \"weakly consistent\" iterator\n+     * that will never throw {@link ConcurrentModificationException},\n+     * and guarantees to traverse elements as they existed upon\n+     * construction of the iterator, and may (but is not guaranteed to)\n+     * reflect any modifications subsequent to construction.\n+     *\n+     * @return the set view\n+     */\n+    @Override\n+    public KeySetView<K,V> keySet() {\n+        KeySetView<K,V> ks;\n+        return (ks = this.keySet) != null ? ks : (this.keySet = new KeySetView<K,V>(this, null));\n+    }\n+\n+    /**\n+     * Returns a {@link Collection} view of the values contained in this map.\n+     * The collection is backed by the map, so changes to the map are\n+     * reflected in the collection, and vice-versa.  The collection\n+     * supports element removal, which removes the corresponding\n+     * mapping from this map, via the {@code Iterator.remove},\n+     * {@code Collection.remove}, {@code removeAll},\n+     * {@code retainAll}, and {@code clear} operations.  It does not\n+     * support the {@code add} or {@code addAll} operations.\n+     *\n+     * <p>The view's {@code iterator} is a \"weakly consistent\" iterator\n+     * that will never throw {@link ConcurrentModificationException},\n+     * and guarantees to traverse elements as they existed upon\n+     * construction of the iterator, and may (but is not guaranteed to)\n+     * reflect any modifications subsequent to construction.\n+     *\n+     * @return the collection view\n+     */\n+    @Override\n+    public Collection<V> values() {\n+        ValuesView<K,V> vs;\n+        return (vs = this.values) != null ? vs : (this.values = new ValuesView<K,V>(this));\n+    }\n+\n+    /**\n+     * Returns a {@link Set} view of the mappings contained in this map.\n+     * The set is backed by the map, so changes to the map are\n+     * reflected in the set, and vice-versa.  The set supports element\n+     * removal, which removes the corresponding mapping from the map,\n+     * via the {@code Iterator.remove}, {@code Set.remove},\n+     * {@code removeAll}, {@code retainAll}, and {@code clear}\n+     * operations.\n+     *\n+     * <p>The view's {@code iterator} is a \"weakly consistent\" iterator\n+     * that will never throw {@link ConcurrentModificationException},\n+     * and guarantees to traverse elements as they existed upon\n+     * construction of the iterator, and may (but is not guaranteed to)\n+     * reflect any modifications subsequent to construction.\n+     *\n+     * @return the set view\n+     */\n+    @Override\n+    public Set<Map.Entry<K,V>> entrySet() {\n+        EntrySetView<K,V> es;\n+        return (es = this.entrySet) != null ? es : (this.entrySet = new EntrySetView<K,V>(this));\n+    }\n+\n+    /**\n+     * Returns the hash code value for this {@link Map}, i.e.,\n+     * the sum of, for each key-value pair in the map,\n+     * {@code key.hashCode() ^ value.hashCode()}.\n+     *\n+     * @return the hash code value for this map\n+     */\n+    @Override\n+    public int hashCode() {\n+        int h = 0;\n+        Node<K,V>[] t;\n+        if ((t = this.table) != null) {\n+            Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n+            for (Node<K,V> p; (p = it.advance()) != null; ) {\n+                h += p.key.hashCode() ^ p.val.hashCode();\n+            }\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Returns a string representation of this map.  The string\n+     * representation consists of a list of key-value mappings (in no\n+     * particular order) enclosed in braces (\"{@code {}}\").  Adjacent\n+     * mappings are separated by the characters {@code \", \"} (comma\n+     * and space).  Each key-value mapping is rendered as the key\n+     * followed by an equals sign (\"{@code =}\") followed by the\n+     * associated value.\n+     *\n+     * @return a string representation of this map\n+     */\n+    @Override\n+    public String toString() {\n+        Node<K,V>[] t;\n+        int f = (t = this.table) == null ? 0 : t.length;\n+        Traverser<K,V> it = new Traverser<K,V>(t, f, 0, f);\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('{');\n+        Node<K,V> p;\n+        if ((p = it.advance()) != null) {\n+            for (;;) {\n+                K k = p.key;\n+                V v = p.val;\n+                sb.append(k == this ? \"(this Map)\" : k);\n+                sb.append('=');\n+                sb.append(v == this ? \"(this Map)\" : v);\n+                if ((p = it.advance()) == null) {\n+                    break;\n+                }\n+                sb.append(',').append(' ');\n+            }\n+        }\n+        return sb.append('}').toString();\n+    }\n+\n+    /**\n+     * Compares the specified object with this map for equality.\n+     * Returns {@code true} if the given object is a map with the same\n+     * mappings as this map.  This operation may return misleading\n+     * results if either map is concurrently modified during execution\n+     * of this method.\n+     *\n+     * @param o object to be compared for equality with this map\n+     * @return {@code true} if the specified object is equal to this map\n+     */\n+    @Override\n+    public boolean equals(Object o) {\n+        if (o != this) {\n+            if (!(o instanceof Map)) {\n+                return false;\n+            }\n+            Map<?,?> m = (Map<?,?>) o;\n+            Node<K,V>[] t;\n+            int f = (t = this.table) == null ? 0 : t.length;\n+            Traverser<K,V> it = new Traverser<K,V>(t, f, 0, f);\n+            for (Node<K,V> p; (p = it.advance()) != null; ) {\n+                V val = p.val;\n+                Object v = m.get(p.key);\n+                if (v == null || v != val && !v.equals(val)) {\n+                    return false;\n+                }\n+            }\n+            for (Map.Entry<?,?> e : m.entrySet()) {\n+                Object mk, mv, v;\n+                if ((mk = e.getKey()) == null ||\n+                    (mv = e.getValue()) == null ||\n+                    (v = get(mk)) == null ||\n+                    mv != v && !mv.equals(v)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Stripped-down version of helper class used in previous version,\n+     * declared for the sake of serialization compatibility\n+     */\n+    static class Segment<K,V> extends ReentrantLock implements Serializable {\n+        private static final long serialVersionUID = 2249069246763182397L;\n+        final float loadFactor;\n+        Segment(float lf) { this.loadFactor = lf; }\n+    }\n+\n+    /**\n+     * Saves the state of the {@code ConcurrentHashMapV8} instance to a\n+     * stream (i.e., serializes it).\n+     * @param s the stream\n+     * @throws java.io.IOException if an I/O error occurs\n+     * @serialData\n+     * the key (Object) and value (Object)\n+     * for each key-value mapping, followed by a null pair.\n+     * The key-value mappings are emitted in no particular order.\n+     */\n+    private void writeObject(java.io.ObjectOutputStream s)\n+        throws java.io.IOException {\n+        // For serialization compatibility\n+        // Emulate segment calculation from previous version of this class\n+        int sshift = 0;\n+        int ssize = 1;\n+        while (ssize < DEFAULT_CONCURRENCY_LEVEL) {\n+            ++sshift;\n+            ssize <<= 1;\n+        }\n+        int segmentShift = 32 - sshift;\n+        int segmentMask = ssize - 1;\n+        @SuppressWarnings(\"unchecked\") Segment<K,V>[] segments = (Segment<K,V>[])\n+            new Segment<?,?>[DEFAULT_CONCURRENCY_LEVEL];\n+        for (int i = 0; i < segments.length; ++i) {\n+            segments[i] = new Segment<K,V>(LOAD_FACTOR);\n+        }\n+        s.putFields().put(\"segments\", segments);\n+        s.putFields().put(\"segmentShift\", segmentShift);\n+        s.putFields().put(\"segmentMask\", segmentMask);\n+        s.writeFields();\n+\n+        Node<K,V>[] t;\n+        if ((t = this.table) != null) {\n+            Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n+            for (Node<K,V> p; (p = it.advance()) != null; ) {\n+                s.writeObject(p.key);\n+                s.writeObject(p.val);\n+            }\n+        }\n+        s.writeObject(null);\n+        s.writeObject(null);\n+        segments = null; // throw away\n+    }\n+\n+    /**\n+     * Reconstitutes the instance from a stream (that is, deserializes it).\n+     * @param s the stream\n+     * @throws ClassNotFoundException if the class of a serialized object\n+     *         could not be found\n+     * @throws java.io.IOException if an I/O error occurs\n+     */\n+    private void readObject(java.io.ObjectInputStream s)\n+        throws java.io.IOException, ClassNotFoundException {\n+        /*\n+         * To improve performance in typical cases, we create nodes\n+         * while reading, then place in table once size is known.\n+         * However, we must also validate uniqueness and deal with\n+         * overpopulated bins while doing so, which requires\n+         * specialized versions of putVal mechanics.\n+         */\n+        this.sizeCtl = -1; // force exclusion for table construction\n+        s.defaultReadObject();\n+        long size = 0L;\n+        Node<K,V> p = null;\n+        for (;;) {\n+            @SuppressWarnings(\"unchecked\") K k = (K) s.readObject();\n+            @SuppressWarnings(\"unchecked\") V v = (V) s.readObject();\n+            if (k != null && v != null) {\n+                p = new Node<K,V>(spread(k.hashCode()), k, v, p);\n+                ++size;\n+            } else {\n+                break;\n+            }\n+        }\n+        if (size == 0L) {\n+            this.sizeCtl = 0;\n+        } else {\n+            int n;\n+            if (size >= MAXIMUM_CAPACITY >>> 1) {\n+                n = MAXIMUM_CAPACITY;\n+            } else {\n+                int sz = (int)size;\n+                n = tableSizeFor(sz + (sz >>> 1) + 1);\n+            }\n+            @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n+                Node<K,V>[] tab = new Node[n];\n+            int mask = n - 1;\n+            long added = 0L;\n+            while (p != null) {\n+                boolean insertAtFront;\n+                Node<K,V> next = p.next, first;\n+                int h = p.hash, j = h & mask;\n+                if ((first = tabAt(tab, j)) == null) {\n+                    insertAtFront = true;\n+                } else {\n+                    K k = p.key;\n+                    if (first.hash < 0) {\n+                        TreeBin<K,V> t = (TreeBin<K,V>)first;\n+                        if (t.putTreeVal(h, k, p.val) == null) {\n+                            ++added;\n+                        }\n+                        insertAtFront = false;\n+                    }\n+                    else {\n+                        int binCount = 0;\n+                        insertAtFront = true;\n+                        Node<K,V> q; K qk;\n+                        for (q = first; q != null; q = q.next) {\n+                            if (q.hash == h &&\n+                                ((qk = q.key) == k ||\n+                                 qk != null && k.equals(qk))) {\n+                                insertAtFront = false;\n+                                break;\n+                            }\n+                            ++binCount;\n+                        }\n+                        if (insertAtFront && binCount >= TREEIFY_THRESHOLD) {\n+                            insertAtFront = false;\n+                            ++added;\n+                            p.next = first;\n+                            TreeNode<K,V> hd = null, tl = null;\n+                            for (q = p; q != null; q = q.next) {\n+                                TreeNode<K,V> t = new TreeNode<K,V>\n+                                    (q.hash, q.key, q.val, null, null);\n+                                if ((t.prev = tl) == null) {\n+                                    hd = t;\n+                                } else {\n+                                    tl.next = t;\n+                                }\n+                                tl = t;\n+                            }\n+                            setTabAt(tab, j, new TreeBin<K,V>(hd));\n+                        }\n+                    }\n+                }\n+                if (insertAtFront) {\n+                    ++added;\n+                    p.next = first;\n+                    setTabAt(tab, j, p);\n+                }\n+                p = next;\n+            }\n+            this.table = tab;\n+            this.sizeCtl = n - (n >>> 2);\n+            this.baseCount = added;\n+        }\n+    }\n+\n+    // ConcurrentMap methods\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @return the previous value associated with the specified key,\n+     *         or {@code null} if there was no mapping for the key\n+     * @throws NullPointerException if the specified key or value is null\n+     */\n+    @Override\n+    public V putIfAbsent(K key, V value) {\n+        return putVal(key, value, true);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException if the specified key is null\n+     */\n+    @Override\n+    public boolean remove(Object key, Object value) {\n+        if (key == null) {\n+            throw new NullPointerException();\n+        }\n+        return value != null && replaceNode(key, null, value) != null;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException if any of the arguments are null\n+     */\n+    @Override\n+    public boolean replace(K key, V oldValue, V newValue) {\n+        if (key == null || oldValue == null || newValue == null) {\n+            throw new NullPointerException();\n+        }\n+        return replaceNode(key, newValue, oldValue) != null;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @return the previous value associated with the specified key,\n+     *         or {@code null} if there was no mapping for the key\n+     * @throws NullPointerException if the specified key or value is null\n+     */\n+    @Override\n+    public V replace(K key, V value) {\n+        if (key == null || value == null) {\n+            throw new NullPointerException();\n+        }\n+        return replaceNode(key, value, null);\n+    }\n+\n+    // Overrides of JDK8+ Map extension method defaults\n+\n+    /**\n+     * Returns the value to which the specified key is mapped, or the\n+     * given default value if this map contains no mapping for the\n+     * key.\n+     *\n+     * @param key the key whose associated value is to be returned\n+     * @param defaultValue the value to return if this map contains\n+     * no mapping for the given key\n+     * @return the mapping for the key, if present; else the default value\n+     * @throws NullPointerException if the specified key is null\n+     */\n+    public V getOrDefault(Object key, V defaultValue) {\n+        V v;\n+        return (v = get(key)) == null ? defaultValue : v;\n+    }\n+\n+    public void forEach(BiAction<? super K, ? super V> action) {\n+        if (action == null) {\n+            throw new NullPointerException();\n+        }\n+        Node<K,V>[] t;\n+        if ((t = this.table) != null) {\n+            Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n+            for (Node<K,V> p; (p = it.advance()) != null; ) {\n+                action.apply(p.key, p.val);\n+            }\n+        }\n+    }\n+\n+    public void replaceAll(BiFun<? super K, ? super V, ? extends V> function) {\n+        if (function == null) {\n+            throw new NullPointerException();\n+        }\n+        Node<K,V>[] t;\n+        if ((t = this.table) != null) {\n+            Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n+            for (Node<K,V> p; (p = it.advance()) != null; ) {\n+                V oldValue = p.val;\n+                for (K key = p.key;;) {\n+                    V newValue = function.apply(key, oldValue);\n+                    if (newValue == null) {\n+                        throw new NullPointerException();\n+                    }\n+                    if (replaceNode(key, newValue, oldValue) != null ||\n+                        (oldValue = get(key)) == null) {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * If the specified key is not already associated with a value,\n+     * attempts to compute its value using the given mapping function\n+     * and enters it into this map unless {@code null}.  The entire\n+     * method invocation is performed atomically, so the function is\n+     * applied at most once per key.  Some attempted update operations\n+     * on this map by other threads may be blocked while computation\n+     * is in progress, so the computation should be short and simple,\n+     * and must not attempt to update any other mappings of this map.\n+     *\n+     * @param key key with which the specified value is to be associated\n+     * @param mappingFunction the function to compute a value\n+     * @return the current (existing or computed) value associated with\n+     *         the specified key, or null if the computed value is null\n+     * @throws NullPointerException if the specified key or mappingFunction\n+     *         is null\n+     * @throws IllegalStateException if the computation detectably\n+     *         attempts a recursive update to this map that would\n+     *         otherwise never complete\n+     * @throws RuntimeException or Error if the mappingFunction does so,\n+     *         in which case the mapping is left unestablished\n+     */\n+    public V computeIfAbsent(K key, Fun<? super K, ? extends V> mappingFunction) {\n+        if (key == null || mappingFunction == null) {\n+            throw new NullPointerException();\n+        }\n+        int h = spread(key.hashCode());\n+        V val = null;\n+        int binCount = 0;\n+        for (Node<K,V>[] tab = this.table;;) {\n+            Node<K,V> f; int n, i, fh;\n+            if (tab == null || (n = tab.length) == 0) {\n+                tab = initTable();\n+            } else if ((f = tabAt(tab, i = n - 1 & h)) == null) {\n+                Node<K,V> r = new ReservationNode<K,V>();\n+                synchronized (r) {\n+                    if (casTabAt(tab, i, null, r)) {\n+                        binCount = 1;\n+                        Node<K,V> node = null;\n+                        try {\n+                            if ((val = mappingFunction.apply(key)) != null) {\n+                                node = new Node<K,V>(h, key, val, null);\n+                            }\n+                        } finally {\n+                            setTabAt(tab, i, node);\n+                        }\n+                    }\n+                }\n+                if (binCount != 0) {\n+                    break;\n+                }\n+            }\n+            else if ((fh = f.hash) == MOVED) {\n+                tab = helpTransfer(tab, f);\n+            } else {\n+                boolean added = false;\n+                synchronized (f) {\n+                    if (tabAt(tab, i) == f) {\n+                        if (fh >= 0) {\n+                            binCount = 1;\n+                            for (Node<K,V> e = f;; ++binCount) {\n+                                K ek; V ev;\n+                                if (e.hash == h &&\n+                                    ((ek = e.key) == key ||\n+                                     ek != null && key.equals(ek))) {\n+                                    val = e.val;\n+                                    break;\n+                                }\n+                                Node<K,V> pred = e;\n+                                if ((e = e.next) == null) {\n+                                    if ((val = mappingFunction.apply(key)) != null) {\n+                                        added = true;\n+                                        pred.next = new Node<K,V>(h, key, val, null);\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        else if (f instanceof TreeBin) {\n+                            binCount = 2;\n+                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n+                            TreeNode<K,V> r, p;\n+                            if ((r = t.root) != null &&\n+                                (p = r.findTreeNode(h, key, null)) != null) {\n+                                val = p.val;\n+                            } else if ((val = mappingFunction.apply(key)) != null) {\n+                                added = true;\n+                                t.putTreeVal(h, key, val);\n+                            }\n+                        }\n+                    }\n+                }\n+                if (binCount != 0) {\n+                    if (binCount >= TREEIFY_THRESHOLD) {\n+                        treeifyBin(tab, i);\n+                    }\n+                    if (!added) {\n+                        return val;\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+        if (val != null) {\n+            addCount(1L, binCount);\n+        }\n+        return val;\n+    }\n+\n+    /**\n+     * If the value for the specified key is present, attempts to\n+     * compute a new mapping given the key and its current mapped\n+     * value.  The entire method invocation is performed atomically.\n+     * Some attempted update operations on this map by other threads\n+     * may be blocked while computation is in progress, so the\n+     * computation should be short and simple, and must not attempt to\n+     * update any other mappings of this map.\n+     *\n+     * @param key key with which a value may be associated\n+     * @param remappingFunction the function to compute a value\n+     * @return the new value associated with the specified key, or null if none\n+     * @throws NullPointerException if the specified key or remappingFunction\n+     *         is null\n+     * @throws IllegalStateException if the computation detectably\n+     *         attempts a recursive update to this map that would\n+     *         otherwise never complete\n+     * @throws RuntimeException or Error if the remappingFunction does so,\n+     *         in which case the mapping is unchanged\n+     */\n+    public V computeIfPresent(K key, BiFun<? super K, ? super V, ? extends V> remappingFunction) {\n+        if (key == null || remappingFunction == null) {\n+            throw new NullPointerException();\n+        }\n+        int h = spread(key.hashCode());\n+        V val = null;\n+        int delta = 0;\n+        int binCount = 0;\n+        for (Node<K,V>[] tab = this.table;;) {\n+            Node<K,V> f; int n, i, fh;\n+            if (tab == null || (n = tab.length) == 0) {\n+                tab = initTable();\n+            } else if ((f = tabAt(tab, i = n - 1 & h)) == null) {\n+                break;\n+            } else if ((fh = f.hash) == MOVED) {\n+                tab = helpTransfer(tab, f);\n+            } else {\n+                synchronized (f) {\n+                    if (tabAt(tab, i) == f) {\n+                        if (fh >= 0) {\n+                            binCount = 1;\n+                            for (Node<K,V> e = f, pred = null;; ++binCount) {\n+                                K ek;\n+                                if (e.hash == h &&\n+                                    ((ek = e.key) == key ||\n+                                     ek != null && key.equals(ek))) {\n+                                    val = remappingFunction.apply(key, e.val);\n+                                    if (val != null) {\n+                                        e.val = val;\n+                                    } else {\n+                                        delta = -1;\n+                                        Node<K,V> en = e.next;\n+                                        if (pred != null) {\n+                                            pred.next = en;\n+                                        } else {\n+                                            setTabAt(tab, i, en);\n+                                        }\n+                                    }\n+                                    break;\n+                                }\n+                                pred = e;\n+                                if ((e = e.next) == null) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        else if (f instanceof TreeBin) {\n+                            binCount = 2;\n+                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n+                            TreeNode<K,V> r, p;\n+                            if ((r = t.root) != null &&\n+                                (p = r.findTreeNode(h, key, null)) != null) {\n+                                val = remappingFunction.apply(key, p.val);\n+                                if (val != null) {\n+                                    p.val = val;\n+                                } else {\n+                                    delta = -1;\n+                                    if (t.removeTreeNode(p)) {\n+                                        setTabAt(tab, i, untreeify(t.first));\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (binCount != 0) {\n+                    break;\n+                }\n+            }\n+        }\n+        if (delta != 0) {\n+            addCount(delta, binCount);\n+        }\n+        return val;\n+    }\n+\n+    /**\n+     * Attempts to compute a mapping for the specified key and its\n+     * current mapped value (or {@code null} if there is no current\n+     * mapping). The entire method invocation is performed atomically.\n+     * Some attempted update operations on this map by other threads\n+     * may be blocked while computation is in progress, so the\n+     * computation should be short and simple, and must not attempt to\n+     * update any other mappings of this Map.\n+     *\n+     * @param key key with which the specified value is to be associated\n+     * @param remappingFunction the function to compute a value\n+     * @return the new value associated with the specified key, or null if none\n+     * @throws NullPointerException if the specified key or remappingFunction\n+     *         is null\n+     * @throws IllegalStateException if the computation detectably\n+     *         attempts a recursive update to this map that would\n+     *         otherwise never complete\n+     * @throws RuntimeException or Error if the remappingFunction does so,\n+     *         in which case the mapping is unchanged\n+     */\n+    public V compute(K key,\n+                     BiFun<? super K, ? super V, ? extends V> remappingFunction) {\n+        if (key == null || remappingFunction == null) {\n+            throw new NullPointerException();\n+        }\n+        int h = spread(key.hashCode());\n+        V val = null;\n+        int delta = 0;\n+        int binCount = 0;\n+        for (Node<K,V>[] tab = this.table;;) {\n+            Node<K,V> f; int n, i, fh;\n+            if (tab == null || (n = tab.length) == 0) {\n+                tab = initTable();\n+            } else if ((f = tabAt(tab, i = n - 1 & h)) == null) {\n+                Node<K,V> r = new ReservationNode<K,V>();\n+                synchronized (r) {\n+                    if (casTabAt(tab, i, null, r)) {\n+                        binCount = 1;\n+                        Node<K,V> node = null;\n+                        try {\n+                            if ((val = remappingFunction.apply(key, null)) != null) {\n+                                delta = 1;\n+                                node = new Node<K,V>(h, key, val, null);\n+                            }\n+                        } finally {\n+                            setTabAt(tab, i, node);\n+                        }\n+                    }\n+                }\n+                if (binCount != 0) {\n+                    break;\n+                }\n+            }\n+            else if ((fh = f.hash) == MOVED) {\n+                tab = helpTransfer(tab, f);\n+            } else {\n+                synchronized (f) {\n+                    if (tabAt(tab, i) == f) {\n+                        if (fh >= 0) {\n+                            binCount = 1;\n+                            for (Node<K,V> e = f, pred = null;; ++binCount) {\n+                                K ek;\n+                                if (e.hash == h &&\n+                                    ((ek = e.key) == key ||\n+                                     ek != null && key.equals(ek))) {\n+                                    val = remappingFunction.apply(key, e.val);\n+                                    if (val != null) {\n+                                        e.val = val;\n+                                    } else {\n+                                        delta = -1;\n+                                        Node<K,V> en = e.next;\n+                                        if (pred != null) {\n+                                            pred.next = en;\n+                                        } else {\n+                                            setTabAt(tab, i, en);\n+                                        }\n+                                    }\n+                                    break;\n+                                }\n+                                pred = e;\n+                                if ((e = e.next) == null) {\n+                                    val = remappingFunction.apply(key, null);\n+                                    if (val != null) {\n+                                        delta = 1;\n+                                        pred.next =\n+                                            new Node<K,V>(h, key, val, null);\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        else if (f instanceof TreeBin) {\n+                            binCount = 1;\n+                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n+                            TreeNode<K,V> r, p;\n+                            if ((r = t.root) != null) {\n+                                p = r.findTreeNode(h, key, null);\n+                            } else {\n+                                p = null;\n+                            }\n+                            V pv = p == null ? null : p.val;\n+                            val = remappingFunction.apply(key, pv);\n+                            if (val != null) {\n+                                if (p != null) {\n+                                    p.val = val;\n+                                } else {\n+                                    delta = 1;\n+                                    t.putTreeVal(h, key, val);\n+                                }\n+                            }\n+                            else if (p != null) {\n+                                delta = -1;\n+                                if (t.removeTreeNode(p)) {\n+                                    setTabAt(tab, i, untreeify(t.first));\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (binCount != 0) {\n+                    if (binCount >= TREEIFY_THRESHOLD) {\n+                        treeifyBin(tab, i);\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+        if (delta != 0) {\n+            addCount(delta, binCount);\n+        }\n+        return val;\n+    }\n+\n+    /**\n+     * If the specified key is not already associated with a\n+     * (non-null) value, associates it with the given value.\n+     * Otherwise, replaces the value with the results of the given\n+     * remapping function, or removes if {@code null}. The entire\n+     * method invocation is performed atomically.  Some attempted\n+     * update operations on this map by other threads may be blocked\n+     * while computation is in progress, so the computation should be\n+     * short and simple, and must not attempt to update any other\n+     * mappings of this Map.\n+     *\n+     * @param key key with which the specified value is to be associated\n+     * @param value the value to use if absent\n+     * @param remappingFunction the function to recompute a value if present\n+     * @return the new value associated with the specified key, or null if none\n+     * @throws NullPointerException if the specified key or the\n+     *         remappingFunction is null\n+     * @throws RuntimeException or Error if the remappingFunction does so,\n+     *         in which case the mapping is unchanged\n+     */\n+    public V merge(K key, V value, BiFun<? super V, ? super V, ? extends V> remappingFunction) {\n+        if (key == null || value == null || remappingFunction == null) {\n+            throw new NullPointerException();\n+        }\n+        int h = spread(key.hashCode());\n+        V val = null;\n+        int delta = 0;\n+        int binCount = 0;\n+        for (Node<K,V>[] tab = this.table;;) {\n+            Node<K,V> f; int n, i, fh;\n+            if (tab == null || (n = tab.length) == 0) {\n+                tab = initTable();\n+            } else if ((f = tabAt(tab, i = n - 1 & h)) == null) {\n+                if (casTabAt(tab, i, null, new Node<K,V>(h, key, value, null))) {\n+                    delta = 1;\n+                    val = value;\n+                    break;\n+                }\n+            }\n+            else if ((fh = f.hash) == MOVED) {\n+                tab = helpTransfer(tab, f);\n+            } else {\n+                synchronized (f) {\n+                    if (tabAt(tab, i) == f) {\n+                        if (fh >= 0) {\n+                            binCount = 1;\n+                            for (Node<K,V> e = f, pred = null;; ++binCount) {\n+                                K ek;\n+                                if (e.hash == h &&\n+                                    ((ek = e.key) == key ||\n+                                     ek != null && key.equals(ek))) {\n+                                    val = remappingFunction.apply(e.val, value);\n+                                    if (val != null) {\n+                                        e.val = val;\n+                                    } else {\n+                                        delta = -1;\n+                                        Node<K,V> en = e.next;\n+                                        if (pred != null) {\n+                                            pred.next = en;\n+                                        } else {\n+                                            setTabAt(tab, i, en);\n+                                        }\n+                                    }\n+                                    break;\n+                                }\n+                                pred = e;\n+                                if ((e = e.next) == null) {\n+                                    delta = 1;\n+                                    val = value;\n+                                    pred.next =\n+                                        new Node<K,V>(h, key, val, null);\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        else if (f instanceof TreeBin) {\n+                            binCount = 2;\n+                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n+                            TreeNode<K,V> r = t.root;\n+                            TreeNode<K,V> p = r == null ? null :\n+                                r.findTreeNode(h, key, null);\n+                            val = p == null ? value :\n+                                remappingFunction.apply(p.val, value);\n+                            if (val != null) {\n+                                if (p != null) {\n+                                    p.val = val;\n+                                } else {\n+                                    delta = 1;\n+                                    t.putTreeVal(h, key, val);\n+                                }\n+                            }\n+                            else if (p != null) {\n+                                delta = -1;\n+                                if (t.removeTreeNode(p)) {\n+                                    setTabAt(tab, i, untreeify(t.first));\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (binCount != 0) {\n+                    if (binCount >= TREEIFY_THRESHOLD) {\n+                        treeifyBin(tab, i);\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+        if (delta != 0) {\n+            addCount(delta, binCount);\n+        }\n+        return val;\n+    }\n+\n+    // Hashtable legacy methods\n+\n+    /**\n+     * Legacy method testing if some key maps into the specified value\n+     * in this table.  This method is identical in functionality to\n+     * {@link #containsValue(Object)}, and exists solely to ensure\n+     * full compatibility with class {@link java.util.Hashtable},\n+     * which supported this method prior to introduction of the\n+     * Java Collections framework.\n+     *\n+     * @param  value a value to search for\n+     * @return {@code true} if and only if some key maps to the\n+     *         {@code value} argument in this table as\n+     *         determined by the {@code equals} method;\n+     *         {@code false} otherwise\n+     * @throws NullPointerException if the specified value is null\n+     */\n+    @Deprecated public boolean contains(Object value) {\n+        return containsValue(value);\n+    }\n+\n+    /**\n+     * Returns an enumeration of the keys in this table.\n+     *\n+     * @return an enumeration of the keys in this table\n+     * @see #keySet()\n+     */\n+    public Enumeration<K> keys() {\n+        Node<K,V>[] t;\n+        int f = (t = this.table) == null ? 0 : t.length;\n+        return new KeyIterator<K,V>(t, f, 0, f, this);\n+    }\n+\n+    /**\n+     * Returns an enumeration of the values in this table.\n+     *\n+     * @return an enumeration of the values in this table\n+     * @see #values()\n+     */\n+    public Enumeration<V> elements() {\n+        Node<K,V>[] t;\n+        int f = (t = this.table) == null ? 0 : t.length;\n+        return new ValueIterator<K,V>(t, f, 0, f, this);\n+    }\n+\n+    // ConcurrentHashMapV8-only methods\n+\n+    /**\n+     * Returns the number of mappings. This method should be used\n+     * instead of {@link #size} because a ConcurrentHashMapV8 may\n+     * contain more mappings than can be represented as an int. The\n+     * value returned is an estimate; the actual count may differ if\n+     * there are concurrent insertions or removals.\n+     *\n+     * @return the number of mappings\n+     * @since 1.8\n+     */\n+    public long mappingCount() {\n+        long n = sumCount();\n+        return n < 0L ? 0L : n; // ignore transient negative values\n+    }\n+\n+    /**\n+     * Creates a new {@link Set} backed by a ConcurrentHashMapV8\n+     * from the given type to {@code Boolean.TRUE}.\n+     *\n+     * @return the new set\n+     * @since 1.8\n+     */\n+    public static <K> KeySetView<K,Boolean> newKeySet() {\n+        return new KeySetView<K,Boolean>\n+            (new ConcurrentHashMapV8<K,Boolean>(), Boolean.TRUE);\n+    }\n+\n+    /**\n+     * Creates a new {@link Set} backed by a ConcurrentHashMapV8\n+     * from the given type to {@code Boolean.TRUE}.\n+     *\n+     * @param initialCapacity The implementation performs internal\n+     * sizing to accommodate this many elements.\n+     * @return the new set\n+     * @throws IllegalArgumentException if the initial capacity of\n+     * elements is negative\n+     * @since 1.8\n+     */\n+    public static <K> KeySetView<K,Boolean> newKeySet(int initialCapacity) {\n+        return new KeySetView<K,Boolean>\n+            (new ConcurrentHashMapV8<K,Boolean>(initialCapacity), Boolean.TRUE);\n+    }\n+\n+    /**\n+     * Returns a {@link Set} view of the keys in this map, using the\n+     * given common mapped value for any additions (i.e., {@link\n+     * Collection#add} and {@link Collection#addAll(Collection)}).\n+     * This is of course only appropriate if it is acceptable to use\n+     * the same value for all additions from this view.\n+     *\n+     * @param mappedValue the mapped value to use for any additions\n+     * @return the set view\n+     * @throws NullPointerException if the mappedValue is null\n+     */\n+    public KeySetView<K,V> keySet(V mappedValue) {\n+        if (mappedValue == null) {\n+            throw new NullPointerException();\n+        }\n+        return new KeySetView<K,V>(this, mappedValue);\n+    }\n+\n+    /* ---------------- Special Nodes -------------- */\n+\n+    /**\n+     * A node inserted at head of bins during transfer operations.\n+     */\n+    static final class ForwardingNode<K,V> extends Node<K,V> {\n+        final Node<K,V>[] nextTable;\n+        ForwardingNode(Node<K,V>[] tab) {\n+            super(MOVED, null, null, null);\n+            this.nextTable = tab;\n+        }\n+\n+        @Override\n+        Node<K,V> find(int h, Object k) {\n+            // loop to avoid arbitrarily deep recursion on forwarding nodes\n+            outer: for (Node<K,V>[] tab = this.nextTable;;) {\n+                Node<K,V> e; int n;\n+                if (k == null || tab == null || (n = tab.length) == 0 ||\n+                    (e = tabAt(tab, n - 1 & h)) == null) {\n+                    return null;\n+                }\n+                for (;;) {\n+                    int eh; K ek;\n+                    if ((eh = e.hash) == h &&\n+                        ((ek = e.key) == k || ek != null && k.equals(ek))) {\n+                        return e;\n+                    }\n+                    if (eh < 0) {\n+                        if (e instanceof ForwardingNode) {\n+                            tab = ((ForwardingNode<K,V>)e).nextTable;\n+                            continue outer;\n+                        } else {\n+                            return e.find(h, k);\n+                        }\n+                    }\n+                    if ((e = e.next) == null) {\n+                        return null;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A place-holder node used in computeIfAbsent and compute\n+     */\n+    static final class ReservationNode<K,V> extends Node<K,V> {\n+        ReservationNode() {\n+            super(RESERVED, null, null, null);\n+        }\n+\n+        @Override\n+        Node<K,V> find(int h, Object k) {\n+            return null;\n+        }\n+    }\n+\n+    /* ---------------- Table Initialization and Resizing -------------- */\n+\n+    /**\n+     * Initializes table, using the size recorded in sizeCtl.\n+     */\n+    private final Node<K,V>[] initTable() {\n+        Node<K,V>[] tab; int sc;\n+        while ((tab = this.table) == null || tab.length == 0) {\n+            if ((sc = this.sizeCtl) < 0) {\n+                Thread.yield(); // lost initialization race; just spin\n+            } else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n+                try {\n+                    if ((tab = this.table) == null || tab.length == 0) {\n+                        int n = sc > 0 ? sc : DEFAULT_CAPACITY;\n+                        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n+                            Node<K,V>[] nt = new Node[n];\n+                        this.table = tab = nt;\n+                        sc = n - (n >>> 2);\n+                    }\n+                } finally {\n+                    this.sizeCtl = sc;\n+                }\n+                break;\n+            }\n+        }\n+        return tab;\n+    }\n+\n+    /**\n+     * Adds to count, and if table is too small and not already\n+     * resizing, initiates transfer. If already resizing, helps\n+     * perform transfer if work is available.  Rechecks occupancy\n+     * after a transfer to see if another resize is already needed\n+     * because resizings are lagging additions.\n+     *\n+     * @param x the count to add\n+     * @param check if <0, don't check resize, if <= 1 only check if uncontended\n+     */\n+    private final void addCount(long x, int check) {\n+        CounterCell[] as; long b, s;\n+        if ((as = this.counterCells) != null ||\n+            !U.compareAndSwapLong(this, BASECOUNT, b = this.baseCount, s = b + x)) {\n+            CounterHashCode hc; CounterCell a; long v; int m;\n+            boolean uncontended = true;\n+            if ((hc = threadCounterHashCode.get()) == null ||\n+                as == null || (m = as.length - 1) < 0 ||\n+                (a = as[m & hc.code]) == null ||\n+                !(uncontended =\n+                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {\n+                fullAddCount(x, hc, uncontended);\n+                return;\n+            }\n+            if (check <= 1) {\n+                return;\n+            }\n+            s = sumCount();\n+        }\n+        if (check >= 0) {\n+            Node<K,V>[] tab, nt; int sc;\n+            while (s >= (sc = this.sizeCtl) && (tab = this.table) != null &&\n+                   tab.length < MAXIMUM_CAPACITY) {\n+                if (sc < 0) {\n+                    if (sc == -1 || this.transferIndex <= this.transferOrigin ||\n+                        (nt = this.nextTable) == null) {\n+                        break;\n+                    }\n+                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc - 1)) {\n+                        transfer(tab, nt);\n+                    }\n+                }\n+                else if (U.compareAndSwapInt(this, SIZECTL, sc, -2)) {\n+                    transfer(tab, null);\n+                }\n+                s = sumCount();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Helps transfer if a resize is in progress.\n+     */\n+    final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) {\n+        Node<K,V>[] nextTab; int sc;\n+        if (f instanceof ForwardingNode &&\n+            (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {\n+            if (nextTab == this.nextTable && tab == this.table &&\n+                this.transferIndex > this.transferOrigin && (sc = this.sizeCtl) < -1 &&\n+                U.compareAndSwapInt(this, SIZECTL, sc, sc - 1)) {\n+                transfer(tab, nextTab);\n+            }\n+            return nextTab;\n+        }\n+        return this.table;\n+    }\n+\n+    /**\n+     * Tries to presize table to accommodate the given number of elements.\n+     *\n+     * @param size number of elements (doesn't need to be perfectly accurate)\n+     */\n+    private final void tryPresize(int size) {\n+        int c = size >= MAXIMUM_CAPACITY >>> 1 ? MAXIMUM_CAPACITY :\n+            tableSizeFor(size + (size >>> 1) + 1);\n+        int sc;\n+        while ((sc = this.sizeCtl) >= 0) {\n+            Node<K,V>[] tab = this.table; int n;\n+            if (tab == null || (n = tab.length) == 0) {\n+                n = sc > c ? sc : c;\n+                if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n+                    try {\n+                        if (this.table == tab) {\n+                            @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n+                                Node<K,V>[] nt = new Node[n];\n+                            this.table = nt;\n+                            sc = n - (n >>> 2);\n+                        }\n+                    } finally {\n+                        this.sizeCtl = sc;\n+                    }\n+                }\n+            }\n+            else if (c <= sc || n >= MAXIMUM_CAPACITY) {\n+                break;\n+            } else if (tab == this.table &&\n+                     U.compareAndSwapInt(this, SIZECTL, sc, -2)) {\n+                transfer(tab, null);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Moves and/or copies the nodes in each bin to new table. See\n+     * above for explanation.\n+     */\n+    private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {\n+        int n = tab.length, stride;\n+        if ((stride = NCPU > 1 ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)\n+         {\n+            stride = MIN_TRANSFER_STRIDE; // subdivide range\n+        }\n+        if (nextTab == null) {            // initiating\n+            try {\n+                @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n+                    Node<K,V>[] nt = new Node[n << 1];\n+                nextTab = nt;\n+            } catch (Throwable ex) {      // try to cope with OOME\n+                this.sizeCtl = Integer.MAX_VALUE;\n+                return;\n+            }\n+            this.nextTable = nextTab;\n+            this.transferOrigin = n;\n+            this.transferIndex = n;\n+            ForwardingNode<K,V> rev = new ForwardingNode<K,V>(tab);\n+            for (int k = n; k > 0;) {    // progressively reveal ready slots\n+                int nextk = k > stride ? k - stride : 0;\n+                for (int m = nextk; m < k; ++m) {\n+                    nextTab[m] = rev;\n+                }\n+                for (int m = n + nextk; m < n + k; ++m) {\n+                    nextTab[m] = rev;\n+                }\n+                U.putOrderedInt(this, TRANSFERORIGIN, k = nextk);\n+            }\n+        }\n+        int nextn = nextTab.length;\n+        ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);\n+        boolean advance = true;\n+        boolean finishing = false; // to ensure sweep before committing nextTab\n+        for (int i = 0, bound = 0;;) {\n+            int nextIndex, nextBound, fh; Node<K,V> f;\n+            while (advance) {\n+                if (--i >= bound || finishing) {\n+                    advance = false;\n+                } else if ((nextIndex = this.transferIndex) <= this.transferOrigin) {\n+                    i = -1;\n+                    advance = false;\n+                }\n+                else if (U.compareAndSwapInt\n+                         (this, TRANSFERINDEX, nextIndex,\n+                          nextBound = nextIndex > stride ?\n+                                       nextIndex - stride : 0)) {\n+                    bound = nextBound;\n+                    i = nextIndex - 1;\n+                    advance = false;\n+                }\n+            }\n+            if (i < 0 || i >= n || i + n >= nextn) {\n+                if (finishing) {\n+                    this.nextTable = null;\n+                    this.table = nextTab;\n+                    this.sizeCtl = (n << 1) - (n >>> 1);\n+                    return;\n+                }\n+                for (int sc;;) {\n+                    if (U.compareAndSwapInt(this, SIZECTL, sc = this.sizeCtl, ++sc)) {\n+                        if (sc != -1) {\n+                            return;\n+                        }\n+                        finishing = advance = true;\n+                        i = n; // recheck before commit\n+                        break;\n+                    }\n+                }\n+            }\n+            else if ((f = tabAt(tab, i)) == null) {\n+                if (casTabAt(tab, i, null, fwd)) {\n+                    setTabAt(nextTab, i, null);\n+                    setTabAt(nextTab, i + n, null);\n+                    advance = true;\n+                }\n+            }\n+            else if ((fh = f.hash) == MOVED) {\n+                advance = true; // already processed\n+            } else {\n+                synchronized (f) {\n+                    if (tabAt(tab, i) == f) {\n+                        Node<K,V> ln, hn;\n+                        if (fh >= 0) {\n+                            int runBit = fh & n;\n+                            Node<K,V> lastRun = f;\n+                            for (Node<K,V> p = f.next; p != null; p = p.next) {\n+                                int b = p.hash & n;\n+                                if (b != runBit) {\n+                                    runBit = b;\n+                                    lastRun = p;\n+                                }\n+                            }\n+                            if (runBit == 0) {\n+                                ln = lastRun;\n+                                hn = null;\n+                            }\n+                            else {\n+                                hn = lastRun;\n+                                ln = null;\n+                            }\n+                            for (Node<K,V> p = f; p != lastRun; p = p.next) {\n+                                int ph = p.hash; K pk = p.key; V pv = p.val;\n+                                if ((ph & n) == 0) {\n+                                    ln = new Node<K,V>(ph, pk, pv, ln);\n+                                } else {\n+                                    hn = new Node<K,V>(ph, pk, pv, hn);\n+                                }\n+                            }\n+                            setTabAt(nextTab, i, ln);\n+                            setTabAt(nextTab, i + n, hn);\n+                            setTabAt(tab, i, fwd);\n+                            advance = true;\n+                        }\n+                        else if (f instanceof TreeBin) {\n+                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n+                            TreeNode<K,V> lo = null, loTail = null;\n+                            TreeNode<K,V> hi = null, hiTail = null;\n+                            int lc = 0, hc = 0;\n+                            for (Node<K,V> e = t.first; e != null; e = e.next) {\n+                                int h = e.hash;\n+                                TreeNode<K,V> p = new TreeNode<K,V>\n+                                    (h, e.key, e.val, null, null);\n+                                if ((h & n) == 0) {\n+                                    if ((p.prev = loTail) == null) {\n+                                        lo = p;\n+                                    } else {\n+                                        loTail.next = p;\n+                                    }\n+                                    loTail = p;\n+                                    ++lc;\n+                                }\n+                                else {\n+                                    if ((p.prev = hiTail) == null) {\n+                                        hi = p;\n+                                    } else {\n+                                        hiTail.next = p;\n+                                    }\n+                                    hiTail = p;\n+                                    ++hc;\n+                                }\n+                            }\n+                            ln = lc <= UNTREEIFY_THRESHOLD ? untreeify(lo) :\n+                                hc != 0 ? new TreeBin<K,V>(lo) : t;\n+                            hn = hc <= UNTREEIFY_THRESHOLD ? untreeify(hi) :\n+                                lc != 0 ? new TreeBin<K,V>(hi) : t;\n+                            setTabAt(nextTab, i, ln);\n+                            setTabAt(nextTab, i + n, hn);\n+                            setTabAt(tab, i, fwd);\n+                            advance = true;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /* ---------------- Conversion from/to TreeBins -------------- */\n+\n+    /**\n+     * Replaces all linked nodes in bin at given index unless table is\n+     * too small, in which case resizes instead.\n+     */\n+    private final void treeifyBin(Node<K,V>[] tab, int index) {\n+        Node<K,V> b; int n, sc;\n+        if (tab != null) {\n+            if ((n = tab.length) < MIN_TREEIFY_CAPACITY) {\n+                if (tab == this.table && (sc = this.sizeCtl) >= 0 &&\n+                    U.compareAndSwapInt(this, SIZECTL, sc, -2)) {\n+                    transfer(tab, null);\n+                }\n+            }\n+            else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {\n+                synchronized (b) {\n+                    if (tabAt(tab, index) == b) {\n+                        TreeNode<K,V> hd = null, tl = null;\n+                        for (Node<K,V> e = b; e != null; e = e.next) {\n+                            TreeNode<K,V> p =\n+                                new TreeNode<K,V>(e.hash, e.key, e.val,\n+                                                  null, null);\n+                            if ((p.prev = tl) == null) {\n+                                hd = p;\n+                            } else {\n+                                tl.next = p;\n+                            }\n+                            tl = p;\n+                        }\n+                        setTabAt(tab, index, new TreeBin<K,V>(hd));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a list on non-TreeNodes replacing those in given list.\n+     */\n+    static <K,V> Node<K,V> untreeify(Node<K,V> b) {\n+        Node<K,V> hd = null, tl = null;\n+        for (Node<K,V> q = b; q != null; q = q.next) {\n+            Node<K,V> p = new Node<K,V>(q.hash, q.key, q.val, null);\n+            if (tl == null) {\n+                hd = p;\n+            } else {\n+                tl.next = p;\n+            }\n+            tl = p;\n+        }\n+        return hd;\n+    }\n+\n+    /* ---------------- TreeNodes -------------- */\n+\n+    /**\n+     * Nodes for use in TreeBins\n+     */\n+    static final class TreeNode<K,V> extends Node<K,V> {\n+        TreeNode<K,V> parent;  // red-black tree links\n+        TreeNode<K,V> left;\n+        TreeNode<K,V> right;\n+        TreeNode<K,V> prev;    // needed to unlink next upon deletion\n+        boolean red;\n+\n+        TreeNode(int hash, K key, V val, Node<K,V> next,\n+                 TreeNode<K,V> parent) {\n+            super(hash, key, val, next);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        Node<K,V> find(int h, Object k) {\n+            return findTreeNode(h, k, null);\n+        }\n+\n+        /**\n+         * Returns the TreeNode (or null if not found) for the given key\n+         * starting at given root.\n+         */\n+        final TreeNode<K,V> findTreeNode(int h, Object k, Class<?> kc) {\n+            if (k != null) {\n+                TreeNode<K,V> p = this;\n+                do  {\n+                    int ph, dir; K pk; TreeNode<K,V> q;\n+                    TreeNode<K,V> pl = p.left, pr = p.right;\n+                    if ((ph = p.hash) > h) {\n+                        p = pl;\n+                    } else if (ph < h) {\n+                        p = pr;\n+                    } else if ((pk = p.key) == k || pk != null && k.equals(pk)) {\n+                        return p;\n+                    } else if (pl == null) {\n+                        p = pr;\n+                    } else if (pr == null) {\n+                        p = pl;\n+                    } else if ((kc != null ||\n+                              (kc = comparableClassFor(k)) != null) &&\n+                             (dir = compareComparables(kc, k, pk)) != 0) {\n+                        p = dir < 0 ? pl : pr;\n+                    } else if ((q = pr.findTreeNode(h, k, kc)) != null) {\n+                        return q;\n+                    } else {\n+                        p = pl;\n+                    }\n+                } while (p != null);\n+            }\n+            return null;\n+        }\n+    }\n+\n+    /* ---------------- TreeBins -------------- */\n+\n+    /**\n+     * TreeNodes used at the heads of bins. TreeBins do not hold user\n+     * keys or values, but instead point to list of TreeNodes and\n+     * their root. They also maintain a parasitic read-write lock\n+     * forcing writers (who hold bin lock) to wait for readers (who do\n+     * not) to complete before tree restructuring operations.\n+     */\n+    static final class TreeBin<K,V> extends Node<K,V> {\n+        TreeNode<K,V> root;\n+        volatile TreeNode<K,V> first;\n+        volatile Thread waiter;\n+        volatile int lockState;\n+        // values for lockState\n+        static final int WRITER = 1; // set while holding write lock\n+        static final int WAITER = 2; // set when waiting for write lock\n+        static final int READER = 4; // increment value for setting read lock\n+\n+        /**\n+         * Tie-breaking utility for ordering insertions when equal\n+         * hashCodes and non-comparable. We don't require a total\n+         * order, just a consistent insertion rule to maintain\n+         * equivalence across rebalancings. Tie-breaking further than\n+         * necessary simplifies testing a bit.\n+         */\n+        static int tieBreakOrder(Object a, Object b) {\n+            int d;\n+            if (a == null || b == null ||\n+                (d = a.getClass().getName().\n+                 compareTo(b.getClass().getName())) == 0) {\n+                d = System.identityHashCode(a) <= System.identityHashCode(b) ?\n+                     -1 : 1;\n+            }\n+            return d;\n+        }\n+\n+        /**\n+         * Creates bin with initial set of nodes headed by b.\n+         */\n+        TreeBin(TreeNode<K,V> b) {\n+            super(TREEBIN, null, null, null);\n+            this.first = b;\n+            TreeNode<K,V> r = null;\n+            for (TreeNode<K,V> x = b, next; x != null; x = next) {\n+                next = (TreeNode<K,V>)x.next;\n+                x.left = x.right = null;\n+                if (r == null) {\n+                    x.parent = null;\n+                    x.red = false;\n+                    r = x;\n+                }\n+                else {\n+                    K k = x.key;\n+                    int h = x.hash;\n+                    Class<?> kc = null;\n+                    for (TreeNode<K,V> p = r;;) {\n+                        int dir, ph;\n+                        K pk = p.key;\n+                        if ((ph = p.hash) > h) {\n+                            dir = -1;\n+                        } else if (ph < h) {\n+                            dir = 1;\n+                        } else if (kc == null &&\n+                                  (kc = comparableClassFor(k)) == null ||\n+                                 (dir = compareComparables(kc, k, pk)) == 0) {\n+                            dir = tieBreakOrder(k, pk);\n+                        }\n+                            TreeNode<K,V> xp = p;\n+                        if ((p = dir <= 0 ? p.left : p.right) == null) {\n+                            x.parent = xp;\n+                            if (dir <= 0) {\n+                                xp.left = x;\n+                            } else {\n+                                xp.right = x;\n+                            }\n+                            r = balanceInsertion(r, x);\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            this.root = r;\n+            assert checkInvariants(this.root);\n+        }\n+\n+        /**\n+         * Acquires write lock for tree restructuring.\n+         */\n+        private final void lockRoot() {\n+            if (!U.compareAndSwapInt(this, LOCKSTATE, 0, WRITER))\n+             {\n+                contendedLock(); // offload to separate method\n+            }\n+        }\n+\n+        /**\n+         * Releases write lock for tree restructuring.\n+         */\n+        private final void unlockRoot() {\n+            this.lockState = 0;\n+        }\n+\n+        /**\n+         * Possibly blocks awaiting root lock.\n+         */\n+        private final void contendedLock() {\n+            boolean waiting = false;\n+            for (int s;;) {\n+                if (((s = this.lockState) & WRITER) == 0) {\n+                    if (U.compareAndSwapInt(this, LOCKSTATE, s, WRITER)) {\n+                        if (waiting) {\n+                            this.waiter = null;\n+                        }\n+                        return;\n+                    }\n+                }\n+                else if ((s | WAITER) == 0) {\n+                    if (U.compareAndSwapInt(this, LOCKSTATE, s, s | WAITER)) {\n+                        waiting = true;\n+                        this.waiter = Thread.currentThread();\n+                    }\n+                }\n+                else if (waiting) {\n+                    LockSupport.park(this);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Returns matching node or null if none. Tries to search\n+         * using tree comparisons from root, but continues linear\n+         * search when lock not available.\n+         */\n+@Override\n+final Node<K,V> find(int h, Object k) {\n+            if (k != null) {\n+                for (Node<K,V> e = this.first; e != null; e = e.next) {\n+                    int s; K ek;\n+                    if (((s = this.lockState) & (WAITER|WRITER)) != 0) {\n+                        if (e.hash == h &&\n+                            ((ek = e.key) == k || ek != null && k.equals(ek))) {\n+                            return e;\n+                        }\n+                    }\n+                    else if (U.compareAndSwapInt(this, LOCKSTATE, s,\n+                                                 s + READER)) {\n+                        TreeNode<K,V> r, p;\n+                        try {\n+                            p = (r = this.root) == null ? null :\n+                                 r.findTreeNode(h, k, null);\n+                        } finally {\n+                            Thread w;\n+                            int ls;\n+                            do {} while (!U.compareAndSwapInt\n+                                         (this, LOCKSTATE,\n+                                          ls = this.lockState, ls - READER));\n+                            if (ls == (READER|WAITER) && (w = this.waiter) != null) {\n+                                LockSupport.unpark(w);\n+                            }\n+                        }\n+                        return p;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+\n+        /**\n+         * Finds or adds a node.\n+         * @return null if added\n+         */\n+        final TreeNode<K,V> putTreeVal(int h, K k, V v) {\n+            Class<?> kc = null;\n+            boolean searched = false;\n+            for (TreeNode<K,V> p = this.root;;) {\n+                int dir, ph; K pk;\n+                if (p == null) {\n+                    this.first = this.root = new TreeNode<K,V>(h, k, v, null, null);\n+                    break;\n+                }\n+                else if ((ph = p.hash) > h) {\n+                    dir = -1;\n+                } else if (ph < h) {\n+                    dir = 1;\n+                } else if ((pk = p.key) == k || pk != null && k.equals(pk)) {\n+                    return p;\n+                } else if (kc == null &&\n+                          (kc = comparableClassFor(k)) == null ||\n+                         (dir = compareComparables(kc, k, pk)) == 0) {\n+                    if (!searched) {\n+                        TreeNode<K,V> q, ch;\n+                        searched = true;\n+                        if ((ch = p.left) != null &&\n+                             (q = ch.findTreeNode(h, k, kc)) != null ||\n+                            (ch = p.right) != null &&\n+                             (q = ch.findTreeNode(h, k, kc)) != null) {\n+                            return q;\n+                        }\n+                    }\n+                    dir = tieBreakOrder(k, pk);\n+                }\n+\n+                TreeNode<K,V> xp = p;\n+                if ((p = dir <= 0 ? p.left : p.right) == null) {\n+                    TreeNode<K,V> x, f = this.first;\n+                    this.first = x = new TreeNode<K,V>(h, k, v, f, xp);\n+                    if (f != null) {\n+                        f.prev = x;\n+                    }\n+                    if (dir <= 0) {\n+                        xp.left = x;\n+                    } else {\n+                        xp.right = x;\n+                    }\n+                    if (!xp.red) {\n+                        x.red = true;\n+                    } else {\n+                        lockRoot();\n+                        try {\n+                            this.root = balanceInsertion(this.root, x);\n+                        } finally {\n+                            unlockRoot();\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+            assert checkInvariants(this.root);\n+            return null;\n+        }\n+\n+        /**\n+         * Removes the given node, that must be present before this\n+         * call.  This is messier than typical red-black deletion code\n+         * because we cannot swap the contents of an interior node\n+         * with a leaf successor that is pinned by \"next\" pointers\n+         * that are accessible independently of lock. So instead we\n+         * swap the tree linkages.\n+         *\n+         * @return true if now too small, so should be untreeified\n+         */\n+        final boolean removeTreeNode(TreeNode<K,V> p) {\n+            TreeNode<K,V> next = (TreeNode<K,V>)p.next;\n+            TreeNode<K,V> pred = p.prev;  // unlink traversal pointers\n+            TreeNode<K,V> r, rl;\n+            if (pred == null) {\n+                this.first = next;\n+            } else {\n+                pred.next = next;\n+            }\n+            if (next != null) {\n+                next.prev = pred;\n+            }\n+            if (this.first == null) {\n+                this.root = null;\n+                return true;\n+            }\n+            if ((r = this.root) == null || r.right == null || // too small\n+                (rl = r.left) == null || rl.left == null) {\n+                return true;\n+            }\n+            lockRoot();\n+            try {\n+                TreeNode<K,V> replacement;\n+                TreeNode<K,V> pl = p.left;\n+                TreeNode<K,V> pr = p.right;\n+                if (pl != null && pr != null) {\n+                    TreeNode<K,V> s = pr, sl;\n+                    while ((sl = s.left) != null) {\n+                        s = sl;\n+                    }\n+                    boolean c = s.red; s.red = p.red; p.red = c; // swap colors\n+                    TreeNode<K,V> sr = s.right;\n+                    TreeNode<K,V> pp = p.parent;\n+                    if (s == pr) { // p was s's direct parent\n+                        p.parent = s;\n+                        s.right = p;\n+                    }\n+                    else {\n+                        TreeNode<K,V> sp = s.parent;\n+                        if ((p.parent = sp) != null) {\n+                            if (s == sp.left) {\n+                                sp.left = p;\n+                            } else {\n+                                sp.right = p;\n+                            }\n+                        }\n+                        if ((s.right = pr) != null) {\n+                            pr.parent = s;\n+                        }\n+                    }\n+                    p.left = null;\n+                    if ((p.right = sr) != null) {\n+                        sr.parent = p;\n+                    }\n+                    if ((s.left = pl) != null) {\n+                        pl.parent = s;\n+                    }\n+                    if ((s.parent = pp) == null) {\n+                        r = s;\n+                    } else if (p == pp.left) {\n+                        pp.left = s;\n+                    } else {\n+                        pp.right = s;\n+                    }\n+                    if (sr != null) {\n+                        replacement = sr;\n+                    } else {\n+                        replacement = p;\n+                    }\n+                }\n+                else if (pl != null) {\n+                    replacement = pl;\n+                } else if (pr != null) {\n+                    replacement = pr;\n+                } else {\n+                    replacement = p;\n+                }\n+                if (replacement != p) {\n+                    TreeNode<K,V> pp = replacement.parent = p.parent;\n+                    if (pp == null) {\n+                        r = replacement;\n+                    } else if (p == pp.left) {\n+                        pp.left = replacement;\n+                    } else {\n+                        pp.right = replacement;\n+                    }\n+                    p.left = p.right = p.parent = null;\n+                }\n+\n+                this.root = p.red ? r : balanceDeletion(r, replacement);\n+\n+                if (p == replacement) {  // detach pointers\n+                    TreeNode<K,V> pp;\n+                    if ((pp = p.parent) != null) {\n+                        if (p == pp.left) {\n+                            pp.left = null;\n+                        } else if (p == pp.right) {\n+                            pp.right = null;\n+                        }\n+                        p.parent = null;\n+                    }\n+                }\n+            } finally {\n+                unlockRoot();\n+            }\n+            assert checkInvariants(this.root);\n+            return false;\n+        }\n+\n+        /* ------------------------------------------------------------ */\n+        // Red-black tree methods, all adapted from CLR\n+\n+        static <K,V> TreeNode<K,V> rotateLeft(TreeNode<K,V> root,\n+                                              TreeNode<K,V> p) {\n+            TreeNode<K,V> r, pp, rl;\n+            if (p != null && (r = p.right) != null) {\n+                if ((rl = p.right = r.left) != null) {\n+                    rl.parent = p;\n+                }\n+                if ((pp = r.parent = p.parent) == null) {\n+                    (root = r).red = false;\n+                } else if (pp.left == p) {\n+                    pp.left = r;\n+                } else {\n+                    pp.right = r;\n+                }\n+                r.left = p;\n+                p.parent = r;\n+            }\n+            return root;\n+        }\n+\n+        static <K,V> TreeNode<K,V> rotateRight(TreeNode<K,V> root,\n+                                               TreeNode<K,V> p) {\n+            TreeNode<K,V> l, pp, lr;\n+            if (p != null && (l = p.left) != null) {\n+                if ((lr = p.left = l.right) != null) {\n+                    lr.parent = p;\n+                }\n+                if ((pp = l.parent = p.parent) == null) {\n+                    (root = l).red = false;\n+                } else if (pp.right == p) {\n+                    pp.right = l;\n+                } else {\n+                    pp.left = l;\n+                }\n+                l.right = p;\n+                p.parent = l;\n+            }\n+            return root;\n+        }\n+\n+        static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root,\n+                                                    TreeNode<K,V> x) {\n+            x.red = true;\n+            for (TreeNode<K,V> xp, xpp, xppl, xppr;;) {\n+                if ((xp = x.parent) == null) {\n+                    x.red = false;\n+                    return x;\n+                }\n+                else if (!xp.red || (xpp = xp.parent) == null) {\n+                    return root;\n+                }\n+                if (xp == (xppl = xpp.left)) {\n+                    if ((xppr = xpp.right) != null && xppr.red) {\n+                        xppr.red = false;\n+                        xp.red = false;\n+                        xpp.red = true;\n+                        x = xpp;\n+                    }\n+                    else {\n+                        if (x == xp.right) {\n+                            root = rotateLeft(root, x = xp);\n+                            xpp = (xp = x.parent) == null ? null : xp.parent;\n+                        }\n+                        if (xp != null) {\n+                            xp.red = false;\n+                            if (xpp != null) {\n+                                xpp.red = true;\n+                                root = rotateRight(root, xpp);\n+                            }\n+                        }\n+                    }\n+                }\n+                else {\n+                    if (xppl != null && xppl.red) {\n+                        xppl.red = false;\n+                        xp.red = false;\n+                        xpp.red = true;\n+                        x = xpp;\n+                    }\n+                    else {\n+                        if (x == xp.left) {\n+                            root = rotateRight(root, x = xp);\n+                            xpp = (xp = x.parent) == null ? null : xp.parent;\n+                        }\n+                        if (xp != null) {\n+                            xp.red = false;\n+                            if (xpp != null) {\n+                                xpp.red = true;\n+                                root = rotateLeft(root, xpp);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        static <K,V> TreeNode<K,V> balanceDeletion(TreeNode<K,V> root,\n+                                                   TreeNode<K,V> x) {\n+            for (TreeNode<K,V> xp, xpl, xpr;;)  {\n+                if (x == null || x == root) {\n+                    return root;\n+                } else if ((xp = x.parent) == null) {\n+                    x.red = false;\n+                    return x;\n+                }\n+                else if (x.red) {\n+                    x.red = false;\n+                    return root;\n+                }\n+                else if ((xpl = xp.left) == x) {\n+                    if ((xpr = xp.right) != null && xpr.red) {\n+                        xpr.red = false;\n+                        xp.red = true;\n+                        root = rotateLeft(root, xp);\n+                        xpr = (xp = x.parent) == null ? null : xp.right;\n+                    }\n+                    if (xpr == null) {\n+                        x = xp;\n+                    } else {\n+                        TreeNode<K,V> sl = xpr.left, sr = xpr.right;\n+                        if ((sr == null || !sr.red) &&\n+                            (sl == null || !sl.red)) {\n+                            xpr.red = true;\n+                            x = xp;\n+                        }\n+                        else {\n+                            if (sr == null || !sr.red) {\n+                                if (sl != null) {\n+                                    sl.red = false;\n+                                }\n+                                xpr.red = true;\n+                                root = rotateRight(root, xpr);\n+                                xpr = (xp = x.parent) == null ?\n+                                    null : xp.right;\n+                            }\n+                            if (xpr != null) {\n+                                xpr.red = xp == null ? false : xp.red;\n+                                if ((sr = xpr.right) != null) {\n+                                    sr.red = false;\n+                                }\n+                            }\n+                            if (xp != null) {\n+                                xp.red = false;\n+                                root = rotateLeft(root, xp);\n+                            }\n+                            x = root;\n+                        }\n+                    }\n+                }\n+                else { // symmetric\n+                    if (xpl != null && xpl.red) {\n+                        xpl.red = false;\n+                        xp.red = true;\n+                        root = rotateRight(root, xp);\n+                        xpl = (xp = x.parent) == null ? null : xp.left;\n+                    }\n+                    if (xpl == null) {\n+                        x = xp;\n+                    } else {\n+                        TreeNode<K,V> sl = xpl.left, sr = xpl.right;\n+                        if ((sl == null || !sl.red) &&\n+                            (sr == null || !sr.red)) {\n+                            xpl.red = true;\n+                            x = xp;\n+                        }\n+                        else {\n+                            if (sl == null || !sl.red) {\n+                                if (sr != null) {\n+                                    sr.red = false;\n+                                }\n+                                xpl.red = true;\n+                                root = rotateLeft(root, xpl);\n+                                xpl = (xp = x.parent) == null ?\n+                                    null : xp.left;\n+                            }\n+                            if (xpl != null) {\n+                                xpl.red = xp == null ? false : xp.red;\n+                                if ((sl = xpl.left) != null) {\n+                                    sl.red = false;\n+                                }\n+                            }\n+                            if (xp != null) {\n+                                xp.red = false;\n+                                root = rotateRight(root, xp);\n+                            }\n+                            x = root;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Recursive invariant check\n+         */\n+        static <K,V> boolean checkInvariants(TreeNode<K,V> t) {\n+            TreeNode<K,V> tp = t.parent, tl = t.left, tr = t.right,\n+                tb = t.prev, tn = (TreeNode<K,V>)t.next;\n+            if (tb != null && tb.next != t) {\n+                return false;\n+            }\n+            if (tn != null && tn.prev != t) {\n+                return false;\n+            }\n+            if (tp != null && t != tp.left && t != tp.right) {\n+                return false;\n+            }\n+            if (tl != null && (tl.parent != t || tl.hash > t.hash)) {\n+                return false;\n+            }\n+            if (tr != null && (tr.parent != t || tr.hash < t.hash)) {\n+                return false;\n+            }\n+            if (t.red && tl != null && tl.red && tr != null && tr.red) {\n+                return false;\n+            }\n+            if (tl != null && !checkInvariants(tl)) {\n+                return false;\n+            }\n+            if (tr != null && !checkInvariants(tr)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        private static final sun.misc.Unsafe U;\n+        private static final long LOCKSTATE;\n+        static {\n+            try {\n+                U = getUnsafe();\n+                Class<?> k = TreeBin.class;\n+                LOCKSTATE = U.objectFieldOffset\n+                    (k.getDeclaredField(\"lockState\"));\n+            } catch (Exception e) {\n+                throw new Error(e);\n+            }\n+        }\n+    }\n+\n+    /* ----------------Table Traversal -------------- */\n+\n+    /**\n+     * Encapsulates traversal for methods such as containsValue; also\n+     * serves as a base class for other iterators and spliterators.\n+     *\n+     * Method advance visits once each still-valid node that was\n+     * reachable upon iterator construction. It might miss some that\n+     * were added to a bin after the bin was visited, which is OK wrt\n+     * consistency guarantees. Maintaining this property in the face\n+     * of possible ongoing resizes requires a fair amount of\n+     * bookkeeping state that is difficult to optimize away amidst\n+     * volatile accesses.  Even so, traversal maintains reasonable\n+     * throughput.\n+     *\n+     * Normally, iteration proceeds bin-by-bin traversing lists.\n+     * However, if the table has been resized, then all future steps\n+     * must traverse both the bin at the current index as well as at\n+     * (index + baseSize); and so on for further resizings. To\n+     * paranoically cope with potential sharing by users of iterators\n+     * across threads, iteration terminates if a bounds checks fails\n+     * for a table read.\n+     */\n+    static class Traverser<K,V> {\n+        Node<K,V>[] tab;        // current table; updated if resized\n+        Node<K,V> next;         // the next entry to use\n+        int index;              // index of bin to use next\n+        int baseIndex;          // current index of initial table\n+        int baseLimit;          // index bound for initial table\n+        final int baseSize;     // initial table size\n+\n+        Traverser(Node<K,V>[] tab, int size, int index, int limit) {\n+            this.tab = tab;\n+            this.baseSize = size;\n+            this.baseIndex = this.index = index;\n+            this.baseLimit = limit;\n+            this.next = null;\n+        }\n+\n+        /**\n+         * Advances if possible, returning next valid node, or null if none.\n+         */\n+        final Node<K,V> advance() {\n+            Node<K,V> e;\n+            if ((e = this.next) != null) {\n+                e = e.next;\n+            }\n+            for (;;) {\n+                Node<K,V>[] t; int i, n; K ek;  // must use locals in checks\n+                if (e != null) {\n+                    return this.next = e;\n+                }\n+                if (this.baseIndex >= this.baseLimit || (t = this.tab) == null ||\n+                    (n = t.length) <= (i = this.index) || i < 0) {\n+                    return this.next = null;\n+                }\n+                if ((e = tabAt(t, this.index)) != null && e.hash < 0) {\n+                    if (e instanceof ForwardingNode) {\n+                        this.tab = ((ForwardingNode<K,V>)e).nextTable;\n+                        e = null;\n+                        continue;\n+                    }\n+                    else if (e instanceof TreeBin) {\n+                        e = ((TreeBin<K,V>)e).first;\n+                    } else {\n+                        e = null;\n+                    }\n+                }\n+                if ((this.index += this.baseSize) >= n)\n+                 {\n+                    this.index = ++this.baseIndex;    // visit upper slots if present\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Base of key, value, and entry Iterators. Adds fields to\n+     * Traverser to support iterator.remove.\n+     */\n+    static class BaseIterator<K,V> extends Traverser<K,V> {\n+        final ConcurrentHashMapV8<K,V> map;\n+        Node<K,V> lastReturned;\n+        BaseIterator(Node<K,V>[] tab, int size, int index, int limit,\n+                    ConcurrentHashMapV8<K,V> map) {\n+            super(tab, size, index, limit);\n+            this.map = map;\n+            advance();\n+        }\n+\n+        public final boolean hasNext() { return this.next != null; }\n+        public final boolean hasMoreElements() { return this.next != null; }\n+\n+        public final void remove() {\n+            Node<K,V> p;\n+            if ((p = this.lastReturned) == null) {\n+                throw new IllegalStateException();\n+            }\n+            this.lastReturned = null;\n+            this.map.replaceNode(p.key, null, null);\n+        }\n+    }\n+\n+    static final class KeyIterator<K,V> extends BaseIterator<K,V>\n+        implements Iterator<K>, Enumeration<K> {\n+        KeyIterator(Node<K,V>[] tab, int index, int size, int limit,\n+                    ConcurrentHashMapV8<K,V> map) {\n+            super(tab, index, size, limit, map);\n+        }\n+\n+        @Override\n+        public final K next() {\n+            Node<K,V> p;\n+            if ((p = this.next) == null) {\n+                throw new NoSuchElementException();\n+            }\n+            K k = p.key;\n+            this.lastReturned = p;\n+            advance();\n+            return k;\n+        }\n+\n+        @Override\n+        public final K nextElement() { return next(); }\n+    }\n+\n+    static final class ValueIterator<K,V> extends BaseIterator<K,V>\n+        implements Iterator<V>, Enumeration<V> {\n+        ValueIterator(Node<K,V>[] tab, int index, int size, int limit,\n+                      ConcurrentHashMapV8<K,V> map) {\n+            super(tab, index, size, limit, map);\n+        }\n+\n+        @Override\n+        public final V next() {\n+            Node<K,V> p;\n+            if ((p = this.next) == null) {\n+                throw new NoSuchElementException();\n+            }\n+            V v = p.val;\n+            this.lastReturned = p;\n+            advance();\n+            return v;\n+        }\n+\n+        @Override\n+        public final V nextElement() { return next(); }\n+    }\n+\n+    static final class EntryIterator<K,V> extends BaseIterator<K,V>\n+        implements Iterator<Map.Entry<K,V>> {\n+        EntryIterator(Node<K,V>[] tab, int index, int size, int limit,\n+                      ConcurrentHashMapV8<K,V> map) {\n+            super(tab, index, size, limit, map);\n+        }\n+\n+        @Override\n+        public final Map.Entry<K,V> next() {\n+            Node<K,V> p;\n+            if ((p = this.next) == null) {\n+                throw new NoSuchElementException();\n+            }\n+            K k = p.key;\n+            V v = p.val;\n+            this.lastReturned = p;\n+            advance();\n+            return new MapEntry<K,V>(k, v, this.map);\n+        }\n+    }\n+\n+    /**\n+     * Exported Entry for EntryIterator\n+     */\n+    static final class MapEntry<K,V> implements Map.Entry<K,V> {\n+        final K key; // non-null\n+        V val;       // non-null\n+        final ConcurrentHashMapV8<K,V> map;\n+        MapEntry(K key, V val, ConcurrentHashMapV8<K,V> map) {\n+            this.key = key;\n+            this.val = val;\n+            this.map = map;\n+        }\n+        @Override\n+        public K getKey()        { return this.key; }\n+        @Override\n+        public V getValue()      { return this.val; }\n+        @Override\n+        public int hashCode()    { return this.key.hashCode() ^ this.val.hashCode(); }\n+        @Override\n+        public String toString() { return this.key + \"=\" + this.val; }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            Object k, v; Map.Entry<?,?> e;\n+            return o instanceof Map.Entry &&\n+                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&\n+                    (v = e.getValue()) != null &&\n+                    (k == this.key || k.equals(this.key)) &&\n+                    (v == this.val || v.equals(this.val));\n+        }\n+\n+        /**\n+         * Sets our entry's value and writes through to the map. The\n+         * value to return is somewhat arbitrary here. Since we do not\n+         * necessarily track asynchronous changes, the most recent\n+         * \"previous\" value could be different from what we return (or\n+         * could even have been removed, in which case the put will\n+         * re-establish). We do not and cannot guarantee more.\n+         */\n+        @Override\n+        public V setValue(V value) {\n+            if (value == null) {\n+                throw new NullPointerException();\n+            }\n+            V v = this.val;\n+            this.val = value;\n+            this.map.put(this.key, value);\n+            return v;\n+        }\n+    }\n+\n+    static final class KeySpliterator<K,V> extends Traverser<K,V>\n+        implements ConcurrentHashMapSpliterator<K> {\n+        long est;               // size estimate\n+        KeySpliterator(Node<K,V>[] tab, int size, int index, int limit,\n+                       long est) {\n+            super(tab, size, index, limit);\n+            this.est = est;\n+        }\n+\n+        @Override\n+        public ConcurrentHashMapSpliterator<K> trySplit() {\n+            int i, f, h;\n+            return (h = (i = this.baseIndex) + (f = this.baseLimit) >>> 1) <= i ? null :\n+                new KeySpliterator<K,V>(this.tab, this.baseSize, this.baseLimit = h,\n+                                        f, this.est >>>= 1);\n+        }\n+\n+        @Override\n+        public void forEachRemaining(Action<? super K> action) {\n+            if (action == null) {\n+                throw new NullPointerException();\n+            }\n+            for (Node<K,V> p; (p = advance()) != null;) {\n+                action.apply(p.key);\n+            }\n+        }\n+\n+        @Override\n+        public boolean tryAdvance(Action<? super K> action) {\n+            if (action == null) {\n+                throw new NullPointerException();\n+            }\n+            Node<K,V> p;\n+            if ((p = advance()) == null) {\n+                return false;\n+            }\n+            action.apply(p.key);\n+            return true;\n+        }\n+\n+        @Override\n+        public long estimateSize() { return this.est; }\n+\n+    }\n+\n+    static final class ValueSpliterator<K,V> extends Traverser<K,V>\n+        implements ConcurrentHashMapSpliterator<V> {\n+        long est;               // size estimate\n+        ValueSpliterator(Node<K,V>[] tab, int size, int index, int limit,\n+                         long est) {\n+            super(tab, size, index, limit);\n+            this.est = est;\n+        }\n+\n+        @Override\n+        public ConcurrentHashMapSpliterator<V> trySplit() {\n+            int i, f, h;\n+            return (h = (i = this.baseIndex) + (f = this.baseLimit) >>> 1) <= i ? null :\n+                new ValueSpliterator<K,V>(this.tab, this.baseSize, this.baseLimit = h,\n+                                          f, this.est >>>= 1);\n+        }\n+\n+        @Override\n+        public void forEachRemaining(Action<? super V> action) {\n+            if (action == null) {\n+                throw new NullPointerException();\n+            }\n+            for (Node<K,V> p; (p = advance()) != null;) {\n+                action.apply(p.val);\n+            }\n+        }\n+\n+        @Override\n+        public boolean tryAdvance(Action<? super V> action) {\n+            if (action == null) {\n+                throw new NullPointerException();\n+            }\n+            Node<K,V> p;\n+            if ((p = advance()) == null) {\n+                return false;\n+            }\n+            action.apply(p.val);\n+            return true;\n+        }\n+\n+        @Override\n+        public long estimateSize() { return this.est; }\n+\n+    }\n+\n+    static final class EntrySpliterator<K,V> extends Traverser<K,V>\n+        implements ConcurrentHashMapSpliterator<Map.Entry<K,V>> {\n+        final ConcurrentHashMapV8<K,V> map; // To export MapEntry\n+        long est;               // size estimate\n+        EntrySpliterator(Node<K,V>[] tab, int size, int index, int limit,\n+                         long est, ConcurrentHashMapV8<K,V> map) {\n+            super(tab, size, index, limit);\n+            this.map = map;\n+            this.est = est;\n+        }\n+\n+        @Override\n+        public ConcurrentHashMapSpliterator<Map.Entry<K,V>> trySplit() {\n+            int i, f, h;\n+            return (h = (i = this.baseIndex) + (f = this.baseLimit) >>> 1) <= i ? null :\n+                new EntrySpliterator<K,V>(this.tab, this.baseSize, this.baseLimit = h,\n+                                          f, this.est >>>= 1, this.map);\n+        }\n+\n+        @Override\n+        public void forEachRemaining(Action<? super Map.Entry<K,V>> action) {\n+            if (action == null) {\n+                throw new NullPointerException();\n+            }\n+            for (Node<K,V> p; (p = advance()) != null; ) {\n+                action.apply(new MapEntry<K,V>(p.key, p.val, this.map));\n+            }\n+        }\n+\n+        @Override\n+        public boolean tryAdvance(Action<? super Map.Entry<K,V>> action) {\n+            if (action == null) {\n+                throw new NullPointerException();\n+            }\n+            Node<K,V> p;\n+            if ((p = advance()) == null) {\n+                return false;\n+            }\n+            action.apply(new MapEntry<K,V>(p.key, p.val, this.map));\n+            return true;\n+        }\n+\n+        @Override\n+        public long estimateSize() { return this.est; }\n+\n+    }\n+\n+    /* ----------------Views -------------- */\n+\n+    /**\n+     * Base class for views.\n+     */\n+    abstract static class CollectionView<K,V,E>\n+        implements Collection<E>, java.io.Serializable {\n+        private static final long serialVersionUID = 7249069246763182397L;\n+        final ConcurrentHashMapV8<K,V> map;\n+        CollectionView(ConcurrentHashMapV8<K,V> map)  { this.map = map; }\n+\n+        /**\n+         * Returns the map backing this view.\n+         *\n+         * @return the map backing this view\n+         */\n+        public ConcurrentHashMapV8<K,V> getMap() { return this.map; }\n+\n+        /**\n+         * Removes all of the elements from this view, by removing all\n+         * the mappings from the map backing this view.\n+         */\n+        @Override\n+        public final void clear()      { this.map.clear(); }\n+        @Override\n+        public final int size()        { return this.map.size(); }\n+        @Override\n+        public final boolean isEmpty() { return this.map.isEmpty(); }\n+\n+        // implementations below rely on concrete classes supplying these\n+        // abstract methods\n+        /**\n+         * Returns a \"weakly consistent\" iterator that will never\n+         * throw {@link ConcurrentModificationException}, and\n+         * guarantees to traverse elements as they existed upon\n+         * construction of the iterator, and may (but is not\n+         * guaranteed to) reflect any modifications subsequent to\n+         * construction.\n+         */\n+        @Override\n+        public abstract Iterator<E> iterator();\n+        @Override\n+        public abstract boolean contains(Object o);\n+        @Override\n+        public abstract boolean remove(Object o);\n+\n+        private static final String oomeMsg = \"Required array size too large\";\n+\n+        @Override\n+        public final Object[] toArray() {\n+            long sz = this.map.mappingCount();\n+            if (sz > MAX_ARRAY_SIZE) {\n+                throw new OutOfMemoryError(oomeMsg);\n+            }\n+            int n = (int)sz;\n+            Object[] r = new Object[n];\n+            int i = 0;\n+            for (E e : this) {\n+                if (i == n) {\n+                    if (n >= MAX_ARRAY_SIZE) {\n+                        throw new OutOfMemoryError(oomeMsg);\n+                    }\n+                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1) {\n+                        n = MAX_ARRAY_SIZE;\n+                    } else {\n+                        n += (n >>> 1) + 1;\n+                    }\n+                    r = Arrays.copyOf(r, n);\n+                }\n+                r[i++] = e;\n+            }\n+            return i == n ? r : Arrays.copyOf(r, i);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public final <T> T[] toArray(T[] a) {\n+            long sz = this.map.mappingCount();\n+            if (sz > MAX_ARRAY_SIZE) {\n+                throw new OutOfMemoryError(oomeMsg);\n+            }\n+            int m = (int)sz;\n+            T[] r = a.length >= m ? a :\n+                (T[])java.lang.reflect.Array\n+                .newInstance(a.getClass().getComponentType(), m);\n+            int n = r.length;\n+            int i = 0;\n+            for (E e : this) {\n+                if (i == n) {\n+                    if (n >= MAX_ARRAY_SIZE) {\n+                        throw new OutOfMemoryError(oomeMsg);\n+                    }\n+                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1) {\n+                        n = MAX_ARRAY_SIZE;\n+                    } else {\n+                        n += (n >>> 1) + 1;\n+                    }\n+                    r = Arrays.copyOf(r, n);\n+                }\n+                r[i++] = (T)e;\n+            }\n+            if (a == r && i < n) {\n+                r[i] = null; // null-terminate\n+                return r;\n+            }\n+            return i == n ? r : Arrays.copyOf(r, i);\n+        }\n+\n+        /**\n+         * Returns a string representation of this collection.\n+         * The string representation consists of the string representations\n+         * of the collection's elements in the order they are returned by\n+         * its iterator, enclosed in square brackets ({@code \"[]\"}).\n+         * Adjacent elements are separated by the characters {@code \", \"}\n+         * (comma and space).  Elements are converted to strings as by\n+         * {@link String#valueOf(Object)}.\n+         *\n+         * @return a string representation of this collection\n+         */\n+        @Override\n+        public final String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append('[');\n+            Iterator<E> it = iterator();\n+            if (it.hasNext()) {\n+                for (;;) {\n+                    Object e = it.next();\n+                    sb.append(e == this ? \"(this Collection)\" : e);\n+                    if (!it.hasNext()) {\n+                        break;\n+                    }\n+                    sb.append(',').append(' ');\n+                }\n+            }\n+            return sb.append(']').toString();\n+        }\n+\n+        @Override\n+        public final boolean containsAll(Collection<?> c) {\n+            if (c != this) {\n+                for (Object e : c) {\n+                    if (e == null || !contains(e)) {\n+                        return false;\n+                    }\n+                }\n+            }\n+            return true;\n+        }\n+\n+        @Override\n+        public final boolean removeAll(Collection<?> c) {\n+            boolean modified = false;\n+            for (Iterator<E> it = iterator(); it.hasNext();) {\n+                if (c.contains(it.next())) {\n+                    it.remove();\n+                    modified = true;\n+                }\n+            }\n+            return modified;\n+        }\n+\n+        @Override\n+        public final boolean retainAll(Collection<?> c) {\n+            boolean modified = false;\n+            for (Iterator<E> it = iterator(); it.hasNext();) {\n+                if (!c.contains(it.next())) {\n+                    it.remove();\n+                    modified = true;\n+                }\n+            }\n+            return modified;\n+        }\n+\n+    }\n+\n+    /**\n+     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in\n+     * which additions may optionally be enabled by mapping to a\n+     * common value.  This class cannot be directly instantiated.\n+     * See {@link #keySet() keySet()},\n+     * {@link #keySet(Object) keySet(V)},\n+     * {@link #newKeySet() newKeySet()},\n+     * {@link #newKeySet(int) newKeySet(int)}.\n+     *\n+     * @since 1.8\n+     */\n+    public static class KeySetView<K,V> extends CollectionView<K,V,K>\n+        implements Set<K>, java.io.Serializable {\n+        private static final long serialVersionUID = 7249069246763182397L;\n+        private final V value;\n+        KeySetView(ConcurrentHashMapV8<K,V> map, V value) {  // non-public\n+            super(map);\n+            this.value = value;\n+        }\n+\n+        /**\n+         * Returns the default mapped value for additions,\n+         * or {@code null} if additions are not supported.\n+         *\n+         * @return the default mapped value for additions, or {@code null}\n+         * if not supported\n+         */\n+        public V getMappedValue() { return this.value; }\n+\n+        /**\n+         * {@inheritDoc}\n+         * @throws NullPointerException if the specified key is null\n+         */\n+        @Override\n+        public boolean contains(Object o) { return this.map.containsKey(o); }\n+\n+        /**\n+         * Removes the key from this map view, by removing the key (and its\n+         * corresponding value) from the backing map.  This method does\n+         * nothing if the key is not in the map.\n+         *\n+         * @param  o the key to be removed from the backing map\n+         * @return {@code true} if the backing map contained the specified key\n+         * @throws NullPointerException if the specified key is null\n+         */\n+        @Override\n+        public boolean remove(Object o) { return this.map.remove(o) != null; }\n+\n+        /**\n+         * @return an iterator over the keys of the backing map\n+         */\n+        @Override\n+        public Iterator<K> iterator() {\n+            Node<K,V>[] t;\n+            ConcurrentHashMapV8<K,V> m = this.map;\n+            int f = (t = m.table) == null ? 0 : t.length;\n+            return new KeyIterator<K,V>(t, f, 0, f, m);\n+        }\n+\n+        /**\n+         * Adds the specified key to this set view by mapping the key to\n+         * the default mapped value in the backing map, if defined.\n+         *\n+         * @param e key to be added\n+         * @return {@code true} if this set changed as a result of the call\n+         * @throws NullPointerException if the specified key is null\n+         * @throws UnsupportedOperationException if no default mapped value\n+         * for additions was provided\n+         */\n+        @Override\n+        public boolean add(K e) {\n+            V v;\n+            if ((v = this.value) == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+            return this.map.putVal(e, v, true) == null;\n+        }\n+\n+        /**\n+         * Adds all of the elements in the specified collection to this set,\n+         * as if by calling {@link #add} on each one.\n+         *\n+         * @param c the elements to be inserted into this set\n+         * @return {@code true} if this set changed as a result of the call\n+         * @throws NullPointerException if the collection or any of its\n+         * elements are {@code null}\n+         * @throws UnsupportedOperationException if no default mapped value\n+         * for additions was provided\n+         */\n+        @Override\n+        public boolean addAll(Collection<? extends K> c) {\n+            boolean added = false;\n+            V v;\n+            if ((v = this.value) == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+            for (K e : c) {\n+                if (this.map.putVal(e, v, true) == null) {\n+                    added = true;\n+                }\n+            }\n+            return added;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = 0;\n+            for (K e : this) {\n+                h += e.hashCode();\n+            }\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            Set<?> c;\n+            return o instanceof Set &&\n+                    ((c = (Set<?>)o) == this ||\n+                     containsAll(c) && c.containsAll(this));\n+        }\n+\n+        public ConcurrentHashMapSpliterator<K> spliterator() {\n+            Node<K,V>[] t;\n+            ConcurrentHashMapV8<K,V> m = this.map;\n+            long n = m.sumCount();\n+            int f = (t = m.table) == null ? 0 : t.length;\n+            return new KeySpliterator<K,V>(t, f, 0, f, n < 0L ? 0L : n);\n+        }\n+\n+        public void forEach(Action<? super K> action) {\n+            if (action == null) {\n+                throw new NullPointerException();\n+            }\n+            Node<K,V>[] t;\n+            if ((t = this.map.table) != null) {\n+                Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n+                for (Node<K,V> p; (p = it.advance()) != null; ) {\n+                    action.apply(p.key);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A view of a ConcurrentHashMapV8 as a {@link Collection} of\n+     * values, in which additions are disabled. This class cannot be\n+     * directly instantiated. See {@link #values()}.\n+     */\n+    static final class ValuesView<K,V> extends CollectionView<K,V,V>\n+        implements Collection<V>, java.io.Serializable {\n+        private static final long serialVersionUID = 2249069246763182397L;\n+        ValuesView(ConcurrentHashMapV8<K,V> map) { super(map); }\n+        @Override\n+        public final boolean contains(Object o) {\n+            return this.map.containsValue(o);\n+        }\n+\n+        @Override\n+        public final boolean remove(Object o) {\n+            if (o != null) {\n+                for (Iterator<V> it = iterator(); it.hasNext();) {\n+                    if (o.equals(it.next())) {\n+                        it.remove();\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public final Iterator<V> iterator() {\n+            ConcurrentHashMapV8<K,V> m = this.map;\n+            Node<K,V>[] t;\n+            int f = (t = m.table) == null ? 0 : t.length;\n+            return new ValueIterator<K,V>(t, f, 0, f, m);\n+        }\n+\n+        @Override\n+        public final boolean add(V e) {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public final boolean addAll(Collection<? extends V> c) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public ConcurrentHashMapSpliterator<V> spliterator() {\n+            Node<K,V>[] t;\n+            ConcurrentHashMapV8<K,V> m = this.map;\n+            long n = m.sumCount();\n+            int f = (t = m.table) == null ? 0 : t.length;\n+            return new ValueSpliterator<K,V>(t, f, 0, f, n < 0L ? 0L : n);\n+        }\n+\n+        public void forEach(Action<? super V> action) {\n+            if (action == null) {\n+                throw new NullPointerException();\n+            }\n+            Node<K,V>[] t;\n+            if ((t = this.map.table) != null) {\n+                Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n+                for (Node<K,V> p; (p = it.advance()) != null; ) {\n+                    action.apply(p.val);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)\n+     * entries.  This class cannot be directly instantiated. See\n+     * {@link #entrySet()}.\n+     */\n+    static final class EntrySetView<K,V> extends CollectionView<K,V,Map.Entry<K,V>>\n+        implements Set<Map.Entry<K,V>>, java.io.Serializable {\n+        private static final long serialVersionUID = 2249069246763182397L;\n+        EntrySetView(ConcurrentHashMapV8<K,V> map) { super(map); }\n+\n+        @Override\n+        public boolean contains(Object o) {\n+            Object k, v, r; Map.Entry<?,?> e;\n+            return o instanceof Map.Entry &&\n+                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&\n+                    (r = this.map.get(k)) != null &&\n+                    (v = e.getValue()) != null &&\n+                    (v == r || v.equals(r));\n+        }\n+\n+        @Override\n+        public boolean remove(Object o) {\n+            Object k, v; Map.Entry<?,?> e;\n+            return o instanceof Map.Entry &&\n+                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&\n+                    (v = e.getValue()) != null &&\n+                    this.map.remove(k, v);\n+        }\n+\n+        /**\n+         * @return an iterator over the entries of the backing map\n+         */\n+        @Override\n+        public Iterator<Map.Entry<K,V>> iterator() {\n+            ConcurrentHashMapV8<K,V> m = this.map;\n+            Node<K,V>[] t;\n+            int f = (t = m.table) == null ? 0 : t.length;\n+            return new EntryIterator<K,V>(t, f, 0, f, m);\n+        }\n+\n+        @Override\n+        public boolean add(Entry<K,V> e) {\n+            return this.map.putVal(e.getKey(), e.getValue(), false) == null;\n+        }\n+\n+        @Override\n+        public boolean addAll(Collection<? extends Entry<K,V>> c) {\n+            boolean added = false;\n+            for (Entry<K,V> e : c) {\n+                if (add(e)) {\n+                    added = true;\n+                }\n+            }\n+            return added;\n+        }\n+\n+        @Override\n+        public final int hashCode() {\n+            int h = 0;\n+            Node<K,V>[] t;\n+            if ((t = this.map.table) != null) {\n+                Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n+                for (Node<K,V> p; (p = it.advance()) != null; ) {\n+                    h += p.hashCode();\n+                }\n+            }\n+            return h;\n+        }\n+\n+        @Override\n+        public final boolean equals(Object o) {\n+            Set<?> c;\n+            return o instanceof Set &&\n+                    ((c = (Set<?>)o) == this ||\n+                     containsAll(c) && c.containsAll(this));\n+        }\n+\n+        public ConcurrentHashMapSpliterator<Map.Entry<K,V>> spliterator() {\n+            Node<K,V>[] t;\n+            ConcurrentHashMapV8<K,V> m = this.map;\n+            long n = m.sumCount();\n+            int f = (t = m.table) == null ? 0 : t.length;\n+            return new EntrySpliterator<K,V>(t, f, 0, f, n < 0L ? 0L : n, m);\n+        }\n+\n+        public void forEach(Action<? super Map.Entry<K,V>> action) {\n+            if (action == null) {\n+                throw new NullPointerException();\n+            }\n+            Node<K,V>[] t;\n+            if ((t = this.map.table) != null) {\n+                Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);\n+                for (Node<K,V> p; (p = it.advance()) != null; ) {\n+                    action.apply(new MapEntry<K,V>(p.key, p.val, this.map));\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    /* ---------------- Counters -------------- */\n+\n+    // Adapted from LongAdder and Striped64.\n+    // See their internal docs for explanation.\n+\n+    // A padded cell for distributing counts\n+    static final class CounterCell {\n+        volatile long p0, p1, p2, p3, p4, p5, p6;\n+        volatile long value;\n+        volatile long q0, q1, q2, q3, q4, q5, q6;\n+        CounterCell(long x) { this.value = x; }\n+    }\n+\n+    /**\n+     * Holder for the thread-local hash code determining which\n+     * CounterCell to use. The code is initialized via the\n+     * counterHashCodeGenerator, but may be moved upon collisions.\n+     */\n+    static final class CounterHashCode {\n+        int code;\n+    }\n+\n+    /**\n+     * Generates initial value for per-thread CounterHashCodes.\n+     */\n+    static final AtomicInteger counterHashCodeGenerator = new AtomicInteger();\n+\n+    /**\n+     * Increment for counterHashCodeGenerator. See class ThreadLocal\n+     * for explanation.\n+     */\n+    static final int SEED_INCREMENT = 0x61c88647;\n+\n+    /**\n+     * Per-thread counter hash codes. Shared across all instances.\n+     */\n+    static final ThreadLocal<CounterHashCode> threadCounterHashCode =\n+        new ThreadLocal<CounterHashCode>();\n+\n+\n+    final long sumCount() {\n+        CounterCell[] as = this.counterCells; CounterCell a;\n+        long sum = this.baseCount;\n+        if (as != null) {\n+            for (int i = 0; i < as.length; ++i) {\n+                if ((a = as[i]) != null) {\n+                    sum += a.value;\n+                }\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    // See LongAdder version for explanation\n+    private final void fullAddCount(long x, CounterHashCode hc,\n+                                    boolean wasUncontended) {\n+        int h;\n+        if (hc == null) {\n+            hc = new CounterHashCode();\n+            int s = counterHashCodeGenerator.addAndGet(SEED_INCREMENT);\n+            h = hc.code = s == 0 ? 1 : s; // Avoid zero\n+            threadCounterHashCode.set(hc);\n+        } else {\n+            h = hc.code;\n+        }\n+        boolean collide = false;                // True if last slot nonempty\n+        for (;;) {\n+            CounterCell[] as; CounterCell a; int n; long v;\n+            if ((as = this.counterCells) != null && (n = as.length) > 0) {\n+                if ((a = as[n - 1 & h]) == null) {\n+                    if (this.cellsBusy == 0) {            // Try to attach new Cell\n+                        CounterCell r = new CounterCell(x); // Optimistic create\n+                        if (this.cellsBusy == 0 &&\n+                            U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {\n+                            boolean created = false;\n+                            try {               // Recheck under lock\n+                                CounterCell[] rs; int m, j;\n+                                if ((rs = this.counterCells) != null &&\n+                                    (m = rs.length) > 0 &&\n+                                    rs[j = m - 1 & h] == null) {\n+                                    rs[j] = r;\n+                                    created = true;\n+                                }\n+                            } finally {\n+                                this.cellsBusy = 0;\n+                            }\n+                            if (created) {\n+                                break;\n+                            }\n+                            continue;           // Slot is now non-empty\n+                        }\n+                    }\n+                    collide = false;\n+                }\n+                else if (!wasUncontended) {\n+                    wasUncontended = true;      // Continue after rehash\n+                } else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)) {\n+                    break;\n+                } else if (this.counterCells != as || n >= NCPU) {\n+                    collide = false;            // At max size or stale\n+                } else if (!collide) {\n+                    collide = true;\n+                } else if (this.cellsBusy == 0 &&\n+                         U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {\n+                    try {\n+                        if (this.counterCells == as) {// Expand table unless stale\n+                            CounterCell[] rs = new CounterCell[n << 1];\n+                            for (int i = 0; i < n; ++i) {\n+                                rs[i] = as[i];\n+                            }\n+                            this.counterCells = rs;\n+                        }\n+                    } finally {\n+                        this.cellsBusy = 0;\n+                    }\n+                    collide = false;\n+                    continue;                   // Retry with expanded table\n+                }\n+                h ^= h << 13;                   // Rehash\n+                h ^= h >>> 17;\n+                h ^= h << 5;\n+            }\n+            else if (this.cellsBusy == 0 && this.counterCells == as &&\n+                     U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {\n+                boolean init = false;\n+                try {                           // Initialize table\n+                    if (this.counterCells == as) {\n+                        CounterCell[] rs = new CounterCell[2];\n+                        rs[h & 1] = new CounterCell(x);\n+                        this.counterCells = rs;\n+                        init = true;\n+                    }\n+                } finally {\n+                    this.cellsBusy = 0;\n+                }\n+                if (init) {\n+                    break;\n+                }\n+            }\n+            else if (U.compareAndSwapLong(this, BASECOUNT, v = this.baseCount, v + x))\n+             {\n+                break;                          // Fall back on using base\n+            }\n+        }\n+        hc.code = h;                            // Record index for next time\n+    }\n+\n+    // Unsafe mechanics\n+    private static final sun.misc.Unsafe U;\n+    private static final long SIZECTL;\n+    private static final long TRANSFERINDEX;\n+    private static final long TRANSFERORIGIN;\n+    private static final long BASECOUNT;\n+    private static final long CELLSBUSY;\n+    private static final long CELLVALUE;\n+    private static final long ABASE;\n+    private static final int ASHIFT;\n+\n+    static {\n+        try {\n+            U = getUnsafe();\n+            Class<?> k = ConcurrentHashMapV8.class;\n+            SIZECTL = U.objectFieldOffset\n+                (k.getDeclaredField(\"sizeCtl\"));\n+            TRANSFERINDEX = U.objectFieldOffset\n+                (k.getDeclaredField(\"transferIndex\"));\n+            TRANSFERORIGIN = U.objectFieldOffset\n+                (k.getDeclaredField(\"transferOrigin\"));\n+            BASECOUNT = U.objectFieldOffset\n+                (k.getDeclaredField(\"baseCount\"));\n+            CELLSBUSY = U.objectFieldOffset\n+                (k.getDeclaredField(\"cellsBusy\"));\n+            Class<?> ck = CounterCell.class;\n+            CELLVALUE = U.objectFieldOffset\n+                (ck.getDeclaredField(\"value\"));\n+            Class<?> ak = Node[].class;\n+            ABASE = U.arrayBaseOffset(ak);\n+            int scale = U.arrayIndexScale(ak);\n+            if ((scale & scale - 1) != 0) {\n+                throw new Error(\"data type scale not a power of two\");\n+            }\n+            ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);\n+        } catch (Exception e) {\n+            throw new Error(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.\n+     * Replace with a simple call to Unsafe.getUnsafe when integrating\n+     * into a jdk.\n+     *\n+     * @return a sun.misc.Unsafe\n+     */\n+    private static sun.misc.Unsafe getUnsafe() {\n+        try {\n+            return sun.misc.Unsafe.getUnsafe();\n+        } catch (SecurityException tryReflectionInstead) {}\n+        try {\n+            return java.security.AccessController.doPrivileged\n+            (new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {\n+                @Override\n+                public sun.misc.Unsafe run() throws Exception {\n+                    Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\n+                    for (java.lang.reflect.Field f : k.getDeclaredFields()) {\n+                        f.setAccessible(true);\n+                        Object x = f.get(null);\n+                        if (k.isInstance(x)) {\n+                            return k.cast(x);\n+                        }\n+                    }\n+                    throw new NoSuchFieldError(\"the Unsafe\");\n+                }});\n+        } catch (java.security.PrivilegedActionException e) {\n+            throw new RuntimeException(\"Could not initialize intrinsics\",\n+                                       e.getCause());\n+        }\n+    }\n+}\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "4fce93874619bd364c46186e4e335773f752c60a",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/IConcurrentSet.java",
            "additions": 0,
            "deletions": 20
        },
        "diff content": "@@ -1,20 +0,0 @@\n-package net.engio.mbassy.common;\n-\n-/**\n- * Todo: Add javadoc\n- *\n- * @author bennidi\n- *         Date: 3/29/13\n- */\n-public interface IConcurrentSet<T> extends Iterable<T> {\n-\n-    void add(T element);\n-\n-    boolean contains(T element);\n-\n-    int size();\n-\n-    void addAll(Iterable<T> elements);\n-\n-    boolean remove(T element);\n-}\n"
    },
    {
        "commit hash": "4fce93874619bd364c46186e4e335773f752c60a",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/StrongConcurrentSet.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,6 @@\n package net.engio.mbassy.common;\n \n \n-import java.util.HashMap;\n import java.util.Iterator;\n \n /**\n@@ -15,7 +14,8 @@ public class StrongConcurrentSet<T> extends AbstractConcurrentSet<T>{\n \n \n     public StrongConcurrentSet() {\n-        super(new HashMap<T, ISetEntry<T>>());\n+        // ConcurrentHashMapV8 is 15%-20% faster than regular ConcurrentHashMap, which is also faster than HashMap.\n+        super(new ConcurrentHashMapV8<T, ISetEntry<T>>());\n     }\n \n     public Iterator<T> iterator() {\n"
    },
    {
        "commit hash": "4fce93874619bd364c46186e4e335773f752c60a",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -1,15 +1,15 @@\n package net.engio.mbassy.subscription;\n \n import net.engio.mbassy.bus.IMessagePublication;\n-import net.engio.mbassy.common.IConcurrentSet;\n import net.engio.mbassy.dispatch.IMessageDispatcher;\n \n+import java.util.Collection;\n import java.util.Comparator;\n import java.util.UUID;\n \n /**\n  * A subscription is a thread-safe container that manages exactly one message handler of all registered\n- * message listeners of the same class, i.e. all subscribed instances (exlcuding subclasses) of a SingleMessageHandler.class\n+ * message listeners of the same class, i.e. all subscribed instances (excluding subclasses) of a SingleMessageHandler.class\n  * will be referenced in the subscription created for SingleMessageHandler.class.\n  *\n  * There will be as many unique subscription objects per message listener class as there are message handlers\n@@ -23,13 +23,13 @@ public class Subscription {\n \n     private final UUID id = UUID.randomUUID();\n \n-    protected final IConcurrentSet<Object> listeners;\n+    protected final Collection<Object> listeners;\n \n     private final IMessageDispatcher dispatcher;\n \n     private final SubscriptionContext context;\n \n-    Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, IConcurrentSet<Object> listeners) {\n+    Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, Collection<Object> listeners) {\n         this.context = context;\n         this.dispatcher = dispatcher;\n         this.listeners = listeners;\n"
    },
    {
        "commit hash": "4fce93874619bd364c46186e4e335773f752c60a",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java",
            "additions": 11,
            "deletions": 6
        },
        "diff content": "@@ -1,12 +1,14 @@\n package net.engio.mbassy.subscription;\n \n import net.engio.mbassy.bus.BusRuntime;\n+import net.engio.mbassy.common.ConcurrentHashMapV8;\n import net.engio.mbassy.common.ReflectionUtils;\n import net.engio.mbassy.common.StrongConcurrentSet;\n import net.engio.mbassy.listener.MessageHandler;\n import net.engio.mbassy.listener.MetadataReader;\n \n import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n /**\n@@ -26,15 +28,14 @@ public class SubscriptionManager {\n     // all subscriptions per message type\n     // this is the primary list for dispatching a specific message\n     // write access is synchronized and happens only when a listener of a specific class is registered the first time\n-    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage\n-            = new HashMap<Class, Collection<Subscription>>(50);\n+    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage;\n \n     // all subscriptions per messageHandler type\n     // this map provides fast access for subscribing and unsubscribing\n     // write access is synchronized and happens very infrequently\n     // once a collection of subscriptions is stored it does not change\n-    private final Map<Class, Collection<Subscription>> subscriptionsPerListener\n-            = new HashMap<Class, Collection<Subscription>>(50);\n+    private final Map<Class, Collection<Subscription>> subscriptionsPerListener;\n+\n \n     // remember already processed classes that do not contain any message handlers\n     private final StrongConcurrentSet<Class> nonListeners = new StrongConcurrentSet<Class>();\n@@ -52,6 +53,10 @@ public class SubscriptionManager {\n         this.metadataReader = metadataReader;\n         this.subscriptionFactory = subscriptionFactory;\n         this.runtime = runtime;\n+\n+        // ConcurrentHashMapV8 is 15%-20% faster than regular ConcurrentHashMap, which is also faster than HashMap.\n+        subscriptionsPerMessage = new ConcurrentHashMapV8<Class, Collection<Subscription>>(50);\n+        subscriptionsPerListener = new ConcurrentHashMapV8<Class, Collection<Subscription>>(50);\n     }\n \n \n@@ -95,7 +100,7 @@ public class SubscriptionManager {\n                     nonListeners.add(listener.getClass());\n                     return;\n                 }\n-                subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n+                subscriptionsByListener = new ArrayDeque<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                 // create subscriptions for all detected message handlers\n                 for (MessageHandler messageHandler : messageHandlers) {\n                     // create the subscription\n@@ -163,7 +168,7 @@ public class SubscriptionManager {\n             readWriteLock.readLock().lock();\n \n             if (subscriptionsPerMessage.get(messageType) != null) {\n-\t            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n+                subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n             }\n             for (Class eventSuperType : ReflectionUtils.getSuperTypes(messageType)) {\n                 Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n"
    },
    {
        "commit hash": "4fce93874619bd364c46186e4e335773f752c60a",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConcurrentSetTest.java",
            "additions": 9,
            "deletions": 10
        },
        "diff content": "@@ -3,7 +3,6 @@ package net.engio.mbassy;\n import junit.framework.Assert;\n import net.engio.mbassy.common.AssertSupport;\n import net.engio.mbassy.common.ConcurrentExecutor;\n-import net.engio.mbassy.common.IConcurrentSet;\n import org.junit.Before;\n import org.junit.Test;\n \n@@ -35,8 +34,8 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n         super.beforeTest();\n         gcProtector = new HashSet();\n     }\n-    \n-    protected abstract IConcurrentSet createSet();\n+\n+    protected abstract Collection createSet();\n \n \n     @Test\n@@ -44,7 +43,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n         final LinkedList<Object> duplicates = new LinkedList<Object>();\n         final HashSet<Object> distinct = new HashSet<Object>();\n \n-        final IConcurrentSet testSet = createSet();\n+        final Collection testSet = createSet();\n         Random rand = new Random();\n \n         // getAll set of distinct objects and list of duplicates\n@@ -76,7 +75,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n \n     @Test()\n     public void testIterationWithConcurrentRemoval() {\n-        final IConcurrentSet<AtomicInteger> testSet = createSet();\n+        final Collection<AtomicInteger> testSet = createSet();\n         final Random rand = new Random();\n \n         for (int i = 0; i < numberOfElements; i++) {\n@@ -127,7 +126,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n         final HashSet<Object> source = new HashSet<Object>();\n         final HashSet<Object> toRemove = new HashSet<Object>();\n \n-        final IConcurrentSet testSet = createSet();\n+        final Collection testSet = createSet();\n         // getAll set of distinct objects and mark a subset of those for removal\n         for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n@@ -174,7 +173,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n         final HashSet<Object> source = new HashSet<Object>();\n         final HashSet<Object> toRemove = new HashSet<Object>();\n \n-        final IConcurrentSet testSet = createSet();\n+        final Collection testSet = createSet();\n         // getAll set of candidates and mark subset for removal\n         for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n@@ -212,7 +211,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n     @Test\n     public void testCompleteRemoval() {\n         final HashSet<Object> source = new HashSet<Object>();\n-        final IConcurrentSet testSet = createSet();\n+        final Collection testSet = createSet();\n \n         // getAll set of candidates and mark subset for removal\n         for (int i = 0; i < numberOfElements; i++) {\n@@ -244,7 +243,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n     @Test\n     public void testRemovalViaIterator() {\n         final HashSet<Object> source = new HashSet<Object>();\n-        final IConcurrentSet setUnderTest = createSet();\n+        final Collection setUnderTest = createSet();\n \n         // getAll set of candidates and mark subset for removal\n         for (int i = 0; i < numberOfElements; i++) {\n@@ -287,7 +286,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n      */\n     @Test\n     public void testConcurrentAddRemove() {\n-        final IConcurrentSet testSet = createSet();\n+        final Collection testSet = createSet();\n         // a set of unique integers that will stay permanently in the test set\n         final List permanentObjects = new ArrayList();\n         // a set of objects that will be added and removed at random to the test set to force rehashing\n"
    },
    {
        "commit hash": "4fce93874619bd364c46186e4e335773f752c60a",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/StrongConcurrentSetTest.java",
            "additions": 3,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.common.IConcurrentSet;\n+import java.util.Collection;\n+\n import net.engio.mbassy.common.StrongConcurrentSet;\n \n /**\n@@ -12,7 +13,7 @@ import net.engio.mbassy.common.StrongConcurrentSet;\n public class StrongConcurrentSetTest extends ConcurrentSetTest{\n \n     @Override\n-    protected IConcurrentSet createSet() {\n+    protected Collection createSet() {\n         return new StrongConcurrentSet();\n     }\n }\n"
    },
    {
        "commit hash": "4fce93874619bd364c46186e4e335773f752c60a",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/WeakConcurrentSetTest.java",
            "additions": 4,
            "deletions": 3
        },
        "diff content": "@@ -1,11 +1,12 @@\n package net.engio.mbassy;\n \n import net.engio.mbassy.common.ConcurrentExecutor;\n-import net.engio.mbassy.common.IConcurrentSet;\n import net.engio.mbassy.common.WeakConcurrentSet;\n+\n import org.junit.Before;\n import org.junit.Test;\n \n+import java.util.Collection;\n import java.util.HashSet;\n import java.util.Random;\n import java.util.Set;\n@@ -23,7 +24,7 @@ public class WeakConcurrentSetTest extends ConcurrentSetTest{\n \n \n     @Override\n-    protected IConcurrentSet createSet() {\n+    protected Collection createSet() {\n         return new WeakConcurrentSet();\n     }\n \n@@ -32,7 +33,7 @@ public class WeakConcurrentSetTest extends ConcurrentSetTest{\n \n         // Assemble\n         final HashSet<Object> permanentElements = new HashSet<Object>();\n-        final IConcurrentSet testSetWeak = createSet();\n+        final Collection testSetWeak = createSet();\n         final Random rand = new Random();\n \n         for (int i = 0; i < numberOfElements; i++) {\n"
    },
    {
        "commit hash": "e9a1e6c95e9cd9b9696b61c4b368de980a301920",
        "previous commit hash": "00f346b0aa0b47e9d069dfc127c22351e2417f11",
        "diff stats": {
            "file_path": "README.md",
            "additions": 3,
            "deletions": 5
        },
        "diff content": "@@ -3,10 +3,9 @@ MBassador\n \n MBassador is a very light-weight message (event) bus implementation following the publish subscribe pattern. It is designed for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. The core of MBassador's high performance is a specialized data structure that minimizes lock contention such that performance degradation of concurrent access is minimal. The performance win of this design is illustrated in <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a> and more recently in the [eventbus-performance](https://github.com/bennidi/eventbus-performance) github repository.\n \n-Using MBassador in your project is very easy. Create as many instances of MBassador as you like (usually a singleton will do) ` bus = new MBassador(BusConfiguration.SyncAsync())`, mark and configure your message handlers with `@Handler` annotations and finally register the listeners at any MBassador instance `bus.subscribe(aListener)`. Start sending messages to your listeners using one of MBassador's publication methods `bus.post(message).now()` or `bus.post(message).asynchronously()`. Done!\n+Using MBassador in your project is very easy. Create as many instances of MBassador as you like (usually a singleton will do) ` bus = new MBassador()`, mark and configure your message handlers with `@Handler` annotations and finally register the listeners at any MBassador instance `bus.subscribe(aListener)`. Start sending messages to your listeners using one of MBassador's publication methods `bus.post(message).now()` or `bus.post(message).asynchronously()`. Done!\n \n-Read this documentation to get an overview of MBassadors features. There is also some documentation in the Wiki - although admittedly\n-not enough to make a developer happy (work is in progress). Additionally, you can browse the [javadoc](http://bennidi.github.io/mbassador/)\n+Read this documentation to get an overview of MBassadors features. There is also some documentation in the Wiki - although admittedly not enough to make a developer happy (work is in progress). Additionally, you can browse the [javadoc](http://bennidi.github.io/mbassador/)\n \n There is a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. It's beta but stable enough to give it a try.\n \n@@ -170,7 +169,7 @@ MBassador is available from the Maven Central Repository using the following coo\n     <dependency>\n         <groupId>net.engio</groupId>\n         <artifactId>mbassador</artifactId>\n-        <version>1.2.0</version>\n+        <version>1.2.1</version>\n     </dependency>\n ```\n \n@@ -182,7 +181,6 @@ There is ongoing effort to extend documentation and provide code samples and det\n <h2>Release Notes</h2>\n \n ### [1.2.1](milestones/1.2.1)\n- + Not yet released!\n  + Centralized handling of common (and arbitrary) properties (see BusConfiguration#setProperty and net.engio.mbassy.bus.common.Properties)\n  + Each bus now has a configurable id and respective #toString() implementation (useful for debugging)\n  + Each bus now has a default logger (System.out) for publication errors (exception in handlers) which can be replaced with BusConfiguration#setProperty \n"
    },
    {
        "commit hash": "00f346b0aa0b47e9d069dfc127c22351e2417f11",
        "previous commit hash": "1d4149a1019c3c8dd8e9053bb275153358854e7e",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.1</version>\n+    <version>1.2.2-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.2.1</tag>\n+        <tag>mbassador-1.2.0</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "1d4149a1019c3c8dd8e9053bb275153358854e7e",
        "previous commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.1-SNAPSHOT</version>\n+    <version>1.2.1</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.2.0</tag>\n+        <tag>mbassador-1.2.1</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "README.md",
            "additions": 47,
            "deletions": 24
        },
        "diff content": "@@ -69,7 +69,11 @@ MBassador is designed to be extensible with custom implementations of various co\n \n <h2>Usage</h2>\n \n-Handler definition (in any bean):\n+### Handler definition\n+\n+Message handlers are defined via annotations added to instance methods. The simplest definition is to just use `@Handler` without changing any parameters or adding of any other annotations.\n+> NOTE: MBassador uses WEAK REFERENCES by default. If you do not hold references to your listeners somewhere else they will be garbage collected! This can be changed by adding `@Listener(references=References.Strong)` to the defining class\n+\n \n         // every message of type TestMessage or any subtype will be delivered\n         // to this handler\n@@ -123,11 +127,21 @@ Handler definition (in any bean):\n         }\n \n \n-Creation of message bus and registration of listeners:\n+### Message bus creation\n \n-        // create as many instances as necessary\n-        // bind it to any upper bound\n+        // Use a default constructor for convenience and create as many instances as you like\n         MBassador<TestMessage> bus = new MBassador<TestMessage>();\n+        MBassador<String> bus2 = new MBassador<String>();\n+       \n+        // Use feature driven configuration to have more control over the configuration details\n+        MBassador globalBus = new MBassador(new BusConfiguration()\n+             .addFeature(Feature.SyncPubSub.Default())\n+             .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n+             .addFeature(Feature.AsynchronousMessageDispatch.Default())\n+             .setProperty(Properties.Common.Id, \"global bus\")\n+             .setProperty(Properties.Handler.PublicationError, new IPublicationErrorHandler{...}));\n+        \n+### Listener subscription\n         ListeningBean listener = new ListeningBean();\n         // the listener will be registered using a weak-reference if not configured otherwise with @Listener\n         bus.subscribe(listener);\n@@ -135,13 +149,18 @@ Creation of message bus and registration of listeners:\n         bus.subscribe(new ClassWithoutAnyDefinedHandlers());\n \n \n-Message publication:\n+### Message publication\n \n         TestMessage message = new TestMessage();\n         TestMessage subMessage = new SubTestMessage();\n \n+Messages can be published asynchronously in another thread (fire and forget):\n+\n         bus.publishAsync(message); //returns immediately, publication will continue asynchronously\n         bus.post(message).asynchronously(); // same as above\n+        \n+Message can be published synchronously in the same thread:        \n+\n         bus.publish(subMessage);   // will return after each handler has been invoked\n         bus.post(subMessage).now(); // same as above\n \n@@ -161,15 +180,19 @@ You can also download binary release and javadoc from the [maven central reposit\n There is ongoing effort to extend documentation and provide code samples and detailed explanations of how the message bus works. Code samples can also be found in the various test cases. Please read about the terminology used in this project to avoid confusion and misunderstanding.\n \n <h2>Release Notes</h2>\n-<h3>[1.2.1](milestones/1.2.1)</h3>\n- + Not yet released!\n- + API-Changes: \n-   + Removed deprecated method BusConfiguration.SyncAsync() -> use MBassador default constructor instead\n-   + Deleted interface ISyncMessageBus since it was merely an aggregation of existing interfaces -> replace with GenericMessagePublicationSupport\n \n-<h3>1.2.0</h3>\n- + Added support for conditional handlers using Java EL. Thanks to Bernd Rosstauscher\n- for the initial implementation.\n+### [1.2.1](milestones/1.2.1)\n+ + Not yet released!\n+ + Centralized handling of common (and arbitrary) properties (see BusConfiguration#setProperty and net.engio.mbassy.bus.common.Properties)\n+ + Each bus now has a configurable id and respective #toString() implementation (useful for debugging)\n+ + Each bus now has a default logger (System.out) for publication errors (exception in handlers) which can be replaced with BusConfiguration#setProperty \n+ + __API-Changes:__\n+   + Interface `IMessageFilter` now receives the SubscriptionContext as second parameter. This gives access to the bus runtime within filter logic (useful for error propagation). -> Change your filters signature. You can access the `MessageHandler` object directly from the context. \n+   + Removed deprecated method BusConfiguration.SyncAsync() -> Use default constructor or feature based configuration instead\n+   + Deleted interface ISyncMessageBus since it was merely an aggregation of existing interfaces -> Replace with GenericMessagePublicationSupport\n+\n+### 1.2.0\n+ + Added support for conditional handlers using Java EL. Thanks to Bernd Rosstauscher for the initial implementation.\n  + BREAKING CHANGES in BusConfiguration\n    + Complete redesign of configuration setup using Features instead of simple get/set parameters. This will allow\n  to flexibly combine features and still be able to exclude those not available in certain environments,for example, threading and reflection in GWT (this will be part of future releases)\n@@ -178,7 +201,7 @@ There is ongoing effort to extend documentation and provide code samples and det\n  with its corresponding interface which will be used for all types of message bus implementations\n \n \n-<h3>1.1.10</h3>\n+### 1.1.10\n  + Fixed broken sort order of prioritized handlers (see #58)\n  + Addressed issue #63 by making the constructor of `MessageHandler` use a map of properties and by replacing dependencies to\n   all MBassador specific annotations with Java primitives and simple interfaces\n@@ -188,11 +211,11 @@ There is ongoing effort to extend documentation and provide code samples and det\n  asynchronous FIFO (asynchronous message publications guaranteed to be delivered in the order they occurred)\n  + Renamed runtime property of `BusRuntime` \"handler.async-service\" to \"handler.async.executor\"\n \n-<h3>1.1.9</h3>\n+### 1.1.9\n \n  + Fixed memory leak reported in issue #53\n \n-<h3>1.1.8</h3>\n+### 1.1.8\n \n  + Internal refactorings and code improvements\n  + Fixed #44 #45 #47\n@@ -200,7 +223,7 @@ There is ongoing effort to extend documentation and provide code samples and det\n  version 1.1.8 is not available from the central repository\n \n \n-<h3>1.1.7</h3>\n+### 1.1.7\n \n  + Console Logger not added to message bus instances by default -> use addErrorHandler(IPublicationErrorHandler.ConsoleLogger)\n  + Fixed race conditions in net.engio.mbassy.subscription.Subscription and of WeakConcurrentSet.contains()\n@@ -209,7 +232,7 @@ There is ongoing effort to extend documentation and provide code samples and det\n  + Improved test-infrastructure and increased test-coverage\n  + Thanks for your feedback!\n \n-<h3>1.1.6</h3>\n+### 1.1.6\n \n  + Added support for choosing between strong and weak references using the new @Listener annotation. @Listener can be\n  added to any class that defines message handlers and allows to configure which reference type is used\n@@ -221,7 +244,7 @@ There is ongoing effort to extend documentation and provide code samples and det\n  + Created a message bus implementation that does not use threading to support use in non-multi-threaded environments like GWT,\n  see ISyncMessageBus\n \n-<h3>1.1.3</h3>\n+### 1.1.3\n \n  + Added support for FilteredMessage event\n  + Renamed @Listener to @Handler and DeadEvent to DeadMessage to increase alignment with the established terminology.\n@@ -230,7 +253,7 @@ There is ongoing effort to extend documentation and provide code samples and det\n  + Introduced message publication factories as configurable components to make MBassador more extensible/customizable\n  + Added more documentation and unit tests\n \n-<h3>1.1.1</h3>\n+### 1.1.1\n \n  + Added support for DeadMessage event\n  + Introduced new property to @Handler annotation that allows to activate/deactivate any message handler\n@@ -240,7 +263,7 @@ There is ongoing effort to extend documentation and provide code samples and det\n    more precisely indicate their meaning\n  + Added more unit tests\n \n-<h3>1.1.0</h3>\n+### 1.1.0\n \n First stable release!\n \n@@ -248,20 +271,20 @@ First stable release!\n  + More exhaustive unit tests\n  + Installation from the central repository\n \n-<h3>1.0.6.RC</h3>\n+### 1.0.6.RC\n \n  + Fixed behaviour with capacity bound blocking queue such that there now are two methods to schedule a message\n  asynchronously. One will block until capacity becomes available, the other will timeout after a specified amount of\n  time.\n  +  Additional unit tests\n \n-<h3>1.0.5.RC</h3>\n+### 1.0.5.RC\n \n  + Added MessageEnvelope and @Enveloped annotation to configure handlers that might receive arbitrary message type\n  + Added handler configuration property to @Handler annotation to move from message filtering to more specific implementation\n  of this feature\n \n-<h3>1.0.4.RC</h3>\n+### 1.0.4.RC\n \n   + Introduced BusConfiguration as a central class to encapsulate configurational aspects\n \n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/docs/TODO.md",
            "additions": 4,
            "deletions": 2
        },
        "diff content": "@@ -2,13 +2,15 @@\n Asyncbus.shutdown() -> no test coverage\n EnvelopedMessageDispatcher -> not tested at all\n \n-#Refactorings\n \n+#Refactorings\n++ split up IMessagePublication into two separate interfaces (internal and external)\n++ create MessagePublicationFactory\n \n #Improvements\n Prio 1: Validation of handlers\n     ERROR:Handler with mismatching parameter types\n-    ERROR:Interfaces + rejectSubtypes\n+    ERROR:Interfaces/Abstract + rejectSubtypes\n     WARN:@Synchronized only for some handlers of a given listener\n Prio 2: Lifecycle Callbacks = Implement in MessagePublication (BeforeStart,AfterCompletion)\n \n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/docs/wiki-listener-def.md",
            "additions": 24,
            "deletions": 24
        },
        "diff content": "@@ -32,37 +32,37 @@ filters, delivery modes etc.\n   </tr>\n \n   <tr>\n-          <td>rejectSubtypes</td>\n-          <td>The primary message type consumed by a message handler is determined by the type of\n-              its parameter.Polymorphism does allow any sub type of that message type to be delivered\n-              to the handler as well, which is the default behaviour of any message handler.\n-              The handler can be configured to not receiving any sub types by specifying thus using this\n-              property.\n-          </td>\n-          <td>false</td>\n+      <td>rejectSubtypes</td>\n+      <td>The primary message type consumed by a message handler is determined by the type of\n+          its parameter.Polymorphism does allow any sub type of that message type to be delivered\n+          to the handler as well, which is the default behaviour of any message handler.\n+          The handler can be configured to not receiving any sub types by specifying thus using this\n+          property.\n+      </td>\n+      <td>false</td>\n   </tr>\n \n-  <tr>\n-            <td>enabled</td>\n-            <td>A handler can be explicitly disabled to not take part in message delivery.\n-            </td>\n-            <td>true</td>\n+    <tr>\n+        <td>enabled</td>\n+        <td>A handler can be explicitly disabled to not take part in message delivery.\n+        </td>\n+        <td>true</td>\n     </tr>\n \n     <tr>\n-                <td>strongReferencess</td>\n-                <td>Whether the bus should use storng references to the listeners instead of weak references\n-                </td>\n-                <td>false</td>\n+        <td>strongReferencess</td>\n+        <td>Whether the bus should use storng references to the listeners instead of weak references\n+        </td>\n+        <td>false</td>\n         </tr>\n     <tr>\n-                    <td>invocation</td>\n-                    <td>Specify a custom implementation for the handler invocation. By default, a generic implementation\n-                    that uses reflection will be used. Note: A custom implementation will not be faster than the generic one\n-                    since there are heavy optimizations by the JVM using JIT-Compiler and more.\n-                    </td>\n-                    <td>false</td>\n-            </tr>\n+        <td>invocation</td>\n+        <td>Specify a custom implementation for the handler invocation. By default, a generic implementation\n+        that uses reflection will be used. Note: A custom implementation will not be faster than the generic one\n+        since there are heavy optimizations by the JVM using JIT-Compiler and more.\n+        </td>\n+        <td>false</td>\n+    </tr>\n \n \n </table>\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/docs/wiki-terminology.md",
            "additions": 6,
            "deletions": 11
        },
        "diff content": "@@ -1,24 +1,19 @@\n <h2>Terminology</h2>\n-To avoid confusion and increase precision of the available documentation a common vocabulary of the most relevant concepts is necessary.\n-Specifically, the terms \"event\" and \"message\" have their own definition within the context of the message bus system and as such require\n+To avoid confusion and increase precision of the available documentation a common vocabulary of the most relevant concepts is necessary. Specifically, the terms \"event\" and \"message\" have their own definition within the context of the message bus system and as such require\n some clarification.\n \n <h3>Message</h3>\n-A message is an object used for communication between multiple other objects.Other libraries established the term \"event\" which essentially\n-refers to the same idea (an event occurs at some point in the system and is published to other components such that they might react to it).\n-MBassador uses the term message instead of event since the object sent through it does not necessarily represent an event. It might merely represent\n-data to be processed, e.g. stored or transformed.\n+A message is an object used for communication between a sender and a set of receivers. Other libraries established the term \"event\" which essentially refers to the same idea (an event occurs at some point in the system and is published to other components such that they might react to it).  \n+MBassador uses the term `message` instead of `event` since the object sent over the wire does not necessarily represent an event. It might merely represent data to be processed, e.g. stored or transformed.\n \n A message can be any object, no restrictions or assumptions are made. A message can be sent by any object that has access to the bus\n-and is delivered to all registered listeners that consume the type of message.\n+and is delivered to all registered handlers consuming that type of message.\n \n <h3>Message handler</h3>\n-A message handler is a method that defines exactly one parameter (the message) and is marked with @Handler. A handler has a message type\n-that is implicitly defined in the method signature (the parameter type). A message handler will be invoked for each message that has a compatible\n-type.\n+A message handler is a method that defines exactly one parameter (the message or a message envelope) and is marked with @Handler. A handler has a message type that is implicitly defined in the method signature (the parameter type). A message handler will be invoked for each message that has a compatible type.\n \n <h3>Message listener</h3>\n-An object that defines one or more message handlers and that has been subscribed at the message bus is referred to as (message) listener.\n+A class defining one or more message handlers and that has been subscribed at the message bus is referred to as (message) listener.\n \n <h3>Subscription</h3>\n Subscription is the process of adding a listener to the message bus, such that it might receive messages. It is used interchangeably with the\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java",
            "additions": 17,
            "deletions": 6
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.bus;\n \n import net.engio.mbassy.bus.common.DeadMessage;\n+import net.engio.mbassy.bus.common.Properties;\n import net.engio.mbassy.bus.common.PubSubSupport;\n import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n@@ -9,10 +10,9 @@ import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.subscription.Subscription;\n import net.engio.mbassy.subscription.SubscriptionManager;\n \n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n+import java.util.*;\n+\n+import static net.engio.mbassy.bus.common.Properties.Handler.PublicationError;\n \n /**\n  * The base class for all message bus implementations.\n@@ -33,8 +33,15 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n \n \n     public AbstractPubSubSupport(IBusConfiguration configuration) {\n-        this.runtime = new BusRuntime(this);\n-        this.runtime.add(BusRuntime.Properties.ErrorHandlers, getRegisteredErrorHandlers());\n+        if(!configuration.hasProperty(Properties.Handler.PublicationError)){\n+            System.out.println(\"WARN: No error handler configured to handle exceptions during publication.\\n\" +\n+                    \"Error handlers can be added to any instance of  AbstractPubSubSupport or via BusConfiguration. \\n\" +\n+                    \"Falling back to console logger.\");\n+        }\n+        this.errorHandlers.add(configuration.getProperty(Properties.Handler.PublicationError, new IPublicationErrorHandler.ConsoleLogger()));\n+        this.runtime = new BusRuntime(this)\n+            .add(PublicationError, getRegisteredErrorHandlers())\n+            .add(Properties.Common.Id, UUID.randomUUID().toString());\n         // configure the pub sub feature\n         Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);\n         this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()\n@@ -97,4 +104,8 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n         }\n     }\n \n+    @Override\n+    public String toString() {\n+        return getClass().getSimpleName() + \"{ \" + runtime.get(Properties.Common.Id) + \"}\";\n+    }\n }\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java",
            "additions": 11,
            "deletions": 9
        },
        "diff content": "@@ -1,6 +1,8 @@\n package net.engio.mbassy.bus;\n \n import net.engio.mbassy.bus.common.IMessageBus;\n+import net.engio.mbassy.bus.common.Properties;\n+import net.engio.mbassy.bus.config.ConfigurationError;\n import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.PublicationError;\n@@ -9,15 +11,14 @@ import net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.TimeUnit;\n \n /**\n  * The base class for all message bus implementations with support for asynchronous message dispatch\n  *\n- * @param <T>\n- * @param <P>\n+ * @param <T> The type of message this bus consumes\n+ * @param <P> The publication commands this bus supports depend on P\n  */\n public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublicationCommand>\n         extends AbstractPubSubSupport<T> implements IMessageBus<T, P> {\n@@ -36,14 +37,20 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n \n         // configure asynchronous message dispatch\n         Feature.AsynchronousMessageDispatch asyncDispatch = configuration.getFeature(Feature.AsynchronousMessageDispatch.class);\n+        if(asyncDispatch == null){\n+            configuration.handleError(ConfigurationError.Missing(Feature.AsynchronousMessageDispatch.class));\n+        }\n         pendingMessages = asyncDispatch.getPendingMessages();\n         dispatchers = new ArrayList<Thread>(asyncDispatch.getNumberOfMessageDispatchers());\n         initDispatcherThreads(asyncDispatch);\n \n         // configure asynchronous handler invocation\n         Feature.AsynchronousHandlerInvocation asyncInvocation = configuration.getFeature(Feature.AsynchronousHandlerInvocation.class);\n+        if(asyncInvocation == null){\n+            configuration.handleError(ConfigurationError.Missing(Feature.AsynchronousHandlerInvocation.class));\n+        }\n         this.executor = asyncInvocation.getExecutor();\n-        getRuntime().add(BusRuntime.Properties.AsynchronousHandlerExecutor, executor);\n+        getRuntime().add(Properties.Handler.AsynchronousHandlerExecutor, executor);\n \n     }\n \n@@ -117,9 +124,4 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n         return pendingMessages.size() > 0;\n     }\n \n-    @Override\n-    public Executor getExecutor() {\n-        return executor;\n-    }\n-\n }\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/BusFactory.java",
            "additions": 1,
            "deletions": 6
        },
        "diff content": "@@ -16,8 +16,6 @@ public class BusFactory {\n      * Create a message bus supporting only synchronous message publication.\n      * All message publications will run in the calling thread, no bus internal\n      * multi-threading will occur.\n-     *\n-     * @return\n      */\n     public static SyncMessageBus SynchronousOnly(){\n         BusConfiguration syncPubSubCfg = new BusConfiguration();\n@@ -26,12 +24,9 @@ public class BusFactory {\n     }\n \n     /**\n-     * Create a message bus supporting synchronous and asynchronous message publication.\n+     * Create a message bus with support for synchronous and asynchronous message publication.\n      * Asynchronous message publication will be handled by a single thread such that FIFO\n      * order of message processing is guaranteed.\n-     *\n-     *\n-     * @return\n      */\n     public static IMessageBus AsynchronousSequentialFIFO(){\n         BusConfiguration asyncFIFOConfig = new BusConfiguration();\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/BusRuntime.java",
            "additions": 0,
            "deletions": 7
        },
        "diff content": "@@ -18,13 +18,6 @@ import java.util.Map;\n  */\n public class BusRuntime {\n \n-    public static class Properties{\n-\n-        public static final String ErrorHandlers = \"error.handlers\";\n-        public static final String AsynchronousHandlerExecutor = \"handler.async.executor\";\n-\n-    }\n-\n     private PubSubSupport provider;\n \n     private Map<String, Object> properties = new HashMap<String, Object>();\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MBassador.java",
            "additions": 6,
            "deletions": 5
        },
        "diff content": "@@ -12,15 +12,16 @@ import java.util.concurrent.TimeUnit;\n \n public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> implements IMessageBus<T, SyncAsyncPostCommand<T>> {\n \n+\n     public MBassador(IBusConfiguration configuration) {\n         super(configuration);\n     }\n \n     public MBassador(){\n-        super(new BusConfiguration()\n-            .addFeature(Feature.SyncPubSub.Default())\n-            .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n-            .addFeature(Feature.AsynchronousMessageDispatch.Default()));\n+        this(new BusConfiguration()\n+                .addFeature(Feature.SyncPubSub.Default())\n+                .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n+                .addFeature(Feature.AsynchronousMessageDispatch.Default()));\n     }\n \n \n@@ -47,7 +48,7 @@ public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCo\n             handlePublicationError(new PublicationError()\n                     .setMessage(\"Error during publication of message\")\n                     .setCause(e)\n-                    .setPublishedObject(message));\n+                    .setPublishedMessage(message));\n         }\n \n     }\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/SyncMessageBus.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -28,7 +28,7 @@ public class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements PubSu\n             handlePublicationError(new PublicationError()\n                     .setMessage(\"Error during publication of message\")\n                     .setCause(e)\n-                    .setPublishedObject(message));\n+                    .setPublishedMessage(message));\n         }\n     }\n \n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/GenericMessagePublicationSupport.java",
            "additions": 6,
            "deletions": 5
        },
        "diff content": "@@ -4,9 +4,10 @@ import net.engio.mbassy.bus.publication.IPublicationCommand;\n \n /**\n  * This interface is meant to be implemented by different bus implementations to offer a consistent way\n- * to plugin different flavors of message publication.\n+ * to plugin different methods of message publication.\n  *\n- * The parametrization of the IPostCommand influences which publication flavours are available.\n+ * The parametrization of the IPostCommand influences which publication methods (asynchronous, synchronous or\n+ * conditional etc.) are available.\n  *\n  */\n public interface GenericMessagePublicationSupport<T, P extends IPublicationCommand> extends PubSubSupport<T>, ErrorHandlingSupport{\n@@ -15,10 +16,10 @@ public interface GenericMessagePublicationSupport<T, P extends IPublicationComma\n      * Publish a message to the bus using on of its supported message publication mechanisms. The supported\n      * mechanisms depend on the available implementation and are exposed as subclasses of IPublicationCommand.\n      * The standard mechanism is the synchronous dispatch which will publish the message in the current thread\n-     * and returns after every matching handler has been invoked. @See IPublicationCommand.\n+     * and returns after every matching handler has been invoked.\n      *\n-     * @param message\n-     * @return\n+     * @param message - Any subtype of T welcome\n+     * @return An object that provides access to the available publication methods supported by the message bus.\n      */\n     P post(T message);\n \n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/IMessageBus.java",
            "additions": 0,
            "deletions": 12
        },
        "diff content": "@@ -2,8 +2,6 @@ package net.engio.mbassy.bus.common;\n \n import net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n \n-import java.util.concurrent.Executor;\n-\n /**\n  * A message bus offers facilities for publishing messages to the message handlers of registered listeners.\n  * A message publication starts when an object is send to the bus using one of the its publication methods.\n@@ -66,16 +64,6 @@ public interface IMessageBus<T, P extends ISyncAsyncPublicationCommand>\n     @Override\n     P post(T message);\n \n-    /**\n-     * Get the executor service that is used for asynchronous message publications.\n-     * The executor is passed to the message bus at creation time.\n-     *\n-     * Note: The executor can be obtained from the run time. See\n-     * @return\n-     */\n-    @Deprecated\n-    Executor getExecutor();\n-\n     /**\n      * Check whether any asynchronous message publications are pending to be processed\n      *\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/Properties.java",
            "additions": 25,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,25 @@\n+package net.engio.mbassy.bus.common;\n+\n+/**\n+ * A collection of properties commonly used by different parts of the library.\n+ *\n+ * @author bennidi\n+ *         Date: 22.02.15\n+ */\n+public final class Properties {\n+\n+    public static final class Handler {\n+\n+        public static final String PublicationError = \"bus.handlers.error\";\n+        public static final String AsynchronousHandlerExecutor = \"bus.handlers.async-executor\";\n+    }\n+\n+    public static final class Common {\n+\n+        public static final String Id = \"bus.id\";\n+    }\n+\n+\n+\n+\n+}\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java",
            "additions": 33,
            "deletions": 6
        },
        "diff content": "@@ -1,6 +1,8 @@\n package net.engio.mbassy.bus.config;\n \n import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n import java.util.Map;\n \n /**\n@@ -8,26 +10,51 @@ import java.util.Map;\n  */\n public class BusConfiguration implements IBusConfiguration {\n \n-    // the registered features\n-    private Map<Class<? extends Feature>, Feature> features = new HashMap<Class<? extends Feature>, Feature>();\n+    // the registered properties\n+    private final Map<Object, Object> properties = new HashMap<Object, Object>();\n+    private final List<ConfigurationErrorHandler> errorHandlerList = new LinkedList<ConfigurationErrorHandler>();\n \n     public BusConfiguration() {\n         super();\n     }\n \n+    @Override\n+    public IBusConfiguration setProperty(String name, Object value) {\n+        properties.put(name, value);\n+        return this;\n+    }\n+\n+    @Override\n+    public <T> T getProperty(String name, T defaultValue) {\n+        return properties.containsKey(name) ? (T) properties.get(name) : defaultValue;\n+    }\n+\n+    @Override\n+    public boolean hasProperty(String name) {\n+        return properties.containsKey(name);\n+    }\n+\n     @Override\n     public <T extends Feature> T getFeature(Class<T> feature) {\n-        return (T)features.get(feature);\n+        return (T) properties.get(feature);\n     }\n \n     @Override\n     public IBusConfiguration addFeature(Feature feature) {\n-        features.put(feature.getClass(), feature);\n+        properties.put(feature.getClass(), feature);\n+        return this;\n+    }\n+\n+    @Override\n+    public IBusConfiguration addConfigurationErrorHandler(ConfigurationErrorHandler handler) {\n+        errorHandlerList.add(handler);\n         return this;\n     }\n \n     @Override\n-    public IBusConfiguration addErrorHandler(ConfigurationErrorHandler handler) {\n-        return null;  // TODO: implement configuration validation\n+    public void handleError(ConfigurationError error) {\n+        for(ConfigurationErrorHandler errorHandler : errorHandlerList){\n+            errorHandler.handle(error);\n+        }\n     }\n }\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/ConfigurationError.java",
            "additions": 21,
            "deletions": 1
        },
        "diff content": "@@ -1,10 +1,30 @@\n package net.engio.mbassy.bus.config;\n \n /**\n- * Todo: Add javadoc\n+ * Configuration errors represent specific misconfigurations of features in a {@link net.engio.mbassy.bus.config.IBusConfiguration}\n  *\n  * @author bennidi\n  *         Date: 8/29/14\n  */\n public class ConfigurationError {\n+\n+    private Class<? extends Feature> featureType;\n+    private Feature feature;\n+    private String message;\n+\n+    public ConfigurationError(Class<? extends Feature> featureType, Feature feature, String message) {\n+        this.featureType = featureType;\n+        this.feature = feature;\n+        this.message = message;\n+    }\n+\n+    public static ConfigurationError Missing(Class<? extends Feature> featureType){\n+        return new ConfigurationError(featureType, null, \"An expected feature was missing. Use addFeature() in IBusConfiguration to add features.\");\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Error for \" + featureType + \":\" + message +\n+                \", (\" + feature + \")\";\n+    }\n }\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/ConfigurationErrorHandler.java",
            "additions": 7,
            "deletions": 1
        },
        "diff content": "@@ -1,10 +1,16 @@\n package net.engio.mbassy.bus.config;\n \n /**\n- * Todo: Add javadoc\n+ * Respond to a {@link net.engio.mbassy.bus.config.ConfigurationError} with any kind of action.\n  *\n  * @author bennidi\n  *         Date: 8/29/14\n  */\n public interface ConfigurationErrorHandler {\n+\n+    /**\n+     * Called when a misconfiguration is detected on a {@link net.engio.mbassy.bus.config.IBusConfiguration}\n+     * @param error The error that represents the detected misconfiguration.\n+     */\n+    void handle(ConfigurationError error);\n }\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/Feature.java",
            "additions": 2,
            "deletions": 3
        },
        "diff content": "@@ -96,9 +96,8 @@ public interface Feature {\n             return Default(numberOfCores, numberOfCores * 2);\n         }\n \n-        public static final AsynchronousHandlerInvocation Default(int initialCoreThreads, int maximumCoreThreads){\n-            int numberOfCores = Runtime.getRuntime().availableProcessors();\n-            return new AsynchronousHandlerInvocation().setExecutor(new ThreadPoolExecutor(initialCoreThreads, maximumCoreThreads, 1,\n+        public static final AsynchronousHandlerInvocation Default(int minThreadCount, int maxThreadCount){\n+            return new AsynchronousHandlerInvocation().setExecutor(new ThreadPoolExecutor(minThreadCount, maxThreadCount, 1,\n                     TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), MessageHandlerThreadFactory));\n         }\n \n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/IBusConfiguration.java",
            "additions": 43,
            "deletions": 5
        },
        "diff content": "@@ -12,19 +12,57 @@ package net.engio.mbassy.bus.config;\n  */\n public interface IBusConfiguration{\n \n+    /**\n+     * Set a property which will be read by the message bus constructor. Existing value will be overwritten.\n+     * Null values are supported (checking for existence of property will return <code>true</code> even if set to <code>null</code>).\n+     *\n+     * @param name The name of the property. Note: Each implementation may support different properties.\n+     * @param value The value of the property.\n+     * @return  A reference to <code>this</code> bus configuration.\n+     */\n+    IBusConfiguration setProperty(String name, Object value);\n+\n+    /**\n+     * Read a property from this configuration.\n+     *\n+     * @param name  The name of the property to be read.\n+     * @param defaultValue  The value to be returned if property was not found\n+     * @param <T>  The type of property\n+     * @return The value associated with the given property name or <code>defaultValue</code> if not present\n+     */\n+    <T> T getProperty(String name, T defaultValue);\n+\n+    /**\n+     * Check whether a property has been set.\n+     *\n+     * @return true if property was set (even if set to null)\n+     *         false otherwise\n+     */\n+    boolean hasProperty(String name);\n+\n+\n     /**\n      * Get a registered feature by its type (class).\n      *\n-     * @param feature\n-     * @param <T>\n-     * @return\n      */\n     <T extends Feature> T getFeature(Class<T> feature);\n \n+    /**\n+     * Add a feature to the given configuration, replacing any existing feature of the same type.\n+     *\n+     * @param feature The feature to add\n+     * @return  A reference to <code>this</code> bus configuration.\n+     */\n     IBusConfiguration addFeature(Feature feature);\n \n-    IBusConfiguration addErrorHandler(ConfigurationErrorHandler handler);\n-\n+    /**\n+     * Add a handler that is called when a misconfiguration is detected.\n+     */\n+    IBusConfiguration addConfigurationErrorHandler(ConfigurationErrorHandler handler);\n \n+    /**\n+     * Calls all ConfigurationErrorHandlers\n+     */\n+    void handleError(ConfigurationError error);\n \n }\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/error/IPublicationErrorHandler.java",
            "additions": 11,
            "deletions": 1
        },
        "diff content": "@@ -26,6 +26,16 @@ public interface IPublicationErrorHandler {\n      */\n     static final class ConsoleLogger implements IPublicationErrorHandler {\n \n+        private final boolean printStackTrace;\n+\n+        public ConsoleLogger() {\n+            this(false);\n+        }\n+\n+        public ConsoleLogger(boolean printStackTrace) {\n+            this.printStackTrace = printStackTrace;\n+        }\n+\n         /**\n          * {@inheritDoc}\n          */\n@@ -36,7 +46,7 @@ public interface IPublicationErrorHandler {\n             System.out.println(error);\n \n             // Printout the stacktrace from the cause.\n-            if (error.getCause() != null) {\n+            if (printStackTrace && error.getCause() != null) {\n                 error.getCause().printStackTrace();\n             }\n         }\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/error/PublicationError.java",
            "additions": 16,
            "deletions": 9
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.bus.error;\n \n import net.engio.mbassy.bus.IMessagePublication;\n+import net.engio.mbassy.subscription.SubscriptionContext;\n \n import java.lang.reflect.Method;\n \n@@ -21,7 +22,7 @@ public class PublicationError{\n     private String message;\n     private Method handler;\n     private Object listener;\n-    private Object publishedObject;\n+    private Object publishedMessage;\n \n \n     /**\n@@ -43,7 +44,7 @@ public class PublicationError{\n         this.message = message;\n         this.handler = handler;\n         this.listener = listener;\n-        this.publishedObject = publishedObject;\n+        this.publishedMessage = publishedObject;\n     }\n \n     public PublicationError(final Throwable cause,\n@@ -51,10 +52,16 @@ public class PublicationError{\n                             final IMessagePublication publication) {\n         this.cause = cause;\n         this.message = message;\n-        this.publishedObject = publication != null ? publication.getMessage() : null;\n+        this.publishedMessage = publication != null ? publication.getMessage() : null;\n     }\n \n-\n+    public PublicationError(final Throwable cause,\n+                            final String message,\n+                            final SubscriptionContext context) {\n+        this.cause = cause;\n+        this.message = message;\n+        this.handler = context.getHandler().getMethod();\n+    }\n \n \n     /**\n@@ -109,12 +116,12 @@ public class PublicationError{\n         return this;\n     }\n \n-    public Object getPublishedObject() {\n-        return publishedObject;\n+    public Object getPublishedMessage() {\n+        return publishedMessage;\n     }\n \n-    public PublicationError setPublishedObject(Object publishedObject) {\n-        this.publishedObject = publishedObject;\n+    public PublicationError setPublishedMessage(Object publishedMessage) {\n+        this.publishedMessage = publishedMessage;\n         return this;\n     }\n \n@@ -134,7 +141,7 @@ public class PublicationError{\n                 newLine +\n                 \"\\tlistener=\" + listener +\n                 newLine +\n-                \"\\tpublishedObject=\" + publishedObject +\n+                \"\\tpublishedMessage=\" + publishedMessage +\n                 '}';\n     }\n }\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ReflectionUtils.java",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -41,7 +41,6 @@ public class ReflectionUtils\n \t *\n \t * @param overridingMethod\n \t * @param subclass\n-\t * @return\n \t */\n \tpublic static Method getOverridingMethod( final Method overridingMethod, final Class subclass ) {\n \t\tClass current = subclass;\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.bus.BusRuntime;\n+import net.engio.mbassy.bus.common.Properties;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n \n import java.util.concurrent.ExecutorService;\n@@ -20,7 +20,7 @@ public class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAw\n     public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n         super(delegate.getContext());\n         this.delegate = delegate;\n-        this.executor = delegate.getContext().getRuntime().get(BusRuntime.Properties.AsynchronousHandlerExecutor);\n+        this.executor = delegate.getContext().getRuntime().get(Properties.Handler.AsynchronousHandlerExecutor);\n     }\n \n     /**\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -17,7 +17,7 @@ public final class FilteredMessageDispatcher extends DelegatingMessageDispatcher\n \r\n     public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\r\n         super(dispatcher);\r\n-        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\r\n+        this.filter = dispatcher.getContext().getHandler().getFilter();\r\n     }\r\n \r\n     private boolean passesFilter(Object message) {\r\n@@ -26,7 +26,7 @@ public final class FilteredMessageDispatcher extends DelegatingMessageDispatcher\n             return true;\r\n         } else {\r\n             for (IMessageFilter aFilter : filter) {\r\n-                if (!aFilter.accepts(message, getContext().getHandlerMetadata())) {\r\n+                if (!aFilter.accepts(message, getContext())) {\r\n                     return false;\r\n                 }\r\n             }\r\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -46,6 +46,6 @@ public class ReflectiveHandlerInvocation extends HandlerInvocation{\n      */\n     @Override\n     public void invoke(final Object listener, final Object message){\n-        invokeHandler(message, listener, getContext().getHandlerMetadata().getHandler());\n+        invokeHandler(message, listener, getContext().getHandler().getMethod());\n     }\n }\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/el/ElFilter.java",
            "additions": 40,
            "deletions": 35
        },
        "diff content": "@@ -1,30 +1,36 @@\n package net.engio.mbassy.dispatch.el;\r\n \r\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\r\n+import net.engio.mbassy.bus.error.PublicationError;\r\n import net.engio.mbassy.listener.IMessageFilter;\r\n import net.engio.mbassy.listener.MessageHandler;\r\n+import net.engio.mbassy.subscription.SubscriptionContext;\r\n \r\n import javax.el.ExpressionFactory;\r\n import javax.el.ValueExpression;\r\n \r\n-/*****************************************************************************\r\n- * A filter that will use a expression from the handler annotation and \r\n+/**\r\n+ * A filter that will use a expression from the handler annotation and\r\n  * parse it as EL.\r\n- ****************************************************************************/\r\n-\r\n+ * <p/>\r\n+ * Accepts a message if the associated EL expression evaluates to <code>true</code>\r\n+ */\r\n public class ElFilter implements IMessageFilter {\r\n \r\n     // thread-safe initialization of EL factory singleton\r\n-    public static final class ExpressionFactoryHolder{\r\n+    public static final class ExpressionFactoryHolder {\r\n \r\n         // if runtime exception is thrown, this will\r\n         public static final ExpressionFactory ELFactory = getELFactory();\r\n \r\n-        /*************************************************************************\r\n+        /**\r\n+         * **********************************************************************\r\n          * Get an implementation of the ExpressionFactory. This uses the\r\n          * Java service lookup mechanism to find a proper implementation.\r\n-         * If none if available we do not support EL filters.\r\n-         ************************************************************************/\r\n-        private static final ExpressionFactory getELFactory(){\r\n+         * If none is available we do not support EL filters.\r\n+         * **********************************************************************\r\n+         */\r\n+        private static final ExpressionFactory getELFactory() {\r\n             try {\r\n                 return ExpressionFactory.newInstance();\r\n             } catch (RuntimeException e) {\r\n@@ -33,40 +39,39 @@ public class ElFilter implements IMessageFilter {\n         }\r\n     }\r\n \r\n-    public static final boolean isELAvailable(){\r\n+    public static final boolean isELAvailable() {\r\n         return ExpressionFactoryHolder.ELFactory != null;\r\n     }\r\n \r\n-    public static final ExpressionFactory ELFactory(){\r\n+    public static final ExpressionFactory ELFactory() {\r\n         return ExpressionFactoryHolder.ELFactory;\r\n     }\r\n \r\n-    /**\r\n-     * Accepts a message if the associated EL expression of the message handler resolves to 'true'\r\n-     *\r\n-     * @param message the message to be handled by the handler\r\n-     * @param  metadata the metadata object which describes the message handler\r\n-     * @return\r\n-     */\r\n-\t@Override\r\n-\tpublic boolean accepts(Object message, MessageHandler metadata) {\r\n-\t\tString expression = metadata.getCondition();\r\n-\t\tStandardELResolutionContext context = new StandardELResolutionContext(message);\r\n-\t\treturn evalExpression(expression, context);\r\n-\t}\r\n \r\n-\tprivate boolean evalExpression(String expression, StandardELResolutionContext context) {\r\n-\t\tValueExpression ve = ELFactory().createValueExpression(context, expression, Boolean.class);\r\n-\t\ttry{\r\n-            Object result = ve.getValue(context);\r\n-            return (Boolean)result;\r\n-             }\r\n-        catch(Throwable exception){\r\n-            // TODO: BusRuntime should be available in this filter to propagate resolution errors\r\n-            // -> this is generally a good feature for filters\r\n+    @Override\r\n+    public boolean accepts(Object message, final SubscriptionContext context) {\r\n+        final MessageHandler metadata = context.getHandler();\r\n+        String expression = metadata.getCondition();\r\n+        StandardELResolutionContext resolutionContext = new StandardELResolutionContext(message);\r\n+        return evalExpression(expression, resolutionContext, context, message);\r\n+    }\r\n+\r\n+    private boolean evalExpression(final String expression,\r\n+                                   final StandardELResolutionContext resolutionContext,\r\n+                                   final SubscriptionContext context,\r\n+                                   final Object message) {\r\n+        ValueExpression ve = ELFactory().createValueExpression(resolutionContext, expression, Boolean.class);\r\n+        try {\r\n+            Object result = ve.getValue(resolutionContext);\r\n+            return (Boolean) result;\r\n+        } catch (Throwable exception) {\r\n+            PublicationError publicationError = new PublicationError(exception, \"Error while evaluating EL expression on message\", context)\r\n+                    .setPublishedMessage(message);\r\n+            for (IPublicationErrorHandler errorHandler : context.getErrorHandlers()) {\r\n+                errorHandler.handleError(publicationError);\r\n+            }\r\n             return false;\r\n-            //throw new IllegalStateException(\"A handler uses an EL filter but the output is not \\\"true\\\" or \\\"false\\\".\");\r\n         }\r\n-\t}\r\n+    }\r\n \r\n }\r\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Filter.java",
            "additions": 1,
            "deletions": 5
        },
        "diff content": "@@ -10,8 +10,6 @@ import java.lang.annotation.Target;\n  * It references a class that implements the IMessageFilter interface.\n  * The filter will be used to check whether a message should be delivered\n  * to the listener or not.\n- * <p/>\n- * <p/>\n  *\n  * @author bennidi\n  *         Date: 2/14/12\n@@ -22,9 +20,7 @@ public @interface Filter {\n \n     /**\n      * The class that implements the filter.\n-     * Note: A filter always needs to provide a non-arg constructor\n-     *\n-     * @return\n+     * IMPORTANT: A filter always needs to provide a non-arg constructor\n      */\n     Class<? extends IMessageFilter> value();\n }\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Filters.java",
            "additions": 6,
            "deletions": 2
        },
        "diff content": "@@ -1,5 +1,7 @@\n package net.engio.mbassy.listener;\n \n+import net.engio.mbassy.subscription.SubscriptionContext;\n+\n /**\n  * A set of standard filters for common use cases.\n  *\n@@ -21,7 +23,8 @@ public class Filters {\n     public static final class RejectSubtypes implements IMessageFilter {\n \n         @Override\n-        public boolean accepts(Object event, MessageHandler metadata) {\n+        public boolean accepts(final Object event, final SubscriptionContext context) {\n+            final MessageHandler metadata = context.getHandler();\n             for (Class handledMessage : metadata.getHandledMessages()) {\n                 if (handledMessage.equals(event.getClass())) {\n                     return true;\n@@ -40,7 +43,8 @@ public class Filters {\n     public static final class SubtypesOnly implements IMessageFilter{\n \n         @Override\n-        public boolean accepts(Object message, MessageHandler metadata) {\n+        public boolean accepts(final Object message, final SubscriptionContext context) {\n+            final MessageHandler metadata = context.getHandler();\n             for(Class acceptedClasses : metadata.getHandledMessages()){\n                 if(acceptedClasses.isAssignableFrom(message.getClass())\n                         && ! acceptedClasses.equals(message.getClass()))\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/IMessageFilter.java",
            "additions": 8,
            "deletions": 4
        },
        "diff content": "@@ -1,5 +1,7 @@\n package net.engio.mbassy.listener;\n \n+import net.engio.mbassy.subscription.SubscriptionContext;\n+\n /**\n  * Message filters can be used to control what messages are delivered to a specific message handler.\n  * Filters are attached to message handler using the @Listener annotation.\n@@ -8,6 +10,7 @@ package net.engio.mbassy.listener;\n  *\n  * Example:\n  *\n+ * {@code\n  * @Lister\n  * @Filters(Urlfilter.class)\n  * public void someHandler(String message){...}\n@@ -22,6 +25,7 @@ package net.engio.mbassy.listener;\n  * bus.post(\"www.stackoverflow.com\"); // will not be delivered\n  *\n  * NOTE: A message filter must provide a no-arg constructor!!!\n+ * }\n  *\n  * @author bennidi\n  *         Date: 2/8/12\n@@ -29,12 +33,12 @@ package net.engio.mbassy.listener;\n public interface IMessageFilter<M> {\n \n     /**\n-     * Check the message for whatever criteria\n+     * Check whether the message matches some criteria\n      *\n-     * @param message the message to be handled by the handler\n-     * @param  metadata the metadata object which describes the message handler\n+     * @param message The message to be handled by the handler\n+     * @param  context The context object containing a description of the message handler and the bus environment\n      * @return  true: if the message matches the criteria and should be delivered to the handler\n      *          false: otherwise\n      */\n-    boolean accepts(M message, MessageHandler metadata);\n+    boolean accepts(M message, SubscriptionContext context);\n }\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Listener.java",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -18,10 +18,9 @@ import java.lang.annotation.*;\n public @interface Listener {\n \n     /**\n-     * By default, references to message listeners are weak to eliminate risks of memory leaks.\n+     * BY DEFAULT, REFERENCES to message listeners ARE WEAK to eliminate risks of memory leaks.\n      * It is possible to use strong references instead.\n      *\n-     * @return\n      */\n     References references() default References.Weak;\n \n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandler.java",
            "additions": 8,
            "deletions": 5
        },
        "diff content": "@@ -41,9 +41,12 @@ public class MessageHandler {\n          * @param filter   The set of preconfigured filters if any\r\n          * @param listenerConfig The listener metadata\r\n          * @return  A map of properties initialized from the given parameters that will conform to the requirements of the\r\n-         *         {@link MessageHandler} constructor. See {@see MessageHandler.validate()} for more details.\r\n+         *         {@link MessageHandler} constructor.\r\n          */\r\n-        public static final Map<String, Object> Create(Method handler, Handler handlerConfig, IMessageFilter[] filter, MessageListener listenerConfig){\r\n+        public static final Map<String, Object> Create(Method handler,\r\n+                                                       Handler handlerConfig,\r\n+                                                       IMessageFilter[] filter,\r\n+                                                       MessageListener listenerConfig){\r\n             if(handler == null){\r\n                 throw new IllegalArgumentException(\"The message handler configuration may not be null\");\r\n             }\r\n@@ -133,6 +136,7 @@ public class MessageHandler {\n     }\r\n \r\n     private void validate(Map<String, Object> properties){\r\n+        // define expected types of known properties\r\n         Object[][] expectedProperties = new Object[][]{\r\n                 new Object[]{Properties.HandlerMethod, Method.class },\r\n                 new Object[]{Properties.Priority, Integer.class },\r\n@@ -145,13 +149,12 @@ public class MessageHandler {\n                 new Object[]{Properties.Listener, MessageListener.class },\r\n                 new Object[]{Properties.AcceptSubtypes, Boolean.class }\r\n         };\r\n+        // ensure types match\r\n         for(Object[] property : expectedProperties){\r\n             if (properties.get(property[0]) == null || !((Class)property[1]).isAssignableFrom(properties.get(property[0]).getClass()))\r\n                 throw new IllegalArgumentException(\"Property \" + property[0] + \" was expected to be not null and of type \" + property[1]\r\n                         + \" but was: \" + properties.get(property[0]));\r\n         }\r\n-\r\n-\r\n     }\r\n \r\n     public <A extends Annotation> A getAnnotation(Class<A> annotationType){\r\n@@ -182,7 +185,7 @@ public class MessageHandler {\n         return priority;\r\n     }\r\n \r\n-    public Method getHandler() {\r\n+    public Method getMethod() {\r\n         return handler;\r\n     }\r\n \r\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 7,
            "deletions": 14
        },
        "diff content": "@@ -36,35 +36,28 @@ public class Subscription {\n     }\n \n     /**\n-     * Check whether this subscription manages a message handler of the given message listener class\n-     *\n-     * @param listener\n-     * @return\n+     * Check whether this subscription manages a message handler of the given listener class.\n      */\n     public boolean belongsTo(Class listener){\n-        return context.getHandlerMetadata().isFromListener(listener);\n+        return context.getHandler().isFromListener(listener);\n     }\n \n     /**\n-     * Check whether this subscriptions manages the given listener instance\n-     * @param listener\n-     * @return\n+     * Check whether this subscriptions manages the given listener instance.\n      */\n     public boolean contains(Object listener){\n         return listeners.contains(listener);\n     }\n \n     /**\n-     * Check whether this subscription manages a message handler\n-     * @param messageType\n-     * @return\n+     * Check whether this subscription manages a specific message type.\n      */\n     public boolean handlesMessageType(Class<?> messageType) {\n-        return context.getHandlerMetadata().handlesMessage(messageType);\n+        return context.getHandler().handlesMessage(messageType);\n     }\n \n     public Class[] getHandledMessageTypes(){\n-        return context.getHandlerMetadata().getHandledMessages();\n+        return context.getHandler().getHandledMessages();\n     }\n \n \n@@ -74,7 +67,7 @@ public class Subscription {\n     }\n \n     public int getPriority() {\n-        return context.getHandlerMetadata().getPriority();\n+        return context.getHandler().getPriority();\n     }\n \n \n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java",
            "additions": 7,
            "deletions": 10
        },
        "diff content": "@@ -19,33 +19,30 @@ import java.util.Collection;\n public class SubscriptionContext implements RuntimeProvider {\n \n     // the handler's metadata -> for each handler in a listener, a unique subscription context is created\n-    private final MessageHandler handlerMetadata;\n+    private final MessageHandler handler;\n \n     // error handling is first-class functionality\n     private final Collection<IPublicationErrorHandler> errorHandlers;\n \n-    private BusRuntime runtime;\n+    private final BusRuntime runtime;\n \n-    public SubscriptionContext(BusRuntime runtime, MessageHandler handlerMetadata,\n-                               Collection<IPublicationErrorHandler> errorHandlers) {\n+    public SubscriptionContext(final BusRuntime runtime, final MessageHandler handler,\n+                               final Collection<IPublicationErrorHandler> errorHandlers) {\n         this.runtime = runtime;\n-        this.handlerMetadata = handlerMetadata;\n+        this.handler = handler;\n         this.errorHandlers = errorHandlers;\n     }\n \n     /**\n      * Get the meta data that specifies the characteristics of the message handler\n      * that is associated with this context\n-     *\n-     * @return\n      */\n-    public MessageHandler getHandlerMetadata() {\n-        return handlerMetadata;\n+    public MessageHandler getHandler() {\n+        return handler;\n     }\n \n     /**\n      * Get the error handlers registered with the enclosing bus.\n-     * @return\n      */\n     public Collection<IPublicationErrorHandler> getErrorHandlers(){\n         return errorHandlers;\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java",
            "additions": 7,
            "deletions": 6
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.subscription;\n \n import net.engio.mbassy.bus.BusRuntime;\n+import net.engio.mbassy.bus.common.Properties;\n import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n import net.engio.mbassy.bus.error.MessageBusException;\n import net.engio.mbassy.common.StrongConcurrentSet;\n@@ -20,7 +21,7 @@ public class SubscriptionFactory {\n \n     public Subscription createSubscription(BusRuntime runtime, MessageHandler handlerMetadata) throws MessageBusException{\n         try {\n-            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(BusRuntime.Properties.ErrorHandlers);\n+            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(Properties.Handler.PublicationError);\n             SubscriptionContext context = new SubscriptionContext(runtime, handlerMetadata, errorHandlers);\n             IHandlerInvocation invocation = buildInvocationForHandler(context);\n             IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n@@ -34,10 +35,10 @@ public class SubscriptionFactory {\n \n     protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {\n         IHandlerInvocation invocation = createBaseHandlerInvocation(context);\n-        if(context.getHandlerMetadata().isSynchronized()){\n+        if(context.getHandler().isSynchronized()){\n             invocation = new SynchronizedHandlerInvocation(invocation);\n         }\n-        if (context.getHandlerMetadata().isAsynchronous()) {\n+        if (context.getHandler().isAsynchronous()) {\n             invocation = new AsynchronousHandlerInvocation(invocation);\n         }\n         return invocation;\n@@ -45,17 +46,17 @@ public class SubscriptionFactory {\n \n     protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n         IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n-        if (context.getHandlerMetadata().isEnveloped()) {\n+        if (context.getHandler().isEnveloped()) {\n             dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n         }\n-        if (context.getHandlerMetadata().isFiltered()) {\n+        if (context.getHandler().isFiltered()) {\n             dispatcher = new FilteredMessageDispatcher(dispatcher);\n         }\n         return dispatcher;\n     }\n \n     protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws MessageBusException {\n-        Class<? extends HandlerInvocation> invocation = context.getHandlerMetadata().getHandlerInvocation();\n+        Class<? extends HandlerInvocation> invocation = context.getHandler().getHandlerInvocation();\n         if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){\n             throw new MessageBusException(\"The handler invocation must be top level class or nested STATIC inner class\");\n         }\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AllTests.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -13,7 +13,7 @@ import org.junit.runners.Suite;\n @Suite.SuiteClasses({\n         StrongConcurrentSetTest.class,\n         WeakConcurrentSetTest.class,\n-        MBassadorTest.class,\n+        SyncAsyncTest.class,\n         SyncBusTest.MBassadorTest.class,\n         SyncBusTest.SyncMessageBusTest.class,\n         FilterTest.class,\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConditionalHandlers.java",
            "additions": 5,
            "deletions": 5
        },
        "diff content": "@@ -93,7 +93,7 @@ public class ConditionalHandlers extends MessageBusTest {\n \t ************************************************************************/\n \t@Test\n \tpublic void testSimpleStringCondition() throws Exception {\n-\t\tMBassador bus = createBus(SyncAsync());\n+\t\tMBassador bus = createBus(SyncAsync(false));\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"TEST\", 0);\n@@ -109,7 +109,7 @@ public class ConditionalHandlers extends MessageBusTest {\n \t ************************************************************************/\n \t@Test\n \tpublic void testSimpleNumberCondition() throws Exception {\n-\t\tMBassador bus = new MBassador();\n+\t\tMBassador bus =  createBus(SyncAsync(false));\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"\", 5);\n@@ -124,7 +124,7 @@ public class ConditionalHandlers extends MessageBusTest {\n \t ************************************************************************/\n \t@Test\n \tpublic void testHandleCombinedEL() throws Exception {\n-\t\tMBassador bus = createBus(SyncAsync());\n+\t\tMBassador bus = createBus(SyncAsync(false));\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"\", 3);\n@@ -139,7 +139,7 @@ public class ConditionalHandlers extends MessageBusTest {\n \t ************************************************************************/\n \t@Test\n \tpublic void testNotMatchingAnyCondition() throws Exception {\n-\t\tMBassador bus = createBus(SyncAsync());\n+\t\tMBassador bus = createBus(SyncAsync(false));\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"\", 0);\n@@ -153,7 +153,7 @@ public class ConditionalHandlers extends MessageBusTest {\n \t ************************************************************************/\n \t@Test\n \tpublic void testHandleMethodAccessEL() throws Exception {\n-\t\tMBassador bus = createBus(SyncAsync());\n+\t\tMBassador bus = createBus(SyncAsync(false));\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"XYZ\", 1);\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/CustomHandlerAnnotationTest.java",
            "additions": 5,
            "deletions": 3
        },
        "diff content": "@@ -4,6 +4,7 @@ import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.listener.*;\n import net.engio.mbassy.subscription.MessageEnvelope;\n+import net.engio.mbassy.subscription.SubscriptionContext;\n import org.junit.Test;\n \n import java.lang.annotation.*;\n@@ -67,13 +68,14 @@ public class CustomHandlerAnnotationTest extends MessageBusTest\n \tpublic static class NamedMessageFilter implements IMessageFilter<NamedMessage>\n \t{\n \t\t@Override\n-\t\tpublic boolean accepts( NamedMessage message, MessageHandler metadata ) {\n-\t\t\tNamedMessageHandler namedMessageHandler = metadata.getAnnotation(NamedMessageHandler.class);\n+\t\tpublic boolean accepts( NamedMessage message,  SubscriptionContext context ) {\n+            MessageHandler handler = context.getHandler();\n+\t\t\tNamedMessageHandler namedMessageHandler = handler.getAnnotation(NamedMessageHandler.class);\n \t\t\tif ( namedMessageHandler != null ) {\n \t\t\t\treturn Arrays.asList( namedMessageHandler.value() ).contains( message.getName() );\n \t\t\t}\n \n-\t\t\tEnvelopedNamedMessageHandler envelopedHandler = metadata.getAnnotation(EnvelopedNamedMessageHandler.class);\n+\t\t\tEnvelopedNamedMessageHandler envelopedHandler = handler.getAnnotation(EnvelopedNamedMessageHandler.class);\n \t\t\treturn envelopedHandler != null && Arrays.asList( envelopedHandler.value() ).contains( message.getName() );\n \n \t\t}\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/FilterTest.java",
            "additions": 3,
            "deletions": 2
        },
        "diff content": "@@ -9,6 +9,7 @@ import net.engio.mbassy.common.TestUtil;\n import net.engio.mbassy.listener.*;\n import net.engio.mbassy.messages.SubTestMessage;\n import net.engio.mbassy.messages.TestMessage;\n+import net.engio.mbassy.subscription.SubscriptionContext;\n import org.junit.Test;\n \n import java.util.List;\n@@ -131,7 +132,7 @@ public class FilterTest extends MessageBusTest {\n     public static class RejectFilteredObjects implements IMessageFilter{\n \n         @Override\n-        public boolean accepts(Object message, MessageHandler metadata) {\n+        public boolean accepts(Object message, SubscriptionContext context) {\n             if(message.getClass().equals(FilteredMessage.class) && ((FilteredMessage)message).getMessage().getClass().equals(Object.class)){\n                 return false;\n             }\n@@ -142,7 +143,7 @@ public class FilterTest extends MessageBusTest {\n     public static final class RejectAll implements IMessageFilter {\n \n         @Override\n-        public boolean accepts(Object event, MessageHandler metadata) {\n+        public boolean accepts(Object event,  SubscriptionContext context) {\n             return false;\n         }\n     }\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 7,
            "deletions": 7
        },
        "diff content": "@@ -1,8 +1,8 @@\n package net.engio.mbassy;\n \n import net.engio.mbassy.bus.BusRuntime;\n+import net.engio.mbassy.bus.common.Properties;\n import net.engio.mbassy.common.*;\n-import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.listeners.*;\n import net.engio.mbassy.messages.*;\n@@ -214,8 +214,8 @@ public class SubscriptionManagerTest extends AssertSupport {\n \n     private BusRuntime mockedRuntime(){\n         return new BusRuntime(null)\n-                .add(BusRuntime.Properties.ErrorHandlers, Collections.EMPTY_SET)\n-                .add(BusRuntime.Properties.AsynchronousHandlerExecutor, null);\n+                .add(Properties.Handler.PublicationError, Collections.EMPTY_SET)\n+                .add(Properties.Handler.AsynchronousHandlerExecutor, null);\n     }\n \n     private ListenerFactory listeners(Class ...listeners){\n@@ -248,22 +248,22 @@ public class SubscriptionManagerTest extends AssertSupport {\n     public static class PrioritizedListener{\n \n \n-        @Handler(priority = 1)\n+        @net.engio.mbassy.listener.Handler(priority = 1)\n         public void handlePrio1(IMessage message){\n             message.handled(this.getClass());\n         }\n \n-        @Handler(priority = 2)\n+        @net.engio.mbassy.listener.Handler(priority = 2)\n         public void handlePrio2(IMessage message){\n             message.handled(this.getClass());\n         }\n \n-        @Handler(priority = 3)\n+        @net.engio.mbassy.listener.Handler(priority = 3)\n         public void handlePrio3(IMessage message){\n             message.handled(this.getClass());\n         }\n \n-        @Handler(priority = 4)\n+        @net.engio.mbassy.listener.Handler(priority = 4)\n         public void handlePrio4(IMessage message){\n             message.handled(this.getClass());\n         }\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncAsyncTest.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy;\n \n import net.engio.mbassy.bus.MBassador;\n-import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.common.Properties;\n import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.common.*;\n@@ -19,7 +19,7 @@ import java.util.concurrent.atomic.AtomicInteger;\n  * @author bennidi\n  *         Date: 2/8/12\n  */\n-public class MBassadorTest extends MessageBusTest {\n+public class SyncAsyncTest extends MessageBusTest {\n \n \n     @Test\n@@ -132,8 +132,8 @@ public class MBassadorTest extends MessageBusTest {\n             }\n         };\n \n-        final MBassador bus = new MBassador(SyncAsync());\n-        bus.addErrorHandler(ExceptionCounter);\n+        final MBassador bus = new MBassador(SyncAsync()\n+                .setProperty(Properties.Handler.PublicationError, ExceptionCounter));\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, ExceptionThrowingListener.class);\n         ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 29,
            "deletions": 18
        },
        "diff content": "@@ -1,8 +1,12 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.bus.BusFactory;\n import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.bus.SyncMessageBus;\n import net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\n+import net.engio.mbassy.bus.common.Properties;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.config.Feature;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.common.ConcurrentExecutor;\n@@ -17,7 +21,6 @@ import net.engio.mbassy.listeners.MessagesListener;\n import net.engio.mbassy.messages.MessageTypes;\n import net.engio.mbassy.messages.MultipartMessage;\n import net.engio.mbassy.messages.StandardMessage;\n-import org.junit.Assert;\n import org.junit.Test;\n \n import java.util.concurrent.atomic.AtomicInteger;\n@@ -31,12 +34,12 @@ import java.util.concurrent.atomic.AtomicInteger;\n public abstract class SyncBusTest extends MessageBusTest {\n \n \n-    protected abstract GenericMessagePublicationSupport getSyncMessageBus();\n+    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException);\n \n     @Test\n     public void testSynchronousMessagePublication() throws Exception {\n \n-        final GenericMessagePublicationSupport bus = getSyncMessageBus();\n+        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                 .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n@@ -87,7 +90,7 @@ public abstract class SyncBusTest extends MessageBusTest {\n             }\n         };\n \n-        final GenericMessagePublicationSupport bus = getSyncMessageBus();\n+        final GenericMessagePublicationSupport bus = getSyncMessageBus(false);\n         bus.addErrorHandler(ExceptionCounter);\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, ExceptionThrowingListener.class);\n@@ -113,7 +116,7 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n     @Test\n     public void testCustomHandlerInvocation(){\n-        final GenericMessagePublicationSupport bus = getSyncMessageBus();\n+        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, CustomInvocationListener.class)\n                 .create(InstancesPerListener, Object.class);\n@@ -147,7 +150,7 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n     @Test\n     public void testHandlerPriorities(){\n-        final GenericMessagePublicationSupport bus = getSyncMessageBus();\n+        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, PrioritizedListener.class)\n                 .create(InstancesPerListener, Object.class);\n@@ -157,9 +160,7 @@ public abstract class SyncBusTest extends MessageBusTest {\n         Runnable publishAndCheck = new Runnable() {\n             @Override\n             public void run() {\n-\n                 bus.post(new IncrementingMessage()).now();\n-\n             }\n         };\n \n@@ -176,8 +177,13 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n \n         @Override\n-        protected GenericMessagePublicationSupport getSyncMessageBus() {\n-            return new MBassador();\n+        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n+            IBusConfiguration asyncFIFOConfig = new BusConfiguration()\n+                    .setProperty(Properties.Handler.PublicationError, new AssertionErrorHandler(failOnException));\n+            asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n+            asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n+            asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n+            return new MBassador(asyncFIFOConfig);\n         }\n \n     }\n@@ -186,13 +192,18 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n \n         @Override\n-        protected GenericMessagePublicationSupport getSyncMessageBus() {\n-            return BusFactory.SynchronousOnly();\n+        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n+            IBusConfiguration syncPubSubCfg = new BusConfiguration()\n+                    .setProperty(Properties.Handler.PublicationError, new AssertionErrorHandler(failOnException));\n+            syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());\n+            return new SyncMessageBus(syncPubSubCfg);\n         }\n     }\n \n \n \n+\n+\n     static class IncrementingMessage{\n \n         private int count = 1;\n@@ -200,7 +211,7 @@ public abstract class SyncBusTest extends MessageBusTest {\n         public void markHandled(int newVal){\n             // only transitions by the next handler are allowed\n             if(count == newVal || count + 1 == newVal) count = newVal;\n-            else Assert.fail(\"Message was handled out of order\");\n+            else throw new RuntimeException(\"Message was handled out of order\");\n         }\n     }\n \n@@ -209,22 +220,22 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n         @Handler(priority = Integer.MIN_VALUE)\n         public void handle1(IncrementingMessage message) {\n-            message.markHandled(1);\n+            message.markHandled(4);\n         }\n \n         @Handler(priority = -2)\n         public void handle2(IncrementingMessage message) {\n-            message.markHandled(2);\n+            message.markHandled(3);\n         }\n \n         @Handler\n         public void handle3(IncrementingMessage message) {\n-            message.markHandled(3);\n+            message.markHandled(2);\n         }\n \n         @Handler(priority = Integer.MAX_VALUE)\n         public void handle4(IncrementingMessage message) {\n-            message.markHandled(4);\n+            message.markHandled(1);\n         }\n \n \n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -29,7 +29,7 @@ public class SynchronizedHandlerTest extends MessageBusTest {\n     @Test\n     public void testSynchronizedWithSynchronousInvocation(){\n         List<SynchronizedWithSynchronousDelivery> handlers = new LinkedList<SynchronizedWithSynchronousDelivery>();\n-        IBusConfiguration config = SyncAsync();\n+        IBusConfiguration config = SyncAsync(true);\n         config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                 .setNumberOfMessageDispatchers(6);\n         IMessageBus bus = createBus(config);\n@@ -57,7 +57,7 @@ public class SynchronizedHandlerTest extends MessageBusTest {\n     @Test\n     public void testSynchronizedWithAsSynchronousInvocation(){\n         List<SynchronizedWithAsynchronousDelivery> handlers = new LinkedList<SynchronizedWithAsynchronousDelivery>();\n-        IBusConfiguration config = SyncAsync();\n+        IBusConfiguration config = SyncAsync(true);\n         config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                 .setNumberOfMessageDispatchers(6);\n         IMessageBus bus = createBus(config);\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/ConcurrentExecutor.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -11,7 +11,7 @@ import java.util.concurrent.*;\n  * <p/>\n  * Date: 2/14/12\n  *\n- * @Author bennidi\n+ * @author bennidi\n  */\n public class ConcurrentExecutor {\n \n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/ListenerFactory.java",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -75,7 +75,6 @@ public class ListenerFactory {\n      *\n      * NOTE: Iterator is not perfectly synchronized with mutator methods of the list of generated listeners\n      * In theory, it is possible that the list is changed while iterators are still running which should be avoided.\n-     * @return\n      */\n     public Iterator iterator(){\n         getAll();\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 18,
            "deletions": 10
        },
        "diff content": "@@ -1,8 +1,7 @@\n package net.engio.mbassy.common;\n \n-import junit.framework.Assert;\n-import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.bus.IMessagePublication;\n+import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n@@ -28,14 +27,20 @@ public abstract class MessageBusTest extends AssertSupport {\n     protected static final int ConcurrentUnits = 10;\n     protected static final int IterationsPerThread = 100;\n \n-    protected static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n+    public static final class AssertionErrorHandler implements IPublicationErrorHandler{\n+\n+        private boolean failOnException;\n+\n+        public AssertionErrorHandler(boolean failOnException) {\n+            this.failOnException = failOnException;\n+        }\n+\n         @Override\n         public void handleError(PublicationError error) {\n-            error.getCause().printStackTrace();\n-            Assert.fail();\n+            if(failOnException)\n+                org.junit.Assert.fail(error.getCause().getMessage());\n         }\n-    };\n-\n+    }\n \n     private StrongConcurrentSet<IMessagePublication> issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n \n@@ -47,21 +52,24 @@ public abstract class MessageBusTest extends AssertSupport {\n     }\n \n     public static IBusConfiguration SyncAsync() {\n+        return SyncAsync(true);\n+    }\n+\n+    public static IBusConfiguration SyncAsync(boolean failOnError) {\n         return new BusConfiguration()\n             .addFeature(Feature.SyncPubSub.Default())\n             .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n-            .addFeature(Feature.AsynchronousMessageDispatch.Default());\n+            .addFeature(Feature.AsynchronousMessageDispatch.Default())\n+            .setProperty(net.engio.mbassy.bus.common.Properties.Handler.PublicationError, new AssertionErrorHandler(failOnError));\n     }\n \n     public MBassador createBus(IBusConfiguration configuration) {\n         MBassador bus = new MBassador(configuration);\n-        bus.addErrorHandler(TestFailingHandler);\n         return bus;\n     }\n \n     public MBassador createBus(IBusConfiguration configuration, ListenerFactory listeners) {\n         MBassador bus = new MBassador(configuration);\n-        bus.addErrorHandler(TestFailingHandler);\n         ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n         return bus;\n     }\n"
    },
    {
        "commit hash": "cebe1bab8d637c3b62c8414f7555ff8eea046abc",
        "previous commit hash": "f509bfe57ff348717ba3d7d4dc04359f659b1825",
        "diff stats": {
            "file_path": "testNTimes.sh",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,12 +1,12 @@\n #!/bin/bash\n for (( i = 1; i < $1 ; i++ ))\n do\n-  echo \"Attempt $i\"\n+  echo \"Round $i\"\n   mvn test -o -Dtest=$2\n   exitcode=$?\n   if [ $exitcode -ne 0 ]\n   then\n-    echo \"Error at attempt $i\"\n+    echo \"Error at round $i\"\n     exit\n   fi\n done\n"
    },
    {
        "commit hash": "7b3032877afb7ea1cf7bb00154b081cdda65d75c",
        "previous commit hash": "1bb957769ff180c687e843f7da8be4b6cc02b9e9",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MessagePublication.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -99,7 +99,7 @@ public class MessagePublication implements IMessagePublication {\n \n     public static class Factory {\n \n-        public MessagePublication createPublication(BusRuntime runtime, Collection<Subscription> subscriptions, Object message) {\n+        public IMessagePublication createPublication(BusRuntime runtime, Collection<Subscription> subscriptions, Object message) {\n             return new MessagePublication(runtime, subscriptions, message, State.Initial);\n         }\n \n"
    },
    {
        "commit hash": "1bb957769ff180c687e843f7da8be4b6cc02b9e9",
        "previous commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "diff stats": {
            "file_path": ".gitignore",
            "additions": 3,
            "deletions": 0
        },
        "diff content": "@@ -13,8 +13,11 @@\n # root of compiled classes #\n target/**/*\n target/**\n+classes/\n+\n \n # the local maven repository #\n+lib/\n mvn-local-repo/**/*\n release.properties\n /.classpath\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -38,7 +38,7 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n         // configure the pub sub feature\n         Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);\n         this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()\n-        \t\t.createManager(pubSubFeature.getMetadataReader(),\n+                .createManager(pubSubFeature.getMetadataReader(),\n                         pubSubFeature.getSubscriptionFactory(), runtime);\n         this.publicationFactory = pubSubFeature.getPublicationFactory();\n     }\n@@ -73,7 +73,7 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n         return runtime;\n     }\n \n-    protected MessagePublication createMessagePublication(T message) {\n+    protected IMessagePublication createMessagePublication(T message) {\n         Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n         if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass().equals(DeadMessage.class)) {\n             // Dead Event\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -29,7 +29,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n     private final List<Thread> dispatchers;\n \n     // all pending messages scheduled for asynchronous dispatch are queued here\n-    private final BlockingQueue<MessagePublication> pendingMessages;\n+    private final BlockingQueue<IMessagePublication> pendingMessages;\n \n     protected AbstractSyncAsyncMessageBus(IBusConfiguration configuration) {\n         super(configuration);\n@@ -55,7 +55,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n             Thread dispatcher = configuration.getDispatcherThreadFactory().newThread(new Runnable() {\n                 public void run() {\n                     while (true) {\n-                        MessagePublication publication = null;\n+                        IMessagePublication publication = null;\n                         try {\n                             publication = pendingMessages.take();\n                             publication.execute();\n@@ -76,7 +76,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n \n \n     // this method queues a message delivery request\n-    protected MessagePublication addAsynchronousPublication(MessagePublication publication) {\n+    protected IMessagePublication addAsynchronousPublication(IMessagePublication publication) {\n         try {\n             pendingMessages.put(publication);\n             return publication.markScheduled();\n@@ -87,7 +87,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n     }\n \n     // this method queues a message delivery request\n-    protected MessagePublication addAsynchronousPublication(MessagePublication publication, long timeout, TimeUnit unit) {\n+    protected IMessagePublication addAsynchronousPublication(IMessagePublication publication, long timeout, TimeUnit unit) {\n         try {\n             return pendingMessages.offer(publication, timeout, unit)\n                     ? publication.markScheduled()\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/IMessagePublication.java",
            "additions": 40,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,40 @@\n+package net.engio.mbassy.bus;\n+\n+import net.engio.mbassy.subscription.Subscription;\n+\n+/**\n+ * A message publication is created for each asynchronous message dispatch. It reflects the state\n+ * of the corresponding message publication process, i.e. provides information whether the\n+ * publication was successfully scheduled, is currently running etc.\n+ * <p/>\n+ * A message publication lives within a single thread. It is not designed in a thread-safe manner -> not eligible to\n+ * be used in multiple threads simultaneously .\n+ *\n+ * @author bennidi\n+ *         Date: 11/16/12\n+ */\n+public interface IMessagePublication {\n+\n+    public boolean add(Subscription subscription);\n+\n+    /*\n+    TODO: document state transitions\n+     */\n+    public void execute();\n+\n+    public boolean isFinished();\n+\n+    public boolean isRunning();\n+\n+    public boolean isScheduled();\n+\n+    public void markDelivered();\n+\n+    public IMessagePublication markScheduled();\n+\n+    public boolean isDeadEvent();\n+\n+    public boolean isFilteredEvent();\n+\n+    public Object getMessage();\n+}\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MBassador.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -24,11 +24,11 @@ public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCo\n     }\n \n \n-    public MessagePublication publishAsync(T message) {\n+    public IMessagePublication publishAsync(T message) {\n         return addAsynchronousPublication(createMessagePublication(message));\n     }\n \n-    public MessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n+    public IMessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n         return addAsynchronousPublication(createMessagePublication(message), timeout, unit);\n     }\n \n@@ -41,7 +41,7 @@ public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCo\n      */\n     public void publish(T message) {\n         try {\n-            MessagePublication publication = createMessagePublication(message);\n+            IMessagePublication publication = createMessagePublication(message);\n             publication.execute();\n         } catch (Throwable e) {\n             handlePublicationError(new PublicationError()\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MessagePublication.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -17,7 +17,7 @@ import java.util.Collection;\n  * @author bennidi\n  *         Date: 11/16/12\n  */\n-public class MessagePublication {\n+public class MessagePublication implements IMessagePublication {\n \n     private final Collection<Subscription> subscriptions;\n     private final Object message;\n@@ -40,7 +40,7 @@ public class MessagePublication {\n     /*\n     TODO: document state transitions\n      */\n-    protected void execute() {\n+    public void execute() {\n         state = State.Running;\n         for (Subscription sub : subscriptions) {\n            sub.publish(this, message);\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/SyncMessageBus.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -22,7 +22,7 @@ public class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements PubSu\n     @Override\n     public void publish(T message) {\n         try {\n-            MessagePublication publication = createMessagePublication(message);\n+            IMessagePublication publication = createMessagePublication(message);\n             publication.execute();\n         } catch (Throwable e) {\n             handlePublicationError(new PublicationError()\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/Feature.java",
            "additions": 5,
            "deletions": 4
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy.bus.config;\n \n+import net.engio.mbassy.bus.IMessagePublication;\n import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.subscription.ISubscriptionManagerProvider;\n@@ -132,12 +133,12 @@ public interface Feature {\n             return new AsynchronousMessageDispatch()\n                 .setNumberOfMessageDispatchers(2)\n                 .setDispatcherThreadFactory(MessageDispatchThreadFactory)\n-                .setMessageQueue(new LinkedBlockingQueue<MessagePublication>(Integer.MAX_VALUE));\n+                .setMessageQueue(new LinkedBlockingQueue<IMessagePublication>(Integer.MAX_VALUE));\n         }\n \n \n         private int numberOfMessageDispatchers;\n-        private BlockingQueue<MessagePublication> pendingMessages;\n+        private BlockingQueue<IMessagePublication> pendingMessages;\n         private ThreadFactory dispatcherThreadFactory;\n \n         public int getNumberOfMessageDispatchers() {\n@@ -149,11 +150,11 @@ public interface Feature {\n             return this;\n         }\n \n-        public BlockingQueue<MessagePublication> getPendingMessages() {\n+        public BlockingQueue<IMessagePublication> getPendingMessages() {\n             return pendingMessages;\n         }\n \n-        public AsynchronousMessageDispatch setMessageQueue(BlockingQueue<MessagePublication> pendingMessages) {\n+        public AsynchronousMessageDispatch setMessageQueue(BlockingQueue<IMessagePublication> pendingMessages) {\n             this.pendingMessages = pendingMessages;\n             return this;\n         }\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/error/PublicationError.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.bus.error;\n \n-import net.engio.mbassy.bus.MessagePublication;\n+import net.engio.mbassy.bus.IMessagePublication;\n \n import java.lang.reflect.Method;\n \n@@ -48,7 +48,7 @@ public class PublicationError{\n \n     public PublicationError(final Throwable cause,\n                             final String message,\n-                            final MessagePublication publication) {\n+                            final IMessagePublication publication) {\n         this.cause = cause;\n         this.message = message;\n         this.publishedObject = publication != null ? publication.getMessage() : null;\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/publication/ISyncAsyncPublicationCommand.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.bus.publication;\n \n-import net.engio.mbassy.bus.MessagePublication;\n+import net.engio.mbassy.bus.IMessagePublication;\n \n import java.util.concurrent.TimeUnit;\n \n@@ -19,7 +19,7 @@ public interface ISyncAsyncPublicationCommand extends IPublicationCommand {\n      *\n      * @return A message publication that can be used to access information about the state of\n      */\n-    MessagePublication asynchronously();\n+    IMessagePublication asynchronously();\n \n     /**\n      * Execute the message publication asynchronously. The behaviour of this method depends on the\n@@ -31,5 +31,5 @@ public interface ISyncAsyncPublicationCommand extends IPublicationCommand {\n      *\n      * @return A message publication that wraps up the publication request\n      */\n-    MessagePublication asynchronously(long timeout, TimeUnit unit);\n+    IMessagePublication asynchronously(long timeout, TimeUnit unit);\n }\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/publication/SyncAsyncPostCommand.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.bus.publication;\n \n import net.engio.mbassy.bus.MBassador;\n-import net.engio.mbassy.bus.MessagePublication;\n+import net.engio.mbassy.bus.IMessagePublication;\n \n import java.util.concurrent.TimeUnit;\n \n@@ -27,12 +27,12 @@ public class SyncAsyncPostCommand<T> implements ISyncAsyncPublicationCommand {\n     }\n \n     @Override\n-    public MessagePublication asynchronously() {\n+    public IMessagePublication asynchronously() {\n         return mBassador.publishAsync(message);\n     }\n \n     @Override\n-    public MessagePublication asynchronously(long timeout, TimeUnit unit) {\n+    public IMessagePublication asynchronously(long timeout, TimeUnit unit) {\n         return mBassador.publishAsync(message, timeout, unit);\n     }\n }\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.bus.MessagePublication;\n+import net.engio.mbassy.bus.IMessagePublication;\n import net.engio.mbassy.subscription.MessageEnvelope;\n \n /**\n@@ -20,7 +20,7 @@ public class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher {\n     }\n \n     @Override\n-    public void dispatch(MessagePublication publication, Object message, Iterable listeners){\n+    public void dispatch(IMessagePublication publication, Object message, Iterable listeners){\n         getDelegate().dispatch(publication, new MessageEnvelope(message), listeners);\n     }\n }\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.dispatch;\r\n \r\n-import net.engio.mbassy.bus.MessagePublication;\r\n+import net.engio.mbassy.bus.IMessagePublication;\r\n import net.engio.mbassy.listener.IMessageFilter;\r\n \r\n /**\r\n@@ -36,7 +36,7 @@ public final class FilteredMessageDispatcher extends DelegatingMessageDispatcher\n \r\n \r\n     @Override\r\n-    public void dispatch(MessagePublication publication, Object message, Iterable listeners){\r\n+    public void dispatch(IMessagePublication publication, Object message, Iterable listeners){\r\n         if (passesFilter(message)) {\r\n             getDelegate().dispatch(publication, message, listeners);\r\n         }\r\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.bus.MessagePublication;\n+import net.engio.mbassy.bus.IMessagePublication;\n import net.engio.mbassy.subscription.ISubscriptionContextAware;\n \n /**\n@@ -29,7 +29,7 @@ public interface IMessageDispatcher extends ISubscriptionContextAware {\n      * @param message     The message that should be delivered to the listeners\n      * @param listeners   The listeners that should receive the message\n      */\n-    void dispatch(MessagePublication publication, Object message, Iterable listeners);\n+    void dispatch(IMessagePublication publication, Object message, Iterable listeners);\n \n     /**\n      * Get the handler invocation that will be used to deliver the\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.bus.MessagePublication;\n+import net.engio.mbassy.bus.IMessagePublication;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n import net.engio.mbassy.subscription.SubscriptionContext;\n \n@@ -24,7 +24,7 @@ public class MessageDispatcher extends AbstractSubscriptionContextAware implemen\n     }\n \n     @Override\n-    public void dispatch(final MessagePublication publication, final Object message, final Iterable listeners){\n+    public void dispatch(final IMessagePublication publication, final Object message, final Iterable listeners){\n         publication.markDelivered();\n         for (Object listener : listeners) {\n             getInvocation().invoke(listener, message);\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.subscription;\n \n-import net.engio.mbassy.bus.MessagePublication;\n+import net.engio.mbassy.bus.IMessagePublication;\n import net.engio.mbassy.common.IConcurrentSet;\n import net.engio.mbassy.dispatch.IMessageDispatcher;\n \n@@ -68,7 +68,7 @@ public class Subscription {\n     }\n \n \n-    public void publish(MessagePublication publication, Object message){\n+    public void publish(IMessagePublication publication, Object message){\n         if(listeners.size() > 0)\n             dispatcher.dispatch(publication, message, listeners);\n     }\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.bus.MessagePublication;\n+import net.engio.mbassy.bus.IMessagePublication;\n import net.engio.mbassy.bus.common.IMessageBus;\n import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n@@ -39,7 +39,7 @@ public class SynchronizedHandlerTest extends MessageBusTest {\n             bus.subscribe(handler);\n         }\n \n-        MessagePublication publication = null;\n+        IMessagePublication publication = null;\n         for(int i = 0; i < numberOfMessages; i++){\n            publication =  bus.post(new Object()).asynchronously();\n         }\n"
    },
    {
        "commit hash": "2a51bb4378a8518c6191ae9440f5d4b4e6fbcc99",
        "previous commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 6,
            "deletions": 6
        },
        "diff content": "@@ -2,7 +2,7 @@ package net.engio.mbassy.common;\n \n import junit.framework.Assert;\n import net.engio.mbassy.bus.MBassador;\n-import net.engio.mbassy.bus.MessagePublication;\n+import net.engio.mbassy.bus.IMessagePublication;\n import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n@@ -37,11 +37,11 @@ public abstract class MessageBusTest extends AssertSupport {\n     };\n \n \n-    private StrongConcurrentSet<MessagePublication> issuedPublications = new StrongConcurrentSet<MessagePublication>();\n+    private StrongConcurrentSet<IMessagePublication> issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n \n     @Before\n     public void setUp(){\n-        issuedPublications = new StrongConcurrentSet<MessagePublication>();\n+        issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n         for(MessageTypes mes : MessageTypes.values())\n             mes.reset();\n     }\n@@ -66,14 +66,14 @@ public abstract class MessageBusTest extends AssertSupport {\n         return bus;\n     }\n \n-    protected void track(MessagePublication asynchronously) {\n+    protected void track(IMessagePublication asynchronously) {\n         issuedPublications.add(asynchronously);\n     }\n \n     public void waitForPublications(long timeOutInMs){\n         long start = System.currentTimeMillis();\n         while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){\n-            for(MessagePublication pub : issuedPublications){\n+            for(IMessagePublication pub : issuedPublications){\n                 if(pub.isFinished())\n                     issuedPublications.remove(pub);\n             }\n@@ -82,7 +82,7 @@ public abstract class MessageBusTest extends AssertSupport {\n             fail(\"Issued publications did not finish within specified timeout of \" + timeOutInMs + \" ms\");\n     }\n \n-    public void addPublication(MessagePublication publication){\n+    public void addPublication(IMessagePublication publication){\n         issuedPublications.add(publication);\n     }\n \n"
    },
    {
        "commit hash": "fd1ca55f58d991e9e7c3f55af3a767c1c39dc66c",
        "previous commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -161,7 +161,8 @@ You can also download binary release and javadoc from the [maven central reposit\n There is ongoing effort to extend documentation and provide code samples and detailed explanations of how the message bus works. Code samples can also be found in the various test cases. Please read about the terminology used in this project to avoid confusion and misunderstanding.\n \n <h2>Release Notes</h2>\n-<h3>1.2.1</h3>\n+<h3>[1.2.1](milestones/1.2.1)</h3>\n+ + Not yet released!\n  + API-Changes: \n    + Removed deprecated method BusConfiguration.SyncAsync() -> use MBassador default constructor instead\n    + Deleted interface ISyncMessageBus since it was merely an aggregation of existing interfaces -> replace with GenericMessagePublicationSupport\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "README.md",
            "additions": 8,
            "deletions": 4
        },
        "diff content": "@@ -127,7 +127,7 @@ Creation of message bus and registration of listeners:\n \n         // create as many instances as necessary\n         // bind it to any upper bound\n-        MBassador<TestMessage> bus = new MBassador<TestMessage>(BusConfiguration.SyncAsync());\n+        MBassador<TestMessage> bus = new MBassador<TestMessage>();\n         ListeningBean listener = new ListeningBean();\n         // the listener will be registered using a weak-reference if not configured otherwise with @Listener\n         bus.subscribe(listener);\n@@ -161,15 +161,19 @@ You can also download binary release and javadoc from the [maven central reposit\n There is ongoing effort to extend documentation and provide code samples and detailed explanations of how the message bus works. Code samples can also be found in the various test cases. Please read about the terminology used in this project to avoid confusion and misunderstanding.\n \n <h2>Release Notes</h2>\n+<h3>1.2.1</h3>\n+ + API-Changes: \n+   + Removed deprecated method BusConfiguration.SyncAsync() -> use MBassador default constructor instead\n+   + Deleted interface ISyncMessageBus since it was merely an aggregation of existing interfaces -> replace with GenericMessagePublicationSupport\n \n <h3>1.2.0</h3>\n  + Added support for conditional handlers using Java EL. Thanks to Bernd Rosstauscher\n  for the initial implementation.\n  + BREAKING CHANGES in BusConfiguration\n- ++ Complete redesign of configuration setup using Features instead of simple get/set parameters. This will allow\n+   + Complete redesign of configuration setup using Features instead of simple get/set parameters. This will allow\n  to flexibly combine features and still be able to exclude those not available in certain environments,for example, threading and reflection in GWT (this will be part of future releases)\n- ++ Properties formerly located in BusConfiguration now moved to their respective Feature class\n- ++ Removed all SyncXX related interfaces and config implementations. There is now only one `BusConfiguration`\n+   + Properties formerly located in BusConfiguration now moved to their respective Feature class\n+   + Removed all SyncXX related interfaces and config implementations. There is now only one `BusConfiguration`\n  with its corresponding interface which will be used for all types of message bus implementations\n \n \n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -84,7 +84,8 @@\n         <dependency>\n         \t<groupId>javax.el</groupId>\n         \t<artifactId>el-api</artifactId>\n-        \t<version>2.2</version>\n+        \t<scope>provided</scope>\n+            <version>2.2</version>\n         </dependency>\n         <dependency>\n         \t<groupId>de.odysseus.juel</groupId>\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/BusFactory.java",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,6 @@\n package net.engio.mbassy.bus;\n \n import net.engio.mbassy.bus.common.IMessageBus;\n-import net.engio.mbassy.bus.common.ISyncMessageBus;\n import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.bus.config.Feature;\n \n@@ -20,7 +19,7 @@ public class BusFactory {\n      *\n      * @return\n      */\n-    public static ISyncMessageBus SynchronousOnly(){\n+    public static SyncMessageBus SynchronousOnly(){\n         BusConfiguration syncPubSubCfg = new BusConfiguration();\n         syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());\n         return new SyncMessageBus(syncPubSubCfg);\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MBassador.java",
            "additions": 9,
            "deletions": 0
        },
        "diff content": "@@ -1,6 +1,8 @@\n package net.engio.mbassy.bus;\n \n import net.engio.mbassy.bus.common.IMessageBus;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.bus.publication.SyncAsyncPostCommand;\n@@ -14,6 +16,13 @@ public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCo\n         super(configuration);\n     }\n \n+    public MBassador(){\n+        super(new BusConfiguration()\n+            .addFeature(Feature.SyncPubSub.Default())\n+            .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n+            .addFeature(Feature.AsynchronousMessageDispatch.Default()));\n+    }\n+\n \n     public MessagePublication publishAsync(T message) {\n         return addAsynchronousPublication(createMessagePublication(message));\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/SyncMessageBus.java",
            "additions": 4,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,8 @@\n package net.engio.mbassy.bus;\n \n-import net.engio.mbassy.bus.common.ISyncMessageBus;\n+import net.engio.mbassy.bus.common.ErrorHandlingSupport;\n+import net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\n+import net.engio.mbassy.bus.common.PubSubSupport;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.bus.publication.IPublicationCommand;\n@@ -10,7 +12,7 @@ import net.engio.mbassy.bus.publication.IPublicationCommand;\n  * will not create any new threads.\n  *\n  */\n-public class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements ISyncMessageBus<T, SyncMessageBus.SyncPostCommand> {\n+public class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements PubSubSupport<T>, ErrorHandlingSupport, GenericMessagePublicationSupport<T, SyncMessageBus.SyncPostCommand>{\n \n \n     public SyncMessageBus(IBusConfiguration configuration) {\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/GenericMessagePublicationSupport.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@ import net.engio.mbassy.bus.publication.IPublicationCommand;\n  * The parametrization of the IPostCommand influences which publication flavours are available.\n  *\n  */\n-public interface GenericMessagePublicationSupport<T, P extends IPublicationCommand> {\n+public interface GenericMessagePublicationSupport<T, P extends IPublicationCommand> extends PubSubSupport<T>, ErrorHandlingSupport{\n \n     /**\n      * Publish a message to the bus using on of its supported message publication mechanisms. The supported\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/IMessageBus.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -58,7 +58,7 @@ import java.util.concurrent.Executor;\n  * Date: 2/8/12\n  */\n public interface IMessageBus<T, P extends ISyncAsyncPublicationCommand>\n-        extends PubSubSupport<T>, ErrorHandlingSupport, GenericMessagePublicationSupport<T, P>, ISyncMessageBus<T,P> {\n+        extends GenericMessagePublicationSupport<T, P>{\n \n     /**\n      * {@inheritDoc}\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java",
            "additions": 1,
            "deletions": 19
        },
        "diff content": "@@ -8,24 +8,6 @@ import java.util.Map;\n  */\n public class BusConfiguration implements IBusConfiguration {\n \n-    /**\n-     * Creates a new instance, using the default settings of 2 dispatchers, and\n-     * asynchronous handlers with an initial count equal to the number of\n-     * available processors in the machine, with maximum count equal to\n-     * 2 * the number of available processors. Uses {@link Runtime#availableProcessors()} to\n-     * determine the number of available processors\n-     *\n-     * @deprecated Use feature driven configuration instead\n-     **/\n-    @Deprecated()\n-    public static BusConfiguration SyncAsync() {\n-        BusConfiguration defaultConfig = new BusConfiguration();\n-        defaultConfig.addFeature(Feature.SyncPubSub.Default());\n-        defaultConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default());\n-        defaultConfig.addFeature(Feature.AsynchronousMessageDispatch.Default());\n-        return defaultConfig;\n-    }\n-\n     // the registered features\n     private Map<Class<? extends Feature>, Feature> features = new HashMap<Class<? extends Feature>, Feature>();\n \n@@ -46,6 +28,6 @@ public class BusConfiguration implements IBusConfiguration {\n \n     @Override\n     public IBusConfiguration addErrorHandler(ConfigurationErrorHandler handler) {\n-        return null;  //To change body of implemented methods use File | Settings | File Templates.\n+        return null;  // TODO: implement configuration validation\n     }\n }\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ReflectionUtils.java",
            "additions": 28,
            "deletions": 23
        },
        "diff content": "@@ -56,7 +56,14 @@ public class ReflectionUtils\n \t\treturn null;\n \t}\n \n-\tpublic static Set<Class> getSuperclasses( Class from ) {\n+    /**\n+     * Collect all directly and indirectly related super types (classes and interfaces) of\n+     * a given class.\n+     *\n+     * @param from The root class to start with\n+     * @return A set of classes, each representing a super type of the root class\n+     */\n+\tpublic static Set<Class> getSuperTypes(Class from) {\n \t\tSet<Class> superclasses = new HashSet<Class>();\n \t\tcollectInterfaces( from, superclasses );\n \t\twhile ( !from.equals( Object.class ) && !from.isInterface() ) {\n@@ -83,43 +90,41 @@ public class ReflectionUtils\n \t\treturn false;\n \t}\n \n-\tpublic static <A extends Annotation> A getAnnotation( Method method, Class<A> annotationType ) {\n-\t\treturn getAnnotation( (AnnotatedElement) method, annotationType );\n-\t}\n \n-\tpublic static <A extends Annotation> A getAnnotation( Class from, Class<A> annotationType ) {\n-\t\treturn getAnnotation( (AnnotatedElement) from, annotationType );\n-\t}\n \n \t/**\n \t * Searches for an Annotation of the given type on the class.  Supports meta annotations.\n \t *\n \t * @param from AnnotatedElement (class, method...)\n \t * @param annotationType Annotation class to look for.\n-\t * @param <A> Annotation class\n+\t * @param <A> Class of annotation type\n \t * @return Annotation instance or null\n \t */\n-\tpublic static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType ) {\n-\t\tA ann = from.getAnnotation( annotationType );\n-\t\tif ( ann == null ) {\n-\t\t\tfor ( Annotation metaAnn : from.getAnnotations() ) {\n-\t\t\t\tann = metaAnn.annotationType().getAnnotation( annotationType );\n-\t\t\t\tif ( ann != null ) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn ann;\n+\tprivate static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType, Set<AnnotatedElement> visited) {\n+\t\tif( visited.contains(from) ) return null;\n+        visited.add(from);\n+        A ann = from.getAnnotation( annotationType );\n+        if( ann != null) return ann;\n+        for ( Annotation metaAnn : from.getAnnotations() ) {\n+            ann = getAnnotation(metaAnn.annotationType(), annotationType, visited);\n+            if ( ann != null ) {\n+                return ann;\n+            }\n+        }\n+        return null;\n \t}\n \n+    public static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType){\n+       return getAnnotation(from, annotationType, new HashSet<AnnotatedElement>());\n+    }\n+\n \tprivate static boolean isOverriddenBy( Method superclassMethod, Method subclassMethod ) {\n \t\t// if the declaring classes are the same or the subclass method is not defined in the subclass\n \t\t// hierarchy of the given superclass method or the method names are not the same then\n \t\t// subclassMethod does not override superclassMethod\n-\t\tif ( superclassMethod.getDeclaringClass().equals(\n-\t\t\t\tsubclassMethod.getDeclaringClass() ) || !superclassMethod.getDeclaringClass().isAssignableFrom(\n-\t\t\t\tsubclassMethod.getDeclaringClass() ) || !superclassMethod.getName().equals(\n-\t\t\t\tsubclassMethod.getName() ) ) {\n+\t\tif ( superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass() )\n+                || !superclassMethod.getDeclaringClass().isAssignableFrom( subclassMethod.getDeclaringClass() )\n+                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n \t\t\treturn false;\n \t\t}\n \n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandler.java",
            "additions": 7,
            "deletions": 2
        },
        "diff content": "@@ -4,6 +4,7 @@ import net.engio.mbassy.common.ReflectionUtils;\n import net.engio.mbassy.dispatch.HandlerInvocation;\r\n import net.engio.mbassy.dispatch.el.ElFilter;\r\n \r\n+import java.lang.annotation.Annotation;\r\n import java.lang.reflect.Method;\r\n import java.util.HashMap;\r\n import java.util.Map;\r\n@@ -49,7 +50,7 @@ public class MessageHandler {\n             if(filter == null){\r\n                 filter = new IMessageFilter[]{};\r\n             }\r\n-            net.engio.mbassy.listener.Enveloped enveloped = ReflectionUtils.getAnnotation( handler, Enveloped.class );\r\n+            Enveloped enveloped = ReflectionUtils.getAnnotation( handler, Enveloped.class );\r\n             Class[] handledMessages = enveloped != null\r\n                     ? enveloped.messages()\r\n                     : handler.getParameterTypes();\r\n@@ -96,7 +97,7 @@ public class MessageHandler {\n \r\n     private final IMessageFilter[] filter;\r\n \r\n-\tprivate String condition;\r\n+\tprivate final String condition;\r\n     \r\n     private final int priority;\r\n \r\n@@ -153,6 +154,10 @@ public class MessageHandler {\n \r\n     }\r\n \r\n+    public <A extends Annotation> A getAnnotation(Class<A> annotationType){\r\n+        return ReflectionUtils.getAnnotation(handler,annotationType);\r\n+    }\r\n+\r\n     public boolean isSynchronized(){\r\n         return isSynchronized;\r\n     }\r\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -165,7 +165,7 @@ public class SubscriptionManager {\n             if (subscriptionsPerMessage.get(messageType) != null) {\n \t            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n             }\n-            for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n+            for (Class eventSuperType : ReflectionUtils.getSuperTypes(messageType)) {\n                 Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n                 if (subs != null) {\n                     for (Subscription sub : subs) {\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConditionalHandlers.java",
            "additions": 5,
            "deletions": 6
        },
        "diff content": "@@ -1,7 +1,6 @@\n package net.engio.mbassy;\n \n import net.engio.mbassy.bus.MBassador;\n-import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.listener.Enveloped;\n import net.engio.mbassy.listener.Handler;\n@@ -94,7 +93,7 @@ public class ConditionalHandlers extends MessageBusTest {\n \t ************************************************************************/\n \t@Test\n \tpublic void testSimpleStringCondition() throws Exception {\n-\t\tMBassador bus = getBus(BusConfiguration.SyncAsync());\n+\t\tMBassador bus = createBus(SyncAsync());\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"TEST\", 0);\n@@ -110,7 +109,7 @@ public class ConditionalHandlers extends MessageBusTest {\n \t ************************************************************************/\n \t@Test\n \tpublic void testSimpleNumberCondition() throws Exception {\n-\t\tMBassador bus = getBus(BusConfiguration.SyncAsync());\n+\t\tMBassador bus = new MBassador();\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"\", 5);\n@@ -125,7 +124,7 @@ public class ConditionalHandlers extends MessageBusTest {\n \t ************************************************************************/\n \t@Test\n \tpublic void testHandleCombinedEL() throws Exception {\n-\t\tMBassador bus = getBus(BusConfiguration.SyncAsync());\n+\t\tMBassador bus = createBus(SyncAsync());\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"\", 3);\n@@ -140,7 +139,7 @@ public class ConditionalHandlers extends MessageBusTest {\n \t ************************************************************************/\n \t@Test\n \tpublic void testNotMatchingAnyCondition() throws Exception {\n-\t\tMBassador bus = getBus(BusConfiguration.SyncAsync());\n+\t\tMBassador bus = createBus(SyncAsync());\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"\", 0);\n@@ -154,7 +153,7 @@ public class ConditionalHandlers extends MessageBusTest {\n \t ************************************************************************/\n \t@Test\n \tpublic void testHandleMethodAccessEL() throws Exception {\n-\t\tMBassador bus = getBus(BusConfiguration.SyncAsync());\n+\t\tMBassador bus = createBus(SyncAsync());\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"XYZ\", 1);\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/CustomHandlerAnnotationTest.java",
            "additions": 19,
            "deletions": 15
        },
        "diff content": "@@ -1,9 +1,7 @@\n package net.engio.mbassy;\n \n import net.engio.mbassy.bus.MBassador;\n-import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.common.MessageBusTest;\n-import net.engio.mbassy.common.ReflectionUtils;\n import net.engio.mbassy.listener.*;\n import net.engio.mbassy.subscription.MessageEnvelope;\n import org.junit.Test;\n@@ -35,6 +33,17 @@ public class CustomHandlerAnnotationTest extends MessageBusTest\n \t\tString[] value();\n \t}\n \n+    /**\n+     * Handler annotation that adds a default filter on the NamedMessage.\n+     * Enveloped is in no way required, but simply added to test a meta enveloped annotation.\n+     */\n+    @Retention(value = RetentionPolicy.RUNTIME)\n+    @Inherited\n+    @NamedMessageHandler(\"messageThree\")\n+    static @interface MessageThree {}\n+\n+\n+\n \t/**\n \t * Test enveloped meta annotation.\n \t */\n@@ -59,16 +68,12 @@ public class CustomHandlerAnnotationTest extends MessageBusTest\n \t{\n \t\t@Override\n \t\tpublic boolean accepts( NamedMessage message, MessageHandler metadata ) {\n-\t\t\tNamedMessageHandler namedMessageHandler =\n-\t\t\t\t\tReflectionUtils.getAnnotation( metadata.getHandler(), NamedMessageHandler.class );\n-\n+\t\t\tNamedMessageHandler namedMessageHandler = metadata.getAnnotation(NamedMessageHandler.class);\n \t\t\tif ( namedMessageHandler != null ) {\n \t\t\t\treturn Arrays.asList( namedMessageHandler.value() ).contains( message.getName() );\n \t\t\t}\n \n-\t\t\tEnvelopedNamedMessageHandler envelopedHandler =\n-\t\t\t\t\tReflectionUtils.getAnnotation( metadata.getHandler(), EnvelopedNamedMessageHandler.class );\n-\n+\t\t\tEnvelopedNamedMessageHandler envelopedHandler = metadata.getAnnotation(EnvelopedNamedMessageHandler.class);\n \t\t\treturn envelopedHandler != null && Arrays.asList( envelopedHandler.value() ).contains( message.getName() );\n \n \t\t}\n@@ -103,7 +108,7 @@ public class CustomHandlerAnnotationTest extends MessageBusTest\n \t\t\thandledByTwo.add( (NamedMessage) envelope.getMessage() );\n \t\t}\n \n-\t\t@NamedMessageHandler(\"messageThree\")\n+\t\t@MessageThree\n \t\tvoid handlerThree( NamedMessage message ) {\n \t\t\thandledByThree.add( message );\n \t\t}\n@@ -111,7 +116,7 @@ public class CustomHandlerAnnotationTest extends MessageBusTest\n \n \t@Test\n \tpublic void testMetaHandlerFiltering() {\n-\t\tMBassador bus = getBus( BusConfiguration.SyncAsync() );\n+\t\tMBassador bus = createBus(SyncAsync());\n \n \t\tNamedMessageListener listener = new NamedMessageListener();\n \t\tbus.subscribe( listener );\n@@ -124,16 +129,15 @@ public class CustomHandlerAnnotationTest extends MessageBusTest\n \t\tbus.publish( messageTwo );\n \t\tbus.publish( messageThree );\n \n+        assertEquals(2, listener.handledByOne.size());\n \t\tassertTrue( listener.handledByOne.contains( messageOne ) );\n-\t\tassertTrue( listener.handledByOne.contains( messageTwo ) );\n-\t\tassertFalse( listener.handledByOne.contains( messageThree ) );\n+\t\tassertTrue(listener.handledByOne.contains(messageTwo));\n \n-\t\tassertFalse( listener.handledByTwo.contains( messageOne ) );\n+        assertEquals(2, listener.handledByTwo.size());\n \t\tassertTrue( listener.handledByTwo.contains( messageTwo ) );\n \t\tassertTrue( listener.handledByTwo.contains( messageThree ) );\n \n-\t\tassertFalse( listener.handledByThree.contains( messageOne ) );\n-\t\tassertFalse( listener.handledByThree.contains( messageTwo ) );\n+        assertEquals(1, listener.handledByThree.size());\n \t\tassertTrue( listener.handledByThree.contains( messageThree ) );\n \t}\n }\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/DeadMessageTest.java",
            "additions": 2,
            "deletions": 3
        },
        "diff content": "@@ -2,7 +2,6 @@ package net.engio.mbassy;\n \n import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.bus.common.DeadMessage;\n-import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.common.ConcurrentExecutor;\n import net.engio.mbassy.common.ListenerFactory;\n import net.engio.mbassy.common.MessageBusTest;\n@@ -32,7 +31,7 @@ public class DeadMessageTest extends MessageBusTest{\n \n     @Test\n     public void testDeadMessage(){\n-        final MBassador bus = getBus(BusConfiguration.SyncAsync());\n+        final MBassador bus = createBus(SyncAsync());\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                 .create(InstancesPerListener, IMessageListener.AsyncListener.class)\n@@ -70,7 +69,7 @@ public class DeadMessageTest extends MessageBusTest{\n \n     @Test\n     public void testUnsubscribingAllListeners() {\n-        final MBassador bus = getBus(BusConfiguration.SyncAsync());\n+        final MBassador bus = createBus(SyncAsync());\n         ListenerFactory deadMessageListener = new ListenerFactory()\n                 .create(InstancesPerListener, DeadMessagHandler.class)\n                 .create(InstancesPerListener, Object.class);\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/FilterTest.java",
            "additions": 3,
            "deletions": 4
        },
        "diff content": "@@ -3,7 +3,6 @@ package net.engio.mbassy;\n import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.bus.common.DeadMessage;\n import net.engio.mbassy.bus.common.FilteredMessage;\n-import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.common.ListenerFactory;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.common.TestUtil;\n@@ -31,7 +30,7 @@ public class FilterTest extends MessageBusTest {\n         FilteredEventCounter.set(0);\n         DeadEventCounter.set(0);\n \n-        MBassador bus = getBus(BusConfiguration.SyncAsync());\n+        MBassador bus = createBus(SyncAsync());\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(100, FilteredMessageListener.class);\n \n@@ -56,7 +55,7 @@ public class FilterTest extends MessageBusTest {\n         FilteredEventCounter.set(0);\n         DeadEventCounter.set(0);\n \n-        MBassador bus = getBus(BusConfiguration.SyncAsync());\n+        MBassador bus = createBus(SyncAsync());\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(100, FilteredMessageListener.class);\n \n@@ -102,7 +101,7 @@ public class FilterTest extends MessageBusTest {\n \n     @Test\n     public void testSubtypesOnly(){\n-        MBassador bus = getBus(BusConfiguration.SyncAsync());\n+        MBassador bus = createBus(SyncAsync());\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(100, TestMessageHandler.class);\n \n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MBassadorTest.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -28,7 +28,7 @@ public class MBassadorTest extends MessageBusTest {\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, Listeners.synchronous())\n                 .create(InstancesPerListener, Listeners.noHandlers());\n-        final MBassador bus = getBus(BusConfiguration.SyncAsync(), listeners);\n+        final MBassador bus = createBus(SyncAsync(), listeners);\n \n \n         Runnable publishAndCheck = new Runnable() {\n@@ -62,7 +62,7 @@ public class MBassadorTest extends MessageBusTest {\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, Listeners.asynchronous())\n                 .create(InstancesPerListener, Listeners.noHandlers());\n-        final MBassador bus = getBus(BusConfiguration.SyncAsync(), listeners);\n+        final MBassador bus = createBus(SyncAsync(), listeners);\n \n         final MessageManager messageManager = new MessageManager();\n         Runnable publishAndCheck = new Runnable() {\n@@ -94,7 +94,7 @@ public class MBassadorTest extends MessageBusTest {\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, Listeners.asynchronous())\n                 .create(InstancesPerListener, Listeners.noHandlers());\n-        final MBassador bus = getBus(BusConfiguration.SyncAsync(), listeners);\n+        final MBassador bus = createBus(SyncAsync(), listeners);\n \n \n         final MessageManager messageManager = new MessageManager();\n@@ -132,7 +132,7 @@ public class MBassadorTest extends MessageBusTest {\n             }\n         };\n \n-        final MBassador bus = new MBassador(BusConfiguration.SyncAsync());\n+        final MBassador bus = new MBassador(SyncAsync());\n         bus.addErrorHandler(ExceptionCounter);\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, ExceptionThrowingListener.class);\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MethodDispatchTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -41,7 +41,7 @@ public class MethodDispatchTest extends MessageBusTest{\n \n     @Test\n     public void testDispatch1(){\n-        IMessageBus bus = getBus(BusConfiguration.SyncAsync());\n+        IMessageBus bus = createBus(SyncAsync());\n         EventListener2 listener2 = new EventListener2();\n         bus.subscribe(listener2);\n         bus.post(\"jfndf\").now();\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 9,
            "deletions": 10
        },
        "diff content": "@@ -2,8 +2,7 @@ package net.engio.mbassy;\n \n import net.engio.mbassy.bus.BusFactory;\n import net.engio.mbassy.bus.MBassador;\n-import net.engio.mbassy.bus.common.ISyncMessageBus;\n-import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\n import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.common.ConcurrentExecutor;\n@@ -32,12 +31,12 @@ import java.util.concurrent.atomic.AtomicInteger;\n public abstract class SyncBusTest extends MessageBusTest {\n \n \n-    protected abstract ISyncMessageBus getSyncMessageBus();\n+    protected abstract GenericMessagePublicationSupport getSyncMessageBus();\n \n     @Test\n     public void testSynchronousMessagePublication() throws Exception {\n \n-        final ISyncMessageBus bus = getSyncMessageBus();\n+        final GenericMessagePublicationSupport bus = getSyncMessageBus();\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                 .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n@@ -88,7 +87,7 @@ public abstract class SyncBusTest extends MessageBusTest {\n             }\n         };\n \n-        final ISyncMessageBus bus = getSyncMessageBus();\n+        final GenericMessagePublicationSupport bus = getSyncMessageBus();\n         bus.addErrorHandler(ExceptionCounter);\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, ExceptionThrowingListener.class);\n@@ -114,7 +113,7 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n     @Test\n     public void testCustomHandlerInvocation(){\n-        final ISyncMessageBus bus = getSyncMessageBus();\n+        final GenericMessagePublicationSupport bus = getSyncMessageBus();\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, CustomInvocationListener.class)\n                 .create(InstancesPerListener, Object.class);\n@@ -148,7 +147,7 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n     @Test\n     public void testHandlerPriorities(){\n-        final ISyncMessageBus bus = getSyncMessageBus();\n+        final GenericMessagePublicationSupport bus = getSyncMessageBus();\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, PrioritizedListener.class)\n                 .create(InstancesPerListener, Object.class);\n@@ -177,8 +176,8 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n \n         @Override\n-        protected ISyncMessageBus getSyncMessageBus() {\n-            return new MBassador(BusConfiguration.SyncAsync());\n+        protected GenericMessagePublicationSupport getSyncMessageBus() {\n+            return new MBassador();\n         }\n \n     }\n@@ -187,7 +186,7 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n \n         @Override\n-        protected ISyncMessageBus getSyncMessageBus() {\n+        protected GenericMessagePublicationSupport getSyncMessageBus() {\n             return BusFactory.SynchronousOnly();\n         }\n     }\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java",
            "additions": 7,
            "deletions": 7
        },
        "diff content": "@@ -2,7 +2,6 @@ package net.engio.mbassy;\n \n import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.bus.common.IMessageBus;\n-import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.common.MessageBusTest;\n@@ -30,10 +29,10 @@ public class SynchronizedHandlerTest extends MessageBusTest {\n     @Test\n     public void testSynchronizedWithSynchronousInvocation(){\n         List<SynchronizedWithSynchronousDelivery> handlers = new LinkedList<SynchronizedWithSynchronousDelivery>();\n-        IBusConfiguration config = BusConfiguration.SyncAsync();\n+        IBusConfiguration config = SyncAsync();\n         config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                 .setNumberOfMessageDispatchers(6);\n-        IMessageBus bus = getBus(config);\n+        IMessageBus bus = createBus(config);\n         for(int i = 0; i < numberOfListeners; i++){\n             SynchronizedWithSynchronousDelivery handler = new SynchronizedWithSynchronousDelivery();\n             handlers.add(handler);\n@@ -58,10 +57,10 @@ public class SynchronizedHandlerTest extends MessageBusTest {\n     @Test\n     public void testSynchronizedWithAsSynchronousInvocation(){\n         List<SynchronizedWithAsynchronousDelivery> handlers = new LinkedList<SynchronizedWithAsynchronousDelivery>();\n-        IBusConfiguration config = BusConfiguration.SyncAsync();\n+        IBusConfiguration config = SyncAsync();\n         config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                 .setNumberOfMessageDispatchers(6);\n-        IMessageBus bus = getBus(config);\n+        IMessageBus bus = createBus(config);\n         for(int i = 0; i < numberOfListeners; i++){\n             SynchronizedWithAsynchronousDelivery handler = new SynchronizedWithAsynchronousDelivery();\n             handlers.add(handler);\n@@ -69,10 +68,9 @@ public class SynchronizedHandlerTest extends MessageBusTest {\n         }\n \n         for(int i = 0; i < numberOfMessages; i++){\n-            bus.post(new Object()).asynchronously();\n+            track(bus.post(new Object()).asynchronously());\n         }\n \n-        // TODO: wait for publication to finish\n         pause(10000);\n \n         for(SynchronizedWithAsynchronousDelivery handler : handlers){\n@@ -81,6 +79,8 @@ public class SynchronizedHandlerTest extends MessageBusTest {\n \n     }\n \n+\n+\n     public static class SynchronizedWithSynchronousDelivery {\n \n         private int counter = 0;\n"
    },
    {
        "commit hash": "1ab19f84c9946a898115d96e222b56f2ae1d8192",
        "previous commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 16,
            "deletions": 2
        },
        "diff content": "@@ -3,6 +3,8 @@ package net.engio.mbassy.common;\n import junit.framework.Assert;\n import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.bus.MessagePublication;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n import net.engio.mbassy.bus.error.PublicationError;\n@@ -39,23 +41,35 @@ public abstract class MessageBusTest extends AssertSupport {\n \n     @Before\n     public void setUp(){\n+        issuedPublications = new StrongConcurrentSet<MessagePublication>();\n         for(MessageTypes mes : MessageTypes.values())\n             mes.reset();\n     }\n \n-    public MBassador getBus(IBusConfiguration configuration) {\n+    public static IBusConfiguration SyncAsync() {\n+        return new BusConfiguration()\n+            .addFeature(Feature.SyncPubSub.Default())\n+            .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n+            .addFeature(Feature.AsynchronousMessageDispatch.Default());\n+    }\n+\n+    public MBassador createBus(IBusConfiguration configuration) {\n         MBassador bus = new MBassador(configuration);\n         bus.addErrorHandler(TestFailingHandler);\n         return bus;\n     }\n \n-    public MBassador getBus(IBusConfiguration configuration, ListenerFactory listeners) {\n+    public MBassador createBus(IBusConfiguration configuration, ListenerFactory listeners) {\n         MBassador bus = new MBassador(configuration);\n         bus.addErrorHandler(TestFailingHandler);\n         ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n         return bus;\n     }\n \n+    protected void track(MessagePublication asynchronously) {\n+        issuedPublications.add(asynchronously);\n+    }\n+\n     public void waitForPublications(long timeOutInMs){\n         long start = System.currentTimeMillis();\n         while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){\n"
    },
    {
        "commit hash": "7cd5a71e797e9b4b0f7afec31d8e0cc07862c094",
        "previous commit hash": "85dc02c4e32e5e9a75ec5eb9dd5d30bada8da3a8",
        "diff stats": {
            "file_path": "README.md",
            "additions": 3,
            "deletions": 4
        },
        "diff content": "@@ -155,7 +155,7 @@ MBassador is available from the Maven Central Repository using the following coo\n     </dependency>\n ```\n \n-You can also download the latest binary release from the official [maven repository](http://mvnrepository.com/artifact/net.engio/mbassador). Of course you can always clone the repository and build from source.\n+You can also download binary release and javadoc from the [maven central repository](http://search.maven.org/#search|ga|1|mbassador). Of course you can always clone the repository and build from source.\n \n <h2>Wiki</h2>\n There is ongoing effort to extend documentation and provide code samples and detailed explanations of how the message bus works. Code samples can also be found in the various test cases. Please read about the terminology used in this project to avoid confusion and misunderstanding.\n@@ -279,10 +279,9 @@ provided an event bus system. The main reason it proved to be unusable for our s\n to the listeners such that every object has to be explicitly unsubscribed. This was difficult in our Spring managed environment.\n Finally, I decided to create a custom implementation, which then matured to be stable, extensible and yet very efficient.\n \n-I want to thank the development team from friendsurance (www.friendsurance.de) for their support and feedback on the bus\n-implementation and the management of friendsurance for allowing me to publish the component as an open source project.\n+I want to thank the development team from friendsurance (www.friendsurance.de) for their support and feedback on the bus implementation and the management of friendsurance for allowing me to publish the component as an open source project.\n \n-Many thanks also to ej-technologies for providing me with an open source license of [![JProfiler](http://www.ej-technologies.com/images/banners/jprofiler_small.png)](http://www.ej-technologies.com/products/jprofiler/overview.html)\n+Many thanks also to ej-technologies for providing me with an open source license of [![JProfiler](http://www.ej-technologies.com/images/banners/jprofiler_small.png)](http://www.ej-technologies.com/products/jprofiler/overview.html) and Jetbrains for a license of [IntelliJ IDEA](http://www.jetbrains.com/idea/)\n \n <h2>Contribute</h2>\n \n"
    },
    {
        "commit hash": "85dc02c4e32e5e9a75ec5eb9dd5d30bada8da3a8",
        "previous commit hash": "02cbeb9df17968d6a50adaceaad0c6cf404d7d96",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 0
        },
        "diff content": "@@ -282,6 +282,8 @@ Finally, I decided to create a custom implementation, which then matured to be s\n I want to thank the development team from friendsurance (www.friendsurance.de) for their support and feedback on the bus\n implementation and the management of friendsurance for allowing me to publish the component as an open source project.\n \n+Many thanks also to ej-technologies for providing me with an open source license of [![JProfiler](http://www.ej-technologies.com/images/banners/jprofiler_small.png)](http://www.ej-technologies.com/products/jprofiler/overview.html)\n+\n <h2>Contribute</h2>\n \n Any feature requests and feedback are more than welcome. You may suggest improvements either by submitting an\n"
    },
    {
        "commit hash": "02cbeb9df17968d6a50adaceaad0c6cf404d7d96",
        "previous commit hash": "3c9e234406fc23bcf2cd13979c775ebdc006a740",
        "diff stats": {
            "file_path": "README.md",
            "additions": 6,
            "deletions": 4
        },
        "diff content": "@@ -3,12 +3,12 @@ MBassador\n \n MBassador is a very light-weight message (event) bus implementation following the publish subscribe pattern. It is designed for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. The core of MBassador's high performance is a specialized data structure that minimizes lock contention such that performance degradation of concurrent access is minimal. The performance win of this design is illustrated in <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a> and more recently in the [eventbus-performance](https://github.com/bennidi/eventbus-performance) github repository.\n \n-Using MBassador in your project is very easy. Create as many instances of MBassador as you like (usually a singleton will do), mark and configure your message handlers with `@Handler` annotations and finally register the listeners at any MBassador instance. Start sending messages to your listeners using one of MBassador's publication methods (sync or async). Done!\n+Using MBassador in your project is very easy. Create as many instances of MBassador as you like (usually a singleton will do) ` bus = new MBassador(BusConfiguration.SyncAsync())`, mark and configure your message handlers with `@Handler` annotations and finally register the listeners at any MBassador instance `bus.subscribe(aListener)`. Start sending messages to your listeners using one of MBassador's publication methods `bus.post(message).now()` or `bus.post(message).asynchronously()`. Done!\n \n Read this documentation to get an overview of MBassadors features. There is also some documentation in the Wiki - although admittedly\n not enough to make a developer happy (work is in progress). Additionally, you can browse the [javadoc](http://bennidi.github.io/mbassador/)\n \n-There is also a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. It's beta but stable enough to give it a try.\n+There is a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. It's beta but stable enough to give it a try.\n \n Table of contents:\n + [Features](#features)\n@@ -38,7 +38,9 @@ Table of contents:\n \n Messages do not need to implement any interface and can be of any type. It is possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery, such that handlers will also receive subtypes of the message type they consume for - e.g. a handler of Object.class receives everything. Messages that do not match any handler result in the publication of a `DeadMessage` object which wraps the original message. DeadMessage events can be handled by registering listeners that handle DeadMessage.\n \n-> Synchronous and asynchronous message delivery|A handler can be invoked to handle a message either synchronously or asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch|\n+> Synchronous and asynchronous message delivery\n+\n+A handler can be invoked to handle a message either synchronously or asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch\n \n > Configurable reference types\n \n@@ -125,7 +127,7 @@ Creation of message bus and registration of listeners:\n \n         // create as many instances as necessary\n         // bind it to any upper bound\n-        MBassador<TestMessage> bus = new MBassador<TestMessage>(BusConfiguration.Default());\n+        MBassador<TestMessage> bus = new MBassador<TestMessage>(BusConfiguration.SyncAsync());\n         ListeningBean listener = new ListeningBean();\n         // the listener will be registered using a weak-reference if not configured otherwise with @Listener\n         bus.subscribe(listener);\n"
    },
    {
        "commit hash": "3c9e234406fc23bcf2cd13979c775ebdc006a740",
        "previous commit hash": "58630b1657ec3ba4cabf1ab3bacfbcc6c61d574c",
        "diff stats": {
            "file_path": "README.md",
            "additions": 39,
            "deletions": 22
        },
        "diff content": "@@ -1,9 +1,7 @@\n MBassador\n =========\n \n-MBassador is a very light-weight message (event) bus implementation following the publish subscribe pattern. It is designed\n-for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. The core of MBassador's\n-high performance is a specialized data structure that minimizes lock contention such that performance degradation of concurrent access is minimal. The performance win of this design is illustrated in <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a> and more recently in the [eventbus-performance](https://github.com/bennidi/eventbus-performance) github repository.\n+MBassador is a very light-weight message (event) bus implementation following the publish subscribe pattern. It is designed for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. The core of MBassador's high performance is a specialized data structure that minimizes lock contention such that performance degradation of concurrent access is minimal. The performance win of this design is illustrated in <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a> and more recently in the [eventbus-performance](https://github.com/bennidi/eventbus-performance) github repository.\n \n Using MBassador in your project is very easy. Create as many instances of MBassador as you like (usually a singleton will do), mark and configure your message handlers with `@Handler` annotations and finally register the listeners at any MBassador instance. Start sending messages to your listeners using one of MBassador's publication methods (sync or async). Done!\n \n@@ -26,24 +24,45 @@ Table of contents:\n \n <h2 name=\"features\">Features</h2>\n \n-| Feature | Description |\n-|:-------------:|:-----|\n-|Annotation driven|To define and customize a message handler simply mark it with @Handler annotation|\n-|Delivers everything|Messages do  not need to implement any interface and can be of any type. It is possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery, such that handlers will also receive subtypes of the message type they consume for, e.g. a handler of Object.class receives everything. Messages that do not match any handler result in the publication of a `DeadMessage` object which wraps the original message. DeadMessage events can be handled by registering listeners that handle DeadMessage.|\n-|Synchronous and asynchronous message delivery|A handler can be invoked to handle a message either synchronously or asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch|\n-|Weak references|By default, MBassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister listeners that are not used anymore (of course it is also possible to explicitly unregister a listener if needed). This is very comfortable in certain environments where listeners are managed by frameworks, i.e. Spring, Guice etc. Just stuff everything into the message bus, it will ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.|\n-|Strong references|Instead of using weak references, a listener can be configured to be referenced using strong references using @Listener|\n-|Filtering|MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to a single message handler. Since version 1.2.0 Java EL expressions in `@Handler` are another way to define conditional message dispatch. Messages that have matching handlers but do not pass the configured filters result in the publication of a FilteredMessage object which wraps the original message. FilteredMessage events can be handled by registering listeners that handle FilteredMessage.|\n-|Enveloped messages|Message handlers can declare to receive an enveloped message. The envelope can wrap different types of messages. This allows for a single handler to handle multiple, unrelated message types.|\n-|Handler priorities|A handler can be associated with a priority to influence the order in which messages are delivered when multiple matching handlers exist|\n-|Custom error handling|Errors during message delivery are sent to all registered error handlers which can be added to the bus as necessary.|\n-|DeadMessage event|\n-|FilteredMessage event|\n-|Synchronization|It is possible to ensure that a handler is invoked non-concurrently,i.e. making it thread-safe by adding @Synchronized|\n-|Extensibility|MBassador is designed to be extensible with custom implementations of various components like message dispatchers and handler invocations (using the decorator pattern), metadata reader (you can add your own annotations) and factories for different kinds of objects. A configuration object is used to customize the different configurable parts (Features)|\n \n+> Annotation driven\n \n+|Annotation|Function|\n+|:-----|:-----|\n+|`@Handler`|Defines and customizes a message handler. Any well-formed method annotated with `@Handler` will cause instances of the defining class to be treated as message listeners|\n+|`@Listener`|Can be used to customize listener wide configuration like the used reference type|\n+|`@Enveloped`|A message envelope can be used to pass messages of different types into a single handler|\n+|`@Filter`|Add filtering to prevent certain messages from being published|\n \n+> Delivers everything\n+\n+Messages do not need to implement any interface and can be of any type. It is possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery, such that handlers will also receive subtypes of the message type they consume for - e.g. a handler of Object.class receives everything. Messages that do not match any handler result in the publication of a `DeadMessage` object which wraps the original message. DeadMessage events can be handled by registering listeners that handle DeadMessage.\n+\n+> Synchronous and asynchronous message delivery|A handler can be invoked to handle a message either synchronously or asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch|\n+\n+> Configurable reference types\n+\n+By default, MBassador uses weak references for listeners to relieve the programmer of the need to explicitly unsubscribe listeners that are not used anymore and avoid memory-leaks. This is very comfortable in container managed environments where listeners are created and destroyed by frameworks, i.e. Spring, Guice etc. Just stuff everything into the message bus, it will ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job. Instead of using weak references, a listener can be configured to be referenced using strong references using `@Listener(references=References.Strong)`. Strongly referenced listeners will stick around until explicitly unsubscribed.\n+\n+> Filtering\n+\n+MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to a single message handler. Since version 1.2.0 Java EL expressions in `@Handler` are another way to define conditional message dispatch. Messages that have matching handlers but do not pass the configured filters result in the publication of a FilteredMessage object which wraps the original message. FilteredMessage events can be handled by registering listeners that handle FilteredMessage.\n+\n+> Enveloped messages\n+\n+Message handlers can declare to receive an enveloped message using `Enveloped`. The envelope can wrap different types of messages to allow a single handler to handle multiple, unrelated message types.\n+\n+> Handler priorities\n+\n+A handler can be associated with a priority to influence the order in which messages are delivered when multiple matching handlers exist\n+\n+> Custom error handling\n+\n+Errors during message delivery are sent to all registered error handlers which can be added to the bus as necessary.\n+\n+> Extensibility\n+\n+MBassador is designed to be extensible with custom implementations of various components like message dispatchers and handler invocations (using the decorator pattern), metadata reader (you can add your own annotations) and factories for different kinds of objects. A configuration object is used to customize the different configurable parts, see [Features](https://github.com/bennidi/mbassador/wiki/Components#Feature)\n \n \n <h2>Usage</h2>\n@@ -137,9 +156,7 @@ MBassador is available from the Maven Central Repository using the following coo\n You can also download the latest binary release from the official [maven repository](http://mvnrepository.com/artifact/net.engio/mbassador). Of course you can always clone the repository and build from source.\n \n <h2>Wiki</h2>\n-There is ongoing effort to extend documentation and provide code samples and detailed explanations of how the message bus\n-works. Code samples can also be found in the various test cases. Please read about the terminology used in this project\n-to avoid confusion and misunderstanding.\n+There is ongoing effort to extend documentation and provide code samples and detailed explanations of how the message bus works. Code samples can also be found in the various test cases. Please read about the terminology used in this project to avoid confusion and misunderstanding.\n \n <h2>Release Notes</h2>\n \n@@ -257,7 +274,7 @@ successful transaction commit etc.). Currently in beta, see <a href=\"https://git\n The initial inspiration for creating this component came from trying out Google Guava's event bus implementation.\n I liked the simplicity of its design and I do trust the developers at Google a lot, so I was happy to find that they also\n provided an event bus system. The main reason it proved to be unusable for our scenario was that it uses strong references\n-to the listeners such that every object has to be explicitly deregistered. This was difficult in our Spring managed environment.\n+to the listeners such that every object has to be explicitly unsubscribed. This was difficult in our Spring managed environment.\n Finally, I decided to create a custom implementation, which then matured to be stable, extensible and yet very efficient.\n \n I want to thank the development team from friendsurance (www.friendsurance.de) for their support and feedback on the bus\n"
    },
    {
        "commit hash": "3c9e234406fc23bcf2cd13979c775ebdc006a740",
        "previous commit hash": "58630b1657ec3ba4cabf1ab3bacfbcc6c61d574c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java",
            "additions": 3,
            "deletions": 2
        },
        "diff content": "@@ -84,6 +84,7 @@ public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n     @Override\n     public boolean remove(T element) {\n         if (!contains(element)) {\n+            // return quickly\n             return false;\n         } else {\n             Lock writeLock = lock.writeLock();\n@@ -91,12 +92,12 @@ public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n                 writeLock.lock();\n                 ISetEntry<T> listelement = entries.get(element);\n                 if (listelement == null) {\n-                    return false; //removed by other thread\n+                    return false; //removed by other thread in the meantime\n                 }\n                 if (listelement != head) {\n                     listelement.remove();\n                 } else {\n-                    ISetEntry<T> oldHead = head;\n+                    // if it was second, now it's first\n                     head = head.next();\n                     //oldHead.clear(); // optimize for GC not possible because of potentially running iterators\n                 }\n"
    },
    {
        "commit hash": "58630b1657ec3ba4cabf1ab3bacfbcc6c61d574c",
        "previous commit hash": "716ba7eaccc60f9a0c580febcac5964049ed5417",
        "diff stats": {
            "file_path": "README.md",
            "additions": 11,
            "deletions": 7
        },
        "diff content": "@@ -26,21 +26,19 @@ Table of contents:\n \n <h2 name=\"features\">Features</h2>\n \n-At its core MBassador offers the following features:\n-\n | Feature | Description |\n |:-------------:|:-----|\n |Annotation driven|To define and customize a message handler simply mark it with @Handler annotation|\n-|Delivers everything|Messages must not implement any interface and can be of any type. It is possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery, such that handlers will also receive subtypes of the message type they consume for, e.g. a handler of Object.class receives everything.|\n+|Delivers everything|Messages do  not need to implement any interface and can be of any type. It is possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery, such that handlers will also receive subtypes of the message type they consume for, e.g. a handler of Object.class receives everything. Messages that do not match any handler result in the publication of a `DeadMessage` object which wraps the original message. DeadMessage events can be handled by registering listeners that handle DeadMessage.|\n |Synchronous and asynchronous message delivery|A handler can be invoked to handle a message either synchronously or asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch|\n |Weak references|By default, MBassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister listeners that are not used anymore (of course it is also possible to explicitly unregister a listener if needed). This is very comfortable in certain environments where listeners are managed by frameworks, i.e. Spring, Guice etc. Just stuff everything into the message bus, it will ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.|\n |Strong references|Instead of using weak references, a listener can be configured to be referenced using strong references using @Listener|\n-|Filtering|MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to a single message handler|\n+|Filtering|MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to a single message handler. Since version 1.2.0 Java EL expressions in `@Handler` are another way to define conditional message dispatch. Messages that have matching handlers but do not pass the configured filters result in the publication of a FilteredMessage object which wraps the original message. FilteredMessage events can be handled by registering listeners that handle FilteredMessage.|\n |Enveloped messages|Message handlers can declare to receive an enveloped message. The envelope can wrap different types of messages. This allows for a single handler to handle multiple, unrelated message types.|\n |Handler priorities|A handler can be associated with a priority to influence the order in which messages are delivered when multiple matching handlers exist|\n |Custom error handling|Errors during message delivery are sent to all registered error handlers which can be added to the bus as necessary.|\n-|DeadMessage event|Messages that do not match any handler result in the publication of a DeadMessage object which wraps the original message. DeadMessage events can be handled by registering listeners that handle DeadMessage.|\n-|FilteredMessage event|Messages that have matching handlers but do not pass the configured filters result in the publication of a FilteredMessage object which wraps the original message.FilteredMessage events can be handled by registering listeners that handle FilteredMessage.|\n+|DeadMessage event|\n+|FilteredMessage event|\n |Synchronization|It is possible to ensure that a handler is invoked non-concurrently,i.e. making it thread-safe by adding @Synchronized|\n |Extensibility|MBassador is designed to be extensible with custom implementations of various components like message dispatchers and handler invocations (using the decorator pattern), metadata reader (you can add your own annotations) and factories for different kinds of objects. A configuration object is used to customize the different configurable parts (Features)|\n \n@@ -97,6 +95,12 @@ Handler definition (in any bean):\n \n         }\n \n+        // conditional handler using Java EL expressions\n+        @Handler(condition = \"msg.getType().equals('XYZ') && msg.getSize() == 1\")\n+        public void handleMethodAccessEL(TestEvent message) {\n+            message.handledBy(\"handleMethodAccessEL\");\n+        }\n+\n \n Creation of message bus and registration of listeners:\n \n@@ -126,7 +130,7 @@ MBassador is available from the Maven Central Repository using the following coo\n     <dependency>\n         <groupId>net.engio</groupId>\n         <artifactId>mbassador</artifactId>\n-        <version>1.1.11</version>\n+        <version>1.2.0</version>\n     </dependency>\n ```\n \n"
    },
    {
        "commit hash": "716ba7eaccc60f9a0c580febcac5964049ed5417",
        "previous commit hash": "b796ee7ba6ed8bb4a633087af7207b699501c4c5",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -29,7 +29,7 @@ Table of contents:\n At its core MBassador offers the following features:\n \n | Feature | Description |\n-|:-------------:|-----:|\n+|:-------------:|:-----|\n |Annotation driven|To define and customize a message handler simply mark it with @Handler annotation|\n |Delivers everything|Messages must not implement any interface and can be of any type. It is possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery, such that handlers will also receive subtypes of the message type they consume for, e.g. a handler of Object.class receives everything.|\n |Synchronous and asynchronous message delivery|A handler can be invoked to handle a message either synchronously or asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch|\n"
    },
    {
        "commit hash": "b796ee7ba6ed8bb4a633087af7207b699501c4c5",
        "previous commit hash": "37f19166af71a89dea9325fdaa16b8aaceb37f8d",
        "diff stats": {
            "file_path": "README.md",
            "additions": 15,
            "deletions": 15
        },
        "diff content": "@@ -28,21 +28,21 @@ Table of contents:\n \n At its core MBassador offers the following features:\n \n-| Feature | Description | Components |\n-|:-------------:|:-----:|:-----:|\n-|Annotation driven|To define and customize a message handler simply mark it with @Handler annotation||\n-|Delivers everything|Messages must not implement any interface and can be of any type. It is possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery, such that handlers will also receive subtypes of the message type they consume for, e.g. a handler of Object.class receives everything.||\n-|Synchronous and asynchronous message delivery|A handler can be invoked to handle a message either synchronously or asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch||\n-|Weak references|By default, MBassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister listeners that are not used anymore (of course it is also possible to explicitly unregister a listener if needed). This is very comfortable in certain environments where listeners are managed by frameworks, i.e. Spring, Guice etc. Just stuff everything into the message bus, it will ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.||\n-|Strong references|Instead of using weak references, a listener can be configured to be referenced using strong references using @Listener||\n-|Filtering|MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to a single message handler||\n-|Enveloped messages|Message handlers can declare to receive an enveloped message. The envelope can wrap different types of messages. This allows for a single handler to handle multiple, unrelated message types.||\n-|Handler priorities|A handler can be associated with a priority to influence the order in which messages are delivered when multiple matching handlers exist||\n-|Custom error handling|Errors during message delivery are sent to all registered error handlers which can be added to the bus as necessary.||\n-|DeadMessage event|Messages that do not match any handler result in the publication of a DeadMessage object which wraps the original message. DeadMessage events can be handled by registering listeners that handle DeadMessage.||\n-|FilteredMessage event|Messages that have matching handlers but do not pass the configured filters result in the publication of a FilteredMessage object which wraps the original message.FilteredMessage events can be handled by registering listeners that handle FilteredMessage.||\n-|Synchronization|It is possible to ensure that a handler is invoked non-concurrently,i.e. making it thread-safe by adding @Synchronized||\n-|Extensibility|MBassador is designed to be extensible with custom implementations of various components like message dispatchers and handler invocations (using the decorator pattern), metadata reader (you can add your own annotations) and factories for different kinds of objects. A configuration object is used to customize the different configurable parts (Features)||\n+| Feature | Description |\n+|:-------------:|-----:|\n+|Annotation driven|To define and customize a message handler simply mark it with @Handler annotation|\n+|Delivers everything|Messages must not implement any interface and can be of any type. It is possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery, such that handlers will also receive subtypes of the message type they consume for, e.g. a handler of Object.class receives everything.|\n+|Synchronous and asynchronous message delivery|A handler can be invoked to handle a message either synchronously or asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch|\n+|Weak references|By default, MBassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister listeners that are not used anymore (of course it is also possible to explicitly unregister a listener if needed). This is very comfortable in certain environments where listeners are managed by frameworks, i.e. Spring, Guice etc. Just stuff everything into the message bus, it will ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.|\n+|Strong references|Instead of using weak references, a listener can be configured to be referenced using strong references using @Listener|\n+|Filtering|MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to a single message handler|\n+|Enveloped messages|Message handlers can declare to receive an enveloped message. The envelope can wrap different types of messages. This allows for a single handler to handle multiple, unrelated message types.|\n+|Handler priorities|A handler can be associated with a priority to influence the order in which messages are delivered when multiple matching handlers exist|\n+|Custom error handling|Errors during message delivery are sent to all registered error handlers which can be added to the bus as necessary.|\n+|DeadMessage event|Messages that do not match any handler result in the publication of a DeadMessage object which wraps the original message. DeadMessage events can be handled by registering listeners that handle DeadMessage.|\n+|FilteredMessage event|Messages that have matching handlers but do not pass the configured filters result in the publication of a FilteredMessage object which wraps the original message.FilteredMessage events can be handled by registering listeners that handle FilteredMessage.|\n+|Synchronization|It is possible to ensure that a handler is invoked non-concurrently,i.e. making it thread-safe by adding @Synchronized|\n+|Extensibility|MBassador is designed to be extensible with custom implementations of various components like message dispatchers and handler invocations (using the decorator pattern), metadata reader (you can add your own annotations) and factories for different kinds of objects. A configuration object is used to customize the different configurable parts (Features)|\n \n \n \n"
    },
    {
        "commit hash": "37f19166af71a89dea9325fdaa16b8aaceb37f8d",
        "previous commit hash": "3a81b0a7b03ede5b6d7b3d58468dabc40c04fa8d",
        "diff stats": {
            "file_path": "README.md",
            "additions": 3,
            "deletions": 6
        },
        "diff content": "@@ -31,15 +31,12 @@ At its core MBassador offers the following features:\n | Feature | Description | Components |\n |:-------------:|:-----:|:-----:|\n |Annotation driven|To define and customize a message handler simply mark it with @Handler annotation||\n-|Delivers everything|Messages must not implement any interface and can be of any type. It is\n-                     possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery, such that handlers will also receive subtypes of the message type they consume for, e.g. a handler of Object.class receives everything.||\n-|Synchronous and asynchronous message delivery|A handler can be invoked to handle a message either synchronously or\n-                                               asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch||\n+|Delivers everything|Messages must not implement any interface and can be of any type. It is possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery, such that handlers will also receive subtypes of the message type they consume for, e.g. a handler of Object.class receives everything.||\n+|Synchronous and asynchronous message delivery|A handler can be invoked to handle a message either synchronously or asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch||\n |Weak references|By default, MBassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister listeners that are not used anymore (of course it is also possible to explicitly unregister a listener if needed). This is very comfortable in certain environments where listeners are managed by frameworks, i.e. Spring, Guice etc. Just stuff everything into the message bus, it will ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.||\n |Strong references|Instead of using weak references, a listener can be configured to be referenced using strong references using @Listener||\n |Filtering|MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to a single message handler||\n-|Enveloped messages|Message handlers can declare to receive an enveloped message. The envelope can wrap different\n-                    types of messages. This allows for a single handler to handle multiple, unrelated message types.||\n+|Enveloped messages|Message handlers can declare to receive an enveloped message. The envelope can wrap different types of messages. This allows for a single handler to handle multiple, unrelated message types.||\n |Handler priorities|A handler can be associated with a priority to influence the order in which messages are delivered when multiple matching handlers exist||\n |Custom error handling|Errors during message delivery are sent to all registered error handlers which can be added to the bus as necessary.||\n |DeadMessage event|Messages that do not match any handler result in the publication of a DeadMessage object which wraps the original message. DeadMessage events can be handled by registering listeners that handle DeadMessage.||\n"
    },
    {
        "commit hash": "3a81b0a7b03ede5b6d7b3d58468dabc40c04fa8d",
        "previous commit hash": "cc37df92fa496c80d8f1c8dc625b18e41da68f9b",
        "diff stats": {
            "file_path": "README.md",
            "additions": 25,
            "deletions": 30
        },
        "diff content": "@@ -3,18 +3,14 @@ MBassador\n \n MBassador is a very light-weight message (event) bus implementation following the publish subscribe pattern. It is designed\n for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. The core of MBassador's\n-high performance is a specialized data structure that minimizes lock contention such that performance degradation of concurrent access is minimal.\n-The performance win of this design is illustrated in <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n-and more recently in the [eventbus-performance](https://github.com/bennidi/eventbus-performance) github repository.\n+high performance is a specialized data structure that minimizes lock contention such that performance degradation of concurrent access is minimal. The performance win of this design is illustrated in <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a> and more recently in the [eventbus-performance](https://github.com/bennidi/eventbus-performance) github repository.\n \n-Read this documentation to get an overview of MBassadors features. There is also some documentation in the Wiki - although admittedly\n-not enough to make a developer happy (work is in progress).\n-Additionally, you can browse the [javadoc](http://bennidi.github.io/mbassador/)\n+Using MBassador in your project is very easy. Create as many instances of MBassador as you like (usually a singleton will do), mark and configure your message handlers with `@Handler` annotations and finally register the listeners at any MBassador instance. Start sending messages to your listeners using one of MBassador's publication methods (sync or async). Done!\n \n-The current version is 1.1.10 and it is available from the Maven Central Repository. See the release notes for more details.\n+Read this documentation to get an overview of MBassadors features. There is also some documentation in the Wiki - although admittedly\n+not enough to make a developer happy (work is in progress). Additionally, you can browse the [javadoc](http://bennidi.github.io/mbassador/)\n \n-There is also an extension available to support CDI-like transactional message sending in a Spring environment. It's beta but\n-stable enough to give it a try. See <a href=\"https://github.com/bennidi/mbassador-spring\" target=\"_blank\">here</a>.\n+There is also a [spring-extension](https://github.com/bennidi/mbassador-spring) available to support CDI-like transactional message sending in a Spring environment. It's beta but stable enough to give it a try.\n \n Table of contents:\n + [Features](#features)\n@@ -32,26 +28,25 @@ Table of contents:\n \n At its core MBassador offers the following features:\n \n-+ <em><strong>Annotation driven</em></strong>: To define and customize a message handler simply mark it with @Handler annotation\n-+ <em><strong>Delivers everything</em></strong>: Messages must not implement any interface and can be of any type. It is\n-possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery, such that handlers will also receive subtypes of the message type they consume for, e.g. a handler of Object.class receives everything.\n-+ <em><strong>Synchronous and asynchronous message delivery</em></strong>: A handler can be invoked to handle a message either synchronously or\n-asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method\n-blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch\n-+ <em><strong>Weak references</em></strong>: By default, MBassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister listeners that are not used anymore (of course it is also possible to explicitly unregister a listener if needed). This is very comfortable in certain environments where listeners are managed by frameworks, i.e. Spring, Guice etc. Just stuff everything into the message bus, it will ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.\n-+ <em><strong>Strong references</em></strong>: Instead of using weak references, a listener can be configured to be referenced using strong references using @Listener\n-+ <em><strong>Filtering</em></strong>: MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to a single message handler\n-+ <em><strong>Message envelopes</em></strong>: Message handlers can declare to receive an enveloped message. The envelope can wrap different\n-types of messages. This allows for a single handler to handle multiple, unrelated message types.\n-+ <em><strong>Handler priorities</em></strong>: A handler can be associated with a priority to influence the order in which messages are delivered when multiple matching handlers exist\n-+ <em><strong>Custom error handling</em></strong>: Errors during message delivery are sent to all registered error handlers which can be added to the bus as necessary.\n-+ <em><strong>DeadMessage event</em></strong>: Messages that do not match any handler result in the publication of a DeadMessage object which wraps the original message. DeadMessage events\n-can be handled by registering listeners that handle DeadMessage.\n-+ <em><strong>FilteredMessage event</em></strong>: Messages that have matching handlers but do not pass the configured filters result in the publication of a FilteredMessage object which wraps the original message.\n-FilteredMessage events can be handled by registering listeners that handle FilteredMessage.\n-+ <em><strong>Synchronization</em></strong>: It is possible to ensure that a handler is invoked non-concurrently,i.e. making it thread-safe by adding @Synchronized\n-+ <em><strong>Extensibility</em></strong>: MBassador is designed to be extensible with custom implementations of various components like message dispatchers and handler invocations (using the decorator pattern), metadata reader (you can add your own annotations) and factories for different kinds of objects. A configuration object is used to customize the different configurable parts (Features)\n-+ <em><strong>Ease of Use</em></strong>: Using MBassador in your project is very easy. Create as many instances of MBassador as you like (usually a singleton will do), mark and configure your message handlers with @Handler annotations and finally register the listeners at any MBassador instance. Start sending messages to your listeners using one of MBassador's publication methods (sync or async). Done!\n+| Feature | Description | Components |\n+|:-------------:|:-----:|:-----:|\n+|Annotation driven|To define and customize a message handler simply mark it with @Handler annotation||\n+|Delivers everything|Messages must not implement any interface and can be of any type. It is\n+                     possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery, such that handlers will also receive subtypes of the message type they consume for, e.g. a handler of Object.class receives everything.||\n+|Synchronous and asynchronous message delivery|A handler can be invoked to handle a message either synchronously or\n+                                               asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch||\n+|Weak references|By default, MBassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister listeners that are not used anymore (of course it is also possible to explicitly unregister a listener if needed). This is very comfortable in certain environments where listeners are managed by frameworks, i.e. Spring, Guice etc. Just stuff everything into the message bus, it will ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.||\n+|Strong references|Instead of using weak references, a listener can be configured to be referenced using strong references using @Listener||\n+|Filtering|MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to a single message handler||\n+|Enveloped messages|Message handlers can declare to receive an enveloped message. The envelope can wrap different\n+                    types of messages. This allows for a single handler to handle multiple, unrelated message types.||\n+|Handler priorities|A handler can be associated with a priority to influence the order in which messages are delivered when multiple matching handlers exist||\n+|Custom error handling|Errors during message delivery are sent to all registered error handlers which can be added to the bus as necessary.||\n+|DeadMessage event|Messages that do not match any handler result in the publication of a DeadMessage object which wraps the original message. DeadMessage events can be handled by registering listeners that handle DeadMessage.||\n+|FilteredMessage event|Messages that have matching handlers but do not pass the configured filters result in the publication of a FilteredMessage object which wraps the original message.FilteredMessage events can be handled by registering listeners that handle FilteredMessage.||\n+|Synchronization|It is possible to ensure that a handler is invoked non-concurrently,i.e. making it thread-safe by adding @Synchronized||\n+|Extensibility|MBassador is designed to be extensible with custom implementations of various components like message dispatchers and handler invocations (using the decorator pattern), metadata reader (you can add your own annotations) and factories for different kinds of objects. A configuration object is used to customize the different configurable parts (Features)||\n+\n \n \n \n@@ -147,7 +142,7 @@ to avoid confusion and misunderstanding.\n \n <h2>Release Notes</h2>\n \n-<h3>1.1.11</h3>\n+<h3>1.2.0</h3>\n  + Added support for conditional handlers using Java EL. Thanks to Bernd Rosstauscher\n  for the initial implementation.\n  + BREAKING CHANGES in BusConfiguration\n"
    },
    {
        "commit hash": "cc37df92fa496c80d8f1c8dc625b18e41da68f9b",
        "previous commit hash": "56597b125fc88539d38208fae7e1aa16f831ab4a",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.0</version>\n+    <version>1.2.1-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n"
    },
    {
        "commit hash": "56597b125fc88539d38208fae7e1aa16f831ab4a",
        "previous commit hash": "e2a403e8577a0c3eeb5e0eb7c39bd0fa7f61eeb9",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.0-SNAPSHOT</version>\n+    <version>1.2.0</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n"
    },
    {
        "commit hash": "e2a403e8577a0c3eeb5e0eb7c39bd0fa7f61eeb9",
        "previous commit hash": "f485cdef1cd1c516dc8f8af2b76ac8c7a72bce37",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 280,
            "deletions": 280
        },
        "diff content": "@@ -1,280 +1,280 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\r\n-\r\n-    <parent>\r\n-        <groupId>org.sonatype.oss</groupId>\r\n-        <artifactId>oss-parent</artifactId>\r\n-        <version>7</version>\r\n-    </parent>\r\n-\r\n-    <modelVersion>4.0.0</modelVersion>\r\n-    <groupId>net.engio</groupId>\r\n-    <artifactId>mbassador</artifactId>\r\n-    <version>1.1.11-SNAPSHOT</version>\r\n-    <packaging>bundle</packaging>\r\n-    <name>mbassador</name>\r\n-    <description>\r\n-        Mbassador is a fast and flexible message bus system following the publish subscribe pattern.\r\n-        It is designed for ease of use and aims to be feature rich and extensible\r\n-        while preserving resource efficiency and performance.\r\n-\r\n-        It features:\r\n-        declarative handler definition via annotations,\r\n-        sync and/or async message delivery,\r\n-        weak-references,\r\n-        message filtering,\r\n-        ordering of message handlers etc.\r\n-    </description>\r\n-\r\n-    <url>https://github.com/bennidi/mbassador</url>\r\n-    <licenses>\r\n-        <license>\r\n-            <name>MIT license</name>\r\n-            <url>http://www.opensource.org/licenses/mit-license.php</url>\r\n-        </license>\r\n-    </licenses>\r\n-    <scm>\r\n-        <url>git@github.com:bennidi/mbassador.git</url>\r\n-        <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\r\n-        <tag>mbassador-1.1.4</tag>\r\n-        <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\r\n-  </scm>\r\n-    <developers>\r\n-\r\n-        <developer>\r\n-            <id>bennidi</id>\r\n-            <name>Benjamin Diedrichsen</name>\r\n-            <timezone>+1</timezone>\r\n-            <email>b.diedrichsen@googlemail.com</email>\r\n-        </developer>\r\n-    </developers>\r\n-\r\n-    <properties>\r\n-        <nazgul-codestyle.version>2.0.1</nazgul-codestyle.version>\r\n-        <jdk.version>1.6</jdk.version>\r\n-        <pmd.plugin.version>3.0.1</pmd.plugin.version>\r\n-\r\n-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n-        <project.build.java.version>1.6</project.build.java.version>\r\n-        <github.url>file://${project.basedir}/mvn-local-repo</github.url>\r\n-    </properties>\r\n-\r\n-    <dependencies>\r\n-\r\n-        <dependency>\r\n-            <groupId>junit</groupId>\r\n-            <artifactId>junit</artifactId>\r\n-            <version>4.10</version>\r\n-            <scope>test</scope>\r\n-        </dependency>\r\n-\r\n-        <dependency>\r\n-            <groupId>org.slf4j</groupId>\r\n-            <artifactId>slf4j-api</artifactId>\r\n-            <version>1.7.5</version>\r\n-            <scope>test</scope>\r\n-        </dependency>\r\n-\r\n-        <dependency>\r\n-            <groupId>org.slf4j</groupId>\r\n-            <artifactId>slf4j-log4j12</artifactId>\r\n-            <version>1.7.5</version>\r\n-            <scope>test</scope>\r\n-        </dependency>\r\n-\r\n-        <dependency>\r\n-        \t<groupId>javax.el</groupId>\r\n-        \t<artifactId>el-api</artifactId>\r\n-        \t<version>2.2</version>\r\n-        </dependency>\r\n-        <dependency>\r\n-        \t<groupId>de.odysseus.juel</groupId>\r\n-        \t<artifactId>juel-impl</artifactId>\r\n-        \t<version>2.2.7</version>\r\n-        \t<scope>runtime</scope>\r\n-        \t<optional>true</optional>\r\n-        </dependency>\r\n-        <dependency>\r\n-        \t<groupId>de.odysseus.juel</groupId>\r\n-        \t<artifactId>juel-spi</artifactId>\r\n-        \t<version>2.2.7</version>\r\n-        \t<scope>runtime</scope>\r\n-        \t<optional>true</optional>\r\n-        </dependency>\r\n-    </dependencies>\r\n-\r\n-    <!--  Local repository (for testing)\r\n-    <distributionManagement>\r\n-        <repository>\r\n-            <id>mbassador-github-repo</id>\r\n-            <url>${github.url}</url>\r\n-        </repository>\r\n-    </distributionManagement>\r\n-    -->\r\n-\r\n-    <build>\r\n-        <plugins>\r\n-            <!-- plugin>\r\n-                <groupId>org.apache.maven.plugins</groupId>\r\n-                <artifactId>maven-pmd-plugin</artifactId>\r\n-                <version>${pmd.plugin.version}</version>\r\n-                <configuration>\r\n-                    <excludeRoots>\r\n-                        <excludeRoot>src/main/generated</excludeRoot>\r\n-                        <excludeRoot>src/test</excludeRoot>\r\n-                    </excludeRoots>\r\n-                    <rulesets>\r\n-                        <ruleset>/codestyle/pmd-rules.xml</ruleset>\r\n-                    </rulesets>\r\n-                    <targetJdk>${jdk.version}</targetJdk>\r\n-                    <sourceEncoding>${project.build.sourceEncoding}</sourceEncoding>\r\n-                </configuration>\r\n-                <executions>\r\n-                    <execution>\r\n-                        <goals>\r\n-                            <goal>check</goal>\r\n-                            <goal>cpd-check</goal>\r\n-                        </goals>\r\n-                    </execution>\r\n-                </executions>\r\n-                <dependencies>\r\n-                    <dependency>\r\n-                        <groupId>se.jguru.nazgul.tools.codestyle</groupId>\r\n-                        <artifactId>nazgul-codestyle</artifactId>\r\n-                        <version>${nazgul-codestyle.version}</version>\r\n-                    </dependency>\r\n-                </dependencies>\r\n-            </plugin -->\r\n-\r\n-            <plugin>\r\n-                <groupId>org.apache.felix</groupId>\r\n-                <artifactId>maven-bundle-plugin</artifactId>\r\n-                <version>2.3.7</version>\r\n-                <extensions>true</extensions>\r\n-                <configuration>\r\n-                    <instructions>\r\n-                        <Bundle-SymbolicName>${project.groupId}.${project.artifactId}</Bundle-SymbolicName>\r\n-                        <Export-Package>{local-packages}</Export-Package>\r\n-                    </instructions>\r\n-                </configuration>\r\n-            </plugin>\r\n-\r\n-            <plugin>\r\n-                <groupId>org.apache.maven.plugins</groupId>\r\n-                <artifactId>maven-compiler-plugin</artifactId>\r\n-                <configuration>\r\n-                    <source>${project.build.java.version}</source>\r\n-                    <target>${project.build.java.version}</target>\r\n-                </configuration>\r\n-            </plugin>\r\n-\r\n-            <plugin>\r\n-                <groupId>org.apache.maven.plugins</groupId>\r\n-                <artifactId>maven-release-plugin</artifactId>\r\n-                <version>2.4</version>\r\n-                <configuration>\r\n-                    <mavenExecutorId>forked-path</mavenExecutorId>\r\n-                </configuration>\r\n-            </plugin>\r\n-\r\n-            <plugin>\r\n-                <groupId>org.apache.maven.plugins</groupId>\r\n-                <artifactId>maven-surefire-plugin</artifactId>\r\n-                <configuration>\r\n-                    <skipTests>false</skipTests>\r\n-                    <excludes>\r\n-                        <!-- exclude the suite which is a convenience class for running all tests from IDE or using scripts -->\r\n-                        <exclude>AllTests.java</exclude>\r\n-                    </excludes>\r\n-                </configuration>\r\n-            </plugin>\r\n-\r\n-            <!-- bind the source attaching to package phase -->\r\n-            <plugin>\r\n-                <groupId>org.apache.maven.plugins</groupId>\r\n-                <artifactId>maven-source-plugin</artifactId>\r\n-                <executions>\r\n-                    <execution>\r\n-                        <id>attach-sources</id>\r\n-                        <goals>\r\n-                            <goal>jar</goal>\r\n-                        </goals>\r\n-                    </execution>\r\n-                </executions>\r\n-            </plugin>\r\n-\r\n-            <plugin>\r\n-                <groupId>org.apache.maven.plugins</groupId>\r\n-                <artifactId>maven-javadoc-plugin</artifactId>\r\n-                <executions>\r\n-                    <execution>\r\n-                        <id>attach-javadocs</id>\r\n-                        <goals>\r\n-                            <goal>jar</goal>\r\n-                        </goals>\r\n-                    </execution>\r\n-                </executions>\r\n-            </plugin>\r\n-\r\n-\t<!-- \r\n-\tThese two plugins take care of building and publishing the javadoc, using\r\n-\t\tmvn clean javadoc:javadoc scm-publish:publish-scm\r\n-\t --> \r\n-\t<plugin>\r\n-\t    <groupId>org.apache.maven.plugins</groupId>\r\n-\t    <artifactId>maven-javadoc-plugin</artifactId>\r\n-\t    <version>2.9.1</version>\r\n-\t    <configuration>\r\n-\t\t<aggregate>true</aggregate>\r\n-\t\t<show>public</show>\r\n-\t\t<nohelp>true</nohelp>\r\n-\t\t<header>mbassador, ${project.version}</header>\r\n-\t\t<footer>mbassador, ${project.version}</footer>\r\n-\t\t<doctitle>mbassador, ${project.version}</doctitle>\r\n-\t    </configuration>\r\n-\t</plugin>\r\n-\t<plugin>\r\n-\t    <groupId>org.apache.maven.plugins</groupId>\r\n-\t    <artifactId>maven-scm-publish-plugin</artifactId>\r\n-\t    <version>1.0-beta-2</version>\r\n-\t    <configuration>\r\n-\t\t<checkoutDirectory>${project.build.directory}/scmpublish</checkoutDirectory>\r\n-\t\t<checkinComment>Publishing javadoc for ${project.artifactId}:${project.version}</checkinComment>\r\n-\t\t<content>${project.reporting.outputDirectory}/apidocs</content>\r\n-\t\t<skipDeletedFiles>true</skipDeletedFiles>\r\n-\t\t<pubScmUrl>scm:git:git@github.com:bennidi/mbassador.git</pubScmUrl>\r\n-\t\t<scmBranch>gh-pages</scmBranch> <!-- branch with static site on github-->\r\n-\t    </configuration>\r\n-\t</plugin>\r\n-        </plugins>\r\n-    </build>\r\n-\r\n-    <profiles>\r\n-        <profile>\r\n-            <id>release-sign-artifacts</id>\r\n-            <activation>\r\n-                <property>\r\n-                    <name>performRelease</name>\r\n-                    <value>true</value>\r\n-                </property>\r\n-            </activation>\r\n-            <build>\r\n-                <plugins>\r\n-                    <plugin>\r\n-                        <groupId>org.apache.maven.plugins</groupId>\r\n-                        <artifactId>maven-gpg-plugin</artifactId>\r\n-                        <version>1.4</version>\r\n-                        <executions>\r\n-                            <execution>\r\n-                                <id>sign-artifacts</id>\r\n-                                <phase>verify</phase>\r\n-                                <goals>\r\n-                                    <goal>sign</goal>\r\n-                                </goals>\r\n-                            </execution>\r\n-                        </executions>\r\n-                    </plugin>\r\n-                </plugins>\r\n-            </build>\r\n-        </profile>\r\n-    </profiles>\r\n-</project>\r\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <parent>\n+        <groupId>org.sonatype.oss</groupId>\n+        <artifactId>oss-parent</artifactId>\n+        <version>7</version>\n+    </parent>\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>net.engio</groupId>\n+    <artifactId>mbassador</artifactId>\n+    <version>1.2.0-SNAPSHOT</version>\n+    <packaging>bundle</packaging>\n+    <name>mbassador</name>\n+    <description>\n+        Mbassador is a fast and flexible message bus system following the publish subscribe pattern.\n+        It is designed for ease of use and aims to be feature rich and extensible\n+        while preserving resource efficiency and performance.\n+\n+        It features:\n+        declarative handler definition via annotations,\n+        sync and/or async message delivery,\n+        weak-references,\n+        message filtering,\n+        ordering of message handlers etc.\n+    </description>\n+\n+    <url>https://github.com/bennidi/mbassador</url>\n+    <licenses>\n+        <license>\n+            <name>MIT license</name>\n+            <url>http://www.opensource.org/licenses/mit-license.php</url>\n+        </license>\n+    </licenses>\n+    <scm>\n+        <url>git@github.com:bennidi/mbassador.git</url>\n+        <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n+        <tag>mbassador-1.2.0</tag>\n+        <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n+  </scm>\n+    <developers>\n+\n+        <developer>\n+            <id>bennidi</id>\n+            <name>Benjamin Diedrichsen</name>\n+            <timezone>+1</timezone>\n+            <email>b.diedrichsen@googlemail.com</email>\n+        </developer>\n+    </developers>\n+\n+    <properties>\n+        <nazgul-codestyle.version>2.0.1</nazgul-codestyle.version>\n+        <jdk.version>1.6</jdk.version>\n+        <pmd.plugin.version>3.0.1</pmd.plugin.version>\n+\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.build.java.version>1.6</project.build.java.version>\n+        <github.url>file://${project.basedir}/mvn-local-repo</github.url>\n+    </properties>\n+\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.10</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>slf4j-api</artifactId>\n+            <version>1.7.5</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>slf4j-log4j12</artifactId>\n+            <version>1.7.5</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+        \t<groupId>javax.el</groupId>\n+        \t<artifactId>el-api</artifactId>\n+        \t<version>2.2</version>\n+        </dependency>\n+        <dependency>\n+        \t<groupId>de.odysseus.juel</groupId>\n+        \t<artifactId>juel-impl</artifactId>\n+        \t<version>2.2.7</version>\n+        \t<scope>runtime</scope>\n+        \t<optional>true</optional>\n+        </dependency>\n+        <dependency>\n+        \t<groupId>de.odysseus.juel</groupId>\n+        \t<artifactId>juel-spi</artifactId>\n+        \t<version>2.2.7</version>\n+        \t<scope>runtime</scope>\n+        \t<optional>true</optional>\n+        </dependency>\n+    </dependencies>\n+\n+    <!--  Local repository (for testing)\n+    <distributionManagement>\n+        <repository>\n+            <id>mbassador-github-repo</id>\n+            <url>${github.url}</url>\n+        </repository>\n+    </distributionManagement>\n+    -->\n+\n+    <build>\n+        <plugins>\n+            <!-- plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-pmd-plugin</artifactId>\n+                <version>${pmd.plugin.version}</version>\n+                <configuration>\n+                    <excludeRoots>\n+                        <excludeRoot>src/main/generated</excludeRoot>\n+                        <excludeRoot>src/test</excludeRoot>\n+                    </excludeRoots>\n+                    <rulesets>\n+                        <ruleset>/codestyle/pmd-rules.xml</ruleset>\n+                    </rulesets>\n+                    <targetJdk>${jdk.version}</targetJdk>\n+                    <sourceEncoding>${project.build.sourceEncoding}</sourceEncoding>\n+                </configuration>\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>check</goal>\n+                            <goal>cpd-check</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+                <dependencies>\n+                    <dependency>\n+                        <groupId>se.jguru.nazgul.tools.codestyle</groupId>\n+                        <artifactId>nazgul-codestyle</artifactId>\n+                        <version>${nazgul-codestyle.version}</version>\n+                    </dependency>\n+                </dependencies>\n+            </plugin -->\n+\n+            <plugin>\n+                <groupId>org.apache.felix</groupId>\n+                <artifactId>maven-bundle-plugin</artifactId>\n+                <version>2.3.7</version>\n+                <extensions>true</extensions>\n+                <configuration>\n+                    <instructions>\n+                        <Bundle-SymbolicName>${project.groupId}.${project.artifactId}</Bundle-SymbolicName>\n+                        <Export-Package>{local-packages}</Export-Package>\n+                    </instructions>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>${project.build.java.version}</source>\n+                    <target>${project.build.java.version}</target>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-release-plugin</artifactId>\n+                <version>2.4</version>\n+                <configuration>\n+                    <mavenExecutorId>forked-path</mavenExecutorId>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <skipTests>false</skipTests>\n+                    <excludes>\n+                        <!-- exclude the suite which is a convenience class for running all tests from IDE or using scripts -->\n+                        <exclude>AllTests.java</exclude>\n+                    </excludes>\n+                </configuration>\n+            </plugin>\n+\n+            <!-- bind the source attaching to package phase -->\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-source-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <id>attach-sources</id>\n+                        <goals>\n+                            <goal>jar</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-javadoc-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <id>attach-javadocs</id>\n+                        <goals>\n+                            <goal>jar</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n+\t<!-- \n+\tThese two plugins take care of building and publishing the javadoc, using\n+\t\tmvn clean javadoc:javadoc scm-publish:publish-scm\n+\t --> \n+\t<plugin>\n+\t    <groupId>org.apache.maven.plugins</groupId>\n+\t    <artifactId>maven-javadoc-plugin</artifactId>\n+\t    <version>2.9.1</version>\n+\t    <configuration>\n+\t\t<aggregate>true</aggregate>\n+\t\t<show>public</show>\n+\t\t<nohelp>true</nohelp>\n+\t\t<header>mbassador, ${project.version}</header>\n+\t\t<footer>mbassador, ${project.version}</footer>\n+\t\t<doctitle>mbassador, ${project.version}</doctitle>\n+\t    </configuration>\n+\t</plugin>\n+\t<plugin>\n+\t    <groupId>org.apache.maven.plugins</groupId>\n+\t    <artifactId>maven-scm-publish-plugin</artifactId>\n+\t    <version>1.0-beta-2</version>\n+\t    <configuration>\n+\t\t<checkoutDirectory>${project.build.directory}/scmpublish</checkoutDirectory>\n+\t\t<checkinComment>Publishing javadoc for ${project.artifactId}:${project.version}</checkinComment>\n+\t\t<content>${project.reporting.outputDirectory}/apidocs</content>\n+\t\t<skipDeletedFiles>true</skipDeletedFiles>\n+\t\t<pubScmUrl>scm:git:git@github.com:bennidi/mbassador.git</pubScmUrl>\n+\t\t<scmBranch>gh-pages</scmBranch> <!-- branch with static site on github-->\n+\t    </configuration>\n+\t</plugin>\n+        </plugins>\n+    </build>\n+\n+    <profiles>\n+        <profile>\n+            <id>release-sign-artifacts</id>\n+            <activation>\n+                <property>\n+                    <name>performRelease</name>\n+                    <value>true</value>\n+                </property>\n+            </activation>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins</groupId>\n+                        <artifactId>maven-gpg-plugin</artifactId>\n+                        <version>1.4</version>\n+                        <executions>\n+                            <execution>\n+                                <id>sign-artifacts</id>\n+                                <phase>verify</phase>\n+                                <goals>\n+                                    <goal>sign</goal>\n+                                </goals>\n+                            </execution>\n+                        </executions>\n+                    </plugin>\n+                </plugins>\n+            </build>\n+        </profile>\n+    </profiles>\n+</project>\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "README.md",
            "additions": 14,
            "deletions": 19
        },
        "diff content": "@@ -34,18 +34,13 @@ At its core MBassador offers the following features:\n \n + <em><strong>Annotation driven</em></strong>: To define and customize a message handler simply mark it with @Handler annotation\n + <em><strong>Delivers everything</em></strong>: Messages must not implement any interface and can be of any type. It is\n-possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery.\n-This means that handlers will also receive subtypes of the message type they are listening for, e.g. a handler of Object.class receives everything.\n+possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery, such that handlers will also receive subtypes of the message type they consume for, e.g. a handler of Object.class receives everything.\n + <em><strong>Synchronous and asynchronous message delivery</em></strong>: A handler can be invoked to handle a message either synchronously or\n asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method\n blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch\n-+ <em><strong>Weak references</em></strong>: By default, MBassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister\n-listeners that are not used anymore (of course it is also possible to explicitly unregister a listener if needed). This is very comfortable\n-in certain environments where listeners are managed by frameworks, i.e. Spring, Guice etc. Just stuff everything into the message bus, it will\n-ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.\n++ <em><strong>Weak references</em></strong>: By default, MBassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister listeners that are not used anymore (of course it is also possible to explicitly unregister a listener if needed). This is very comfortable in certain environments where listeners are managed by frameworks, i.e. Spring, Guice etc. Just stuff everything into the message bus, it will ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.\n + <em><strong>Strong references</em></strong>: Instead of using weak references, a listener can be configured to be referenced using strong references using @Listener\n-+ <em><strong>Filtering</em></strong>: MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to\n-a single message handler\n++ <em><strong>Filtering</em></strong>: MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to a single message handler\n + <em><strong>Message envelopes</em></strong>: Message handlers can declare to receive an enveloped message. The envelope can wrap different\n types of messages. This allows for a single handler to handle multiple, unrelated message types.\n + <em><strong>Handler priorities</em></strong>: A handler can be associated with a priority to influence the order in which messages are delivered when multiple matching handlers exist\n@@ -55,12 +50,8 @@ can be handled by registering listeners that handle DeadMessage.\n + <em><strong>FilteredMessage event</em></strong>: Messages that have matching handlers but do not pass the configured filters result in the publication of a FilteredMessage object which wraps the original message.\n FilteredMessage events can be handled by registering listeners that handle FilteredMessage.\n + <em><strong>Synchronization</em></strong>: It is possible to ensure that a handler is invoked non-concurrently,i.e. making it thread-safe by adding @Synchronized\n-+ <em><strong>Extensibility</em></strong>:MBassador is designed to be extensible with custom implementations of various components like message\n-dispatchers and handler invocations (using the decorator pattern), metadata reader (you can add your own annotations) and factories for different\n- kinds of objects. A configuration object is used to customize the different configurable parts\n-+ <em><strong>Ease of Use</em></strong>: Using MBassador in your project is very easy. Create as many instances of MBassador as you like (usually a singleton will do),\n-mark and configure your message handlers with @Handler annotations and finally register the listeners at any MBassador instance. Start\n-sending messages to your listeners using one of MBassador's publication methods (sync or async). Done!\n++ <em><strong>Extensibility</em></strong>: MBassador is designed to be extensible with custom implementations of various components like message dispatchers and handler invocations (using the decorator pattern), metadata reader (you can add your own annotations) and factories for different kinds of objects. A configuration object is used to customize the different configurable parts (Features)\n++ <em><strong>Ease of Use</em></strong>: Using MBassador in your project is very easy. Create as many instances of MBassador as you like (usually a singleton will do), mark and configure your message handlers with @Handler annotations and finally register the listeners at any MBassador instance. Start sending messages to your listeners using one of MBassador's publication methods (sync or async). Done!\n \n \n \n@@ -138,18 +129,16 @@ Message publication:\n         bus.post(subMessage).now(); // same as above\n \n <h2>Installation</h2>\n-Beginning with version 1.1.0 MBassador is available from the Maven Central Repository using the following coordinates:\n+MBassador is available from the Maven Central Repository using the following coordinates:\n ```xml\n     <dependency>\n         <groupId>net.engio</groupId>\n         <artifactId>mbassador</artifactId>\n-        <version>1.1.10</version>\n+        <version>1.1.11</version>\n     </dependency>\n ```\n \n-You can also download the latest binary release here: http://mvnrepository.com/artifact/net.engio/mbassador\n-\n-Of course you can always clone the repository and build from source.\n+You can also download the latest binary release from the official [maven repository](http://mvnrepository.com/artifact/net.engio/mbassador). Of course you can always clone the repository and build from source.\n \n <h2>Wiki</h2>\n There is ongoing effort to extend documentation and provide code samples and detailed explanations of how the message bus\n@@ -161,6 +150,12 @@ to avoid confusion and misunderstanding.\n <h3>1.1.11</h3>\n  + Added support for conditional handlers using Java EL. Thanks to Bernd Rosstauscher\n  for the initial implementation.\n+ + BREAKING CHANGES in BusConfiguration\n+ ++ Complete redesign of configuration setup using Features instead of simple get/set parameters. This will allow\n+ to flexibly combine features and still be able to exclude those not available in certain environments,for example, threading and reflection in GWT (this will be part of future releases)\n+ ++ Properties formerly located in BusConfiguration now moved to their respective Feature class\n+ ++ Removed all SyncXX related interfaces and config implementations. There is now only one `BusConfiguration`\n+ with its corresponding interface which will be used for all types of message bus implementations\n \n \n <h3>1.1.10</h3>\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java",
            "additions": 9,
            "deletions": 6
        },
        "diff content": "@@ -2,7 +2,8 @@ package net.engio.mbassy.bus;\n \n import net.engio.mbassy.bus.common.DeadMessage;\n import net.engio.mbassy.bus.common.PubSubSupport;\n-import net.engio.mbassy.bus.config.ISyncBusConfiguration;\n+import net.engio.mbassy.bus.config.Feature;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.subscription.Subscription;\n@@ -31,13 +32,15 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n     private final BusRuntime runtime;\n \n \n-    public AbstractPubSubSupport(ISyncBusConfiguration configuration) {\n+    public AbstractPubSubSupport(IBusConfiguration configuration) {\n         this.runtime = new BusRuntime(this);\n         this.runtime.add(BusRuntime.Properties.ErrorHandlers, getRegisteredErrorHandlers());\n-        this.subscriptionManager = configuration.getSubscriptionManagerProvider()\n-        \t\t.createManager(configuration.getMetadataReader(),\n-                configuration.getSubscriptionFactory(), runtime);\n-        this.publicationFactory = configuration.getMessagePublicationFactory();\n+        // configure the pub sub feature\n+        Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);\n+        this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()\n+        \t\t.createManager(pubSubFeature.getMetadataReader(),\n+                        pubSubFeature.getSubscriptionFactory(), runtime);\n+        this.publicationFactory = pubSubFeature.getPublicationFactory();\n     }\n \n     protected MessagePublication.Factory getPublicationFactory() {\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java",
            "additions": 14,
            "deletions": 8
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.bus;\n \n import net.engio.mbassy.bus.common.IMessageBus;\n+import net.engio.mbassy.bus.config.Feature;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n@@ -32,21 +33,26 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n \n     protected AbstractSyncAsyncMessageBus(IBusConfiguration configuration) {\n         super(configuration);\n-        this.executor = configuration.getExecutorForAsynchronousHandlers();\n+\n+        // configure asynchronous message dispatch\n+        Feature.AsynchronousMessageDispatch asyncDispatch = configuration.getFeature(Feature.AsynchronousMessageDispatch.class);\n+        pendingMessages = asyncDispatch.getPendingMessages();\n+        dispatchers = new ArrayList<Thread>(asyncDispatch.getNumberOfMessageDispatchers());\n+        initDispatcherThreads(asyncDispatch);\n+\n+        // configure asynchronous handler invocation\n+        Feature.AsynchronousHandlerInvocation asyncInvocation = configuration.getFeature(Feature.AsynchronousHandlerInvocation.class);\n+        this.executor = asyncInvocation.getExecutor();\n         getRuntime().add(BusRuntime.Properties.AsynchronousHandlerExecutor, executor);\n-        pendingMessages = configuration.getPendingMessagesQueue();\n-        dispatchers = new ArrayList<Thread>(configuration.getNumberOfMessageDispatchers());\n-        initDispatcherThreads(configuration);\n-    }\n \n+    }\n \n     // initialize the dispatch workers\n-    private void initDispatcherThreads(IBusConfiguration configuration) {\n+    private void initDispatcherThreads(Feature.AsynchronousMessageDispatch configuration) {\n         for (int i = 0; i < configuration.getNumberOfMessageDispatchers(); i++) {\n             // each thread will run forever and process incoming\n             // message publication requests\n-\n-            Thread dispatcher = configuration.getThreadFactoryForAsynchronousMessageDispatch().newThread(new Runnable() {\n+            Thread dispatcher = configuration.getDispatcherThreadFactory().newThread(new Runnable() {\n                 public void run() {\n                     while (true) {\n                         MessagePublication publication = null;\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/BusFactory.java",
            "additions": 9,
            "deletions": 3
        },
        "diff content": "@@ -3,7 +3,7 @@ package net.engio.mbassy.bus;\n import net.engio.mbassy.bus.common.IMessageBus;\n import net.engio.mbassy.bus.common.ISyncMessageBus;\n import net.engio.mbassy.bus.config.BusConfiguration;\n-import net.engio.mbassy.bus.config.SyncBusConfiguration;\n+import net.engio.mbassy.bus.config.Feature;\n \n /**\n  * The bus factory provides convenient factory methods for the most common bus use cases.\n@@ -21,7 +21,9 @@ public class BusFactory {\n      * @return\n      */\n     public static ISyncMessageBus SynchronousOnly(){\n-        return new SyncMessageBus(new SyncBusConfiguration());\n+        BusConfiguration syncPubSubCfg = new BusConfiguration();\n+        syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());\n+        return new SyncMessageBus(syncPubSubCfg);\n     }\n \n     /**\n@@ -33,6 +35,10 @@ public class BusFactory {\n      * @return\n      */\n     public static IMessageBus AsynchronousSequentialFIFO(){\n-        return new MBassador(BusConfiguration.Default(1,1,1));\n+        BusConfiguration asyncFIFOConfig = new BusConfiguration();\n+        asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n+        asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n+        asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n+        return new MBassador(asyncFIFOConfig);\n     }\n }\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MBassador.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.bus;\n \n import net.engio.mbassy.bus.common.IMessageBus;\n-import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.bus.publication.SyncAsyncPostCommand;\n \n@@ -10,7 +10,7 @@ import java.util.concurrent.TimeUnit;\n \n public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> implements IMessageBus<T, SyncAsyncPostCommand<T>> {\n \n-    public MBassador(BusConfiguration configuration) {\n+    public MBassador(IBusConfiguration configuration) {\n         super(configuration);\n     }\n \n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/SyncMessageBus.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.bus;\n \n import net.engio.mbassy.bus.common.ISyncMessageBus;\n-import net.engio.mbassy.bus.config.ISyncBusConfiguration;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.bus.publication.IPublicationCommand;\n \n@@ -13,7 +13,7 @@ import net.engio.mbassy.bus.publication.IPublicationCommand;\n public class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements ISyncMessageBus<T, SyncMessageBus.SyncPostCommand> {\n \n \n-    public SyncMessageBus(ISyncBusConfiguration configuration) {\n+    public SyncMessageBus(IBusConfiguration configuration) {\n         super(configuration);\n     }\n \n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java",
            "additions": 20,
            "deletions": 170
        },
        "diff content": "@@ -1,201 +1,51 @@\n package net.engio.mbassy.bus.config;\n \n-import net.engio.mbassy.bus.MessagePublication;\n-import net.engio.mbassy.listener.MetadataReader;\n-import net.engio.mbassy.subscription.ISubscriptionManagerProvider;\n-import net.engio.mbassy.subscription.SubscriptionFactory;\n-import net.engio.mbassy.subscription.SubscriptionManagerProvider;\n-\n-import java.util.concurrent.*;\n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.HashMap;\n+import java.util.Map;\n \n /**\n  * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n- *\n- * @author bennidi\n- *         Date: 12/8/12\n  */\n public class BusConfiguration implements IBusConfiguration {\n \n-    protected static final ThreadFactory AsynchronousHandlerThreadFactory = new ThreadFactory() {\n-\n-        private final AtomicInteger threadID = new AtomicInteger(0);\n-\n-        @Override\n-        public Thread newThread(Runnable r) {\n-            Thread thread = Executors.defaultThreadFactory().newThread(r);\n-            thread.setName(\"AsyncHandler-\" + threadID.getAndIncrement());\n-            thread.setDaemon(true);\n-            return thread;\n-        }\n-    };\n-\n-    protected static final ThreadFactory DispatcherThreadFactory = new ThreadFactory() {\n-\n-        private final AtomicInteger threadID = new AtomicInteger(0);\n-\n-        @Override\n-        public Thread newThread(Runnable r) {\n-            Thread thread = Executors.defaultThreadFactory().newThread(r);\n-            thread.setDaemon(true);// do not prevent the JVM from exiting\n-            thread.setName(\"Dispatcher-\" + threadID.getAndIncrement());\n-            return thread;\n-        }\n-    };\n-\n     /**\n-     * Creates a new instance, using the Default settings of 2 dispatchers, and\n+     * Creates a new instance, using the default settings of 2 dispatchers, and\n      * asynchronous handlers with an initial count equal to the number of\n      * available processors in the machine, with maximum count equal to\n      * 2 * the number of available processors. Uses {@link Runtime#availableProcessors()} to\n      * determine the number of available processors\n-     * \n-     * @return a Default BusConfiguration\n-     */\n-    public static BusConfiguration Default() {\n-    \treturn Default(2);\n-    }\n-\n-    /**\n-     * Creates a new instance, using the specified number of dispatchers, and\n-     * asynchronous handlers with an initial count equal to the number of\n-     * available processors in the machine, with maximum count equal to\n-     * 2 * the number of available processors. Uses {@link Runtime#availableProcessors()} to\n-     * determine the number of available processors\n-     * \n-     * @return a Default BusConfiguration\n-     */\n-    public static BusConfiguration Default(int numberOfDispatchers) {\n-        int numberOfCoreThreads = Runtime.getRuntime().availableProcessors();\n-        return Default(numberOfDispatchers, numberOfCoreThreads, numberOfCoreThreads * 2);\n-    }\n-    \n-    /**\n-     * Creates a new instance, using the specified number of dispatchers, and\n-     * asynchronous handlers with initial threads and maximum threads specified by the calling\n-     * parameters.\n-     * \n-     * @return a Default BusConfiguration\n-     */\n-    public static BusConfiguration Default(int numberOfDispatchers, int initialCoreThreads, int maximumCoreThreads) {\n-    \tThreadPoolExecutor executor = new ThreadPoolExecutor(initialCoreThreads, maximumCoreThreads, 1,\n-                TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), AsynchronousHandlerThreadFactory);\n-    \treturn Default(numberOfDispatchers, executor);\n-    }\n-    \n-    /**\n-     * Creates a new instance, using the specified number of dispatchers, and\n-     * asynchronous handlers that use the provided ThreadPoolExecutor.\n-     * \n-     * @return a Default BusConfiguration\n-     */\n-    public static BusConfiguration Default(int numberOfDispatchers, ThreadPoolExecutor executor) {\n+     *\n+     * @deprecated Use feature driven configuration instead\n+     **/\n+    @Deprecated()\n+    public static BusConfiguration SyncAsync() {\n         BusConfiguration defaultConfig = new BusConfiguration();\n-        defaultConfig.setExecutorForAsynchronousHandlers(executor);\n-        defaultConfig.setMetadataReader(new MetadataReader());\n-        defaultConfig.setSubscriptionFactory(new SubscriptionFactory());\n-        defaultConfig.setNumberOfMessageDispatchers(numberOfDispatchers);\n-        defaultConfig.setMessagePublicationFactory(new MessagePublication.Factory());\n-        defaultConfig.setPendingMessagesQueue(new LinkedBlockingQueue<MessagePublication>(Integer.MAX_VALUE));\n-        defaultConfig.setThreadFactoryForAsynchronousMessageDispatch(DispatcherThreadFactory);\n-        defaultConfig.setSubscriptionManagerProvider(new SubscriptionManagerProvider());\n+        defaultConfig.addFeature(Feature.SyncPubSub.Default());\n+        defaultConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default());\n+        defaultConfig.addFeature(Feature.AsynchronousMessageDispatch.Default());\n         return defaultConfig;\n     }\n \n-    public static BusConfiguration Empty(){\n-        return new BusConfiguration();\n-    }\n-\n-    protected int numberOfMessageDispatchers;\n-    protected ExecutorService executor;\n-    protected SubscriptionFactory subscriptionFactory;\n-    protected MetadataReader metadataReader;\n-    protected MessagePublication.Factory messagePublicationFactory;\n-    protected ThreadFactory dispatcherThreadFactory;\n-    protected ISubscriptionManagerProvider subscriptionManagerProvider;\n-\n-    public void setPendingMessagesQueue(BlockingQueue<MessagePublication> pendingMessagesQueue) {\n-        this.pendingMessagesQueue = pendingMessagesQueue;\n-    }\n-\n-    protected BlockingQueue<MessagePublication> pendingMessagesQueue;\n+    // the registered features\n+    private Map<Class<? extends Feature>, Feature> features = new HashMap<Class<? extends Feature>, Feature>();\n \n-    private BusConfiguration() {\n+    public BusConfiguration() {\n         super();\n     }\n \n     @Override\n-    public int getNumberOfMessageDispatchers() {\n-        return numberOfMessageDispatchers > 0 ? numberOfMessageDispatchers : 2;\n-    }\n-\n-    public BusConfiguration setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n-        this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n-        return this;\n+    public <T extends Feature> T getFeature(Class<T> feature) {\n+        return (T)features.get(feature);\n     }\n \n-\n     @Override\n-    public ExecutorService getExecutorForAsynchronousHandlers() {\n-        return executor;\n-    }\n-\n-    @Override\n-    public BlockingQueue<MessagePublication> getPendingMessagesQueue() {\n-        return new LinkedBlockingQueue<MessagePublication>(Integer.MAX_VALUE);\n-    }\n-\n-    @Override\n-    public ThreadFactory getThreadFactoryForAsynchronousMessageDispatch() {\n-        return dispatcherThreadFactory;\n-    }\n-\n-    public BusConfiguration setThreadFactoryForAsynchronousMessageDispatch(ThreadFactory factory) {\n-        dispatcherThreadFactory = factory;\n-        return this;\n-    }\n-\n-    public BusConfiguration setExecutorForAsynchronousHandlers(ExecutorService executor) {\n-        this.executor = executor;\n-        return this;\n-    }\n-\n-    @Override\n-    public MessagePublication.Factory getMessagePublicationFactory() {\n-        return messagePublicationFactory;\n-    }\n-\n-    public BusConfiguration setMessagePublicationFactory(MessagePublication.Factory messagePublicationFactory) {\n-        this.messagePublicationFactory = messagePublicationFactory;\n-        return this;\n-    }\n-\n-    @Override\n-    public MetadataReader getMetadataReader() {\n-        return metadataReader;\n-    }\n-\n-    public BusConfiguration setMetadataReader(MetadataReader metadataReader) {\n-        this.metadataReader = metadataReader;\n+    public IBusConfiguration addFeature(Feature feature) {\n+        features.put(feature.getClass(), feature);\n         return this;\n     }\n \n     @Override\n-    public SubscriptionFactory getSubscriptionFactory() {\n-        return subscriptionFactory;\n-    }\n-\n-    public BusConfiguration setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n-        this.subscriptionFactory = subscriptionFactory;\n-        return this;\n-    }\n-\n-    public ISubscriptionManagerProvider getSubscriptionManagerProvider() {\n-    \treturn subscriptionManagerProvider;\n-    }\n-    \n-    public BusConfiguration setSubscriptionManagerProvider(ISubscriptionManagerProvider subscriptionManagerProvider) {\n-    \tthis.subscriptionManagerProvider = subscriptionManagerProvider;\n-        return this;\n+    public IBusConfiguration addErrorHandler(ConfigurationErrorHandler handler) {\n+        return null;  //To change body of implemented methods use File | Settings | File Templates.\n     }\n }\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/ConfigurationError.java",
            "additions": 10,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,10 @@\n+package net.engio.mbassy.bus.config;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 8/29/14\n+ */\n+public class ConfigurationError {\n+}\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/ConfigurationErrorHandler.java",
            "additions": 10,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,10 @@\n+package net.engio.mbassy.bus.config;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 8/29/14\n+ */\n+public interface ConfigurationErrorHandler {\n+}\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/Feature.java",
            "additions": 172,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,172 @@\n+package net.engio.mbassy.bus.config;\n+\n+import net.engio.mbassy.bus.MessagePublication;\n+import net.engio.mbassy.listener.MetadataReader;\n+import net.engio.mbassy.subscription.ISubscriptionManagerProvider;\n+import net.engio.mbassy.subscription.SubscriptionFactory;\n+import net.engio.mbassy.subscription.SubscriptionManagerProvider;\n+\n+import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * A feature defines the configuration of a specific functionality of a message bus.\n+ *\n+ * @author bennidi\n+ *         Date: 8/29/14\n+ */\n+public interface Feature {\n+\n+\n+    class SyncPubSub implements Feature{\n+\n+        public static final SyncPubSub Default(){\n+            return new SyncPubSub()\n+                    .setMetadataReader(new MetadataReader())\n+                    .setPublicationFactory(new MessagePublication.Factory())\n+                    .setSubscriptionFactory(new SubscriptionFactory())\n+                    .setSubscriptionManagerProvider(new SubscriptionManagerProvider());\n+        }\n+\n+        private MessagePublication.Factory publicationFactory;\n+        private MetadataReader metadataReader;\n+        private SubscriptionFactory subscriptionFactory;\n+        private ISubscriptionManagerProvider subscriptionManagerProvider;\n+\n+        public ISubscriptionManagerProvider getSubscriptionManagerProvider() {\n+            return subscriptionManagerProvider;\n+        }\n+\n+        public SyncPubSub setSubscriptionManagerProvider(ISubscriptionManagerProvider subscriptionManagerProvider) {\n+            this.subscriptionManagerProvider = subscriptionManagerProvider;\n+            return this;\n+        }\n+\n+        public SubscriptionFactory getSubscriptionFactory() {\n+            return subscriptionFactory;\n+        }\n+\n+        public SyncPubSub setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n+            this.subscriptionFactory = subscriptionFactory;\n+            return this;\n+        }\n+\n+        public MetadataReader getMetadataReader() {\n+            return metadataReader;\n+        }\n+\n+        public SyncPubSub setMetadataReader(MetadataReader metadataReader) {\n+            this.metadataReader = metadataReader;\n+            return this;\n+        }\n+\n+        /**\n+         * The message publication factory is used to wrap a published message\n+         * in a {@link MessagePublication} for processing.\n+         * @return The factory to be used by the bus to create the publications\n+         */\n+        public MessagePublication.Factory getPublicationFactory() {\n+            return publicationFactory;\n+        }\n+\n+        public SyncPubSub setPublicationFactory(MessagePublication.Factory publicationFactory) {\n+            this.publicationFactory = publicationFactory;\n+            return this;\n+        }\n+    }\n+\n+    class AsynchronousHandlerInvocation implements Feature{\n+\n+        protected static final ThreadFactory MessageHandlerThreadFactory = new ThreadFactory() {\n+\n+            private final AtomicInteger threadID = new AtomicInteger(0);\n+\n+            @Override\n+            public Thread newThread(Runnable r) {\n+                Thread thread = Executors.defaultThreadFactory().newThread(r);\n+                thread.setName(\"AsyncHandler-\" + threadID.getAndIncrement());\n+                thread.setDaemon(true);\n+                return thread;\n+            }\n+        };\n+\n+        public static final AsynchronousHandlerInvocation Default(){\n+            int numberOfCores = Runtime.getRuntime().availableProcessors();\n+            return Default(numberOfCores, numberOfCores * 2);\n+        }\n+\n+        public static final AsynchronousHandlerInvocation Default(int initialCoreThreads, int maximumCoreThreads){\n+            int numberOfCores = Runtime.getRuntime().availableProcessors();\n+            return new AsynchronousHandlerInvocation().setExecutor(new ThreadPoolExecutor(initialCoreThreads, maximumCoreThreads, 1,\n+                    TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), MessageHandlerThreadFactory));\n+        }\n+\n+        private ExecutorService executor;\n+\n+        public ExecutorService getExecutor() {\n+            return executor;\n+        }\n+\n+        public AsynchronousHandlerInvocation setExecutor(ExecutorService executor) {\n+            this.executor = executor;\n+            return this;\n+        }\n+    }\n+\n+    class AsynchronousMessageDispatch implements Feature{\n+\n+        protected static final ThreadFactory MessageDispatchThreadFactory = new ThreadFactory() {\n+\n+            private final AtomicInteger threadID = new AtomicInteger(0);\n+\n+            @Override\n+            public Thread newThread(Runnable r) {\n+                Thread thread = Executors.defaultThreadFactory().newThread(r);\n+                thread.setDaemon(true);// do not prevent the JVM from exiting\n+                thread.setName(\"Dispatcher-\" + threadID.getAndIncrement());\n+                return thread;\n+            }\n+        };\n+\n+        public static final AsynchronousMessageDispatch Default(){\n+            return new AsynchronousMessageDispatch()\n+                .setNumberOfMessageDispatchers(2)\n+                .setDispatcherThreadFactory(MessageDispatchThreadFactory)\n+                .setMessageQueue(new LinkedBlockingQueue<MessagePublication>(Integer.MAX_VALUE));\n+        }\n+\n+\n+        private int numberOfMessageDispatchers;\n+        private BlockingQueue<MessagePublication> pendingMessages;\n+        private ThreadFactory dispatcherThreadFactory;\n+\n+        public int getNumberOfMessageDispatchers() {\n+            return numberOfMessageDispatchers;\n+        }\n+\n+        public AsynchronousMessageDispatch setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n+            this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n+            return this;\n+        }\n+\n+        public BlockingQueue<MessagePublication> getPendingMessages() {\n+            return pendingMessages;\n+        }\n+\n+        public AsynchronousMessageDispatch setMessageQueue(BlockingQueue<MessagePublication> pendingMessages) {\n+            this.pendingMessages = pendingMessages;\n+            return this;\n+        }\n+\n+        public ThreadFactory getDispatcherThreadFactory() {\n+            return dispatcherThreadFactory;\n+        }\n+\n+        public AsynchronousMessageDispatch setDispatcherThreadFactory(ThreadFactory dispatcherThreadFactory) {\n+            this.dispatcherThreadFactory = dispatcherThreadFactory;\n+            return this;\n+        }\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/IBusConfiguration.java",
            "additions": 20,
            "deletions": 16
        },
        "diff content": "@@ -1,26 +1,30 @@\n package net.engio.mbassy.bus.config;\n \n-import net.engio.mbassy.bus.MessagePublication;\n-\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.ThreadFactory;\n-\n /**\n- * Created with IntelliJ IDEA.\n- * User: benjamin\n- * Date: 8/16/13\n- * Time: 9:56 AM\n- * To change this template use File | Settings | File Templates.\n+ * The configuration of message bus instances is feature driven, e.g. configuration parameters\n+ * are grouped into {@link Feature}.\n+ *\n+ * Features can be added to a bus configuration to be used later in the instantiation process of the message bus.\n+ * Each bus will look for the features it requires and configure them according to the provided configuration. If a required feature is not found the bus will publish a {@link ConfigurationError}\n+ * to the {@link ConfigurationErrorHandler}\n+ *\n+ * @author bennidi.\n  */\n-public interface IBusConfiguration extends ISyncBusConfiguration {\n+public interface IBusConfiguration{\n+\n+    /**\n+     * Get a registered feature by its type (class).\n+     *\n+     * @param feature\n+     * @param <T>\n+     * @return\n+     */\n+    <T extends Feature> T getFeature(Class<T> feature);\n \n-    int getNumberOfMessageDispatchers();\n+    IBusConfiguration addFeature(Feature feature);\n \n-    ExecutorService getExecutorForAsynchronousHandlers();\n+    IBusConfiguration addErrorHandler(ConfigurationErrorHandler handler);\n \n-    BlockingQueue<MessagePublication> getPendingMessagesQueue();\n \n-    ThreadFactory getThreadFactoryForAsynchronousMessageDispatch();\n \n }\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/ISyncBusConfiguration.java",
            "additions": 0,
            "deletions": 26
        },
        "diff content": "@@ -1,26 +0,0 @@\n-package net.engio.mbassy.bus.config;\r\n-\r\n-import net.engio.mbassy.bus.MessagePublication;\r\n-import net.engio.mbassy.listener.MetadataReader;\r\n-import net.engio.mbassy.subscription.ISubscriptionManagerProvider;\r\n-import net.engio.mbassy.subscription.SubscriptionFactory;\r\n-\r\n-/**\r\n- * The configuration options for the synchronous message bus {@link net.engio.mbassy.bus.SyncMessageBus}\r\n- */\r\n-public interface ISyncBusConfiguration {\r\n-\r\n-    /**\r\n-     * The message publication factory is used to wrap a published message\r\n-     * and while it is being processed\r\n-     * @return The factory to be used by the bus to create the publications\r\n-     */\r\n-\tMessagePublication.Factory getMessagePublicationFactory();\r\n-\r\n-\tMetadataReader getMetadataReader();\r\n-\r\n-\tSubscriptionFactory getSubscriptionFactory();\r\n-\t\r\n-\tISubscriptionManagerProvider getSubscriptionManagerProvider();\r\n-\r\n-}\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/SyncBusConfiguration.java",
            "additions": 0,
            "deletions": 63
        },
        "diff content": "@@ -1,63 +0,0 @@\n-package net.engio.mbassy.bus.config;\n-\n-import net.engio.mbassy.bus.MessagePublication;\n-import net.engio.mbassy.listener.MetadataReader;\n-import net.engio.mbassy.subscription.ISubscriptionManagerProvider;\n-import net.engio.mbassy.subscription.SubscriptionFactory;\n-import net.engio.mbassy.subscription.SubscriptionManagerProvider;\n-\n-/**\n- * Todo: Add javadoc\n- *\n- * @author bennidi\n- *         Date: 3/29/13\n- */\n-public class SyncBusConfiguration<C extends SyncBusConfiguration<C>> implements ISyncBusConfiguration {\n-\n-    protected SubscriptionFactory subscriptionFactory;\n-    protected MetadataReader metadataReader;\n-    protected MessagePublication.Factory messagePublicationFactory;\n-    protected ISubscriptionManagerProvider subscriptionManagerProvider;\n-\n-    public SyncBusConfiguration() {\n-        this.metadataReader = new MetadataReader();\n-        this.subscriptionFactory = new SubscriptionFactory();\n-        this.messagePublicationFactory = new MessagePublication.Factory();\n-        this.subscriptionManagerProvider = new SubscriptionManagerProvider();\n-    }\n-\n-    public MessagePublication.Factory getMessagePublicationFactory() {\n-        return messagePublicationFactory;\n-    }\n-\n-    public void setMessagePublicationFactory(MessagePublication.Factory messagePublicationFactory) {\n-        this.messagePublicationFactory = messagePublicationFactory;\n-    }\n-\n-    public MetadataReader getMetadataReader() {\n-        return metadataReader;\n-    }\n-\n-    public C setMetadataReader(MetadataReader metadataReader) {\n-        this.metadataReader = metadataReader;\n-        return (C) this;\n-    }\n-\n-    public SubscriptionFactory getSubscriptionFactory() {\n-        return subscriptionFactory;\n-    }\n-\n-    public C setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n-        this.subscriptionFactory = subscriptionFactory;\n-        return (C) this;\n-    }\n-    \n-    public ISubscriptionManagerProvider getSubscriptionManagerProvider() {\n-    \treturn subscriptionManagerProvider;\n-    }\n-    \n-    public C setSubscriptionManagerProvider(ISubscriptionManagerProvider subscriptionManagerProvider) {\n-    \tthis.subscriptionManagerProvider = subscriptionManagerProvider;\n-    \treturn (C) this;\n-    }\n-}\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/error/MessageBusException.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.bus.error;\n \n /**\n- * Todo: Add javadoc\n+ * The universal exception type for message bus implementations.\n  *\n  * @author bennidi\n  *         Date: 3/29/13\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/HandlerInvocation.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -8,7 +8,7 @@ import net.engio.mbassy.subscription.SubscriptionContext;\n import java.util.Collection;\n \n /**\n- * Todo: Add javadoc\n+ * This is the base class for handler invocations that already implements all context related methods only leaving the implementation of the actual invocation mechanism to the concrete subclass.\n  *\n  * @author bennidi\n  *         Date: 3/29/13\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConditionalHandlers.java",
            "additions": 5,
            "deletions": 5
        },
        "diff content": "@@ -94,7 +94,7 @@ public class ConditionalHandlers extends MessageBusTest {\n \t ************************************************************************/\n \t@Test\n \tpublic void testSimpleStringCondition() throws Exception {\n-\t\tMBassador bus = getBus(BusConfiguration.Default());\n+\t\tMBassador bus = getBus(BusConfiguration.SyncAsync());\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"TEST\", 0);\n@@ -110,7 +110,7 @@ public class ConditionalHandlers extends MessageBusTest {\n \t ************************************************************************/\n \t@Test\n \tpublic void testSimpleNumberCondition() throws Exception {\n-\t\tMBassador bus = getBus(BusConfiguration.Default());\n+\t\tMBassador bus = getBus(BusConfiguration.SyncAsync());\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"\", 5);\n@@ -125,7 +125,7 @@ public class ConditionalHandlers extends MessageBusTest {\n \t ************************************************************************/\n \t@Test\n \tpublic void testHandleCombinedEL() throws Exception {\n-\t\tMBassador bus = getBus(BusConfiguration.Default());\n+\t\tMBassador bus = getBus(BusConfiguration.SyncAsync());\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"\", 3);\n@@ -140,7 +140,7 @@ public class ConditionalHandlers extends MessageBusTest {\n \t ************************************************************************/\n \t@Test\n \tpublic void testNotMatchingAnyCondition() throws Exception {\n-\t\tMBassador bus = getBus(BusConfiguration.Default());\n+\t\tMBassador bus = getBus(BusConfiguration.SyncAsync());\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"\", 0);\n@@ -154,7 +154,7 @@ public class ConditionalHandlers extends MessageBusTest {\n \t ************************************************************************/\n \t@Test\n \tpublic void testHandleMethodAccessEL() throws Exception {\n-\t\tMBassador bus = getBus(BusConfiguration.Default());\n+\t\tMBassador bus = getBus(BusConfiguration.SyncAsync());\n \t\tbus.subscribe(new ConditionalMessageListener());\n \n \t\tTestEvent message = new TestEvent(\"XYZ\", 1);\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/CustomHandlerAnnotationTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -111,7 +111,7 @@ public class CustomHandlerAnnotationTest extends MessageBusTest\n \n \t@Test\n \tpublic void testMetaHandlerFiltering() {\n-\t\tMBassador bus = getBus( BusConfiguration.Default() );\n+\t\tMBassador bus = getBus( BusConfiguration.SyncAsync() );\n \n \t\tNamedMessageListener listener = new NamedMessageListener();\n \t\tbus.subscribe( listener );\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/DeadMessageTest.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -32,7 +32,7 @@ public class DeadMessageTest extends MessageBusTest{\n \n     @Test\n     public void testDeadMessage(){\n-        final MBassador bus = getBus(BusConfiguration.Default());\n+        final MBassador bus = getBus(BusConfiguration.SyncAsync());\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                 .create(InstancesPerListener, IMessageListener.AsyncListener.class)\n@@ -70,7 +70,7 @@ public class DeadMessageTest extends MessageBusTest{\n \n     @Test\n     public void testUnsubscribingAllListeners() {\n-        final MBassador bus = getBus(BusConfiguration.Default());\n+        final MBassador bus = getBus(BusConfiguration.SyncAsync());\n         ListenerFactory deadMessageListener = new ListenerFactory()\n                 .create(InstancesPerListener, DeadMessagHandler.class)\n                 .create(InstancesPerListener, Object.class);\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/FilterTest.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -31,7 +31,7 @@ public class FilterTest extends MessageBusTest {\n         FilteredEventCounter.set(0);\n         DeadEventCounter.set(0);\n \n-        MBassador bus = getBus(BusConfiguration.Default());\n+        MBassador bus = getBus(BusConfiguration.SyncAsync());\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(100, FilteredMessageListener.class);\n \n@@ -56,7 +56,7 @@ public class FilterTest extends MessageBusTest {\n         FilteredEventCounter.set(0);\n         DeadEventCounter.set(0);\n \n-        MBassador bus = getBus(BusConfiguration.Default());\n+        MBassador bus = getBus(BusConfiguration.SyncAsync());\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(100, FilteredMessageListener.class);\n \n@@ -102,7 +102,7 @@ public class FilterTest extends MessageBusTest {\n \n     @Test\n     public void testSubtypesOnly(){\n-        MBassador bus = getBus(BusConfiguration.Default());\n+        MBassador bus = getBus(BusConfiguration.SyncAsync());\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(100, TestMessageHandler.class);\n \n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MBassadorTest.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -28,7 +28,7 @@ public class MBassadorTest extends MessageBusTest {\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, Listeners.synchronous())\n                 .create(InstancesPerListener, Listeners.noHandlers());\n-        final MBassador bus = getBus(BusConfiguration.Default(), listeners);\n+        final MBassador bus = getBus(BusConfiguration.SyncAsync(), listeners);\n \n \n         Runnable publishAndCheck = new Runnable() {\n@@ -62,7 +62,7 @@ public class MBassadorTest extends MessageBusTest {\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, Listeners.asynchronous())\n                 .create(InstancesPerListener, Listeners.noHandlers());\n-        final MBassador bus = getBus(BusConfiguration.Default(), listeners);\n+        final MBassador bus = getBus(BusConfiguration.SyncAsync(), listeners);\n \n         final MessageManager messageManager = new MessageManager();\n         Runnable publishAndCheck = new Runnable() {\n@@ -94,7 +94,7 @@ public class MBassadorTest extends MessageBusTest {\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, Listeners.asynchronous())\n                 .create(InstancesPerListener, Listeners.noHandlers());\n-        final MBassador bus = getBus(BusConfiguration.Default(), listeners);\n+        final MBassador bus = getBus(BusConfiguration.SyncAsync(), listeners);\n \n \n         final MessageManager messageManager = new MessageManager();\n@@ -132,7 +132,7 @@ public class MBassadorTest extends MessageBusTest {\n             }\n         };\n \n-        final MBassador bus = new MBassador(BusConfiguration.Default());\n+        final MBassador bus = new MBassador(BusConfiguration.SyncAsync());\n         bus.addErrorHandler(ExceptionCounter);\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, ExceptionThrowingListener.class);\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MetadataReaderTest.java",
            "additions": 25,
            "deletions": 2
        },
        "diff content": "@@ -34,6 +34,14 @@ public class MetadataReaderTest extends AssertSupport {\n         validator.check(listener);\n     }\n \n+    /*\n+    public void testInterfaced() {\n+        MessageListener listener = reader.getMessageListener(InterfacedListener.class);\n+        ListenerValidator validator = new ListenerValidator()\n+                .expectHandlers(1, Object.class);\n+        validator.check(listener);\n+    }  WIP */\n+\n \n     @Test\n     public void testListenerWithInheritance() {\n@@ -164,7 +172,7 @@ public class MetadataReaderTest extends AssertSupport {\n         }\n \n         @Handler\n-        @Enveloped(messages = {Number.class})\n+        @Enveloped(messages = Number.class)\n         public void handleEnveloped2(MessageEnvelope o) {\n \n         }\n@@ -175,11 +183,26 @@ public class MetadataReaderTest extends AssertSupport {\n \n         // narrow to integer\n         @Handler\n-        @Enveloped(messages = {Integer.class})\n+        @Enveloped(messages = Integer.class)\n         public void handleEnveloped2(MessageEnvelope o) {\n \n         }\n \n     }\n \n+    public static interface ListenerInterface{\n+\n+        @Handler\n+        @Enveloped(messages = Object.class)\n+        void handle(MessageEnvelope envelope);\n+    }\n+\n+    public class InterfacedListener implements  ListenerInterface{\n+\n+        @Override\n+        public void handle(MessageEnvelope envelope) {\n+            //\n+        }\n+    }\n+\n }\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MethodDispatchTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -41,7 +41,7 @@ public class MethodDispatchTest extends MessageBusTest{\n \n     @Test\n     public void testDispatch1(){\n-        IMessageBus bus = getBus(BusConfiguration.Default());\n+        IMessageBus bus = getBus(BusConfiguration.SyncAsync());\n         EventListener2 listener2 = new EventListener2();\n         bus.subscribe(listener2);\n         bus.post(\"jfndf\").now();\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -178,7 +178,7 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n         @Override\n         protected ISyncMessageBus getSyncMessageBus() {\n-            return new MBassador(BusConfiguration.Default());\n+            return new MBassador(BusConfiguration.SyncAsync());\n         }\n \n     }\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java",
            "additions": 11,
            "deletions": 5
        },
        "diff content": "@@ -3,6 +3,8 @@ package net.engio.mbassy;\n import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.bus.common.IMessageBus;\n import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.config.Feature;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Invoke;\n@@ -28,8 +30,10 @@ public class SynchronizedHandlerTest extends MessageBusTest {\n     @Test\n     public void testSynchronizedWithSynchronousInvocation(){\n         List<SynchronizedWithSynchronousDelivery> handlers = new LinkedList<SynchronizedWithSynchronousDelivery>();\n-        IMessageBus bus = getBus(BusConfiguration.Default()\n-                .setNumberOfMessageDispatchers(6));\n+        IBusConfiguration config = BusConfiguration.SyncAsync();\n+        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n+                .setNumberOfMessageDispatchers(6);\n+        IMessageBus bus = getBus(config);\n         for(int i = 0; i < numberOfListeners; i++){\n             SynchronizedWithSynchronousDelivery handler = new SynchronizedWithSynchronousDelivery();\n             handlers.add(handler);\n@@ -54,8 +58,10 @@ public class SynchronizedHandlerTest extends MessageBusTest {\n     @Test\n     public void testSynchronizedWithAsSynchronousInvocation(){\n         List<SynchronizedWithAsynchronousDelivery> handlers = new LinkedList<SynchronizedWithAsynchronousDelivery>();\n-        IMessageBus bus = getBus(BusConfiguration.Default()\n-                .setNumberOfMessageDispatchers(6));\n+        IBusConfiguration config = BusConfiguration.SyncAsync();\n+        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n+                .setNumberOfMessageDispatchers(6);\n+        IMessageBus bus = getBus(config);\n         for(int i = 0; i < numberOfListeners; i++){\n             SynchronizedWithAsynchronousDelivery handler = new SynchronizedWithAsynchronousDelivery();\n             handlers.add(handler);\n@@ -66,7 +72,7 @@ public class SynchronizedHandlerTest extends MessageBusTest {\n             bus.post(new Object()).asynchronously();\n         }\n \n-        // TODO: wait for publication\n+        // TODO: wait for publication to finish\n         pause(10000);\n \n         for(SynchronizedWithAsynchronousDelivery handler : handlers){\n"
    },
    {
        "commit hash": "5c56360bf85b6eb0894fbe552a814b22dee1640c",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -3,7 +3,7 @@ package net.engio.mbassy.common;\n import junit.framework.Assert;\n import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.bus.MessagePublication;\n-import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.messages.MessageTypes;\n@@ -43,13 +43,13 @@ public abstract class MessageBusTest extends AssertSupport {\n             mes.reset();\n     }\n \n-    public MBassador getBus(BusConfiguration configuration) {\n+    public MBassador getBus(IBusConfiguration configuration) {\n         MBassador bus = new MBassador(configuration);\n         bus.addErrorHandler(TestFailingHandler);\n         return bus;\n     }\n \n-    public MBassador getBus(BusConfiguration configuration, ListenerFactory listeners) {\n+    public MBassador getBus(IBusConfiguration configuration, ListenerFactory listeners) {\n         MBassador bus = new MBassador(configuration);\n         bus.addErrorHandler(TestFailingHandler);\n         ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n"
    },
    {
        "commit hash": "10b77616328daafdd498f246dc6e40380fc0bbdb",
        "previous commit hash": "86830b847dea460c47cea9d471a18b9b6918bc6d",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -33,7 +33,7 @@ Table of contents:\n At its core MBassador offers the following features:\n \n + <em><strong>Annotation driven</em></strong>: To define and customize a message handler simply mark it with @Handler annotation\n-+ <em><strong>Delivers everything</em></strong>: Messages must not implement any interface and can be of any type. It is\n++ <em><strong>Delivers everything</em></strong>: Messages do not have to implement any interface and can be of any type. It is\n possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery.\n This means that handlers will also receive subtypes of the message type they are listening for, e.g. a handler of Object.class receives everything.\n + <em><strong>Synchronous and asynchronous message delivery</em></strong>: A handler can be invoked to handle a message either synchronously or\n"
    },
    {
        "commit hash": "1834145fe7c9670b24357f3df38cc53e760cb984",
        "previous commit hash": "9a81992a0ac991e7eb8b007e98a786229075d13f",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ReflectionUtils.java",
            "additions": 120,
            "deletions": 82
        },
        "diff content": "@@ -1,100 +1,138 @@\n package net.engio.mbassy.common;\n \n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n import java.lang.reflect.Method;\n-import java.util.*;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n \n /**\n  * @author bennidi\n  *         Date: 2/16/12\n  *         Time: 12:14 PM\n  */\n-public class ReflectionUtils {\n+public class ReflectionUtils\n+{\n \n-    public static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n-        List<Method> methods = new LinkedList<Method>();\n-        try {\n-            for (Method method : target.getDeclaredMethods()) {\n-                if (condition.apply(method)) {\n-                    methods.add(method);\n-                }\n-            }\n-        } catch (Exception e) {\n-            //nop\n-        }\n-        if (!target.equals(Object.class)) {\n-            methods.addAll(getMethods(condition, target.getSuperclass()));\n-        }\n-        return methods;\n-    }\n+\tpublic static List<Method> getMethods( IPredicate<Method> condition, Class<?> target ) {\n+\t\tList<Method> methods = new LinkedList<Method>();\n+\t\ttry {\n+\t\t\tfor ( Method method : target.getDeclaredMethods() ) {\n+\t\t\t\tif ( condition.apply( method ) ) {\n+\t\t\t\t\tmethods.add( method );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tcatch ( Exception e ) {\n+\t\t\t//nop\n+\t\t}\n+\t\tif ( !target.equals( Object.class ) ) {\n+\t\t\tmethods.addAll( getMethods( condition, target.getSuperclass() ) );\n+\t\t}\n+\t\treturn methods;\n+\t}\n \n-    /**\n-     * Traverses the class hierarchy upwards, starting at the given subclass, looking\n-     * for an override of the given methods -> finds the bottom most override of the given\n-     * method if any exists\n-     *\n-     * @param overridingMethod\n-     * @param subclass\n-     * @return\n-     */\n-    public static Method getOverridingMethod(final Method overridingMethod, final Class subclass) {\n-        Class current = subclass;\n-        while (!current.equals(overridingMethod.getDeclaringClass())) {\n-            try {\n-                return current.getDeclaredMethod(overridingMethod.getName(), overridingMethod.getParameterTypes());\n-            } catch (NoSuchMethodException e) {\n-                current = current.getSuperclass();\n-            }\n-        }\n-        return null;\n-    }\n+\t/**\n+\t * Traverses the class hierarchy upwards, starting at the given subclass, looking\n+\t * for an override of the given methods -> finds the bottom most override of the given\n+\t * method if any exists\n+\t *\n+\t * @param overridingMethod\n+\t * @param subclass\n+\t * @return\n+\t */\n+\tpublic static Method getOverridingMethod( final Method overridingMethod, final Class subclass ) {\n+\t\tClass current = subclass;\n+\t\twhile ( !current.equals( overridingMethod.getDeclaringClass() ) ) {\n+\t\t\ttry {\n+\t\t\t\treturn current.getDeclaredMethod( overridingMethod.getName(), overridingMethod.getParameterTypes() );\n+\t\t\t}\n+\t\t\tcatch ( NoSuchMethodException e ) {\n+\t\t\t\tcurrent = current.getSuperclass();\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n \n-    public static Set<Class> getSuperclasses(Class from) {\n-        Set<Class> superclasses = new HashSet<Class>();\n-        collectInterfaces(from, superclasses);\n-        while (!from.equals(Object.class) && !from.isInterface()) {\n-            superclasses.add(from.getSuperclass());\n-            from = from.getSuperclass();\n-            collectInterfaces(from, superclasses);\n-        }\n-        return superclasses;\n-    }\n+\tpublic static Set<Class> getSuperclasses( Class from ) {\n+\t\tSet<Class> superclasses = new HashSet<Class>();\n+\t\tcollectInterfaces( from, superclasses );\n+\t\twhile ( !from.equals( Object.class ) && !from.isInterface() ) {\n+\t\t\tsuperclasses.add( from.getSuperclass() );\n+\t\t\tfrom = from.getSuperclass();\n+\t\t\tcollectInterfaces( from, superclasses );\n+\t\t}\n+\t\treturn superclasses;\n+\t}\n \n-    public static void collectInterfaces(Class from, Set<Class> accumulator){\n-        for(Class intface : from.getInterfaces()){\n-            accumulator.add(intface);\n-            collectInterfaces(intface, accumulator);\n-        }\n-    }\n+\tpublic static void collectInterfaces( Class from, Set<Class> accumulator ) {\n+\t\tfor ( Class intface : from.getInterfaces() ) {\n+\t\t\taccumulator.add( intface );\n+\t\t\tcollectInterfaces( intface, accumulator );\n+\t\t}\n+\t}\n \n-    public static boolean containsOverridingMethod(final List<Method> allMethods, final Method methodToCheck) {\n-        for (Method method : allMethods) {\n-            if (isOverriddenBy(methodToCheck, method)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n+\tpublic static boolean containsOverridingMethod( final List<Method> allMethods, final Method methodToCheck ) {\n+\t\tfor ( Method method : allMethods ) {\n+\t\t\tif ( isOverriddenBy( methodToCheck, method ) ) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n \n-    private static boolean isOverriddenBy(Method superclassMethod, Method subclassMethod) {\n-        // if the declaring classes are the same or the subclass method is not defined in the subclass\n-        // hierarchy of the given superclass method or the method names are not the same then\n-        // subclassMethod does not override superclassMethod\n-        if (superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass())\n-                || !superclassMethod.getDeclaringClass().isAssignableFrom(subclassMethod.getDeclaringClass())\n-                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n-            return false;\n-        }\n+\tpublic static <A extends Annotation> A getAnnotation( Method method, Class<A> annotationType ) {\n+\t\treturn getAnnotation( (AnnotatedElement) method, annotationType );\n+\t}\n \n-        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n-        Class[] subClassMethodParameters = subclassMethod.getParameterTypes();\n-        // method must specify the same number of parameters\n-        //the parameters must occur in the exact same order\n-        for (int i = 0; i < subClassMethodParameters.length; i++) {\n-            if (!superClassMethodParameters[i].equals(subClassMethodParameters[i])) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n+\tpublic static <A extends Annotation> A getAnnotation( Class from, Class<A> annotationType ) {\n+\t\treturn getAnnotation( (AnnotatedElement) from, annotationType );\n+\t}\n+\n+\t/**\n+\t * Searches for an Annotation of the given type on the class.  Supports meta annotations.\n+\t *\n+\t * @param from AnnotatedElement (class, method...)\n+\t * @param annotationType Annotation class to look for.\n+\t * @param <A> Annotation class\n+\t * @return Annotation instance or null\n+\t */\n+\tpublic static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType ) {\n+\t\tA ann = from.getAnnotation( annotationType );\n+\t\tif ( ann == null ) {\n+\t\t\tfor ( Annotation metaAnn : from.getAnnotations() ) {\n+\t\t\t\tann = metaAnn.annotationType().getAnnotation( annotationType );\n+\t\t\t\tif ( ann != null ) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn ann;\n+\t}\n+\n+\tprivate static boolean isOverriddenBy( Method superclassMethod, Method subclassMethod ) {\n+\t\t// if the declaring classes are the same or the subclass method is not defined in the subclass\n+\t\t// hierarchy of the given superclass method or the method names are not the same then\n+\t\t// subclassMethod does not override superclassMethod\n+\t\tif ( superclassMethod.getDeclaringClass().equals(\n+\t\t\t\tsubclassMethod.getDeclaringClass() ) || !superclassMethod.getDeclaringClass().isAssignableFrom(\n+\t\t\t\tsubclassMethod.getDeclaringClass() ) || !superclassMethod.getName().equals(\n+\t\t\t\tsubclassMethod.getName() ) ) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tClass[] superClassMethodParameters = superclassMethod.getParameterTypes();\n+\t\tClass[] subClassMethodParameters = subclassMethod.getParameterTypes();\n+\t\t// method must specify the same number of parameters\n+\t\t//the parameters must occur in the exact same order\n+\t\tfor ( int i = 0; i < subClassMethodParameters.length; i++ ) {\n+\t\t\tif ( !superClassMethodParameters[i].equals( subClassMethodParameters[i] ) ) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n \n }\n"
    },
    {
        "commit hash": "1834145fe7c9670b24357f3df38cc53e760cb984",
        "previous commit hash": "9a81992a0ac991e7eb8b007e98a786229075d13f",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Enveloped.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -15,7 +15,7 @@ import java.lang.annotation.Target;\n  */\n @Retention(value = RetentionPolicy.RUNTIME)\n @Inherited\n-@Target(value = {ElementType.METHOD})\n+@Target(value = {ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n public @interface Enveloped {\n \n     /**\n"
    },
    {
        "commit hash": "1834145fe7c9670b24357f3df38cc53e760cb984",
        "previous commit hash": "9a81992a0ac991e7eb8b007e98a786229075d13f",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Handler.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -14,7 +14,7 @@ import java.lang.annotation.*;\n  */\r\n @Retention(value = RetentionPolicy.RUNTIME)\r\n @Inherited\r\n-@Target(value = {ElementType.METHOD})\r\n+@Target(value = {ElementType.METHOD,ElementType.ANNOTATION_TYPE})\r\n public @interface Handler {\r\n \r\n     /**\r\n"
    },
    {
        "commit hash": "1834145fe7c9670b24357f3df38cc53e760cb984",
        "previous commit hash": "9a81992a0ac991e7eb8b007e98a786229075d13f",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Listener.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -13,7 +13,7 @@ import java.lang.annotation.*;\n  * @author bennidi\n  */\n @Retention(value = RetentionPolicy.RUNTIME)\n-@Target(value = {ElementType.TYPE})\n+@Target(value = {ElementType.TYPE, ElementType.ANNOTATION_TYPE})\n @Inherited\n public @interface Listener {\n \n"
    },
    {
        "commit hash": "1834145fe7c9670b24357f3df38cc53e760cb984",
        "previous commit hash": "9a81992a0ac991e7eb8b007e98a786229075d13f",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandler.java",
            "additions": 3,
            "deletions": 2
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy.listener;\r\n \r\n+import net.engio.mbassy.common.ReflectionUtils;\r\n import net.engio.mbassy.dispatch.HandlerInvocation;\r\n import net.engio.mbassy.dispatch.el.ElFilter;\r\n \r\n@@ -48,7 +49,7 @@ public class MessageHandler {\n             if(filter == null){\r\n                 filter = new IMessageFilter[]{};\r\n             }\r\n-            net.engio.mbassy.listener.Enveloped enveloped = handler.getAnnotation(Enveloped.class);\r\n+            net.engio.mbassy.listener.Enveloped enveloped = ReflectionUtils.getAnnotation( handler, Enveloped.class );\r\n             Class[] handledMessages = enveloped != null\r\n                     ? enveloped.messages()\r\n                     : handler.getParameterTypes();\r\n@@ -76,7 +77,7 @@ public class MessageHandler {\n             properties.put(Enveloped, enveloped != null);\r\n             properties.put(AcceptSubtypes, !handlerConfig.rejectSubtypes());\r\n             properties.put(Listener, listenerConfig);\r\n-            properties.put(IsSynchronized, handler.getAnnotation(Synchronized.class) != null);\r\n+            properties.put(IsSynchronized, ReflectionUtils.getAnnotation( handler, Synchronized.class) != null);\r\n             properties.put(HandledMessages, handledMessages);\r\n             return properties;\r\n         }\r\n"
    },
    {
        "commit hash": "1834145fe7c9670b24357f3df38cc53e760cb984",
        "previous commit hash": "9a81992a0ac991e7eb8b007e98a786229075d13f",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageListener.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.listener;\n \n import net.engio.mbassy.common.IPredicate;\n+import net.engio.mbassy.common.ReflectionUtils;\n \n import java.util.ArrayList;\n import java.util.Collection;\n@@ -42,7 +43,7 @@ public class MessageListener<T> {\n \n     public MessageListener(Class<T> listenerDefinition) {\n        this.listenerDefinition = listenerDefinition;\n-       listenerAnnotation = listenerDefinition.getAnnotation(Listener.class);\n+       listenerAnnotation = ReflectionUtils.getAnnotation( listenerDefinition, Listener.class );\n     }\n \n \n"
    },
    {
        "commit hash": "1834145fe7c9670b24357f3df38cc53e760cb984",
        "previous commit hash": "9a81992a0ac991e7eb8b007e98a786229075d13f",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MetadataReader.java",
            "additions": 4,
            "deletions": 5
        },
        "diff content": "@@ -22,7 +22,7 @@ public class MetadataReader {\n     private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n         @Override\n         public boolean apply(Method target) {\n-            return target.getAnnotation(Handler.class) != null;\n+\t        return ReflectionUtils.getAnnotation(target, Handler.class) != null;\n         }\n     };\n \n@@ -52,7 +52,6 @@ public class MetadataReader {\n         return filters;\n     }\n \n-\n     // get all listeners defined by the given class (includes\n     // listeners defined in super classes)\n     public MessageListener getMessageListener(Class target) {\n@@ -70,7 +69,7 @@ public class MetadataReader {\n         // for each handler there will be no overriding method that specifies @Handler annotation\n         // but an overriding method does inherit the listener configuration of the overwritten method\n         for (Method handler : bottomMostHandlers) {\n-            Handler handlerConfig = handler.getAnnotation(Handler.class);\n+            Handler handlerConfig = ReflectionUtils.getAnnotation( handler, Handler.class);\n             if (!handlerConfig.enabled() || !isValidMessageHandler(handler)) {\n                 continue; // disabled or invalid listeners are ignored\n             }\n@@ -89,7 +88,7 @@ public class MetadataReader {\n \n \n     private boolean isValidMessageHandler(Method handler) {\n-        if (handler == null || handler.getAnnotation(Handler.class) == null) {\n+        if (handler == null || ReflectionUtils.getAnnotation( handler, Handler.class) == null) {\n             return false;\n         }\n         if (handler.getParameterTypes().length != 1) {\n@@ -98,7 +97,7 @@ public class MetadataReader {\n                     + \"]. A messageHandler must define exactly one parameter\");\n             return false;\n         }\n-        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n+        Enveloped envelope = ReflectionUtils.getAnnotation( handler, Enveloped.class);\n         if (envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])) {\n             System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n             return false;\n"
    },
    {
        "commit hash": "1834145fe7c9670b24357f3df38cc53e760cb984",
        "previous commit hash": "9a81992a0ac991e7eb8b007e98a786229075d13f",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Synchronized.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -18,6 +18,6 @@ import java.lang.annotation.*;\n  */\n @Retention(value = RetentionPolicy.RUNTIME)\n @Inherited\n-@Target(value = {ElementType.METHOD})\n+@Target(value = {ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n public @interface Synchronized {\n }\n"
    },
    {
        "commit hash": "1834145fe7c9670b24357f3df38cc53e760cb984",
        "previous commit hash": "9a81992a0ac991e7eb8b007e98a786229075d13f",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -163,7 +163,7 @@ public class SubscriptionManager {\n             readWriteLock.readLock().lock();\n \n             if (subscriptionsPerMessage.get(messageType) != null) {\n-                subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n+\t            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n             }\n             for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n                 Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n"
    },
    {
        "commit hash": "1834145fe7c9670b24357f3df38cc53e760cb984",
        "previous commit hash": "9a81992a0ac991e7eb8b007e98a786229075d13f",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/CustomHandlerAnnotationTest.java",
            "additions": 139,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,139 @@\n+package net.engio.mbassy;\n+\n+import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.common.MessageBusTest;\n+import net.engio.mbassy.common.ReflectionUtils;\n+import net.engio.mbassy.listener.*;\n+import net.engio.mbassy.subscription.MessageEnvelope;\n+import org.junit.Test;\n+\n+import java.lang.annotation.*;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Tests a custom handler annotation with a @Handler meta annotation and a default filter.\n+ */\n+public class CustomHandlerAnnotationTest extends MessageBusTest\n+{\n+\t/**\n+\t * Handler annotation that adds a default filter on the NamedMessage.\n+\t * Enveloped is in no way required, but simply added to test a meta enveloped annotation.\n+\t */\n+\t@Retention(value = RetentionPolicy.RUNTIME)\n+\t@Inherited\n+\t@Handler(filters = { @Filter(NamedMessageFilter.class) })\n+\t@Synchronized\n+\t@Target(value = { ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n+\tstatic @interface NamedMessageHandler\n+\t{\n+\t\t/**\n+\t\t * @return The message names supported.\n+\t\t */\n+\t\tString[] value();\n+\t}\n+\n+\t/**\n+\t * Test enveloped meta annotation.\n+\t */\n+\t@Retention(value = RetentionPolicy.RUNTIME)\n+\t@Target(value = { ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n+\t@Inherited\n+\t@Handler(filters = { @Filter(NamedMessageFilter.class) })\n+\t@Enveloped(messages = NamedMessage.class)\n+\tstatic @interface EnvelopedNamedMessageHandler\n+\t{\n+\t\t/**\n+\t\t * @return The message names supported.\n+\t\t */\n+\t\tString[] value();\n+\t}\n+\n+\t/**\n+\t * Searches for a NamedMessageHandler annotation on the handler method.\n+\t * The annotation specifies the supported message names.\n+\t */\n+\tpublic static class NamedMessageFilter implements IMessageFilter<NamedMessage>\n+\t{\n+\t\t@Override\n+\t\tpublic boolean accepts( NamedMessage message, MessageHandler metadata ) {\n+\t\t\tNamedMessageHandler namedMessageHandler =\n+\t\t\t\t\tReflectionUtils.getAnnotation( metadata.getHandler(), NamedMessageHandler.class );\n+\n+\t\t\tif ( namedMessageHandler != null ) {\n+\t\t\t\treturn Arrays.asList( namedMessageHandler.value() ).contains( message.getName() );\n+\t\t\t}\n+\n+\t\t\tEnvelopedNamedMessageHandler envelopedHandler =\n+\t\t\t\t\tReflectionUtils.getAnnotation( metadata.getHandler(), EnvelopedNamedMessageHandler.class );\n+\n+\t\t\treturn envelopedHandler != null && Arrays.asList( envelopedHandler.value() ).contains( message.getName() );\n+\n+\t\t}\n+\t}\n+\n+\tstatic class NamedMessage\n+\t{\n+\t\tprivate String name;\n+\n+\t\tNamedMessage( String name ) {\n+\t\t\tthis.name = name;\n+\t\t}\n+\n+\t\tpublic String getName() {\n+\t\t\treturn name;\n+\t\t}\n+\t}\n+\n+\tstatic class NamedMessageListener\n+\t{\n+\t\tfinal Set<NamedMessage> handledByOne = new HashSet<NamedMessage>();\n+\t\tfinal Set<NamedMessage> handledByTwo = new HashSet<NamedMessage>();\n+\t\tfinal Set<NamedMessage> handledByThree = new HashSet<NamedMessage>();\n+\n+\t\t@NamedMessageHandler({ \"messageOne\", \"messageTwo\" })\n+\t\tvoid handlerOne( NamedMessage message ) {\n+\t\t\thandledByOne.add( message );\n+\t\t}\n+\n+\t\t@EnvelopedNamedMessageHandler({ \"messageTwo\", \"messageThree\" })\n+\t\tvoid handlerTwo( MessageEnvelope envelope ) {\n+\t\t\thandledByTwo.add( (NamedMessage) envelope.getMessage() );\n+\t\t}\n+\n+\t\t@NamedMessageHandler(\"messageThree\")\n+\t\tvoid handlerThree( NamedMessage message ) {\n+\t\t\thandledByThree.add( message );\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testMetaHandlerFiltering() {\n+\t\tMBassador bus = getBus( BusConfiguration.Default() );\n+\n+\t\tNamedMessageListener listener = new NamedMessageListener();\n+\t\tbus.subscribe( listener );\n+\n+\t\tNamedMessage messageOne = new NamedMessage( \"messageOne\" );\n+\t\tNamedMessage messageTwo = new NamedMessage( \"messageTwo\" );\n+\t\tNamedMessage messageThree = new NamedMessage( \"messageThree\" );\n+\n+\t\tbus.publish( messageOne );\n+\t\tbus.publish( messageTwo );\n+\t\tbus.publish( messageThree );\n+\n+\t\tassertTrue( listener.handledByOne.contains( messageOne ) );\n+\t\tassertTrue( listener.handledByOne.contains( messageTwo ) );\n+\t\tassertFalse( listener.handledByOne.contains( messageThree ) );\n+\n+\t\tassertFalse( listener.handledByTwo.contains( messageOne ) );\n+\t\tassertTrue( listener.handledByTwo.contains( messageTwo ) );\n+\t\tassertTrue( listener.handledByTwo.contains( messageThree ) );\n+\n+\t\tassertFalse( listener.handledByThree.contains( messageOne ) );\n+\t\tassertFalse( listener.handledByThree.contains( messageTwo ) );\n+\t\tassertTrue( listener.handledByThree.contains( messageThree ) );\n+\t}\n+}\n"
    },
    {
        "commit hash": "9a81992a0ac991e7eb8b007e98a786229075d13f",
        "previous commit hash": "ed901a85016dad266d9c90b2bf83dad74974efc0",
        "diff stats": {
            "file_path": "README.md",
            "additions": 8,
            "deletions": 2
        },
        "diff content": "@@ -4,8 +4,8 @@ MBassador\n MBassador is a very light-weight message (event) bus implementation following the publish subscribe pattern. It is designed\n for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. The core of MBassador's\n high performance is a specialized data structure that minimizes lock contention such that performance degradation of concurrent access is minimal.\n-The performance win of this design is illustrated in <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>.\n-The benchmarking code can be found <a href=\"https://github.com/bennidi/eventbus-performance\" target=\"_blank\">here</a>\n+The performance win of this design is illustrated in <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n+and more recently in the [eventbus-performance](https://github.com/bennidi/eventbus-performance) github repository.\n \n Read this documentation to get an overview of MBassadors features. There is also some documentation in the Wiki - although admittedly\n not enough to make a developer happy (work is in progress).\n@@ -147,6 +147,7 @@ Beginning with version 1.1.0 MBassador is available from the Maven Central Repos\n     </dependency>\n ```\n \n+You can also download the latest binary release here: http://mvnrepository.com/artifact/net.engio/mbassador\n \n Of course you can always clone the repository and build from source.\n \n@@ -157,6 +158,11 @@ to avoid confusion and misunderstanding.\n \n <h2>Release Notes</h2>\n \n+<h3>1.1.11</h3>\n+ + Added support for conditional handlers using Java EL. Thanks to Bernd Rosstauscher\n+ for the initial implementation.\n+\n+\n <h3>1.1.10</h3>\n  + Fixed broken sort order of prioritized handlers (see #58)\n  + Addressed issue #63 by making the constructor of `MessageHandler` use a map of properties and by replacing dependencies to\n"
    },
    {
        "commit hash": "9a81992a0ac991e7eb8b007e98a786229075d13f",
        "previous commit hash": "ed901a85016dad266d9c90b2bf83dad74974efc0",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MessagePublication.java",
            "additions": 4,
            "deletions": 1
        },
        "diff content": "@@ -23,7 +23,7 @@ public class MessagePublication {\n     private final Object message;\n     // message publications can be referenced by multiple threads to query publication progress\n     private volatile State state = State.Initial;\n-    private volatile boolean delivered = false; // TODO: maybe replace with return value of subscription and dispatchers?\n+    private volatile boolean delivered = false;\n     private final BusRuntime runtime;\n \n     protected MessagePublication(BusRuntime runtime, Collection<Subscription> subscriptions, Object message, State initialState) {\n@@ -37,6 +37,9 @@ public class MessagePublication {\n         return subscriptions.add(subscription);\n     }\n \n+    /*\n+    TODO: document state transitions\n+     */\n     protected void execute() {\n         state = State.Running;\n         for (Subscription sub : subscriptions) {\n"
    },
    {
        "commit hash": "9a81992a0ac991e7eb8b007e98a786229075d13f",
        "previous commit hash": "ed901a85016dad266d9c90b2bf83dad74974efc0",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Listener.java",
            "additions": 7,
            "deletions": 1
        },
        "diff content": "@@ -3,8 +3,14 @@ package net.engio.mbassy.listener;\n import java.lang.annotation.*;\n \n /**\n+ *\n+ * This annotation is meant to carry configuration that is shared among all instances of the annotated\n+ * listener. Supported configurations are:\n+ *\n+ *  Reference type: The bus will use either strong or weak references to its registered listeners,\n+ *  depending on which reference type (@see References) is set\n+ *\n  * @author bennidi\n- *         Date: 3/29/13\n  */\n @Retention(value = RetentionPolicy.RUNTIME)\n @Target(value = {ElementType.TYPE})\n"
    },
    {
        "commit hash": "ed901a85016dad266d9c90b2bf83dad74974efc0",
        "previous commit hash": "7c0c0b6f825d98793525595a7be5ed43f6b99e43",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java",
            "additions": 3,
            "deletions": 6
        },
        "diff content": "@@ -28,18 +28,16 @@ public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n     protected abstract Entry<T> createEntry(T value, Entry<T> next);\n \n     @Override\n-    public IConcurrentSet<T> add(T element) {\n-        if (element == null) return this;\n+    public void add(T element) {\n+        if (element == null) return;\n         Lock writeLock = lock.writeLock();\n         writeLock.lock();\n         if (element == null || entries.containsKey(element)) {\n             writeLock.unlock();\n-            return this;\n         } else {\n             insert(element);\n             writeLock.unlock();\n         }\n-        return this;\n     }\n \n     @Override\n@@ -69,7 +67,7 @@ public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n     }\n \n     @Override\n-    public IConcurrentSet<T> addAll(Iterable<T> elements) {\n+    public void addAll(Iterable<T> elements) {\n         Lock writeLock = lock.writeLock();\n         try {\n             writeLock.lock();\n@@ -81,7 +79,6 @@ public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n         } finally {\n             writeLock.unlock();\n         }\n-        return this;\n     }\n \n     @Override\n"
    },
    {
        "commit hash": "ed901a85016dad266d9c90b2bf83dad74974efc0",
        "previous commit hash": "7c0c0b6f825d98793525595a7be5ed43f6b99e43",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/IConcurrentSet.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -8,13 +8,13 @@ package net.engio.mbassy.common;\n  */\n public interface IConcurrentSet<T> extends Iterable<T> {\n \n-    IConcurrentSet<T> add(T element);\n+    void add(T element);\n \n     boolean contains(T element);\n \n     int size();\n \n-    IConcurrentSet<T> addAll(Iterable<T> elements);\n+    void addAll(Iterable<T> elements);\n \n     boolean remove(T element);\n }\n"
    },
    {
        "commit hash": "ed901a85016dad266d9c90b2bf83dad74974efc0",
        "previous commit hash": "7c0c0b6f825d98793525595a7be5ed43f6b99e43",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandler.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -56,7 +56,7 @@ public class MessageHandler {\n             Map<String, Object> properties = new HashMap<String, Object>();\r\n             properties.put(HandlerMethod, handler);\r\n             // add EL filter if a condition is present\r\n-            if(handlerConfig.condition() != null){\r\n+            if(handlerConfig.condition().length() > 0){\r\n                 if (!ElFilter.isELAvailable()) {\r\n                     throw new IllegalStateException(\"A handler uses an EL filter but no EL implementation is available.\");\r\n                 }\r\n"
    },
    {
        "commit hash": "ed901a85016dad266d9c90b2bf83dad74974efc0",
        "previous commit hash": "7c0c0b6f825d98793525595a7be5ed43f6b99e43",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AllTests.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -22,7 +22,8 @@ import org.junit.runners.Suite;\n         DeadMessageTest.class,\n         SynchronizedHandlerTest.class,\n         SubscriptionManagerTest.class,\n-        AsyncFIFOBusTest.class\n+        AsyncFIFOBusTest.class,\n+        ConditionalHandlers.class\n })\n public class AllTests {\n }\n"
    },
    {
        "commit hash": "ed901a85016dad266d9c90b2bf83dad74974efc0",
        "previous commit hash": "7c0c0b6f825d98793525595a7be5ed43f6b99e43",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConditionalHandlers.java",
            "additions": 168,
            "deletions": 168
        },
        "diff content": "@@ -1,168 +1,168 @@\n-package net.engio.mbassy;\r\n-\r\n-import net.engio.mbassy.bus.MBassador;\r\n-import net.engio.mbassy.bus.config.BusConfiguration;\r\n-import net.engio.mbassy.common.MessageBusTest;\r\n-import net.engio.mbassy.listener.Enveloped;\r\n-import net.engio.mbassy.listener.Handler;\r\n-import net.engio.mbassy.listener.Listener;\r\n-import net.engio.mbassy.listener.References;\r\n-import net.engio.mbassy.subscription.MessageEnvelope;\r\n-import org.junit.Test;\r\n-\r\n-import java.util.HashSet;\r\n-import java.util.Set;\r\n-\r\n-/*****************************************************************************\r\n- * Some unit tests for the \"condition\" filter.\r\n- ****************************************************************************/\r\n-\r\n-public class ConditionTest extends MessageBusTest {\r\n-\r\n-\tpublic static class TestEvent {\r\n-\r\n-\t\tprivate Set<String> handledBy = new HashSet<String>();\r\n-\t\tprivate String type;\r\n-\t\tprivate int size;\r\n-\r\n-\t\tpublic TestEvent(String type, int size) {\r\n-\t\t\tsuper();\r\n-\t\t\tthis.type = type;\r\n-\t\t\tthis.size = size;\r\n-\t\t}\r\n-\t\t\r\n-\t\tpublic String getType() {\r\n-\t\t\treturn type;\r\n-\t\t}\r\n-\r\n-\t\tpublic int getSize() {\r\n-\t\t\treturn size;\r\n-\t\t}\r\n-\r\n-        public boolean wasHandledBy(String ...handlers){\r\n-            for(String handler : handlers){\r\n-                if (!handledBy.contains(handler)) return false;\r\n-            }\r\n-            return true;\r\n-        }\r\n-\r\n-        public void handledBy(String handler){\r\n-            handledBy.add(handler);\r\n-        }\r\n-\t\t\r\n-\t}\r\n-\r\n-    @Listener(references = References.Strong)\r\n-\tpublic static class ConditionalMessageListener {\r\n-\r\n-\t\t@Handler(condition = \"msg.type == 'TEST'\")\r\n-\t\tpublic void handleTypeMessage(TestEvent message) {\r\n-\t\t\tmessage.handledBy(\"handleTypeMessage\");\r\n-\t\t}\r\n-\r\n-\t\t@Handler(condition = \"msg.size > 4\")\r\n-\t\tpublic void handleSizeMessage(TestEvent message) {\r\n-\t\t\tmessage.handledBy(\"handleSizeMessage\");\r\n-\t\t}\r\n-\r\n-        @Handler(condition = \"msg.foo > 4\")\r\n-        public void handleInvalidEL(TestEvent message) {\r\n-            message.handledBy(\"handleInvalidEL\");\r\n-        }\r\n-\t\t\r\n-\t\t@Handler(condition = \"msg.size > 2 && msg.size < 4\")\r\n-\t\tpublic void handleCombinedEL(TestEvent message) {\r\n-\t\t\tmessage.handledBy( \"handleCombinedEL\");\r\n-\t\t}\r\n-\t\t\r\n-\t\t@Handler(condition = \"msg.getType().equals('XYZ') && msg.getSize() == 1\")\r\n-\t\tpublic void handleMethodAccessEL(TestEvent message) {\r\n-\t\t\tmessage.handledBy(\"handleMethodAccessEL\");\r\n-\t\t}\r\n-\r\n-        @Handler(condition = \"msg.type == 'TEST'\")\r\n-        @Enveloped(messages = {TestEvent.class, Object.class})\r\n-        public void handleEnvelopedMessage(MessageEnvelope envelope) {\r\n-            envelope.<TestEvent>getMessage().handledBy(\"handleEnvelopedMessage\");\r\n-        }\r\n-\t\t\r\n-\t}\r\n-\r\n-\r\n-\t/*************************************************************************\r\n-\t * @throws Exception\r\n-\t ************************************************************************/\r\n-\t@Test\r\n-\tpublic void testSimpleStringCondition() throws Exception {\r\n-\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n-\t\tbus.subscribe(new ConditionalMessageListener());\r\n-\r\n-\t\tTestEvent message = new TestEvent(\"TEST\", 0);\r\n-\t\tbus.publish(message);\r\n-\r\n-\t\tassertTrue(message.wasHandledBy(\"handleTypeMessage\", \"handleEnvelopedMessage\"));\r\n-        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\r\n-\t}\r\n-\r\n-\r\n-\t/*************************************************************************\r\n-\t * @throws Exception\r\n-\t ************************************************************************/\r\n-\t@Test\r\n-\tpublic void testSimpleNumberCondition() throws Exception {\r\n-\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n-\t\tbus.subscribe(new ConditionalMessageListener());\r\n-\r\n-\t\tTestEvent message = new TestEvent(\"\", 5);\r\n-\t\tbus.publish(message);\r\n-\r\n-\t\tassertTrue(message.wasHandledBy(\"handleSizeMessage\"));\r\n-        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\r\n-\t}\r\n-\t\r\n-\t/*************************************************************************\r\n-\t * @throws Exception\r\n-\t ************************************************************************/\r\n-\t@Test\r\n-\tpublic void testHandleCombinedEL() throws Exception {\r\n-\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n-\t\tbus.subscribe(new ConditionalMessageListener());\r\n-\r\n-\t\tTestEvent message = new TestEvent(\"\", 3);\r\n-\t\tbus.publish(message);\r\n-\r\n-        assertTrue(message.wasHandledBy(\"handleCombinedEL\"));\r\n-        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\r\n-\t}\r\n-\t\r\n-\t/*************************************************************************\r\n-\t * @throws Exception\r\n-\t ************************************************************************/\r\n-\t@Test\r\n-\tpublic void testNotMatchingAnyCondition() throws Exception {\r\n-\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n-\t\tbus.subscribe(new ConditionalMessageListener());\r\n-\r\n-\t\tTestEvent message = new TestEvent(\"\", 0);\r\n-\t\tbus.publish(message);\r\n-\r\n-\t\tassertTrue(message.handledBy.isEmpty());\r\n-\t}\r\n-\t\r\n-\t/*************************************************************************\r\n-\t * @throws Exception\r\n-\t ************************************************************************/\r\n-\t@Test\r\n-\tpublic void testHandleMethodAccessEL() throws Exception {\r\n-\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n-\t\tbus.subscribe(new ConditionalMessageListener());\r\n-\r\n-\t\tTestEvent message = new TestEvent(\"XYZ\", 1);\r\n-\t\tbus.publish(message);\r\n-\r\n-        assertTrue(message.wasHandledBy(\"handleMethodAccessEL\"));\r\n-        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\r\n-\r\n-    }\r\n-\r\n-}\r\n+package net.engio.mbassy;\n+\n+import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.common.MessageBusTest;\n+import net.engio.mbassy.listener.Enveloped;\n+import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.References;\n+import net.engio.mbassy.subscription.MessageEnvelope;\n+import org.junit.Test;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/*****************************************************************************\n+ * Some unit tests for the \"condition\" filter.\n+ ****************************************************************************/\n+\n+public class ConditionalHandlers extends MessageBusTest {\n+\n+\tpublic static class TestEvent {\n+\n+\t\tprivate Set<String> handledBy = new HashSet<String>();\n+\t\tprivate String type;\n+\t\tprivate int size;\n+\n+\t\tpublic TestEvent(String type, int size) {\n+\t\t\tsuper();\n+\t\t\tthis.type = type;\n+\t\t\tthis.size = size;\n+\t\t}\n+\t\t\n+\t\tpublic String getType() {\n+\t\t\treturn type;\n+\t\t}\n+\n+\t\tpublic int getSize() {\n+\t\t\treturn size;\n+\t\t}\n+\n+        public boolean wasHandledBy(String ...handlers){\n+            for(String handler : handlers){\n+                if (!handledBy.contains(handler)) return false;\n+            }\n+            return true;\n+        }\n+\n+        public void handledBy(String handler){\n+            handledBy.add(handler);\n+        }\n+\t\t\n+\t}\n+\n+    @Listener(references = References.Strong)\n+\tpublic static class ConditionalMessageListener {\n+\n+\t\t@Handler(condition = \"msg.type == 'TEST'\")\n+\t\tpublic void handleTypeMessage(TestEvent message) {\n+\t\t\tmessage.handledBy(\"handleTypeMessage\");\n+\t\t}\n+\n+\t\t@Handler(condition = \"msg.size > 4\")\n+\t\tpublic void handleSizeMessage(TestEvent message) {\n+\t\t\tmessage.handledBy(\"handleSizeMessage\");\n+\t\t}\n+\n+        @Handler(condition = \"msg.foo > 4\")\n+        public void handleInvalidEL(TestEvent message) {\n+            message.handledBy(\"handleInvalidEL\");\n+        }\n+\t\t\n+\t\t@Handler(condition = \"msg.size > 2 && msg.size < 4\")\n+\t\tpublic void handleCombinedEL(TestEvent message) {\n+\t\t\tmessage.handledBy( \"handleCombinedEL\");\n+\t\t}\n+\t\t\n+\t\t@Handler(condition = \"msg.getType().equals('XYZ') && msg.getSize() == 1\")\n+\t\tpublic void handleMethodAccessEL(TestEvent message) {\n+\t\t\tmessage.handledBy(\"handleMethodAccessEL\");\n+\t\t}\n+\n+        @Handler(condition = \"msg.type == 'TEST'\")\n+        @Enveloped(messages = {TestEvent.class, Object.class})\n+        public void handleEnvelopedMessage(MessageEnvelope envelope) {\n+            envelope.<TestEvent>getMessage().handledBy(\"handleEnvelopedMessage\");\n+        }\n+\t\t\n+\t}\n+\n+\n+\t/*************************************************************************\n+\t * @throws Exception\n+\t ************************************************************************/\n+\t@Test\n+\tpublic void testSimpleStringCondition() throws Exception {\n+\t\tMBassador bus = getBus(BusConfiguration.Default());\n+\t\tbus.subscribe(new ConditionalMessageListener());\n+\n+\t\tTestEvent message = new TestEvent(\"TEST\", 0);\n+\t\tbus.publish(message);\n+\n+\t\tassertTrue(message.wasHandledBy(\"handleTypeMessage\", \"handleEnvelopedMessage\"));\n+        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n+\t}\n+\n+\n+\t/*************************************************************************\n+\t * @throws Exception\n+\t ************************************************************************/\n+\t@Test\n+\tpublic void testSimpleNumberCondition() throws Exception {\n+\t\tMBassador bus = getBus(BusConfiguration.Default());\n+\t\tbus.subscribe(new ConditionalMessageListener());\n+\n+\t\tTestEvent message = new TestEvent(\"\", 5);\n+\t\tbus.publish(message);\n+\n+\t\tassertTrue(message.wasHandledBy(\"handleSizeMessage\"));\n+        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n+\t}\n+\t\n+\t/*************************************************************************\n+\t * @throws Exception\n+\t ************************************************************************/\n+\t@Test\n+\tpublic void testHandleCombinedEL() throws Exception {\n+\t\tMBassador bus = getBus(BusConfiguration.Default());\n+\t\tbus.subscribe(new ConditionalMessageListener());\n+\n+\t\tTestEvent message = new TestEvent(\"\", 3);\n+\t\tbus.publish(message);\n+\n+        assertTrue(message.wasHandledBy(\"handleCombinedEL\"));\n+        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n+\t}\n+\t\n+\t/*************************************************************************\n+\t * @throws Exception\n+\t ************************************************************************/\n+\t@Test\n+\tpublic void testNotMatchingAnyCondition() throws Exception {\n+\t\tMBassador bus = getBus(BusConfiguration.Default());\n+\t\tbus.subscribe(new ConditionalMessageListener());\n+\n+\t\tTestEvent message = new TestEvent(\"\", 0);\n+\t\tbus.publish(message);\n+\n+\t\tassertTrue(message.handledBy.isEmpty());\n+\t}\n+\t\n+\t/*************************************************************************\n+\t * @throws Exception\n+\t ************************************************************************/\n+\t@Test\n+\tpublic void testHandleMethodAccessEL() throws Exception {\n+\t\tMBassador bus = getBus(BusConfiguration.Default());\n+\t\tbus.subscribe(new ConditionalMessageListener());\n+\n+\t\tTestEvent message = new TestEvent(\"XYZ\", 1);\n+\t\tbus.publish(message);\n+\n+        assertTrue(message.wasHandledBy(\"handleMethodAccessEL\"));\n+        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n+\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "ed901a85016dad266d9c90b2bf83dad74974efc0",
        "previous commit hash": "7c0c0b6f825d98793525595a7be5ed43f6b99e43",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/ListenerFactory.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -30,7 +30,7 @@ public class ListenerFactory {\n         return this;\n     }\n \n-    public ListenerFactory create(int numberOfInstances, Class[] classes){\n+    public ListenerFactory create(int numberOfInstances, Class ...classes){\n         for(Class clazz : classes)\n             create(numberOfInstances,clazz);\n         return this;\n"
    },
    {
        "commit hash": "7c0c0b6f825d98793525595a7be5ed43f6b99e43",
        "previous commit hash": "86bdcad3364acfda93b04e3ba386db6da99e8a5a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java",
            "additions": 2,
            "deletions": 14
        },
        "diff content": "@@ -1,7 +1,6 @@\n package net.engio.mbassy.dispatch;\r\n \r\n import net.engio.mbassy.bus.MessagePublication;\r\n-import net.engio.mbassy.dispatch.el.ElFilter;\r\n import net.engio.mbassy.listener.IMessageFilter;\r\n \r\n /**\r\n@@ -12,7 +11,7 @@ import net.engio.mbassy.listener.IMessageFilter;\n  * @author bennidi\r\n  *         Date: 11/23/12\r\n  */\r\n-public class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\r\n+public final class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\r\n \r\n     private final IMessageFilter[] filter;\r\n \r\n@@ -38,20 +37,9 @@ public class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n \r\n     @Override\r\n     public void dispatch(MessagePublication publication, Object message, Iterable listeners){\r\n-        if (passesFilter(message) && passesELFilter(message)) {\r\n+        if (passesFilter(message)) {\r\n             getDelegate().dispatch(publication, message, listeners);\r\n         }\r\n     }\r\n \r\n-\t/*************************************************************************\r\n-\t * This will test the EL expression defined on the Handler annotation.\r\n-\t * This is like a \"parameterizable\" filter.\r\n-\t * @param me the message object to filter with the EL expression if there is one.\r\n-\t * @return true if the event is allowed, false if it is rejected.\r\n-\t ************************************************************************/\r\n-        \r\n-\tprivate boolean passesELFilter(Object message) {\r\n-\t\tElFilter filter = ElFilter.getInstance();\r\n-\t\treturn filter != null && filter.accepts(message, getContext().getHandlerMetadata());\r\n-\t}\r\n }\r\n"
    },
    {
        "commit hash": "7c0c0b6f825d98793525595a7be5ed43f6b99e43",
        "previous commit hash": "86bdcad3364acfda93b04e3ba386db6da99e8a5a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/el/ElFilter.java",
            "additions": 50,
            "deletions": 91
        },
        "diff content": "@@ -1,11 +1,11 @@\n package net.engio.mbassy.dispatch.el;\r\n \r\n-import javax.el.ExpressionFactory;\r\n-import javax.el.ValueExpression;\r\n-\r\n import net.engio.mbassy.listener.IMessageFilter;\r\n import net.engio.mbassy.listener.MessageHandler;\r\n \r\n+import javax.el.ExpressionFactory;\r\n+import javax.el.ValueExpression;\r\n+\r\n /*****************************************************************************\r\n  * A filter that will use a expression from the handler annotation and \r\n  * parse it as EL.\r\n@@ -13,101 +13,60 @@ import net.engio.mbassy.listener.MessageHandler;\n \r\n public class ElFilter implements IMessageFilter {\r\n \r\n-\tprivate static ElFilter instance;\r\n-\t\r\n-\tstatic {\r\n-\t\ttry {\r\n-\t\t\tinstance = new ElFilter();\r\n-\t\t} catch (Exception e) {\r\n-\t\t\t// Most likely the javax.el package is not available.\r\n-\t\t\tinstance = null;\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-\tprivate ExpressionFactory elFactory;\r\n-\t\r\n-\t/*************************************************************************\r\n-\t * Constructor\r\n-\t ************************************************************************/\r\n-\t\r\n-\tprivate ElFilter() {\r\n-\t\tsuper();\r\n-\t\tinitELFactory();\r\n-\t}\r\n-\t\r\n-\t/*************************************************************************\r\n-\t * Get an implementation of the ExpressionFactory. This uses the \r\n-\t * Java service lookup mechanism to find a proper implementation.\r\n-\t * If none if available we do not support EL filters.\r\n-\t ************************************************************************/\r\n+    // thread-safe initialization of EL factory singleton\r\n+    public static final class ExpressionFactoryHolder{\r\n \r\n-\tprivate void initELFactory() {\r\n-\t\ttry {\r\n-\t\t\tthis.elFactory = ExpressionFactory.newInstance();\r\n-\t\t} catch (RuntimeException e) {\r\n-\t\t\t// No EL implementation on the class path.\r\n-\t\t\telFactory = null;\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-\t/*************************************************************************\r\n-\t * accepts\r\n-\t * @see net.engio.mbassy.listener.IMessageFilter#accepts(java.lang.Object, net.engio.mbassy.listener.MessageHandler)\r\n-\t ************************************************************************/\r\n+        // if runtime exception is thrown, this will\r\n+        public static final ExpressionFactory ELFactory = getELFactory();\r\n+\r\n+        /*************************************************************************\r\n+         * Get an implementation of the ExpressionFactory. This uses the\r\n+         * Java service lookup mechanism to find a proper implementation.\r\n+         * If none if available we do not support EL filters.\r\n+         ************************************************************************/\r\n+        private static final ExpressionFactory getELFactory(){\r\n+            try {\r\n+                return ExpressionFactory.newInstance();\r\n+            } catch (RuntimeException e) {\r\n+                return null;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    public static final boolean isELAvailable(){\r\n+        return ExpressionFactoryHolder.ELFactory != null;\r\n+    }\r\n+\r\n+    public static final ExpressionFactory ELFactory(){\r\n+        return ExpressionFactoryHolder.ELFactory;\r\n+    }\r\n+\r\n+    /**\r\n+     * Accepts a message if the associated EL expression of the message handler resolves to 'true'\r\n+     *\r\n+     * @param message the message to be handled by the handler\r\n+     * @param  metadata the metadata object which describes the message handler\r\n+     * @return\r\n+     */\r\n \t@Override\r\n \tpublic boolean accepts(Object message, MessageHandler metadata) {\r\n \t\tString expression = metadata.getCondition();\r\n-\t\tif (expression == null || expression.trim().length() == 0) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t\tif (elFactory == null) {\r\n-\t\t\t// TODO should we test this some where earlier? Perhaps in MessageHandler.validate()  ?\r\n-\t\t\tthrow new IllegalStateException(\"A handler uses an EL filter but no EL implementation is available.\");\r\n-\t\t}\r\n-\t\t\r\n-\t\texpression = cleanupExpression(expression);\r\n-\t\t\r\n-\t\tEventContext context = new EventContext();\r\n-\t\tcontext.bindToEvent(message);\r\n-\t\t\r\n+\t\tStandardELResolutionContext context = new StandardELResolutionContext(message);\r\n \t\treturn evalExpression(expression, context);\r\n \t}\r\n \r\n-\t/*************************************************************************\r\n-\t * @param expression\r\n-\t * @param context\r\n-\t * @return\r\n-\t ************************************************************************/\r\n-\t\r\n-\tprivate boolean evalExpression(String expression, EventContext context) {\r\n-\t\tValueExpression ve = elFactory.createValueExpression(context, expression, Boolean.class);\r\n-\t\tObject result = ve.getValue(context);\r\n-\t\tif (!(result instanceof Boolean)) {\r\n-\t\t\tthrow new IllegalStateException(\"A handler uses an EL filter but the output is not \\\"true\\\" or \\\"false\\\".\");\r\n-\t\t}\r\n-\t\treturn (Boolean)result;\r\n-\t}\r\n-\r\n-\t/*************************************************************************\r\n-\t * Make it a valid expression because the parser expects it like this.\r\n-\t * @param expression\r\n-\t * @return\r\n-\t ************************************************************************/\r\n-\t\r\n-\tprivate String cleanupExpression(String expression) {\r\n-\t\t \r\n-\t\tif (!expression.trim().startsWith(\"${\") && !expression.trim().startsWith(\"#{\")) {\r\n-\t\t\texpression = \"${\"+expression+\"}\";\r\n-\t\t}\r\n-\t\treturn expression;\r\n-\t}\r\n-\r\n-\t/*************************************************************************\r\n-\t * @return the one and only\r\n-\t ************************************************************************/\r\n-\t\r\n-\tpublic static synchronized ElFilter getInstance() {\r\n-\t\treturn instance;\r\n+\tprivate boolean evalExpression(String expression, StandardELResolutionContext context) {\r\n+\t\tValueExpression ve = ELFactory().createValueExpression(context, expression, Boolean.class);\r\n+\t\ttry{\r\n+            Object result = ve.getValue(context);\r\n+            return (Boolean)result;\r\n+             }\r\n+        catch(Throwable exception){\r\n+            // TODO: BusRuntime should be available in this filter to propagate resolution errors\r\n+            // -> this is generally a good feature for filters\r\n+            return false;\r\n+            //throw new IllegalStateException(\"A handler uses an EL filter but the output is not \\\"true\\\" or \\\"false\\\".\");\r\n+        }\r\n \t}\r\n \r\n }\r\n"
    },
    {
        "commit hash": "7c0c0b6f825d98793525595a7be5ed43f6b99e43",
        "previous commit hash": "86bdcad3364acfda93b04e3ba386db6da99e8a5a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/el/EventContext.java",
            "additions": 0,
            "deletions": 102
        },
        "diff content": "@@ -1,102 +0,0 @@\n-package net.engio.mbassy.dispatch.el;\r\n-\r\n-import java.lang.reflect.Method;\r\n-\r\n-import javax.el.BeanELResolver;\r\n-import javax.el.CompositeELResolver;\r\n-import javax.el.ELContext;\r\n-import javax.el.ELResolver;\r\n-import javax.el.FunctionMapper;\r\n-import javax.el.ValueExpression;\r\n-import javax.el.VariableMapper;\r\n-\r\n-/*****************************************************************************\r\n- * An EL context that knows how to resolve everything from a \r\n- * given message but event.\r\n- ****************************************************************************/\r\n-\r\n-public class EventContext extends ELContext {\r\n-\r\n-\tprivate final CompositeELResolver resolver;\r\n-\tprivate final FunctionMapper functionMapper;\r\n-\tprivate final VariableMapper variableMapper;\r\n-\tprivate RootResolver rootResolver;\r\n-\r\n-\t/*************************************************************************\r\n-\t * Constructor\r\n-\t * \r\n-\t * @param me\r\n-\t ************************************************************************/\r\n-\r\n-\tpublic EventContext() {\r\n-\t\tsuper();\r\n-\t\tthis.functionMapper = new NoopFunctionMapper();\r\n-\t\tthis.variableMapper = new NoopMapperImpl();\r\n-\t\t\r\n-\t\tthis.resolver = new CompositeELResolver();\r\n-\t\tthis.rootResolver = new RootResolver();\r\n-\t\tthis.resolver.add(rootResolver);\r\n-\t\tthis.resolver.add(new BeanELResolver(true));\r\n-\t}\r\n-\t\r\n-\t /*************************************************************************\r\n-\t * Binds an event object with the EL expression. This will allow access\r\n-\t * to all properties of a given event.\r\n-\t * @param event to bind.\r\n-\t ************************************************************************/\r\n-\t\r\n-\tpublic void bindToEvent(Object event) {\r\n-\t\t this.rootResolver.setRoot(event);\r\n-\t }\r\n-\r\n-\t/*************************************************************************\r\n-\t * The resolver for the event object.\r\n-\t * @see javax.el.ELContext#getELResolver()\r\n-\t ************************************************************************/\r\n-\t@Override\r\n-\tpublic ELResolver getELResolver() {\r\n-\t\treturn this.resolver;\r\n-\t}\r\n-\r\n-\t/*************************************************************************\r\n-\t * @see javax.el.ELContext#getFunctionMapper()\r\n-\t ************************************************************************/\r\n-\t@Override\r\n-\tpublic FunctionMapper getFunctionMapper() {\r\n-\t\treturn this.functionMapper;\r\n-\t}\r\n-\r\n-\t/*************************************************************************\r\n-\t * @see javax.el.ELContext#getVariableMapper()\r\n-\t ************************************************************************/\r\n-\t@Override\r\n-\tpublic VariableMapper getVariableMapper() {\r\n-\t\treturn this.variableMapper;\r\n-\t}\r\n-\r\n-\t/*****************************************************************************\r\n-\t *  Dummy implementation.\r\n-\t ****************************************************************************/\r\n-\t\r\n-\tprivate class NoopMapperImpl extends VariableMapper {\r\n-\t\tpublic ValueExpression resolveVariable(String s) {\r\n-\t\t\treturn null;\r\n-\t\t}\r\n-\r\n-\t\tpublic ValueExpression setVariable(String s,\r\n-\t\t\t\tValueExpression valueExpression) {\r\n-\t\t\treturn null;\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t/*****************************************************************************\r\n-\t *  Dummy implementation.\r\n-\t ****************************************************************************/\r\n-\t\r\n-\tprivate class NoopFunctionMapper extends FunctionMapper {\r\n-\t\tpublic Method resolveFunction(String s, String s1) {\r\n-\t\t\treturn null;\r\n-\t\t}\r\n-\t}\r\n-\r\n-}\r\n"
    },
    {
        "commit hash": "7c0c0b6f825d98793525595a7be5ed43f6b99e43",
        "previous commit hash": "86bdcad3364acfda93b04e3ba386db6da99e8a5a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/el/RootResolver.java",
            "additions": 0,
            "deletions": 89
        },
        "diff content": "@@ -1,89 +0,0 @@\n-package net.engio.mbassy.dispatch.el;\r\n-\r\n-import java.beans.FeatureDescriptor;\r\n-import java.util.Iterator;\r\n-\r\n-import javax.el.ELContext;\r\n-import javax.el.ELResolver;\r\n-\r\n-/*****************************************************************************\r\n- * A resolver that will resolve the \"msg\" variable to the event object that \r\n- * is posted.\r\n- ****************************************************************************/\r\n-\r\n-public class RootResolver extends ELResolver {\r\n-\r\n-\tprivate static final String ROOT_VAR_NAME = \"msg\";\r\n-\tpublic Object rootObject; \r\n-\t\r\n-\t/*************************************************************************\r\n-\t * @param rootObject\r\n-\t ************************************************************************/\r\n-\t\r\n-\tpublic void setRoot(Object rootObject) {\r\n-\t\tthis.rootObject = rootObject;\r\n-\t}\r\n-\t\r\n-\t/*************************************************************************\r\n-\t * getValue\r\n-\t * @see javax.el.ELResolver#getValue(javax.el.ELContext, java.lang.Object, java.lang.Object)\r\n-\t ************************************************************************/\r\n-\t@Override\r\n-\tpublic Object getValue(ELContext context, Object base, Object property) {\r\n-\t\tif (context == null) {\r\n-\t\t\tthrow new NullPointerException();\r\n-\t\t}\r\n-\t\tif (base == null && ROOT_VAR_NAME.equals(property)) {\r\n-\t\t\tcontext.setPropertyResolved(true);\r\n-\t\t\treturn this.rootObject;\r\n-\t\t}\r\n-\t\treturn null;\r\n-\t}\r\n-\r\n-\t\r\n-\t/*************************************************************************\r\n-\t * getCommonPropertyType\r\n-\t * @see javax.el.ELResolver#getCommonPropertyType(javax.el.ELContext, java.lang.Object)\r\n-\t ************************************************************************/\r\n-\t@Override\r\n-\tpublic Class<?> getCommonPropertyType(ELContext context, Object base) {\r\n-\t\treturn String.class;\r\n-\t}\r\n-\r\n-\t/*************************************************************************\r\n-\t * getFeatureDescriptors\r\n-\t * @see javax.el.ELResolver#getFeatureDescriptors(javax.el.ELContext, java.lang.Object)\r\n-\t ************************************************************************/\r\n-\t@Override\r\n-\tpublic Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext context, Object base) {\r\n-\t\treturn null;\r\n-\t}\r\n-\r\n-\t/*************************************************************************\r\n-\t * getType\r\n-\t * @see javax.el.ELResolver#getType(javax.el.ELContext, java.lang.Object, java.lang.Object)\r\n-\t ************************************************************************/\r\n-\t@Override\r\n-\tpublic Class<?> getType(ELContext context, Object base, Object property) {\r\n-\t\treturn null;\r\n-\t}\r\n-\r\n-\t/*************************************************************************\r\n-\t * isReadOnly\r\n-\t * @see javax.el.ELResolver#isReadOnly(javax.el.ELContext, java.lang.Object, java.lang.Object)\r\n-\t ************************************************************************/\r\n-\t@Override\r\n-\tpublic boolean isReadOnly(ELContext context, Object base, Object property) {\r\n-\t\treturn true;\r\n-\t}\r\n-\r\n-\t/*************************************************************************\r\n-\t * setValue\r\n-\t * @see javax.el.ELResolver#setValue(javax.el.ELContext, java.lang.Object, java.lang.Object, java.lang.Object)\r\n-\t ************************************************************************/\r\n-\t@Override\r\n-\tpublic void setValue(ELContext context, Object base, Object property, Object value) {\r\n-\t\t// Do nothing\r\n-\t}\r\n-\r\n-}\r\n"
    },
    {
        "commit hash": "7c0c0b6f825d98793525595a7be5ed43f6b99e43",
        "previous commit hash": "86bdcad3364acfda93b04e3ba386db6da99e8a5a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/el/StandardELResolutionContext.java",
            "additions": 92,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,92 @@\n+package net.engio.mbassy.dispatch.el;\n+\n+import javax.el.*;\n+import java.lang.reflect.Method;\n+\n+/**\n+ *  This ELContext implementation provides support for standard BeanEL resolution in conditional message handlers.\n+ *  The message parameter of the message handlers is bound to 'msg' such that it can be referenced int the EL expressions.\n+ *\n+ *  Example:\n+ *  @Handler(condition = \"msg.type == 'onClick'\")\n+ *  public void handle(ButtonEvent event)\n+ *\n+ */\n+public class StandardELResolutionContext extends ELContext {\n+\n+\tprivate final ELResolver resolver;\n+\tprivate final FunctionMapper functionMapper;\n+\tprivate final VariableMapper variableMapper;\n+    private final Object message;\n+\n+\n+\tpublic StandardELResolutionContext(Object message) {\n+\t\tsuper();\n+        this.message = message;\n+\t\tthis.functionMapper = new NoopFunctionMapper();\n+\t\tthis.variableMapper = new MsgMapper();\n+        // Composite resolver not necessary as the only resolution type currently supported is standard BeanEL\n+\t\t//this.resolver = new CompositeELResolver();\n+        this.resolver = new BeanELResolver(true);\n+\t}\n+\t\n+\n+\n+\t/*************************************************************************\n+\t * The resolver for the event object.\n+\t * @see javax.el.ELContext#getELResolver()\n+\t ************************************************************************/\n+\t@Override\n+\tpublic ELResolver getELResolver() {\n+\t\treturn this.resolver;\n+\t}\n+\n+\t/*************************************************************************\n+\t * @see javax.el.ELContext#getFunctionMapper()\n+\t ************************************************************************/\n+\t@Override\n+\tpublic FunctionMapper getFunctionMapper() {\n+\t\treturn this.functionMapper;\n+\t}\n+\n+\t/*************************************************************************\n+\t * @see javax.el.ELContext#getVariableMapper()\n+\t ************************************************************************/\n+\t@Override\n+\tpublic VariableMapper getVariableMapper() {\n+\t\treturn this.variableMapper;\n+\t}\n+\n+    /**\n+     * This mapper resolves the variable identifies \"msg\" to the message\n+     * object of the current handler invocation\n+     */\n+\tprivate class MsgMapper extends VariableMapper {\n+        private static final String msg = \"msg\";\n+        // reuse the same expression as it always resolves to the same object\n+        private final ValueExpression msgExpression = ElFilter.ELFactory().createValueExpression(message, message.getClass());\n+\n+\t\tpublic ValueExpression resolveVariable(final String s) {\n+            // resolve 'msg' to the message object of the handler invocation\n+            return !s.equals(msg) ? null : msgExpression;\n+\t\t}\n+\n+\t\tpublic ValueExpression setVariable(String s,\n+\t\t\t\tValueExpression valueExpression) {\n+            // not necessary - the mapper resolves only \"msg\" and nothing else\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+    /**\n+     * This function mapper does nothing, i.e. custom EL functions are not\n+     * supported by default. It may be supported in the future to pass in\n+     * custom function mappers at bus instanciation time.\n+     */\n+\tprivate class NoopFunctionMapper extends FunctionMapper {\n+\t\tpublic Method resolveFunction(String s, String s1) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+}\n"
    },
    {
        "commit hash": "7c0c0b6f825d98793525595a7be5ed43f6b99e43",
        "previous commit hash": "86bdcad3364acfda93b04e3ba386db6da99e8a5a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandler.java",
            "additions": 27,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.listener;\r\n \r\n import net.engio.mbassy.dispatch.HandlerInvocation;\r\n+import net.engio.mbassy.dispatch.el.ElFilter;\r\n \r\n import java.lang.reflect.Method;\r\n import java.util.HashMap;\r\n@@ -44,6 +45,9 @@ public class MessageHandler {\n             if(handler == null){\r\n                 throw new IllegalArgumentException(\"The message handler configuration may not be null\");\r\n             }\r\n+            if(filter == null){\r\n+                filter = new IMessageFilter[]{};\r\n+            }\r\n             net.engio.mbassy.listener.Enveloped enveloped = handler.getAnnotation(Enveloped.class);\r\n             Class[] handledMessages = enveloped != null\r\n                     ? enveloped.messages()\r\n@@ -51,8 +55,21 @@ public class MessageHandler {\n             handler.setAccessible(true);\r\n             Map<String, Object> properties = new HashMap<String, Object>();\r\n             properties.put(HandlerMethod, handler);\r\n-            properties.put(Filter, filter != null ? filter : new IMessageFilter[]{});\r\n-            properties.put(Condition, handlerConfig.condition());\r\n+            // add EL filter if a condition is present\r\n+            if(handlerConfig.condition() != null){\r\n+                if (!ElFilter.isELAvailable()) {\r\n+                    throw new IllegalStateException(\"A handler uses an EL filter but no EL implementation is available.\");\r\n+                }\r\n+\r\n+                IMessageFilter[] expandedFilter = new IMessageFilter[filter.length + 1];\r\n+                for(int i = 0; i < filter.length ; i++){\r\n+                   expandedFilter[i] = filter[i];\r\n+                }\r\n+                expandedFilter[filter.length] = new ElFilter();\r\n+                filter = expandedFilter;\r\n+            }\r\n+            properties.put(Filter, filter);\r\n+            properties.put(Condition, cleanEL(handlerConfig.condition()));\r\n             properties.put(Priority, handlerConfig.priority());\r\n             properties.put(Invocation, handlerConfig.invocation());\r\n             properties.put(InvocationMode, handlerConfig.delivery());\r\n@@ -63,6 +80,14 @@ public class MessageHandler {\n             properties.put(HandledMessages, handledMessages);\r\n             return properties;\r\n         }\r\n+\r\n+        private static String cleanEL(String expression) {\r\n+\r\n+            if (!expression.trim().startsWith(\"${\") && !expression.trim().startsWith(\"#{\")) {\r\n+                expression = \"${\"+expression+\"}\";\r\n+            }\r\n+            return expression;\r\n+        }\r\n     }\r\n \r\n \r\n"
    },
    {
        "commit hash": "7c0c0b6f825d98793525595a7be5ed43f6b99e43",
        "previous commit hash": "86bdcad3364acfda93b04e3ba386db6da99e8a5a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConditionTest.java",
            "additions": 48,
            "deletions": 13
        },
        "diff content": "@@ -3,10 +3,16 @@ package net.engio.mbassy;\n import net.engio.mbassy.bus.MBassador;\r\n import net.engio.mbassy.bus.config.BusConfiguration;\r\n import net.engio.mbassy.common.MessageBusTest;\r\n+import net.engio.mbassy.listener.Enveloped;\r\n import net.engio.mbassy.listener.Handler;\r\n-\r\n+import net.engio.mbassy.listener.Listener;\r\n+import net.engio.mbassy.listener.References;\r\n+import net.engio.mbassy.subscription.MessageEnvelope;\r\n import org.junit.Test;\r\n \r\n+import java.util.HashSet;\r\n+import java.util.Set;\r\n+\r\n /*****************************************************************************\r\n  * Some unit tests for the \"condition\" filter.\r\n  ****************************************************************************/\r\n@@ -15,7 +21,7 @@ public class ConditionTest extends MessageBusTest {\n \r\n \tpublic static class TestEvent {\r\n \r\n-\t\tpublic Object result;\r\n+\t\tprivate Set<String> handledBy = new HashSet<String>();\r\n \t\tprivate String type;\r\n \t\tprivate int size;\r\n \r\n@@ -32,34 +38,57 @@ public class ConditionTest extends MessageBusTest {\n \t\tpublic int getSize() {\r\n \t\t\treturn size;\r\n \t\t}\r\n+\r\n+        public boolean wasHandledBy(String ...handlers){\r\n+            for(String handler : handlers){\r\n+                if (!handledBy.contains(handler)) return false;\r\n+            }\r\n+            return true;\r\n+        }\r\n+\r\n+        public void handledBy(String handler){\r\n+            handledBy.add(handler);\r\n+        }\r\n \t\t\r\n \t}\r\n \r\n+    @Listener(references = References.Strong)\r\n \tpublic static class ConditionalMessageListener {\r\n \r\n \t\t@Handler(condition = \"msg.type == 'TEST'\")\r\n \t\tpublic void handleTypeMessage(TestEvent message) {\r\n-\t\t\tmessage.result = \"handleTypeMessage\";\r\n+\t\t\tmessage.handledBy(\"handleTypeMessage\");\r\n \t\t}\r\n \r\n \t\t@Handler(condition = \"msg.size > 4\")\r\n \t\tpublic void handleSizeMessage(TestEvent message) {\r\n-\t\t\tmessage.result = \"handleSizeMessage\";\r\n+\t\t\tmessage.handledBy(\"handleSizeMessage\");\r\n \t\t}\r\n+\r\n+        @Handler(condition = \"msg.foo > 4\")\r\n+        public void handleInvalidEL(TestEvent message) {\r\n+            message.handledBy(\"handleInvalidEL\");\r\n+        }\r\n \t\t\r\n \t\t@Handler(condition = \"msg.size > 2 && msg.size < 4\")\r\n \t\tpublic void handleCombinedEL(TestEvent message) {\r\n-\t\t\tmessage.result = \"handleCombinedEL\";\r\n+\t\t\tmessage.handledBy( \"handleCombinedEL\");\r\n \t\t}\r\n \t\t\r\n \t\t@Handler(condition = \"msg.getType().equals('XYZ') && msg.getSize() == 1\")\r\n \t\tpublic void handleMethodAccessEL(TestEvent message) {\r\n-\t\t\tmessage.result = \"handleMethodAccessEL\";\r\n+\t\t\tmessage.handledBy(\"handleMethodAccessEL\");\r\n \t\t}\r\n \r\n+        @Handler(condition = \"msg.type == 'TEST'\")\r\n+        @Enveloped(messages = {TestEvent.class, Object.class})\r\n+        public void handleEnvelopedMessage(MessageEnvelope envelope) {\r\n+            envelope.<TestEvent>getMessage().handledBy(\"handleEnvelopedMessage\");\r\n+        }\r\n \t\t\r\n \t}\r\n \r\n+\r\n \t/*************************************************************************\r\n \t * @throws Exception\r\n \t ************************************************************************/\r\n@@ -71,9 +100,11 @@ public class ConditionTest extends MessageBusTest {\n \t\tTestEvent message = new TestEvent(\"TEST\", 0);\r\n \t\tbus.publish(message);\r\n \r\n-\t\tassertEquals(\"handleTypeMessage\", message.result);\r\n+\t\tassertTrue(message.wasHandledBy(\"handleTypeMessage\", \"handleEnvelopedMessage\"));\r\n+        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\r\n \t}\r\n-\t\r\n+\r\n+\r\n \t/*************************************************************************\r\n \t * @throws Exception\r\n \t ************************************************************************/\r\n@@ -85,7 +116,8 @@ public class ConditionTest extends MessageBusTest {\n \t\tTestEvent message = new TestEvent(\"\", 5);\r\n \t\tbus.publish(message);\r\n \r\n-\t\tassertEquals(\"handleSizeMessage\", message.result);\r\n+\t\tassertTrue(message.wasHandledBy(\"handleSizeMessage\"));\r\n+        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\r\n \t}\r\n \t\r\n \t/*************************************************************************\r\n@@ -99,7 +131,8 @@ public class ConditionTest extends MessageBusTest {\n \t\tTestEvent message = new TestEvent(\"\", 3);\r\n \t\tbus.publish(message);\r\n \r\n-\t\tassertEquals(\"handleCombinedEL\", message.result);\r\n+        assertTrue(message.wasHandledBy(\"handleCombinedEL\"));\r\n+        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\r\n \t}\r\n \t\r\n \t/*************************************************************************\r\n@@ -113,7 +146,7 @@ public class ConditionTest extends MessageBusTest {\n \t\tTestEvent message = new TestEvent(\"\", 0);\r\n \t\tbus.publish(message);\r\n \r\n-\t\tassertTrue(message.result == null);\r\n+\t\tassertTrue(message.handledBy.isEmpty());\r\n \t}\r\n \t\r\n \t/*************************************************************************\r\n@@ -127,7 +160,9 @@ public class ConditionTest extends MessageBusTest {\n \t\tTestEvent message = new TestEvent(\"XYZ\", 1);\r\n \t\tbus.publish(message);\r\n \r\n-\t\tassertEquals(\"handleMethodAccessEL\", message.result);\r\n-\t}\r\n+        assertTrue(message.wasHandledBy(\"handleMethodAccessEL\"));\r\n+        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\r\n+\r\n+    }\r\n \r\n }\r\n"
    },
    {
        "commit hash": "7c0c0b6f825d98793525595a7be5ed43f6b99e43",
        "previous commit hash": "86bdcad3364acfda93b04e3ba386db6da99e8a5a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -29,6 +29,7 @@ public abstract class MessageBusTest extends AssertSupport {\n     protected static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n         @Override\n         public void handleError(PublicationError error) {\n+            error.getCause().printStackTrace();\n             Assert.fail();\n         }\n     };\n"
    },
    {
        "commit hash": "cf104666c6e660c6ecf82136a90d18c3b71a4806",
        "previous commit hash": "752feca1c2e7a6b3ad0d1c87f9b707c2861ac51e",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 0
        },
        "diff content": "@@ -91,12 +91,14 @@\n         \t<artifactId>juel-impl</artifactId>\r\n         \t<version>2.2.7</version>\r\n         \t<scope>runtime</scope>\r\n+        \t<optional>true</optional>\r\n         </dependency>\r\n         <dependency>\r\n         \t<groupId>de.odysseus.juel</groupId>\r\n         \t<artifactId>juel-spi</artifactId>\r\n         \t<version>2.2.7</version>\r\n         \t<scope>runtime</scope>\r\n+        \t<optional>true</optional>\r\n         </dependency>\r\n     </dependencies>\r\n \r\n"
    },
    {
        "commit hash": "79323c55cfb791a191d6ef9a94f9fe9459327f9e",
        "previous commit hash": "de9515ed7d3576c38c1f5b161c5982dfe345bccb",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -11,7 +11,7 @@ Read this documentation to get an overview of MBassadors features. There is also\n not enough to make a developer happy (work is in progress).\n Additionally, you can browse the [javadoc](http://bennidi.github.io/mbassador/)\n \n-The current version is 1.1.9 and it is available from the Maven Central Repository. See the release notes for more details.\n+The current version is 1.1.10 and it is available from the Maven Central Repository. See the release notes for more details.\n \n There is also an extension available to support CDI-like transactional message sending in a Spring environment. It's beta but\n stable enough to give it a try. See <a href=\"https://github.com/bennidi/mbassador-spring\" target=\"_blank\">here</a>.\n@@ -143,7 +143,7 @@ Beginning with version 1.1.0 MBassador is available from the Maven Central Repos\n     <dependency>\n         <groupId>net.engio</groupId>\n         <artifactId>mbassador</artifactId>\n-        <version>1.1.9</version>\n+        <version>1.1.10</version>\n     </dependency>\n ```\n \n"
    },
    {
        "commit hash": "752feca1c2e7a6b3ad0d1c87f9b707c2861ac51e",
        "previous commit hash": "e170301c2c591dc3289909f2d3ea2ab10e293753",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConditionTest.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -37,7 +37,7 @@ public class ConditionTest extends MessageBusTest {\n \r\n \tpublic static class ConditionalMessageListener {\r\n \r\n-\t\t@Handler(condition = \"msg.type == \\\"TEST\\\"\")\r\n+\t\t@Handler(condition = \"msg.type == 'TEST'\")\r\n \t\tpublic void handleTypeMessage(TestEvent message) {\r\n \t\t\tmessage.result = \"handleTypeMessage\";\r\n \t\t}\r\n@@ -52,7 +52,7 @@ public class ConditionTest extends MessageBusTest {\n \t\t\tmessage.result = \"handleCombinedEL\";\r\n \t\t}\r\n \t\t\r\n-\t\t@Handler(condition = \"msg.getType().equals(\\\"XYZ\\\") && msg.getSize() == 1\")\r\n+\t\t@Handler(condition = \"msg.getType().equals('XYZ') && msg.getSize() == 1\")\r\n \t\tpublic void handleMethodAccessEL(TestEvent message) {\r\n \t\t\tmessage.result = \"handleMethodAccessEL\";\r\n \t\t}\r\n"
    },
    {
        "commit hash": "e170301c2c591dc3289909f2d3ea2ab10e293753",
        "previous commit hash": "de9515ed7d3576c38c1f5b161c5982dfe345bccb",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 278,
            "deletions": 261
        },
        "diff content": "@@ -1,261 +1,278 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-\n-    <parent>\n-        <groupId>org.sonatype.oss</groupId>\n-        <artifactId>oss-parent</artifactId>\n-        <version>7</version>\n-    </parent>\n-\n-    <modelVersion>4.0.0</modelVersion>\n-    <groupId>net.engio</groupId>\n-    <artifactId>mbassador</artifactId>\n-    <version>1.1.11-SNAPSHOT</version>\n-    <packaging>bundle</packaging>\n-    <name>mbassador</name>\n-    <description>\n-        Mbassador is a fast and flexible message bus system following the publish subscribe pattern.\n-        It is designed for ease of use and aims to be feature rich and extensible\n-        while preserving resource efficiency and performance.\n-\n-        It features:\n-        declarative handler definition via annotations,\n-        sync and/or async message delivery,\n-        weak-references,\n-        message filtering,\n-        ordering of message handlers etc.\n-    </description>\n-\n-    <url>https://github.com/bennidi/mbassador</url>\n-    <licenses>\n-        <license>\n-            <name>MIT license</name>\n-            <url>http://www.opensource.org/licenses/mit-license.php</url>\n-        </license>\n-    </licenses>\n-    <scm>\n-        <url>git@github.com:bennidi/mbassador.git</url>\n-        <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.4</tag>\n-        <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n-  </scm>\n-    <developers>\n-\n-        <developer>\n-            <id>bennidi</id>\n-            <name>Benjamin Diedrichsen</name>\n-            <timezone>+1</timezone>\n-            <email>b.diedrichsen@googlemail.com</email>\n-        </developer>\n-    </developers>\n-\n-    <properties>\n-        <nazgul-codestyle.version>2.0.1</nazgul-codestyle.version>\n-        <jdk.version>1.6</jdk.version>\n-        <pmd.plugin.version>3.0.1</pmd.plugin.version>\n-\n-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-        <project.build.java.version>1.6</project.build.java.version>\n-        <github.url>file://${project.basedir}/mvn-local-repo</github.url>\n-    </properties>\n-\n-    <dependencies>\n-\n-        <dependency>\n-            <groupId>junit</groupId>\n-            <artifactId>junit</artifactId>\n-            <version>4.10</version>\n-            <scope>test</scope>\n-        </dependency>\n-\n-        <dependency>\n-            <groupId>org.slf4j</groupId>\n-            <artifactId>slf4j-api</artifactId>\n-            <version>1.7.5</version>\n-            <scope>test</scope>\n-        </dependency>\n-\n-        <dependency>\n-            <groupId>org.slf4j</groupId>\n-            <artifactId>slf4j-log4j12</artifactId>\n-            <version>1.7.5</version>\n-            <scope>test</scope>\n-        </dependency>\n-\n-    </dependencies>\n-\n-    <!--  Local repository (for testing)\n-    <distributionManagement>\n-        <repository>\n-            <id>mbassador-github-repo</id>\n-            <url>${github.url}</url>\n-        </repository>\n-    </distributionManagement>\n-    -->\n-\n-    <build>\n-        <plugins>\n-            <!-- plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-pmd-plugin</artifactId>\n-                <version>${pmd.plugin.version}</version>\n-                <configuration>\n-                    <excludeRoots>\n-                        <excludeRoot>src/main/generated</excludeRoot>\n-                        <excludeRoot>src/test</excludeRoot>\n-                    </excludeRoots>\n-                    <rulesets>\n-                        <ruleset>/codestyle/pmd-rules.xml</ruleset>\n-                    </rulesets>\n-                    <targetJdk>${jdk.version}</targetJdk>\n-                    <sourceEncoding>${project.build.sourceEncoding}</sourceEncoding>\n-                </configuration>\n-                <executions>\n-                    <execution>\n-                        <goals>\n-                            <goal>check</goal>\n-                            <goal>cpd-check</goal>\n-                        </goals>\n-                    </execution>\n-                </executions>\n-                <dependencies>\n-                    <dependency>\n-                        <groupId>se.jguru.nazgul.tools.codestyle</groupId>\n-                        <artifactId>nazgul-codestyle</artifactId>\n-                        <version>${nazgul-codestyle.version}</version>\n-                    </dependency>\n-                </dependencies>\n-            </plugin -->\n-\n-            <plugin>\n-                <groupId>org.apache.felix</groupId>\n-                <artifactId>maven-bundle-plugin</artifactId>\n-                <version>2.3.7</version>\n-                <extensions>true</extensions>\n-                <configuration>\n-                    <instructions>\n-                        <Bundle-SymbolicName>${project.groupId}.${project.artifactId}</Bundle-SymbolicName>\n-                        <Export-Package>{local-packages}</Export-Package>\n-                    </instructions>\n-                </configuration>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>${project.build.java.version}</source>\n-                    <target>${project.build.java.version}</target>\n-                </configuration>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-release-plugin</artifactId>\n-                <version>2.4</version>\n-                <configuration>\n-                    <mavenExecutorId>forked-path</mavenExecutorId>\n-                </configuration>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-surefire-plugin</artifactId>\n-                <configuration>\n-                    <skipTests>false</skipTests>\n-                    <excludes>\n-                        <!-- exclude the suite which is a convenience class for running all tests from IDE or using scripts -->\n-                        <exclude>AllTests.java</exclude>\n-                    </excludes>\n-                </configuration>\n-            </plugin>\n-\n-            <!-- bind the source attaching to package phase -->\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-source-plugin</artifactId>\n-                <executions>\n-                    <execution>\n-                        <id>attach-sources</id>\n-                        <goals>\n-                            <goal>jar</goal>\n-                        </goals>\n-                    </execution>\n-                </executions>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-javadoc-plugin</artifactId>\n-                <executions>\n-                    <execution>\n-                        <id>attach-javadocs</id>\n-                        <goals>\n-                            <goal>jar</goal>\n-                        </goals>\n-                    </execution>\n-                </executions>\n-            </plugin>\n-\n-\t<!-- \n-\tThese two plugins take care of building and publishing the javadoc, using\n-\t\tmvn clean javadoc:javadoc scm-publish:publish-scm\n-\t --> \n-\t<plugin>\n-\t    <groupId>org.apache.maven.plugins</groupId>\n-\t    <artifactId>maven-javadoc-plugin</artifactId>\n-\t    <version>2.9.1</version>\n-\t    <configuration>\n-\t\t<aggregate>true</aggregate>\n-\t\t<show>public</show>\n-\t\t<nohelp>true</nohelp>\n-\t\t<header>mbassador, ${project.version}</header>\n-\t\t<footer>mbassador, ${project.version}</footer>\n-\t\t<doctitle>mbassador, ${project.version}</doctitle>\n-\t    </configuration>\n-\t</plugin>\n-\t<plugin>\n-\t    <groupId>org.apache.maven.plugins</groupId>\n-\t    <artifactId>maven-scm-publish-plugin</artifactId>\n-\t    <version>1.0-beta-2</version>\n-\t    <configuration>\n-\t\t<checkoutDirectory>${project.build.directory}/scmpublish</checkoutDirectory>\n-\t\t<checkinComment>Publishing javadoc for ${project.artifactId}:${project.version}</checkinComment>\n-\t\t<content>${project.reporting.outputDirectory}/apidocs</content>\n-\t\t<skipDeletedFiles>true</skipDeletedFiles>\n-\t\t<pubScmUrl>scm:git:git@github.com:bennidi/mbassador.git</pubScmUrl>\n-\t\t<scmBranch>gh-pages</scmBranch> <!-- branch with static site on github-->\n-\t    </configuration>\n-\t</plugin>\n-        </plugins>\n-    </build>\n-\n-    <profiles>\n-        <profile>\n-            <id>release-sign-artifacts</id>\n-            <activation>\n-                <property>\n-                    <name>performRelease</name>\n-                    <value>true</value>\n-                </property>\n-            </activation>\n-            <build>\n-                <plugins>\n-                    <plugin>\n-                        <groupId>org.apache.maven.plugins</groupId>\n-                        <artifactId>maven-gpg-plugin</artifactId>\n-                        <version>1.4</version>\n-                        <executions>\n-                            <execution>\n-                                <id>sign-artifacts</id>\n-                                <phase>verify</phase>\n-                                <goals>\n-                                    <goal>sign</goal>\n-                                </goals>\n-                            </execution>\n-                        </executions>\n-                    </plugin>\n-                </plugins>\n-            </build>\n-        </profile>\n-    </profiles>\n-</project>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\r\n+\r\n+    <parent>\r\n+        <groupId>org.sonatype.oss</groupId>\r\n+        <artifactId>oss-parent</artifactId>\r\n+        <version>7</version>\r\n+    </parent>\r\n+\r\n+    <modelVersion>4.0.0</modelVersion>\r\n+    <groupId>net.engio</groupId>\r\n+    <artifactId>mbassador</artifactId>\r\n+    <version>1.1.11-SNAPSHOT</version>\r\n+    <packaging>bundle</packaging>\r\n+    <name>mbassador</name>\r\n+    <description>\r\n+        Mbassador is a fast and flexible message bus system following the publish subscribe pattern.\r\n+        It is designed for ease of use and aims to be feature rich and extensible\r\n+        while preserving resource efficiency and performance.\r\n+\r\n+        It features:\r\n+        declarative handler definition via annotations,\r\n+        sync and/or async message delivery,\r\n+        weak-references,\r\n+        message filtering,\r\n+        ordering of message handlers etc.\r\n+    </description>\r\n+\r\n+    <url>https://github.com/bennidi/mbassador</url>\r\n+    <licenses>\r\n+        <license>\r\n+            <name>MIT license</name>\r\n+            <url>http://www.opensource.org/licenses/mit-license.php</url>\r\n+        </license>\r\n+    </licenses>\r\n+    <scm>\r\n+        <url>git@github.com:bennidi/mbassador.git</url>\r\n+        <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\r\n+        <tag>mbassador-1.1.4</tag>\r\n+        <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\r\n+  </scm>\r\n+    <developers>\r\n+\r\n+        <developer>\r\n+            <id>bennidi</id>\r\n+            <name>Benjamin Diedrichsen</name>\r\n+            <timezone>+1</timezone>\r\n+            <email>b.diedrichsen@googlemail.com</email>\r\n+        </developer>\r\n+    </developers>\r\n+\r\n+    <properties>\r\n+        <nazgul-codestyle.version>2.0.1</nazgul-codestyle.version>\r\n+        <jdk.version>1.6</jdk.version>\r\n+        <pmd.plugin.version>3.0.1</pmd.plugin.version>\r\n+\r\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n+        <project.build.java.version>1.6</project.build.java.version>\r\n+        <github.url>file://${project.basedir}/mvn-local-repo</github.url>\r\n+    </properties>\r\n+\r\n+    <dependencies>\r\n+\r\n+        <dependency>\r\n+            <groupId>junit</groupId>\r\n+            <artifactId>junit</artifactId>\r\n+            <version>4.10</version>\r\n+            <scope>test</scope>\r\n+        </dependency>\r\n+\r\n+        <dependency>\r\n+            <groupId>org.slf4j</groupId>\r\n+            <artifactId>slf4j-api</artifactId>\r\n+            <version>1.7.5</version>\r\n+            <scope>test</scope>\r\n+        </dependency>\r\n+\r\n+        <dependency>\r\n+            <groupId>org.slf4j</groupId>\r\n+            <artifactId>slf4j-log4j12</artifactId>\r\n+            <version>1.7.5</version>\r\n+            <scope>test</scope>\r\n+        </dependency>\r\n+\r\n+        <dependency>\r\n+        \t<groupId>javax.el</groupId>\r\n+        \t<artifactId>el-api</artifactId>\r\n+        \t<version>2.2</version>\r\n+        </dependency>\r\n+        <dependency>\r\n+        \t<groupId>de.odysseus.juel</groupId>\r\n+        \t<artifactId>juel-impl</artifactId>\r\n+        \t<version>2.2.7</version>\r\n+        \t<scope>runtime</scope>\r\n+        </dependency>\r\n+        <dependency>\r\n+        \t<groupId>de.odysseus.juel</groupId>\r\n+        \t<artifactId>juel-spi</artifactId>\r\n+        \t<version>2.2.7</version>\r\n+        \t<scope>runtime</scope>\r\n+        </dependency>\r\n+    </dependencies>\r\n+\r\n+    <!--  Local repository (for testing)\r\n+    <distributionManagement>\r\n+        <repository>\r\n+            <id>mbassador-github-repo</id>\r\n+            <url>${github.url}</url>\r\n+        </repository>\r\n+    </distributionManagement>\r\n+    -->\r\n+\r\n+    <build>\r\n+        <plugins>\r\n+            <!-- plugin>\r\n+                <groupId>org.apache.maven.plugins</groupId>\r\n+                <artifactId>maven-pmd-plugin</artifactId>\r\n+                <version>${pmd.plugin.version}</version>\r\n+                <configuration>\r\n+                    <excludeRoots>\r\n+                        <excludeRoot>src/main/generated</excludeRoot>\r\n+                        <excludeRoot>src/test</excludeRoot>\r\n+                    </excludeRoots>\r\n+                    <rulesets>\r\n+                        <ruleset>/codestyle/pmd-rules.xml</ruleset>\r\n+                    </rulesets>\r\n+                    <targetJdk>${jdk.version}</targetJdk>\r\n+                    <sourceEncoding>${project.build.sourceEncoding}</sourceEncoding>\r\n+                </configuration>\r\n+                <executions>\r\n+                    <execution>\r\n+                        <goals>\r\n+                            <goal>check</goal>\r\n+                            <goal>cpd-check</goal>\r\n+                        </goals>\r\n+                    </execution>\r\n+                </executions>\r\n+                <dependencies>\r\n+                    <dependency>\r\n+                        <groupId>se.jguru.nazgul.tools.codestyle</groupId>\r\n+                        <artifactId>nazgul-codestyle</artifactId>\r\n+                        <version>${nazgul-codestyle.version}</version>\r\n+                    </dependency>\r\n+                </dependencies>\r\n+            </plugin -->\r\n+\r\n+            <plugin>\r\n+                <groupId>org.apache.felix</groupId>\r\n+                <artifactId>maven-bundle-plugin</artifactId>\r\n+                <version>2.3.7</version>\r\n+                <extensions>true</extensions>\r\n+                <configuration>\r\n+                    <instructions>\r\n+                        <Bundle-SymbolicName>${project.groupId}.${project.artifactId}</Bundle-SymbolicName>\r\n+                        <Export-Package>{local-packages}</Export-Package>\r\n+                    </instructions>\r\n+                </configuration>\r\n+            </plugin>\r\n+\r\n+            <plugin>\r\n+                <groupId>org.apache.maven.plugins</groupId>\r\n+                <artifactId>maven-compiler-plugin</artifactId>\r\n+                <configuration>\r\n+                    <source>${project.build.java.version}</source>\r\n+                    <target>${project.build.java.version}</target>\r\n+                </configuration>\r\n+            </plugin>\r\n+\r\n+            <plugin>\r\n+                <groupId>org.apache.maven.plugins</groupId>\r\n+                <artifactId>maven-release-plugin</artifactId>\r\n+                <version>2.4</version>\r\n+                <configuration>\r\n+                    <mavenExecutorId>forked-path</mavenExecutorId>\r\n+                </configuration>\r\n+            </plugin>\r\n+\r\n+            <plugin>\r\n+                <groupId>org.apache.maven.plugins</groupId>\r\n+                <artifactId>maven-surefire-plugin</artifactId>\r\n+                <configuration>\r\n+                    <skipTests>false</skipTests>\r\n+                    <excludes>\r\n+                        <!-- exclude the suite which is a convenience class for running all tests from IDE or using scripts -->\r\n+                        <exclude>AllTests.java</exclude>\r\n+                    </excludes>\r\n+                </configuration>\r\n+            </plugin>\r\n+\r\n+            <!-- bind the source attaching to package phase -->\r\n+            <plugin>\r\n+                <groupId>org.apache.maven.plugins</groupId>\r\n+                <artifactId>maven-source-plugin</artifactId>\r\n+                <executions>\r\n+                    <execution>\r\n+                        <id>attach-sources</id>\r\n+                        <goals>\r\n+                            <goal>jar</goal>\r\n+                        </goals>\r\n+                    </execution>\r\n+                </executions>\r\n+            </plugin>\r\n+\r\n+            <plugin>\r\n+                <groupId>org.apache.maven.plugins</groupId>\r\n+                <artifactId>maven-javadoc-plugin</artifactId>\r\n+                <executions>\r\n+                    <execution>\r\n+                        <id>attach-javadocs</id>\r\n+                        <goals>\r\n+                            <goal>jar</goal>\r\n+                        </goals>\r\n+                    </execution>\r\n+                </executions>\r\n+            </plugin>\r\n+\r\n+\t<!-- \r\n+\tThese two plugins take care of building and publishing the javadoc, using\r\n+\t\tmvn clean javadoc:javadoc scm-publish:publish-scm\r\n+\t --> \r\n+\t<plugin>\r\n+\t    <groupId>org.apache.maven.plugins</groupId>\r\n+\t    <artifactId>maven-javadoc-plugin</artifactId>\r\n+\t    <version>2.9.1</version>\r\n+\t    <configuration>\r\n+\t\t<aggregate>true</aggregate>\r\n+\t\t<show>public</show>\r\n+\t\t<nohelp>true</nohelp>\r\n+\t\t<header>mbassador, ${project.version}</header>\r\n+\t\t<footer>mbassador, ${project.version}</footer>\r\n+\t\t<doctitle>mbassador, ${project.version}</doctitle>\r\n+\t    </configuration>\r\n+\t</plugin>\r\n+\t<plugin>\r\n+\t    <groupId>org.apache.maven.plugins</groupId>\r\n+\t    <artifactId>maven-scm-publish-plugin</artifactId>\r\n+\t    <version>1.0-beta-2</version>\r\n+\t    <configuration>\r\n+\t\t<checkoutDirectory>${project.build.directory}/scmpublish</checkoutDirectory>\r\n+\t\t<checkinComment>Publishing javadoc for ${project.artifactId}:${project.version}</checkinComment>\r\n+\t\t<content>${project.reporting.outputDirectory}/apidocs</content>\r\n+\t\t<skipDeletedFiles>true</skipDeletedFiles>\r\n+\t\t<pubScmUrl>scm:git:git@github.com:bennidi/mbassador.git</pubScmUrl>\r\n+\t\t<scmBranch>gh-pages</scmBranch> <!-- branch with static site on github-->\r\n+\t    </configuration>\r\n+\t</plugin>\r\n+        </plugins>\r\n+    </build>\r\n+\r\n+    <profiles>\r\n+        <profile>\r\n+            <id>release-sign-artifacts</id>\r\n+            <activation>\r\n+                <property>\r\n+                    <name>performRelease</name>\r\n+                    <value>true</value>\r\n+                </property>\r\n+            </activation>\r\n+            <build>\r\n+                <plugins>\r\n+                    <plugin>\r\n+                        <groupId>org.apache.maven.plugins</groupId>\r\n+                        <artifactId>maven-gpg-plugin</artifactId>\r\n+                        <version>1.4</version>\r\n+                        <executions>\r\n+                            <execution>\r\n+                                <id>sign-artifacts</id>\r\n+                                <phase>verify</phase>\r\n+                                <goals>\r\n+                                    <goal>sign</goal>\r\n+                                </goals>\r\n+                            </execution>\r\n+                        </executions>\r\n+                    </plugin>\r\n+                </plugins>\r\n+            </build>\r\n+        </profile>\r\n+    </profiles>\r\n+</project>\r\n"
    },
    {
        "commit hash": "e170301c2c591dc3289909f2d3ea2ab10e293753",
        "previous commit hash": "de9515ed7d3576c38c1f5b161c5982dfe345bccb",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java",
            "additions": 57,
            "deletions": 45
        },
        "diff content": "@@ -1,45 +1,57 @@\n-package net.engio.mbassy.dispatch;\n-\n-import net.engio.mbassy.bus.MessagePublication;\n-import net.engio.mbassy.listener.IMessageFilter;\n-\n-/**\n- * A dispatcher that implements message filtering based on the filter configuration\n- * of the associated message handler. It will delegate message delivery to another\n- * message dispatcher after having performed the filtering logic.\n- *\n- * @author bennidi\n- *         Date: 11/23/12\n- */\n-public class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n-\n-    private final IMessageFilter[] filter;\n-\n-    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\n-        super(dispatcher);\n-        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\n-    }\n-\n-    private boolean passesFilter(Object message) {\n-\n-        if (filter == null) {\n-            return true;\n-        } else {\n-            for (IMessageFilter aFilter : filter) {\n-                if (!aFilter.accepts(message, getContext().getHandlerMetadata())) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-    }\n-\n-\n-    @Override\n-    public void dispatch(MessagePublication publication, Object message, Iterable listeners){\n-        if (passesFilter(message)) {\n-            getDelegate().dispatch(publication, message, listeners);\n-        }\n-    }\n-\n-}\n+package net.engio.mbassy.dispatch;\r\n+\r\n+import net.engio.mbassy.bus.MessagePublication;\r\n+import net.engio.mbassy.dispatch.el.ElFilter;\r\n+import net.engio.mbassy.listener.IMessageFilter;\r\n+\r\n+/**\r\n+ * A dispatcher that implements message filtering based on the filter configuration\r\n+ * of the associated message handler. It will delegate message delivery to another\r\n+ * message dispatcher after having performed the filtering logic.\r\n+ *\r\n+ * @author bennidi\r\n+ *         Date: 11/23/12\r\n+ */\r\n+public class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\r\n+\r\n+    private final IMessageFilter[] filter;\r\n+\r\n+    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\r\n+        super(dispatcher);\r\n+        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\r\n+    }\r\n+\r\n+    private boolean passesFilter(Object message) {\r\n+\r\n+        if (filter == null) {\r\n+            return true;\r\n+        } else {\r\n+            for (IMessageFilter aFilter : filter) {\r\n+                if (!aFilter.accepts(message, getContext().getHandlerMetadata())) {\r\n+                    return false;\r\n+                }\r\n+            }\r\n+            return true;\r\n+        }\r\n+    }\r\n+\r\n+\r\n+    @Override\r\n+    public void dispatch(MessagePublication publication, Object message, Iterable listeners){\r\n+        if (passesFilter(message) && passesELFilter(message)) {\r\n+            getDelegate().dispatch(publication, message, listeners);\r\n+        }\r\n+    }\r\n+\r\n+\t/*************************************************************************\r\n+\t * This will test the EL expression defined on the Handler annotation.\r\n+\t * This is like a \"parameterizable\" filter.\r\n+\t * @param me the message object to filter with the EL expression if there is one.\r\n+\t * @return true if the event is allowed, false if it is rejected.\r\n+\t ************************************************************************/\r\n+        \r\n+\tprivate boolean passesELFilter(Object message) {\r\n+\t\tElFilter filter = ElFilter.getInstance();\r\n+\t\treturn filter != null && filter.accepts(message, getContext().getHandlerMetadata());\r\n+\t}\r\n+}\r\n"
    },
    {
        "commit hash": "e170301c2c591dc3289909f2d3ea2ab10e293753",
        "previous commit hash": "de9515ed7d3576c38c1f5b161c5982dfe345bccb",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/el/ElFilter.java",
            "additions": 113,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,113 @@\n+package net.engio.mbassy.dispatch.el;\r\n+\r\n+import javax.el.ExpressionFactory;\r\n+import javax.el.ValueExpression;\r\n+\r\n+import net.engio.mbassy.listener.IMessageFilter;\r\n+import net.engio.mbassy.listener.MessageHandler;\r\n+\r\n+/*****************************************************************************\r\n+ * A filter that will use a expression from the handler annotation and \r\n+ * parse it as EL.\r\n+ ****************************************************************************/\r\n+\r\n+public class ElFilter implements IMessageFilter {\r\n+\r\n+\tprivate static ElFilter instance;\r\n+\t\r\n+\tstatic {\r\n+\t\ttry {\r\n+\t\t\tinstance = new ElFilter();\r\n+\t\t} catch (Exception e) {\r\n+\t\t\t// Most likely the javax.el package is not available.\r\n+\t\t\tinstance = null;\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\tprivate ExpressionFactory elFactory;\r\n+\t\r\n+\t/*************************************************************************\r\n+\t * Constructor\r\n+\t ************************************************************************/\r\n+\t\r\n+\tprivate ElFilter() {\r\n+\t\tsuper();\r\n+\t\tinitELFactory();\r\n+\t}\r\n+\t\r\n+\t/*************************************************************************\r\n+\t * Get an implementation of the ExpressionFactory. This uses the \r\n+\t * Java service lookup mechanism to find a proper implementation.\r\n+\t * If none if available we do not support EL filters.\r\n+\t ************************************************************************/\r\n+\r\n+\tprivate void initELFactory() {\r\n+\t\ttry {\r\n+\t\t\tthis.elFactory = ExpressionFactory.newInstance();\r\n+\t\t} catch (RuntimeException e) {\r\n+\t\t\t// No EL implementation on the class path.\r\n+\t\t\telFactory = null;\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\t/*************************************************************************\r\n+\t * accepts\r\n+\t * @see net.engio.mbassy.listener.IMessageFilter#accepts(java.lang.Object, net.engio.mbassy.listener.MessageHandler)\r\n+\t ************************************************************************/\r\n+\t@Override\r\n+\tpublic boolean accepts(Object message, MessageHandler metadata) {\r\n+\t\tString expression = metadata.getCondition();\r\n+\t\tif (expression == null || expression.trim().length() == 0) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\tif (elFactory == null) {\r\n+\t\t\t// TODO should we test this some where earlier? Perhaps in MessageHandler.validate()  ?\r\n+\t\t\tthrow new IllegalStateException(\"A handler uses an EL filter but no EL implementation is available.\");\r\n+\t\t}\r\n+\t\t\r\n+\t\texpression = cleanupExpression(expression);\r\n+\t\t\r\n+\t\tEventContext context = new EventContext();\r\n+\t\tcontext.bindToEvent(message);\r\n+\t\t\r\n+\t\treturn evalExpression(expression, context);\r\n+\t}\r\n+\r\n+\t/*************************************************************************\r\n+\t * @param expression\r\n+\t * @param context\r\n+\t * @return\r\n+\t ************************************************************************/\r\n+\t\r\n+\tprivate boolean evalExpression(String expression, EventContext context) {\r\n+\t\tValueExpression ve = elFactory.createValueExpression(context, expression, Boolean.class);\r\n+\t\tObject result = ve.getValue(context);\r\n+\t\tif (!(result instanceof Boolean)) {\r\n+\t\t\tthrow new IllegalStateException(\"A handler uses an EL filter but the output is not \\\"true\\\" or \\\"false\\\".\");\r\n+\t\t}\r\n+\t\treturn (Boolean)result;\r\n+\t}\r\n+\r\n+\t/*************************************************************************\r\n+\t * Make it a valid expression because the parser expects it like this.\r\n+\t * @param expression\r\n+\t * @return\r\n+\t ************************************************************************/\r\n+\t\r\n+\tprivate String cleanupExpression(String expression) {\r\n+\t\t \r\n+\t\tif (!expression.trim().startsWith(\"${\") && !expression.trim().startsWith(\"#{\")) {\r\n+\t\t\texpression = \"${\"+expression+\"}\";\r\n+\t\t}\r\n+\t\treturn expression;\r\n+\t}\r\n+\r\n+\t/*************************************************************************\r\n+\t * @return the one and only\r\n+\t ************************************************************************/\r\n+\t\r\n+\tpublic static synchronized ElFilter getInstance() {\r\n+\t\treturn instance;\r\n+\t}\r\n+\r\n+}\r\n"
    },
    {
        "commit hash": "e170301c2c591dc3289909f2d3ea2ab10e293753",
        "previous commit hash": "de9515ed7d3576c38c1f5b161c5982dfe345bccb",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/el/EventContext.java",
            "additions": 102,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,102 @@\n+package net.engio.mbassy.dispatch.el;\r\n+\r\n+import java.lang.reflect.Method;\r\n+\r\n+import javax.el.BeanELResolver;\r\n+import javax.el.CompositeELResolver;\r\n+import javax.el.ELContext;\r\n+import javax.el.ELResolver;\r\n+import javax.el.FunctionMapper;\r\n+import javax.el.ValueExpression;\r\n+import javax.el.VariableMapper;\r\n+\r\n+/*****************************************************************************\r\n+ * An EL context that knows how to resolve everything from a \r\n+ * given message but event.\r\n+ ****************************************************************************/\r\n+\r\n+public class EventContext extends ELContext {\r\n+\r\n+\tprivate final CompositeELResolver resolver;\r\n+\tprivate final FunctionMapper functionMapper;\r\n+\tprivate final VariableMapper variableMapper;\r\n+\tprivate RootResolver rootResolver;\r\n+\r\n+\t/*************************************************************************\r\n+\t * Constructor\r\n+\t * \r\n+\t * @param me\r\n+\t ************************************************************************/\r\n+\r\n+\tpublic EventContext() {\r\n+\t\tsuper();\r\n+\t\tthis.functionMapper = new NoopFunctionMapper();\r\n+\t\tthis.variableMapper = new NoopMapperImpl();\r\n+\t\t\r\n+\t\tthis.resolver = new CompositeELResolver();\r\n+\t\tthis.rootResolver = new RootResolver();\r\n+\t\tthis.resolver.add(rootResolver);\r\n+\t\tthis.resolver.add(new BeanELResolver(true));\r\n+\t}\r\n+\t\r\n+\t /*************************************************************************\r\n+\t * Binds an event object with the EL expression. This will allow access\r\n+\t * to all properties of a given event.\r\n+\t * @param event to bind.\r\n+\t ************************************************************************/\r\n+\t\r\n+\tpublic void bindToEvent(Object event) {\r\n+\t\t this.rootResolver.setRoot(event);\r\n+\t }\r\n+\r\n+\t/*************************************************************************\r\n+\t * The resolver for the event object.\r\n+\t * @see javax.el.ELContext#getELResolver()\r\n+\t ************************************************************************/\r\n+\t@Override\r\n+\tpublic ELResolver getELResolver() {\r\n+\t\treturn this.resolver;\r\n+\t}\r\n+\r\n+\t/*************************************************************************\r\n+\t * @see javax.el.ELContext#getFunctionMapper()\r\n+\t ************************************************************************/\r\n+\t@Override\r\n+\tpublic FunctionMapper getFunctionMapper() {\r\n+\t\treturn this.functionMapper;\r\n+\t}\r\n+\r\n+\t/*************************************************************************\r\n+\t * @see javax.el.ELContext#getVariableMapper()\r\n+\t ************************************************************************/\r\n+\t@Override\r\n+\tpublic VariableMapper getVariableMapper() {\r\n+\t\treturn this.variableMapper;\r\n+\t}\r\n+\r\n+\t/*****************************************************************************\r\n+\t *  Dummy implementation.\r\n+\t ****************************************************************************/\r\n+\t\r\n+\tprivate class NoopMapperImpl extends VariableMapper {\r\n+\t\tpublic ValueExpression resolveVariable(String s) {\r\n+\t\t\treturn null;\r\n+\t\t}\r\n+\r\n+\t\tpublic ValueExpression setVariable(String s,\r\n+\t\t\t\tValueExpression valueExpression) {\r\n+\t\t\treturn null;\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/*****************************************************************************\r\n+\t *  Dummy implementation.\r\n+\t ****************************************************************************/\r\n+\t\r\n+\tprivate class NoopFunctionMapper extends FunctionMapper {\r\n+\t\tpublic Method resolveFunction(String s, String s1) {\r\n+\t\t\treturn null;\r\n+\t\t}\r\n+\t}\r\n+\r\n+}\r\n"
    },
    {
        "commit hash": "e170301c2c591dc3289909f2d3ea2ab10e293753",
        "previous commit hash": "de9515ed7d3576c38c1f5b161c5982dfe345bccb",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/el/RootResolver.java",
            "additions": 89,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,89 @@\n+package net.engio.mbassy.dispatch.el;\r\n+\r\n+import java.beans.FeatureDescriptor;\r\n+import java.util.Iterator;\r\n+\r\n+import javax.el.ELContext;\r\n+import javax.el.ELResolver;\r\n+\r\n+/*****************************************************************************\r\n+ * A resolver that will resolve the \"msg\" variable to the event object that \r\n+ * is posted.\r\n+ ****************************************************************************/\r\n+\r\n+public class RootResolver extends ELResolver {\r\n+\r\n+\tprivate static final String ROOT_VAR_NAME = \"msg\";\r\n+\tpublic Object rootObject; \r\n+\t\r\n+\t/*************************************************************************\r\n+\t * @param rootObject\r\n+\t ************************************************************************/\r\n+\t\r\n+\tpublic void setRoot(Object rootObject) {\r\n+\t\tthis.rootObject = rootObject;\r\n+\t}\r\n+\t\r\n+\t/*************************************************************************\r\n+\t * getValue\r\n+\t * @see javax.el.ELResolver#getValue(javax.el.ELContext, java.lang.Object, java.lang.Object)\r\n+\t ************************************************************************/\r\n+\t@Override\r\n+\tpublic Object getValue(ELContext context, Object base, Object property) {\r\n+\t\tif (context == null) {\r\n+\t\t\tthrow new NullPointerException();\r\n+\t\t}\r\n+\t\tif (base == null && ROOT_VAR_NAME.equals(property)) {\r\n+\t\t\tcontext.setPropertyResolved(true);\r\n+\t\t\treturn this.rootObject;\r\n+\t\t}\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\t\r\n+\t/*************************************************************************\r\n+\t * getCommonPropertyType\r\n+\t * @see javax.el.ELResolver#getCommonPropertyType(javax.el.ELContext, java.lang.Object)\r\n+\t ************************************************************************/\r\n+\t@Override\r\n+\tpublic Class<?> getCommonPropertyType(ELContext context, Object base) {\r\n+\t\treturn String.class;\r\n+\t}\r\n+\r\n+\t/*************************************************************************\r\n+\t * getFeatureDescriptors\r\n+\t * @see javax.el.ELResolver#getFeatureDescriptors(javax.el.ELContext, java.lang.Object)\r\n+\t ************************************************************************/\r\n+\t@Override\r\n+\tpublic Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext context, Object base) {\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\t/*************************************************************************\r\n+\t * getType\r\n+\t * @see javax.el.ELResolver#getType(javax.el.ELContext, java.lang.Object, java.lang.Object)\r\n+\t ************************************************************************/\r\n+\t@Override\r\n+\tpublic Class<?> getType(ELContext context, Object base, Object property) {\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\t/*************************************************************************\r\n+\t * isReadOnly\r\n+\t * @see javax.el.ELResolver#isReadOnly(javax.el.ELContext, java.lang.Object, java.lang.Object)\r\n+\t ************************************************************************/\r\n+\t@Override\r\n+\tpublic boolean isReadOnly(ELContext context, Object base, Object property) {\r\n+\t\treturn true;\r\n+\t}\r\n+\r\n+\t/*************************************************************************\r\n+\t * setValue\r\n+\t * @see javax.el.ELResolver#setValue(javax.el.ELContext, java.lang.Object, java.lang.Object, java.lang.Object)\r\n+\t ************************************************************************/\r\n+\t@Override\r\n+\tpublic void setValue(ELContext context, Object base, Object property, Object value) {\r\n+\t\t// Do nothing\r\n+\t}\r\n+\r\n+}\r\n"
    },
    {
        "commit hash": "e170301c2c591dc3289909f2d3ea2ab10e293753",
        "previous commit hash": "de9515ed7d3576c38c1f5b161c5982dfe345bccb",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Handler.java",
            "additions": 76,
            "deletions": 66
        },
        "diff content": "@@ -1,66 +1,76 @@\n-package net.engio.mbassy.listener;\n-\n-import net.engio.mbassy.dispatch.HandlerInvocation;\n-import net.engio.mbassy.dispatch.ReflectiveHandlerInvocation;\n-\n-import java.lang.annotation.*;\n-\n-/**\n- * Mark any method of any class(=listener) as a message handler and configure the handler\n- * using different properties.\n- *\n- * @author bennidi\n- *         Date: 2/8/12\n- */\n-@Retention(value = RetentionPolicy.RUNTIME)\n-@Inherited\n-@Target(value = {ElementType.METHOD})\n-public @interface Handler {\n-\n-    /**\n-     * Add any numbers of filters to the handler. All filters are evaluated before the handler\n-     * is actually invoked, which is only if all the filters accept the message.\n-     */\n-    Filter[] filters() default {};\n-\n-    /**\n-     * Define the mode in which a message is delivered to each listener. Listeners can be notified\n-     * sequentially or concurrently.\n-     */\n-    Invoke delivery() default Invoke.Synchronously;\n-\n-    /**\n-     * Handlers are ordered by priority and handlers with higher priority are processed before\n-     * those with lower priority, i.e. Influence the order in which different handlers that consume\n-     * the same message type are invoked.\n-     */\n-    int priority() default 0;\n-\n-    /**\n-     * Define whether or not the handler accepts sub types of the message type it declares in its\n-     * signature.\n-     */\n-    boolean rejectSubtypes() default false;\n-\n-\n-    /**\n-     * Enable or disable the handler. Disabled handlers do not receive any messages.\n-     * This property is useful for quick changes in configuration and necessary to disable\n-     * handlers that have been declared by a superclass but do not apply to the subclass\n-     */\n-    boolean enabled() default true;\n-\n-\n-    /**\n-     * Each handler call is implemented as an invocation object that implements the invocation mechanism.\n-     * The basic implementation uses reflection and is the default. It is possible though to provide a custom\n-     * invocation to add additional logic.\n-     *\n-     * Note: Providing a custom invocation will most likely reduce performance, since the JIT-Compiler\n-     * can not do some of its sophisticated byte code optimizations.\n-     *\n-     */\n-    Class<? extends HandlerInvocation> invocation() default ReflectiveHandlerInvocation.class;\n-\n-\n-}\n+package net.engio.mbassy.listener;\r\n+\r\n+import net.engio.mbassy.dispatch.HandlerInvocation;\r\n+import net.engio.mbassy.dispatch.ReflectiveHandlerInvocation;\r\n+\r\n+import java.lang.annotation.*;\r\n+\r\n+/**\r\n+ * Mark any method of any class(=listener) as a message handler and configure the handler\r\n+ * using different properties.\r\n+ *\r\n+ * @author bennidi\r\n+ *         Date: 2/8/12\r\n+ */\r\n+@Retention(value = RetentionPolicy.RUNTIME)\r\n+@Inherited\r\n+@Target(value = {ElementType.METHOD})\r\n+public @interface Handler {\r\n+\r\n+    /**\r\n+     * Add any numbers of filters to the handler. All filters are evaluated before the handler\r\n+     * is actually invoked, which is only if all the filters accept the message.\r\n+     */\r\n+    Filter[] filters() default {};\r\n+    \r\n+    \r\n+    /**\r\n+     * Defines a filter condition as Expression Language. This can be used to filter the events based on \r\n+     * attributes of the event object. Note that the expression must resolve to either\r\n+     * <code>true</code> to allow the event or <code>false</code> to block it from delivery to the handler. \r\n+     * The message itself is available as \"msg\" variable. \r\n+     * @return the condition in EL syntax.\r\n+     */\r\n+    String condition() default \"\";\r\n+\r\n+    /**\r\n+     * Define the mode in which a message is delivered to each listener. Listeners can be notified\r\n+     * sequentially or concurrently.\r\n+     */\r\n+    Invoke delivery() default Invoke.Synchronously;\r\n+\r\n+    /**\r\n+     * Handlers are ordered by priority and handlers with higher priority are processed before\r\n+     * those with lower priority, i.e. Influence the order in which different handlers that consume\r\n+     * the same message type are invoked.\r\n+     */\r\n+    int priority() default 0;\r\n+\r\n+    /**\r\n+     * Define whether or not the handler accepts sub types of the message type it declares in its\r\n+     * signature.\r\n+     */\r\n+    boolean rejectSubtypes() default false;\r\n+\r\n+\r\n+    /**\r\n+     * Enable or disable the handler. Disabled handlers do not receive any messages.\r\n+     * This property is useful for quick changes in configuration and necessary to disable\r\n+     * handlers that have been declared by a superclass but do not apply to the subclass\r\n+     */\r\n+    boolean enabled() default true;\r\n+\r\n+\r\n+    /**\r\n+     * Each handler call is implemented as an invocation object that implements the invocation mechanism.\r\n+     * The basic implementation uses reflection and is the default. It is possible though to provide a custom\r\n+     * invocation to add additional logic.\r\n+     *\r\n+     * Note: Providing a custom invocation will most likely reduce performance, since the JIT-Compiler\r\n+     * can not do some of its sophisticated byte code optimizations.\r\n+     *\r\n+     */\r\n+    Class<? extends HandlerInvocation> invocation() default ReflectiveHandlerInvocation.class;\r\n+\r\n+\r\n+}\r\n"
    },
    {
        "commit hash": "e170301c2c591dc3289909f2d3ea2ab10e293753",
        "previous commit hash": "de9515ed7d3576c38c1f5b161c5982dfe345bccb",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandler.java",
            "additions": 194,
            "deletions": 183
        },
        "diff content": "@@ -1,183 +1,194 @@\n-package net.engio.mbassy.listener;\n-\n-import net.engio.mbassy.dispatch.HandlerInvocation;\n-\n-import java.lang.reflect.Method;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-/**\n- * Any method in any class annotated with the @Handler annotation represents a message handler. The class that contains\n- * the handler is called a  message listener and more generally, any class containing a message handler in its class hierarchy\n- * defines such a message listener.\n- *\n- * @author bennidi\n- *         Date: 11/14/12\n- */\n-public class MessageHandler {\n-\n-    public static final class Properties{\n-\n-        public static final String HandlerMethod = \"handler\";\n-        public static final String InvocationMode = \"invocationMode\";\n-        public static final String Filter = \"filter\";\n-        public static final String Enveloped = \"envelope\";\n-        public static final String HandledMessages = \"messages\";\n-        public static final String IsSynchronized = \"synchronized\";\n-        public static final String Listener = \"listener\";\n-        public static final String AcceptSubtypes = \"subtypes\";\n-        public static final String Priority = \"priority\";\n-        public static final String Invocation = \"invocation\";\n-\n-        /**\n-         * Create the property map for the {@link MessageHandler} constructor using the default objects.\n-         *\n-         * @param handler  The handler annotated method of the listener\n-         * @param handlerConfig The annotation that configures the handler\n-         * @param filter   The set of preconfigured filters if any\n-         * @param listenerConfig The listener metadata\n-         * @return  A map of properties initialized from the given parameters that will conform to the requirements of the\n-         *         {@link MessageHandler} constructor. See {@see MessageHandler.validate()} for more details.\n-         */\n-        public static final Map<String, Object> Create(Method handler, Handler handlerConfig, IMessageFilter[] filter, MessageListener listenerConfig){\n-            if(handler == null){\n-                throw new IllegalArgumentException(\"The message handler configuration may not be null\");\n-            }\n-            net.engio.mbassy.listener.Enveloped enveloped = handler.getAnnotation(Enveloped.class);\n-            Class[] handledMessages = enveloped != null\n-                    ? enveloped.messages()\n-                    : handler.getParameterTypes();\n-            handler.setAccessible(true);\n-            Map<String, Object> properties = new HashMap<String, Object>();\n-            properties.put(HandlerMethod, handler);\n-            properties.put(Filter, filter != null ? filter : new IMessageFilter[]{});\n-            properties.put(Priority, handlerConfig.priority());\n-            properties.put(Invocation, handlerConfig.invocation());\n-            properties.put(InvocationMode, handlerConfig.delivery());\n-            properties.put(Enveloped, enveloped != null);\n-            properties.put(AcceptSubtypes, !handlerConfig.rejectSubtypes());\n-            properties.put(Listener, listenerConfig);\n-            properties.put(IsSynchronized, handler.getAnnotation(Synchronized.class) != null);\n-            properties.put(HandledMessages, handledMessages);\n-            return properties;\n-        }\n-    }\n-\n-\n-    private final Method handler;\n-\n-    private final IMessageFilter[] filter;\n-\n-    private final int priority;\n-\n-    private final Class<? extends HandlerInvocation> invocation;\n-\n-    private final Invoke invocationMode;\n-\n-    private final boolean isEnvelope;\n-\n-    private final Class[] handledMessages;\n-\n-    private final boolean acceptsSubtypes;\n-\n-    private final MessageListener listenerConfig;\n-\n-    private final boolean isSynchronized;\n-\n-    public MessageHandler(Map<String, Object> properties){\n-        super();\n-        validate(properties);\n-        this.handler = (Method)properties.get(Properties.HandlerMethod);\n-        this.filter = (IMessageFilter[])properties.get(Properties.Filter);\n-        this.priority = (Integer)properties.get(Properties.Priority);\n-        this.invocation = (Class<? extends HandlerInvocation>)properties.get(Properties.Invocation);\n-        this.invocationMode = (Invoke)properties.get(Properties.InvocationMode);\n-        this.isEnvelope = (Boolean)properties.get(Properties.Enveloped);\n-        this.acceptsSubtypes = (Boolean)properties.get(Properties.AcceptSubtypes);\n-        this.listenerConfig = (MessageListener)properties.get(Properties.Listener);\n-        this.isSynchronized = (Boolean)properties.get(Properties.IsSynchronized);\n-        this.handledMessages = (Class[])properties.get(Properties.HandledMessages);\n-    }\n-\n-    private void validate(Map<String, Object> properties){\n-        Object[][] expectedProperties = new Object[][]{\n-                new Object[]{Properties.HandlerMethod, Method.class },\n-                new Object[]{Properties.Priority, Integer.class },\n-                new Object[]{Properties.Invocation, Class.class },\n-                new Object[]{Properties.Filter, IMessageFilter[].class },\n-                new Object[]{Properties.Enveloped, Boolean.class },\n-                new Object[]{Properties.HandledMessages, Class[].class },\n-                new Object[]{Properties.IsSynchronized, Boolean.class },\n-                new Object[]{Properties.Listener, MessageListener.class },\n-                new Object[]{Properties.AcceptSubtypes, Boolean.class }\n-        };\n-        for(Object[] property : expectedProperties){\n-            if (properties.get(property[0]) == null || !((Class)property[1]).isAssignableFrom(properties.get(property[0]).getClass()))\n-                throw new IllegalArgumentException(\"Property \" + property[0] + \" was expected to be not null and of type \" + property[1]\n-                        + \" but was: \" + properties.get(property[0]));\n-        }\n-\n-\n-    }\n-\n-    public boolean isSynchronized(){\n-        return isSynchronized;\n-    }\n-\n-    public boolean useStrongReferences(){\n-        return listenerConfig.useStrongReferences();\n-    }\n-\n-    public boolean isFromListener(Class listener){\n-        return listenerConfig.isFromListener(listener);\n-    }\n-\n-    public boolean isAsynchronous() {\n-        return invocationMode.equals(Invoke.Asynchronously);\n-    }\n-\n-    public boolean isFiltered() {\n-        return filter.length > 0;\n-    }\n-\n-    public int getPriority() {\n-        return priority;\n-    }\n-\n-    public Method getHandler() {\n-        return handler;\n-    }\n-\n-    public IMessageFilter[] getFilter() {\n-        return filter;\n-    }\n-\n-    public Class[] getHandledMessages() {\n-        return handledMessages;\n-    }\n-\n-    public boolean isEnveloped() {\n-        return isEnvelope;\n-    }\n-\n-    public Class<? extends HandlerInvocation> getHandlerInvocation(){\n-        return invocation;\n-    }\n-\n-    public boolean handlesMessage(Class<?> messageType) {\n-        for (Class<?> handledMessage : handledMessages) {\n-            if (handledMessage.equals(messageType)) {\n-                return true;\n-            }\n-            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    public boolean acceptsSubtypes() {\n-        return acceptsSubtypes;\n-    }\n-\n-}\n+package net.engio.mbassy.listener;\r\n+\r\n+import net.engio.mbassy.dispatch.HandlerInvocation;\r\n+\r\n+import java.lang.reflect.Method;\r\n+import java.util.HashMap;\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Any method in any class annotated with the @Handler annotation represents a message handler. The class that contains\r\n+ * the handler is called a  message listener and more generally, any class containing a message handler in its class hierarchy\r\n+ * defines such a message listener.\r\n+ *\r\n+ * @author bennidi\r\n+ *         Date: 11/14/12\r\n+ */\r\n+public class MessageHandler {\r\n+\r\n+    public static final class Properties{\r\n+\r\n+        public static final String HandlerMethod = \"handler\";\r\n+        public static final String InvocationMode = \"invocationMode\";\r\n+        public static final String Filter = \"filter\";\r\n+        public static final String Condition = \"condition\";\r\n+        public static final String Enveloped = \"envelope\";\r\n+        public static final String HandledMessages = \"messages\";\r\n+        public static final String IsSynchronized = \"synchronized\";\r\n+        public static final String Listener = \"listener\";\r\n+        public static final String AcceptSubtypes = \"subtypes\";\r\n+        public static final String Priority = \"priority\";\r\n+        public static final String Invocation = \"invocation\";\r\n+\r\n+        /**\r\n+         * Create the property map for the {@link MessageHandler} constructor using the default objects.\r\n+         *\r\n+         * @param handler  The handler annotated method of the listener\r\n+         * @param handlerConfig The annotation that configures the handler\r\n+         * @param filter   The set of preconfigured filters if any\r\n+         * @param listenerConfig The listener metadata\r\n+         * @return  A map of properties initialized from the given parameters that will conform to the requirements of the\r\n+         *         {@link MessageHandler} constructor. See {@see MessageHandler.validate()} for more details.\r\n+         */\r\n+        public static final Map<String, Object> Create(Method handler, Handler handlerConfig, IMessageFilter[] filter, MessageListener listenerConfig){\r\n+            if(handler == null){\r\n+                throw new IllegalArgumentException(\"The message handler configuration may not be null\");\r\n+            }\r\n+            net.engio.mbassy.listener.Enveloped enveloped = handler.getAnnotation(Enveloped.class);\r\n+            Class[] handledMessages = enveloped != null\r\n+                    ? enveloped.messages()\r\n+                    : handler.getParameterTypes();\r\n+            handler.setAccessible(true);\r\n+            Map<String, Object> properties = new HashMap<String, Object>();\r\n+            properties.put(HandlerMethod, handler);\r\n+            properties.put(Filter, filter != null ? filter : new IMessageFilter[]{});\r\n+            properties.put(Condition, handlerConfig.condition());\r\n+            properties.put(Priority, handlerConfig.priority());\r\n+            properties.put(Invocation, handlerConfig.invocation());\r\n+            properties.put(InvocationMode, handlerConfig.delivery());\r\n+            properties.put(Enveloped, enveloped != null);\r\n+            properties.put(AcceptSubtypes, !handlerConfig.rejectSubtypes());\r\n+            properties.put(Listener, listenerConfig);\r\n+            properties.put(IsSynchronized, handler.getAnnotation(Synchronized.class) != null);\r\n+            properties.put(HandledMessages, handledMessages);\r\n+            return properties;\r\n+        }\r\n+    }\r\n+\r\n+\r\n+    private final Method handler;\r\n+\r\n+    private final IMessageFilter[] filter;\r\n+\r\n+\tprivate String condition;\r\n+    \r\n+    private final int priority;\r\n+\r\n+    private final Class<? extends HandlerInvocation> invocation;\r\n+\r\n+    private final Invoke invocationMode;\r\n+\r\n+    private final boolean isEnvelope;\r\n+\r\n+    private final Class[] handledMessages;\r\n+\r\n+    private final boolean acceptsSubtypes;\r\n+\r\n+    private final MessageListener listenerConfig;\r\n+\r\n+    private final boolean isSynchronized;\r\n+\r\n+\r\n+    public MessageHandler(Map<String, Object> properties){\r\n+        super();\r\n+        validate(properties);\r\n+        this.handler = (Method)properties.get(Properties.HandlerMethod);\r\n+        this.filter = (IMessageFilter[])properties.get(Properties.Filter);\r\n+        this.condition = (String)properties.get(Properties.Condition);\r\n+        this.priority = (Integer)properties.get(Properties.Priority);\r\n+        this.invocation = (Class<? extends HandlerInvocation>)properties.get(Properties.Invocation);\r\n+        this.invocationMode = (Invoke)properties.get(Properties.InvocationMode);\r\n+        this.isEnvelope = (Boolean)properties.get(Properties.Enveloped);\r\n+        this.acceptsSubtypes = (Boolean)properties.get(Properties.AcceptSubtypes);\r\n+        this.listenerConfig = (MessageListener)properties.get(Properties.Listener);\r\n+        this.isSynchronized = (Boolean)properties.get(Properties.IsSynchronized);\r\n+        this.handledMessages = (Class[])properties.get(Properties.HandledMessages);\r\n+    }\r\n+\r\n+    private void validate(Map<String, Object> properties){\r\n+        Object[][] expectedProperties = new Object[][]{\r\n+                new Object[]{Properties.HandlerMethod, Method.class },\r\n+                new Object[]{Properties.Priority, Integer.class },\r\n+                new Object[]{Properties.Invocation, Class.class },\r\n+                new Object[]{Properties.Filter, IMessageFilter[].class },\r\n+                new Object[]{Properties.Condition, String.class },\r\n+                new Object[]{Properties.Enveloped, Boolean.class },\r\n+                new Object[]{Properties.HandledMessages, Class[].class },\r\n+                new Object[]{Properties.IsSynchronized, Boolean.class },\r\n+                new Object[]{Properties.Listener, MessageListener.class },\r\n+                new Object[]{Properties.AcceptSubtypes, Boolean.class }\r\n+        };\r\n+        for(Object[] property : expectedProperties){\r\n+            if (properties.get(property[0]) == null || !((Class)property[1]).isAssignableFrom(properties.get(property[0]).getClass()))\r\n+                throw new IllegalArgumentException(\"Property \" + property[0] + \" was expected to be not null and of type \" + property[1]\r\n+                        + \" but was: \" + properties.get(property[0]));\r\n+        }\r\n+\r\n+\r\n+    }\r\n+\r\n+    public boolean isSynchronized(){\r\n+        return isSynchronized;\r\n+    }\r\n+\r\n+    public boolean useStrongReferences(){\r\n+        return listenerConfig.useStrongReferences();\r\n+    }\r\n+\r\n+    public boolean isFromListener(Class listener){\r\n+        return listenerConfig.isFromListener(listener);\r\n+    }\r\n+\r\n+    public boolean isAsynchronous() {\r\n+        return invocationMode.equals(Invoke.Asynchronously);\r\n+    }\r\n+\r\n+    public boolean isFiltered() {\r\n+        return filter.length > 0 || (condition != null && condition.trim().length() > 0);\r\n+    }\r\n+\r\n+    public int getPriority() {\r\n+        return priority;\r\n+    }\r\n+\r\n+    public Method getHandler() {\r\n+        return handler;\r\n+    }\r\n+\r\n+    public IMessageFilter[] getFilter() {\r\n+        return filter;\r\n+    }\r\n+    \r\n+    public String getCondition() {\r\n+    \treturn this.condition;\r\n+    }\r\n+\r\n+    public Class[] getHandledMessages() {\r\n+        return handledMessages;\r\n+    }\r\n+\r\n+    public boolean isEnveloped() {\r\n+        return isEnvelope;\r\n+    }\r\n+\r\n+    public Class<? extends HandlerInvocation> getHandlerInvocation(){\r\n+        return invocation;\r\n+    }\r\n+\r\n+    public boolean handlesMessage(Class<?> messageType) {\r\n+        for (Class<?> handledMessage : handledMessages) {\r\n+            if (handledMessage.equals(messageType)) {\r\n+                return true;\r\n+            }\r\n+            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\r\n+                return true;\r\n+            }\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    public boolean acceptsSubtypes() {\r\n+        return acceptsSubtypes;\r\n+    }\r\n+\r\n+}\r\n"
    },
    {
        "commit hash": "e170301c2c591dc3289909f2d3ea2ab10e293753",
        "previous commit hash": "de9515ed7d3576c38c1f5b161c5982dfe345bccb",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConditionTest.java",
            "additions": 133,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,133 @@\n+package net.engio.mbassy;\r\n+\r\n+import net.engio.mbassy.bus.MBassador;\r\n+import net.engio.mbassy.bus.config.BusConfiguration;\r\n+import net.engio.mbassy.common.MessageBusTest;\r\n+import net.engio.mbassy.listener.Handler;\r\n+\r\n+import org.junit.Test;\r\n+\r\n+/*****************************************************************************\r\n+ * Some unit tests for the \"condition\" filter.\r\n+ ****************************************************************************/\r\n+\r\n+public class ConditionTest extends MessageBusTest {\r\n+\r\n+\tpublic static class TestEvent {\r\n+\r\n+\t\tpublic Object result;\r\n+\t\tprivate String type;\r\n+\t\tprivate int size;\r\n+\r\n+\t\tpublic TestEvent(String type, int size) {\r\n+\t\t\tsuper();\r\n+\t\t\tthis.type = type;\r\n+\t\t\tthis.size = size;\r\n+\t\t}\r\n+\t\t\r\n+\t\tpublic String getType() {\r\n+\t\t\treturn type;\r\n+\t\t}\r\n+\r\n+\t\tpublic int getSize() {\r\n+\t\t\treturn size;\r\n+\t\t}\r\n+\t\t\r\n+\t}\r\n+\r\n+\tpublic static class ConditionalMessageListener {\r\n+\r\n+\t\t@Handler(condition = \"msg.type == \\\"TEST\\\"\")\r\n+\t\tpublic void handleTypeMessage(TestEvent message) {\r\n+\t\t\tmessage.result = \"handleTypeMessage\";\r\n+\t\t}\r\n+\r\n+\t\t@Handler(condition = \"msg.size > 4\")\r\n+\t\tpublic void handleSizeMessage(TestEvent message) {\r\n+\t\t\tmessage.result = \"handleSizeMessage\";\r\n+\t\t}\r\n+\t\t\r\n+\t\t@Handler(condition = \"msg.size > 2 && msg.size < 4\")\r\n+\t\tpublic void handleCombinedEL(TestEvent message) {\r\n+\t\t\tmessage.result = \"handleCombinedEL\";\r\n+\t\t}\r\n+\t\t\r\n+\t\t@Handler(condition = \"msg.getType().equals(\\\"XYZ\\\") && msg.getSize() == 1\")\r\n+\t\tpublic void handleMethodAccessEL(TestEvent message) {\r\n+\t\t\tmessage.result = \"handleMethodAccessEL\";\r\n+\t\t}\r\n+\r\n+\t\t\r\n+\t}\r\n+\r\n+\t/*************************************************************************\r\n+\t * @throws Exception\r\n+\t ************************************************************************/\r\n+\t@Test\r\n+\tpublic void testSimpleStringCondition() throws Exception {\r\n+\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n+\t\tbus.subscribe(new ConditionalMessageListener());\r\n+\r\n+\t\tTestEvent message = new TestEvent(\"TEST\", 0);\r\n+\t\tbus.publish(message);\r\n+\r\n+\t\tassertEquals(\"handleTypeMessage\", message.result);\r\n+\t}\r\n+\t\r\n+\t/*************************************************************************\r\n+\t * @throws Exception\r\n+\t ************************************************************************/\r\n+\t@Test\r\n+\tpublic void testSimpleNumberCondition() throws Exception {\r\n+\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n+\t\tbus.subscribe(new ConditionalMessageListener());\r\n+\r\n+\t\tTestEvent message = new TestEvent(\"\", 5);\r\n+\t\tbus.publish(message);\r\n+\r\n+\t\tassertEquals(\"handleSizeMessage\", message.result);\r\n+\t}\r\n+\t\r\n+\t/*************************************************************************\r\n+\t * @throws Exception\r\n+\t ************************************************************************/\r\n+\t@Test\r\n+\tpublic void testHandleCombinedEL() throws Exception {\r\n+\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n+\t\tbus.subscribe(new ConditionalMessageListener());\r\n+\r\n+\t\tTestEvent message = new TestEvent(\"\", 3);\r\n+\t\tbus.publish(message);\r\n+\r\n+\t\tassertEquals(\"handleCombinedEL\", message.result);\r\n+\t}\r\n+\t\r\n+\t/*************************************************************************\r\n+\t * @throws Exception\r\n+\t ************************************************************************/\r\n+\t@Test\r\n+\tpublic void testNotMatchingAnyCondition() throws Exception {\r\n+\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n+\t\tbus.subscribe(new ConditionalMessageListener());\r\n+\r\n+\t\tTestEvent message = new TestEvent(\"\", 0);\r\n+\t\tbus.publish(message);\r\n+\r\n+\t\tassertTrue(message.result == null);\r\n+\t}\r\n+\t\r\n+\t/*************************************************************************\r\n+\t * @throws Exception\r\n+\t ************************************************************************/\r\n+\t@Test\r\n+\tpublic void testHandleMethodAccessEL() throws Exception {\r\n+\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n+\t\tbus.subscribe(new ConditionalMessageListener());\r\n+\r\n+\t\tTestEvent message = new TestEvent(\"XYZ\", 1);\r\n+\t\tbus.publish(message);\r\n+\r\n+\t\tassertEquals(\"handleMethodAccessEL\", message.result);\r\n+\t}\r\n+\r\n+}\r\n"
    },
    {
        "commit hash": "de9515ed7d3576c38c1f5b161c5982dfe345bccb",
        "previous commit hash": "c0a087b26abe7f538dc07843783c15fa09d9724e",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.10</version>\n+    <version>1.1.11-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.10</tag>\n+        <tag>mbassador-1.1.4</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "c0a087b26abe7f538dc07843783c15fa09d9724e",
        "previous commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.10-SNAPSHOT</version>\n+    <version>1.1.10</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.4</tag>\n+        <tag>mbassador-1.1.10</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "README.md",
            "additions": 10,
            "deletions": 0
        },
        "diff content": "@@ -157,6 +157,16 @@ to avoid confusion and misunderstanding.\n \n <h2>Release Notes</h2>\n \n+<h3>1.1.10</h3>\n+ + Fixed broken sort order of prioritized handlers (see #58)\n+ + Addressed issue #63 by making the constructor of `MessageHandler` use a map of properties and by replacing dependencies to\n+  all MBassador specific annotations with Java primitives and simple interfaces\n+ + Small refactorings (moved stuff around to have cleaner packaging)\n+ + MessageBus.getExecutor() is now deprecated and will be removed with next release -> use the runtime to get access to it.\n+ + Introduced BusFactory with convenience methods for creating bus instances for different message dispatching scenarios like\n+ asynchronous FIFO (asynchronous message publications guaranteed to be delivered in the order they occurred)\n+ + Renamed runtime property of `BusRuntime` \"handler.async-service\" to \"handler.async.executor\"\n+\n <h3>1.1.9</h3>\n \n  + Fixed memory leak reported in issue #53\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/docs/TODO.md",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -18,5 +18,6 @@ Add code examples Javadoc of main classes\n Describe 1-Thread FIFO scheme with async dispatch\n Explain how MBassador can be extended easily using delegation\n Refer to Spring integration component\n+Creating bus hierarchies\n How to make sender part of the message publication\n How to add global filtering by means of delegation\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java",
            "additions": 6,
            "deletions": 5
        },
        "diff content": "@@ -1,9 +1,10 @@\n package net.engio.mbassy.bus;\n \n-import net.engio.mbassy.IPublicationErrorHandler;\n-import net.engio.mbassy.PublicationError;\n+import net.engio.mbassy.bus.common.DeadMessage;\n+import net.engio.mbassy.bus.common.PubSubSupport;\n import net.engio.mbassy.bus.config.ISyncBusConfiguration;\n-import net.engio.mbassy.common.DeadMessage;\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n+import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.subscription.Subscription;\n import net.engio.mbassy.subscription.SubscriptionManager;\n \n@@ -17,7 +18,7 @@ import java.util.List;\n  *\n  * @param <T>\n  */\n-public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T>{\n+public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n \n \n     // this handler will receive all errors that occur during message dispatch or message handling\n@@ -32,7 +33,7 @@ public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T>{\n \n     public AbstractPubSubSupport(ISyncBusConfiguration configuration) {\n         this.runtime = new BusRuntime(this);\n-        this.runtime.add(\"error.handlers\", getRegisteredErrorHandlers());\n+        this.runtime.add(BusRuntime.Properties.ErrorHandlers, getRegisteredErrorHandlers());\n         this.subscriptionManager = configuration.getSubscriptionManagerProvider()\n         \t\t.createManager(configuration.getMetadataReader(),\n                 configuration.getSubscriptionFactory(), runtime);\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java",
            "additions": 6,
            "deletions": 4
        },
        "diff content": "@@ -1,7 +1,8 @@\n package net.engio.mbassy.bus;\n \n-import net.engio.mbassy.PublicationError;\n+import net.engio.mbassy.bus.common.IMessageBus;\n import net.engio.mbassy.bus.config.IBusConfiguration;\n+import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n \n import java.util.ArrayList;\n@@ -12,7 +13,7 @@ import java.util.concurrent.ExecutorService;\n import java.util.concurrent.TimeUnit;\n \n /**\n- * The base class for all async message bus implementations.\n+ * The base class for all message bus implementations with support for asynchronous message dispatch\n  *\n  * @param <T>\n  * @param <P>\n@@ -32,7 +33,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n     protected AbstractSyncAsyncMessageBus(IBusConfiguration configuration) {\n         super(configuration);\n         this.executor = configuration.getExecutorForAsynchronousHandlers();\n-        getRuntime().add(\"handler.async-service\", executor);\n+        getRuntime().add(BusRuntime.Properties.AsynchronousHandlerExecutor, executor);\n         pendingMessages = configuration.getPendingMessagesQueue();\n         dispatchers = new ArrayList<Thread>(configuration.getNumberOfMessageDispatchers());\n         initDispatcherThreads(configuration);\n@@ -61,6 +62,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n                     }\n                 }\n             });\n+            dispatcher.setName(\"Message dispatcher\");\n             dispatchers.add(dispatcher);\n             dispatcher.start();\n         }\n@@ -92,8 +94,8 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n \n     @Override\n     protected void finalize() throws Throwable {\n-        shutdown();\n         super.finalize();\n+        shutdown();\n     }\n \n     @Override\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/BusFactory.java",
            "additions": 38,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,38 @@\n+package net.engio.mbassy.bus;\n+\n+import net.engio.mbassy.bus.common.IMessageBus;\n+import net.engio.mbassy.bus.common.ISyncMessageBus;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.config.SyncBusConfiguration;\n+\n+/**\n+ * The bus factory provides convenient factory methods for the most common bus use cases.\n+ *\n+ * @author bennidi\n+ *         Date: 3/30/14\n+ */\n+public class BusFactory {\n+\n+    /**\n+     * Create a message bus supporting only synchronous message publication.\n+     * All message publications will run in the calling thread, no bus internal\n+     * multi-threading will occur.\n+     *\n+     * @return\n+     */\n+    public static ISyncMessageBus SynchronousOnly(){\n+        return new SyncMessageBus(new SyncBusConfiguration());\n+    }\n+\n+    /**\n+     * Create a message bus supporting synchronous and asynchronous message publication.\n+     * Asynchronous message publication will be handled by a single thread such that FIFO\n+     * order of message processing is guaranteed.\n+     *\n+     *\n+     * @return\n+     */\n+    public static IMessageBus AsynchronousSequentialFIFO(){\n+        return new MBassador(BusConfiguration.Default(1,1,1));\n+    }\n+}\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/BusRuntime.java",
            "additions": 9,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.bus;\n \n-import net.engio.mbassy.common.MissingPropertyException;\n+import net.engio.mbassy.bus.common.PubSubSupport;\n+import net.engio.mbassy.bus.error.MissingPropertyException;\n \n import java.util.Collection;\n import java.util.HashMap;\n@@ -17,6 +18,13 @@ import java.util.Map;\n  */\n public class BusRuntime {\n \n+    public static class Properties{\n+\n+        public static final String ErrorHandlers = \"error.handlers\";\n+        public static final String AsynchronousHandlerExecutor = \"handler.async.executor\";\n+\n+    }\n+\n     private PubSubSupport provider;\n \n     private Map<String, Object> properties = new HashMap<String, Object>();\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/IMBassador.java",
            "additions": 0,
            "deletions": 19
        },
        "diff content": "@@ -1,19 +0,0 @@\n-package net.engio.mbassy.bus;\n-\n-import net.engio.mbassy.bus.publication.SyncAsyncPostCommand;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Created with IntelliJ IDEA.\n- * User: benjamin\n- * Date: 8/21/13\n- * Time: 11:05 AM\n- * To change this template use File | Settings | File Templates.\n- */\n-public interface IMBassador<T> extends IMessageBus<T, SyncAsyncPostCommand<T>> {\n-\n-    MessagePublication publishAsync(T message);\n-\n-    MessagePublication publishAsync(T message, long timeout, TimeUnit unit);\n-}\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MBassador.java",
            "additions": 3,
            "deletions": 4
        },
        "diff content": "@@ -1,25 +1,24 @@\n package net.engio.mbassy.bus;\n \n-import net.engio.mbassy.PublicationError;\n+import net.engio.mbassy.bus.common.IMessageBus;\n import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.bus.publication.SyncAsyncPostCommand;\n \n import java.util.concurrent.TimeUnit;\n \n \n-public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> implements IMBassador<T> {\n+public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> implements IMessageBus<T, SyncAsyncPostCommand<T>> {\n \n     public MBassador(BusConfiguration configuration) {\n         super(configuration);\n     }\n \n \n-    @Override\n     public MessagePublication publishAsync(T message) {\n         return addAsynchronousPublication(createMessagePublication(message));\n     }\n \n-    @Override\n     public MessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n         return addAsynchronousPublication(createMessagePublication(message), timeout, unit);\n     }\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MessagePublication.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.bus;\n \n-import net.engio.mbassy.common.DeadMessage;\n-import net.engio.mbassy.common.FilteredMessage;\n+import net.engio.mbassy.bus.common.DeadMessage;\n+import net.engio.mbassy.bus.common.FilteredMessage;\n import net.engio.mbassy.subscription.Subscription;\n \n import java.util.Collection;\n@@ -79,11 +79,11 @@ public class MessagePublication {\n \n \n     public boolean isDeadEvent() {\n-        return DeadMessage.class.isAssignableFrom(message.getClass());\n+        return DeadMessage.class.equals(message.getClass());\n     }\n \n     public boolean isFilteredEvent() {\n-        return FilteredMessage.class.isAssignableFrom(message.getClass());\n+        return FilteredMessage.class.equals(message.getClass());\n     }\n \n     public Object getMessage() {\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/SyncMessageBus.java",
            "additions": 3,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,8 @@\n package net.engio.mbassy.bus;\n \n-import net.engio.mbassy.PublicationError;\n+import net.engio.mbassy.bus.common.ISyncMessageBus;\n import net.engio.mbassy.bus.config.ISyncBusConfiguration;\n+import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.bus.publication.IPublicationCommand;\n \n /**\n@@ -9,7 +10,7 @@ import net.engio.mbassy.bus.publication.IPublicationCommand;\n  * will not create any new threads.\n  *\n  */\n-public class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements ISyncMessageBus<T, SyncMessageBus.SyncPostCommand>{\n+public class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements ISyncMessageBus<T, SyncMessageBus.SyncPostCommand> {\n \n \n     public SyncMessageBus(ISyncBusConfiguration configuration) {\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/DeadMessage.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,7 @@\n-package net.engio.mbassy.common;\n+package net.engio.mbassy.bus.common;\n \n /**\n- * The DeadEvent is delivered to all subscribed handlers (if any) whenever no message\n+ * The dead message event is published whenever no message\n  * handlers could be found for a given message publication.\n  *\n  * @author bennidi\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/ErrorHandlingSupport.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,6 @@\n-package net.engio.mbassy.bus;\n+package net.engio.mbassy.bus.common;\n \n-import net.engio.mbassy.IPublicationErrorHandler;\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n \n import java.util.Collection;\n \n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/FilteredMessage.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -1,14 +1,14 @@\n-package net.engio.mbassy.common;\n+package net.engio.mbassy.bus.common;\n \n /**\n- * A filtered event is published when there have been matching subscriptions for a given\n+ * A filtered message event is published when there have been matching subscriptions for a given\n  * message publication but configured filters prevented the message from being delivered to\n  * any of the handlers.\n  *\n  * @author bennidi\n  *         Date: 3/1/13\n  */\n-public class FilteredMessage extends PublicationEvent {\n+public final class FilteredMessage extends PublicationEvent {\n \n \n     public FilteredMessage(Object event) {\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/GenericMessagePublicationSupport.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package net.engio.mbassy.bus;\n+package net.engio.mbassy.bus.common;\n \n import net.engio.mbassy.bus.publication.IPublicationCommand;\n \n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/IMessageBus.java",
            "additions": 4,
            "deletions": 2
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package net.engio.mbassy.bus;\n+package net.engio.mbassy.bus.common;\n \n import net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n \n@@ -70,14 +70,16 @@ public interface IMessageBus<T, P extends ISyncAsyncPublicationCommand>\n      * Get the executor service that is used for asynchronous message publications.\n      * The executor is passed to the message bus at creation time.\n      *\n+     * Note: The executor can be obtained from the run time. See\n      * @return\n      */\n+    @Deprecated\n     Executor getExecutor();\n \n     /**\n      * Check whether any asynchronous message publications are pending to be processed\n      *\n-     * @return\n+     * @return true if any unfinished message publications are found\n      */\n     boolean hasPendingMessages();\n \n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/ISyncMessageBus.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package net.engio.mbassy.bus;\n+package net.engio.mbassy.bus.common;\n \n import net.engio.mbassy.bus.publication.IPublicationCommand;\n \n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/PubSubSupport.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package net.engio.mbassy.bus;\n+package net.engio.mbassy.bus.common;\n \n /**\n  * This interface defines the very basic message publication semantics according to the publish subscribe pattern.\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/PublicationEvent.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package net.engio.mbassy.common;\n+package net.engio.mbassy.bus.common;\n \n /**\n  * A wrapped event is created when various conditions are matched (these depend on the concrete\n@@ -9,13 +9,13 @@ package net.engio.mbassy.common;\n  */\n public abstract class PublicationEvent {\n \n-    private Object event;\n+    private Object relatedMessage;\n \n     public PublicationEvent(Object message) {\n-        this.event = message;\n+        this.relatedMessage = message;\n     }\n \n     public Object getMessage() {\n-        return event;\n+        return relatedMessage;\n     }\n }\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/common/RuntimeProvider.java",
            "additions": 3,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,6 @@\n-package net.engio.mbassy.bus;\n+package net.engio.mbassy.bus.common;\n+\n+import net.engio.mbassy.bus.BusRuntime;\n \n /**\n  * Each message bus provides a runtime object to access its dynamic features and runtime configuration.\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java",
            "additions": 4,
            "deletions": 2
        },
        "diff content": "@@ -175,8 +175,9 @@ public class BusConfiguration implements IBusConfiguration {\n         return metadataReader;\n     }\n \n-    public void setMetadataReader(MetadataReader metadataReader) {\n+    public BusConfiguration setMetadataReader(MetadataReader metadataReader) {\n         this.metadataReader = metadataReader;\n+        return this;\n     }\n \n     @Override\n@@ -193,7 +194,8 @@ public class BusConfiguration implements IBusConfiguration {\n     \treturn subscriptionManagerProvider;\n     }\n     \n-    public void setSubscriptionManagerProvider(ISubscriptionManagerProvider subscriptionManagerProvider) {\n+    public BusConfiguration setSubscriptionManagerProvider(ISubscriptionManagerProvider subscriptionManagerProvider) {\n     \tthis.subscriptionManagerProvider = subscriptionManagerProvider;\n+        return this;\n     }\n }\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/ISyncBusConfiguration.java",
            "additions": 8,
            "deletions": 0
        },
        "diff content": "@@ -5,8 +5,16 @@ import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.subscription.ISubscriptionManagerProvider;\r\n import net.engio.mbassy.subscription.SubscriptionFactory;\r\n \r\n+/**\r\n+ * The configuration options for the synchronous message bus {@link net.engio.mbassy.bus.SyncMessageBus}\r\n+ */\r\n public interface ISyncBusConfiguration {\r\n \r\n+    /**\r\n+     * The message publication factory is used to wrap a published message\r\n+     * and while it is being processed\r\n+     * @return The factory to be used by the bus to create the publications\r\n+     */\r\n \tMessagePublication.Factory getMessagePublicationFactory();\r\n \r\n \tMetadataReader getMetadataReader();\r\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/error/IPublicationErrorHandler.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package net.engio.mbassy;\n+package net.engio.mbassy.bus.error;\n \n /**\n  * Publication error handlers are provided with a publication error every time an\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/error/MessageBusException.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package net.engio.mbassy;\n+package net.engio.mbassy.bus.error;\n \n /**\n  * Todo: Add javadoc\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/error/MissingPropertyException.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package net.engio.mbassy.common;\n+package net.engio.mbassy.bus.error;\n \n /**\n  * This exception is thrown when a property value that is unavailable at runtime is accessed.\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/error/PublicationError.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package net.engio.mbassy;\n+package net.engio.mbassy.bus.error;\n \n import net.engio.mbassy.bus.MessagePublication;\n \n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n+import net.engio.mbassy.bus.BusRuntime;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n \n import java.util.concurrent.ExecutorService;\n@@ -19,7 +20,7 @@ public class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAw\n     public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n         super(delegate.getContext());\n         this.delegate = delegate;\n-        this.executor = delegate.getContext().getRuntime().get(\"handler.async-service\");\n+        this.executor = delegate.getContext().getRuntime().get(BusRuntime.Properties.AsynchronousHandlerExecutor);\n     }\n \n     /**\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/HandlerInvocation.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.IPublicationErrorHandler;\n-import net.engio.mbassy.PublicationError;\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n+import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n import net.engio.mbassy.subscription.SubscriptionContext;\n \n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.PublicationError;\n+import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.subscription.SubscriptionContext;\n \n import java.lang.reflect.InvocationTargetException;\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandler.java",
            "additions": 96,
            "deletions": 39
        },
        "diff content": "@@ -3,30 +3,80 @@ package net.engio.mbassy.listener;\n import net.engio.mbassy.dispatch.HandlerInvocation;\n \n import java.lang.reflect.Method;\n-import java.util.LinkedList;\n-import java.util.List;\n+import java.util.HashMap;\n+import java.util.Map;\n \n /**\n  * Any method in any class annotated with the @Handler annotation represents a message handler. The class that contains\n- * the handler defines the message listener and more generally, any class containing a message handler in its class hierarchy\n- * defines a message listener.\n+ * the handler is called a  message listener and more generally, any class containing a message handler in its class hierarchy\n+ * defines such a message listener.\n  *\n  * @author bennidi\n  *         Date: 11/14/12\n  */\n public class MessageHandler {\n \n+    public static final class Properties{\n+\n+        public static final String HandlerMethod = \"handler\";\n+        public static final String InvocationMode = \"invocationMode\";\n+        public static final String Filter = \"filter\";\n+        public static final String Enveloped = \"envelope\";\n+        public static final String HandledMessages = \"messages\";\n+        public static final String IsSynchronized = \"synchronized\";\n+        public static final String Listener = \"listener\";\n+        public static final String AcceptSubtypes = \"subtypes\";\n+        public static final String Priority = \"priority\";\n+        public static final String Invocation = \"invocation\";\n+\n+        /**\n+         * Create the property map for the {@link MessageHandler} constructor using the default objects.\n+         *\n+         * @param handler  The handler annotated method of the listener\n+         * @param handlerConfig The annotation that configures the handler\n+         * @param filter   The set of preconfigured filters if any\n+         * @param listenerConfig The listener metadata\n+         * @return  A map of properties initialized from the given parameters that will conform to the requirements of the\n+         *         {@link MessageHandler} constructor. See {@see MessageHandler.validate()} for more details.\n+         */\n+        public static final Map<String, Object> Create(Method handler, Handler handlerConfig, IMessageFilter[] filter, MessageListener listenerConfig){\n+            if(handler == null){\n+                throw new IllegalArgumentException(\"The message handler configuration may not be null\");\n+            }\n+            net.engio.mbassy.listener.Enveloped enveloped = handler.getAnnotation(Enveloped.class);\n+            Class[] handledMessages = enveloped != null\n+                    ? enveloped.messages()\n+                    : handler.getParameterTypes();\n+            handler.setAccessible(true);\n+            Map<String, Object> properties = new HashMap<String, Object>();\n+            properties.put(HandlerMethod, handler);\n+            properties.put(Filter, filter != null ? filter : new IMessageFilter[]{});\n+            properties.put(Priority, handlerConfig.priority());\n+            properties.put(Invocation, handlerConfig.invocation());\n+            properties.put(InvocationMode, handlerConfig.delivery());\n+            properties.put(Enveloped, enveloped != null);\n+            properties.put(AcceptSubtypes, !handlerConfig.rejectSubtypes());\n+            properties.put(Listener, listenerConfig);\n+            properties.put(IsSynchronized, handler.getAnnotation(Synchronized.class) != null);\n+            properties.put(HandledMessages, handledMessages);\n+            return properties;\n+        }\n+    }\n+\n+\n     private final Method handler;\n \n     private final IMessageFilter[] filter;\n \n-    private final Handler handlerConfig;\n+    private final int priority;\n+\n+    private final Class<? extends HandlerInvocation> invocation;\n \n-    private final boolean isAsynchronous;\n+    private final Invoke invocationMode;\n \n-    private final Enveloped envelope;\n+    private final boolean isEnvelope;\n \n-    private final List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n+    private final Class[] handledMessages;\n \n     private final boolean acceptsSubtypes;\n \n@@ -34,29 +84,40 @@ public class MessageHandler {\n \n     private final boolean isSynchronized;\n \n-    private Class listeningClass;\n-\n+    public MessageHandler(Map<String, Object> properties){\n+        super();\n+        validate(properties);\n+        this.handler = (Method)properties.get(Properties.HandlerMethod);\n+        this.filter = (IMessageFilter[])properties.get(Properties.Filter);\n+        this.priority = (Integer)properties.get(Properties.Priority);\n+        this.invocation = (Class<? extends HandlerInvocation>)properties.get(Properties.Invocation);\n+        this.invocationMode = (Invoke)properties.get(Properties.InvocationMode);\n+        this.isEnvelope = (Boolean)properties.get(Properties.Enveloped);\n+        this.acceptsSubtypes = (Boolean)properties.get(Properties.AcceptSubtypes);\n+        this.listenerConfig = (MessageListener)properties.get(Properties.Listener);\n+        this.isSynchronized = (Boolean)properties.get(Properties.IsSynchronized);\n+        this.handledMessages = (Class[])properties.get(Properties.HandledMessages);\n+    }\n \n-    public MessageHandler(Method handler, IMessageFilter[] filter, Handler handlerConfig, MessageListener listenerConfig) {\n-        if(handler == null || handlerConfig == null){\n-            throw new IllegalArgumentException(\"The message handler configuration may not be null\");\n-        }\n-        this.handler = handler;\n-        this.filter = filter;\n-        this.handlerConfig = handlerConfig;\n-        this.isAsynchronous = handlerConfig.delivery().equals(Invoke.Asynchronously);\n-        this.envelope = handler.getAnnotation(Enveloped.class);\n-        this.acceptsSubtypes = !handlerConfig.rejectSubtypes();\n-        this.listenerConfig = listenerConfig;\n-        this.isSynchronized = handler.getAnnotation(Synchronized.class) != null;\n-        if (this.envelope != null) {\n-            for(Class messageType : envelope.messages()){\n-                handledMessages.add(messageType);\n-            }\n-        } else {\n-            handledMessages.add(handler.getParameterTypes()[0]);\n+    private void validate(Map<String, Object> properties){\n+        Object[][] expectedProperties = new Object[][]{\n+                new Object[]{Properties.HandlerMethod, Method.class },\n+                new Object[]{Properties.Priority, Integer.class },\n+                new Object[]{Properties.Invocation, Class.class },\n+                new Object[]{Properties.Filter, IMessageFilter[].class },\n+                new Object[]{Properties.Enveloped, Boolean.class },\n+                new Object[]{Properties.HandledMessages, Class[].class },\n+                new Object[]{Properties.IsSynchronized, Boolean.class },\n+                new Object[]{Properties.Listener, MessageListener.class },\n+                new Object[]{Properties.AcceptSubtypes, Boolean.class }\n+        };\n+        for(Object[] property : expectedProperties){\n+            if (properties.get(property[0]) == null || !((Class)property[1]).isAssignableFrom(properties.get(property[0]).getClass()))\n+                throw new IllegalArgumentException(\"Property \" + property[0] + \" was expected to be not null and of type \" + property[1]\n+                        + \" but was: \" + properties.get(property[0]));\n         }\n-        this.handler.setAccessible(true);\n+\n+\n     }\n \n     public boolean isSynchronized(){\n@@ -72,15 +133,15 @@ public class MessageHandler {\n     }\n \n     public boolean isAsynchronous() {\n-        return isAsynchronous;\n+        return invocationMode.equals(Invoke.Asynchronously);\n     }\n \n     public boolean isFiltered() {\n-        return filter != null && filter.length > 0;\n+        return filter.length > 0;\n     }\n \n     public int getPriority() {\n-        return handlerConfig.priority();\n+        return priority;\n     }\n \n     public Method getHandler() {\n@@ -91,16 +152,16 @@ public class MessageHandler {\n         return filter;\n     }\n \n-    public List<Class<?>> getHandledMessages() {\n+    public Class[] getHandledMessages() {\n         return handledMessages;\n     }\n \n     public boolean isEnveloped() {\n-        return envelope != null;\n+        return isEnvelope;\n     }\n \n     public Class<? extends HandlerInvocation> getHandlerInvocation(){\n-        return handlerConfig.invocation();\n+        return invocation;\n     }\n \n     public boolean handlesMessage(Class<?> messageType) {\n@@ -119,8 +180,4 @@ public class MessageHandler {\n         return acceptsSubtypes;\n     }\n \n-\n-    public boolean isEnabled() {\n-        return handlerConfig.enabled();\n-    }\n }\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MetadataReader.java",
            "additions": 3,
            "deletions": 2
        },
        "diff content": "@@ -76,8 +76,9 @@ public class MetadataReader {\n             }\n             Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n             // if a handler is overwritten it inherits the configuration of its parent method\n-            MessageHandler handlerMetadata = new MessageHandler(overriddenHandler == null ? handler : overriddenHandler,\n-                    getFilter(handlerConfig), handlerConfig, listenerMetadata);\n+            Map<String, Object> handlerProperties = MessageHandler.Properties.Create(overriddenHandler == null ? handler : overriddenHandler,\n+                    handlerConfig, getFilter(handlerConfig), listenerMetadata);\n+            MessageHandler handlerMetadata = new MessageHandler(handlerProperties);\n             listenerMetadata.addHandler(handlerMetadata);\n \n         }\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -5,7 +5,6 @@ import net.engio.mbassy.common.IConcurrentSet;\n import net.engio.mbassy.dispatch.IMessageDispatcher;\n \n import java.util.Comparator;\n-import java.util.List;\n import java.util.UUID;\n \n /**\n@@ -64,7 +63,7 @@ public class Subscription {\n         return context.getHandlerMetadata().handlesMessage(messageType);\n     }\n \n-    public List<Class<?>> getHandledMessageTypes(){\n+    public Class[] getHandledMessageTypes(){\n         return context.getHandlerMetadata().getHandledMessages();\n     }\n \n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,8 +1,8 @@\n package net.engio.mbassy.subscription;\n \n-import net.engio.mbassy.IPublicationErrorHandler;\n import net.engio.mbassy.bus.BusRuntime;\n-import net.engio.mbassy.bus.RuntimeProvider;\n+import net.engio.mbassy.bus.common.RuntimeProvider;\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n import net.engio.mbassy.listener.MessageHandler;\n \n import java.util.Collection;\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java",
            "additions": 3,
            "deletions": 5
        },
        "diff content": "@@ -1,8 +1,8 @@\n package net.engio.mbassy.subscription;\n \n-import net.engio.mbassy.IPublicationErrorHandler;\n-import net.engio.mbassy.MessageBusException;\n import net.engio.mbassy.bus.BusRuntime;\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n+import net.engio.mbassy.bus.error.MessageBusException;\n import net.engio.mbassy.common.StrongConcurrentSet;\n import net.engio.mbassy.common.WeakConcurrentSet;\n import net.engio.mbassy.dispatch.*;\n@@ -18,11 +18,9 @@ import java.util.Collection;\n  */\n public class SubscriptionFactory {\n \n-    private static final String ErrorHandlers = \"error.handlers\";\n-\n     public Subscription createSubscription(BusRuntime runtime, MessageHandler handlerMetadata) throws MessageBusException{\n         try {\n-            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(ErrorHandlers);\n+            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(BusRuntime.Properties.ErrorHandlers);\n             SubscriptionContext context = new SubscriptionContext(runtime, handlerMetadata, errorHandlers);\n             IHandlerInvocation invocation = buildInvocationForHandler(context);\n             IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AllTests.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -21,7 +21,8 @@ import org.junit.runners.Suite;\n         MethodDispatchTest.class,\n         DeadMessageTest.class,\n         SynchronizedHandlerTest.class,\n-        SubscriptionManagerTest.class\n+        SubscriptionManagerTest.class,\n+        AsyncFIFOBusTest.class\n })\n public class AllTests {\n }\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AsyncFIFOBusTest.java",
            "additions": 162,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,162 @@\n+package net.engio.mbassy;\n+\n+import net.engio.mbassy.bus.BusFactory;\n+import net.engio.mbassy.bus.common.IMessageBus;\n+import net.engio.mbassy.common.MessageBusTest;\n+import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listener.Invoke;\n+import org.junit.Test;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 3/30/14\n+ */\n+public class AsyncFIFOBusTest extends MessageBusTest {\n+\n+    @Test\n+    public void testSingleThreadedSyncFIFO(){\n+        // create a fifo bus with 1000 concurrently subscribed listeners\n+        IMessageBus fifoBUs = BusFactory.AsynchronousSequentialFIFO();\n+\n+        List<SyncListener> listeners = new LinkedList<SyncListener>();\n+        for(int i = 0; i < 1000 ; i++){\n+            SyncListener listener = new SyncListener();\n+            listeners.add(listener);\n+            fifoBUs.subscribe(listener);\n+        }\n+\n+        // prepare set of messages in increasing order\n+        int[] messages = new int[1000];\n+        for(int i = 0; i < messages.length ; i++){\n+             messages[i] = i;\n+        }\n+        // publish in ascending order\n+        for(Integer message : messages)\n+            fifoBUs.post(message).asynchronously();\n+\n+        while(fifoBUs.hasPendingMessages())\n+            pause(1000);\n+\n+        for(SyncListener listener : listeners){\n+            assertEquals(messages.length, listener.receivedSync.size());\n+            for(int i=0; i < messages.length; i++){\n+                assertEquals(messages[i], listener.receivedSync.get(i));\n+            }\n+        }\n+\n+    }\n+\n+    // NOTE: Can fail due to timing issues.\n+    @Test\n+    public void testSingleThreadedSyncAsyncFIFO(){\n+        // create a fifo bus with 1000 concurrently subscribed listeners\n+        IMessageBus fifoBUs = BusFactory.AsynchronousSequentialFIFO();\n+\n+        List<SyncAsyncListener> listeners = new LinkedList<SyncAsyncListener>();\n+        for(int i = 0; i < 1000 ; i++){\n+            SyncAsyncListener listener = new SyncAsyncListener();\n+            listeners.add(listener);\n+            fifoBUs.subscribe(listener);\n+        }\n+\n+        // prepare set of messages in increasing order\n+        int[] messages = new int[1000];\n+        for(int i = 0; i < messages.length ; i++){\n+            messages[i] = i;\n+        }\n+        // publish in ascending order\n+        for(Integer message : messages)\n+            fifoBUs.post(message).asynchronously();\n+\n+        while(fifoBUs.hasPendingMessages())\n+            pause(2000);\n+\n+        for(SyncAsyncListener listener : listeners){\n+            assertEquals(messages.length, listener.receivedSync.size());\n+            assertEquals(listener.receivedSync.size(), listener.receivedAsync.size());\n+            for(int i=0; i < listener.receivedAsync.size(); i++){\n+                assertEquals(messages[i], listener.receivedSync.get(i));\n+                // sync and async in same order\n+                assertEquals(listener.receivedSync.get(i), listener.receivedAsync.get(i));\n+            }\n+        }\n+\n+    }\n+\n+    /*\n+    @Test\n+    public void testMultiThreadedSyncFIFO(){\n+        // create a fifo bus with 1000 concurrently subscribed listeners\n+        final IMessageBus fifoBUs = BusFactory.AsynchronousSequentialFIFO();\n+\n+        List<SyncListener> listeners = new LinkedList<SyncListener>();\n+        for(int i = 0; i < 1000 ; i++){\n+            SyncListener listener = new SyncListener();\n+            listeners.add(listener);\n+            fifoBUs.subscribe(listener);\n+        }\n+\n+        // prepare set of messages in increasing order\n+        final int[] messages = new int[10000];\n+        for(int i = 0; i < messages.length ; i++){\n+            messages[i] = i;\n+        }\n+        final AtomicInteger messageIndex = new AtomicInteger(0);\n+        // publish in ascending order\n+        ConcurrentExecutor.runConcurrent(new Runnable() {\n+            @Override\n+            public void run() {\n+                int idx;\n+                while((idx = messageIndex.getAndIncrement()) < messages.length){\n+                    fifoBUs.post(messages[idx]).asynchronously();\n+                }\n+            }\n+        }, 5);\n+\n+        while(fifoBUs.hasPendingMessages())\n+            pause(1000);\n+\n+        for(SyncListener listener : listeners){\n+            assertEquals(messages.length, listener.receivedSync.size());\n+            for(int i=0; i < messages.length; i++){\n+                assertEquals(messages[i], listener.receivedSync.get(i));\n+            }\n+        }\n+\n+    }  */\n+\n+\n+\n+    public static class SyncListener {\n+\n+        private List<Integer> receivedSync = new LinkedList<Integer>();\n+\n+        @Handler\n+        public void handleSync(Integer message){\n+            receivedSync.add(message);\n+        }\n+\n+    }\n+\n+    public static class SyncAsyncListener {\n+\n+        private List<Integer> receivedSync = new LinkedList<Integer>();\n+        private List<Integer> receivedAsync = new LinkedList<Integer>();\n+\n+        @Handler\n+        public void handleSync(Integer message){\n+            receivedSync.add(message);\n+        }\n+\n+        @Handler(delivery = Invoke.Asynchronously)\n+        public void handleASync(Integer message){\n+            receivedAsync.add(message);\n+        }\n+\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/DeadMessageTest.java",
            "additions": 6,
            "deletions": 3
        },
        "diff content": "@@ -1,11 +1,14 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.bus.MBassador;\n-import net.engio.mbassy.common.*;\n+import net.engio.mbassy.bus.common.DeadMessage;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.common.ConcurrentExecutor;\n+import net.engio.mbassy.common.ListenerFactory;\n+import net.engio.mbassy.common.MessageBusTest;\n+import net.engio.mbassy.common.TestUtil;\n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listeners.IMessageListener;\n-import net.engio.mbassy.common.ListenerFactory;\n import net.engio.mbassy.listeners.MessagesListener;\n import net.engio.mbassy.listeners.ObjectListener;\n import org.junit.Before;\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/FilterTest.java",
            "additions": 5,
            "deletions": 1
        },
        "diff content": "@@ -1,8 +1,12 @@\n package net.engio.mbassy;\n \n import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.bus.common.DeadMessage;\n+import net.engio.mbassy.bus.common.FilteredMessage;\n import net.engio.mbassy.bus.config.BusConfiguration;\n-import net.engio.mbassy.common.*;\n+import net.engio.mbassy.common.ListenerFactory;\n+import net.engio.mbassy.common.MessageBusTest;\n+import net.engio.mbassy.common.TestUtil;\n import net.engio.mbassy.listener.*;\n import net.engio.mbassy.messages.SubTestMessage;\n import net.engio.mbassy.messages.TestMessage;\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MBassadorTest.java",
            "additions": 3,
            "deletions": 1
        },
        "diff content": "@@ -1,7 +1,9 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n+import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.common.*;\n import net.engio.mbassy.listeners.*;\n import net.engio.mbassy.messages.MessageTypes;\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MethodDispatchTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.bus.IMessageBus;\n+import net.engio.mbassy.bus.common.IMessageBus;\n import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.listener.Handler;\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -214,8 +214,8 @@ public class SubscriptionManagerTest extends AssertSupport {\n \n     private BusRuntime mockedRuntime(){\n         return new BusRuntime(null)\n-                .add(\"error.handlers\", Collections.EMPTY_SET)\n-                .add(\"handler.async-service\", null);\n+                .add(BusRuntime.Properties.ErrorHandlers, Collections.EMPTY_SET)\n+                .add(BusRuntime.Properties.AsynchronousHandlerExecutor, null);\n     }\n \n     private ListenerFactory listeners(Class ...listeners){\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 5,
            "deletions": 5
        },
        "diff content": "@@ -1,10 +1,11 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.bus.ISyncMessageBus;\n+import net.engio.mbassy.bus.BusFactory;\n import net.engio.mbassy.bus.MBassador;\n-import net.engio.mbassy.bus.SyncMessageBus;\n+import net.engio.mbassy.bus.common.ISyncMessageBus;\n import net.engio.mbassy.bus.config.BusConfiguration;\n-import net.engio.mbassy.bus.config.SyncBusConfiguration;\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n+import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.common.ConcurrentExecutor;\n import net.engio.mbassy.common.ListenerFactory;\n import net.engio.mbassy.common.MessageBusTest;\n@@ -17,7 +18,6 @@ import net.engio.mbassy.listeners.MessagesListener;\n import net.engio.mbassy.messages.MessageTypes;\n import net.engio.mbassy.messages.MultipartMessage;\n import net.engio.mbassy.messages.StandardMessage;\n-\n import org.junit.Assert;\n import org.junit.Test;\n \n@@ -188,7 +188,7 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n         @Override\n         protected ISyncMessageBus getSyncMessageBus() {\n-            return new SyncMessageBus(new SyncBusConfiguration());\n+            return BusFactory.SynchronousOnly();\n         }\n     }\n \n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java",
            "additions": 3,
            "deletions": 2
        },
        "diff content": "@@ -1,8 +1,8 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.bus.config.BusConfiguration;\n-import net.engio.mbassy.bus.IMessageBus;\n import net.engio.mbassy.bus.MessagePublication;\n+import net.engio.mbassy.bus.common.IMessageBus;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Invoke;\n@@ -66,6 +66,7 @@ public class SynchronizedHandlerTest extends MessageBusTest {\n             bus.post(new Object()).asynchronously();\n         }\n \n+        // TODO: wait for publication\n         pause(10000);\n \n         for(SynchronizedWithAsynchronousDelivery handler : handlers){\n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -1,11 +1,11 @@\n package net.engio.mbassy.common;\n \n import junit.framework.Assert;\n-import net.engio.mbassy.IPublicationErrorHandler;\n-import net.engio.mbassy.PublicationError;\n+import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.bus.config.BusConfiguration;\n-import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.bus.error.IPublicationErrorHandler;\n+import net.engio.mbassy.bus.error.PublicationError;\n import net.engio.mbassy.messages.MessageTypes;\n import org.junit.Before;\n \n"
    },
    {
        "commit hash": "4034024e30c5033878ae9905495fa8dce28a9732",
        "previous commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/TestUtil.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.common;\n \n import net.engio.mbassy.bus.MBassador;\n-import net.engio.mbassy.bus.PubSubSupport;\n+import net.engio.mbassy.bus.common.PubSubSupport;\n import net.engio.mbassy.subscription.SubscriptionManager;\n \n import java.util.Iterator;\n"
    },
    {
        "commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "previous commit hash": "d84b3877faa2596015c9efdfa119a4e456cac29a",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 0,
            "deletions": 3
        },
        "diff content": "@@ -211,9 +211,6 @@\n \t\t<header>mbassador, ${project.version}</header>\n \t\t<footer>mbassador, ${project.version}</footer>\n \t\t<doctitle>mbassador, ${project.version}</doctitle>\n-\t\t<links>\n-\t\t    <link></link>\n-\t\t</links>\n \t    </configuration>\n \t</plugin>\n \t<plugin>\n"
    },
    {
        "commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "previous commit hash": "d84b3877faa2596015c9efdfa119a4e456cac29a",
        "diff stats": {
            "file_path": "src/docs/TODO.md",
            "additions": 22,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,22 @@\n+#Tests\n+Asyncbus.shutdown() -> no test coverage\n+EnvelopedMessageDispatcher -> not tested at all\n+\n+#Refactorings\n+\n+\n+#Improvements\n+Prio 1: Validation of handlers\n+    ERROR:Handler with mismatching parameter types\n+    ERROR:Interfaces + rejectSubtypes\n+    WARN:@Synchronized only for some handlers of a given listener\n+Prio 2: Lifecycle Callbacks = Implement in MessagePublication (BeforeStart,AfterCompletion)\n+\n+\n+#Documentation\n+Add code examples Javadoc of main classes\n+Describe 1-Thread FIFO scheme with async dispatch\n+Explain how MBassador can be extended easily using delegation\n+Refer to Spring integration component\n+How to make sender part of the message publication\n+How to add global filtering by means of delegation\n"
    },
    {
        "commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "previous commit hash": "d84b3877faa2596015c9efdfa119a4e456cac29a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/PublicationError.java",
            "additions": 13,
            "deletions": 0
        },
        "diff content": "@@ -1,5 +1,7 @@\n package net.engio.mbassy;\n \n+import net.engio.mbassy.bus.MessagePublication;\n+\n import java.lang.reflect.Method;\n \n /**\n@@ -44,6 +46,17 @@ public class PublicationError{\n         this.publishedObject = publishedObject;\n     }\n \n+    public PublicationError(final Throwable cause,\n+                            final String message,\n+                            final MessagePublication publication) {\n+        this.cause = cause;\n+        this.message = message;\n+        this.publishedObject = publication != null ? publication.getMessage() : null;\n+    }\n+\n+\n+\n+\n     /**\n      * Default constructor.\n      */\n"
    },
    {
        "commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "previous commit hash": "d84b3877faa2596015c9efdfa119a4e456cac29a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java",
            "additions": 3,
            "deletions": 5
        },
        "diff content": "@@ -3,7 +3,6 @@ package net.engio.mbassy.bus;\n import net.engio.mbassy.IPublicationErrorHandler;\n import net.engio.mbassy.PublicationError;\n import net.engio.mbassy.bus.config.ISyncBusConfiguration;\n-import net.engio.mbassy.bus.publication.IPublicationCommand;\n import net.engio.mbassy.common.DeadMessage;\n import net.engio.mbassy.subscription.Subscription;\n import net.engio.mbassy.subscription.SubscriptionManager;\n@@ -17,9 +16,8 @@ import java.util.List;\n  * The base class for all message bus implementations.\n  *\n  * @param <T>\n- * @param <P>\n  */\n-public abstract class AbstractSyncMessageBus<T, P extends IPublicationCommand> implements ISyncMessageBus<T, P>{\n+public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T>{\n \n \n     // this handler will receive all errors that occur during message dispatch or message handling\n@@ -32,7 +30,7 @@ public abstract class AbstractSyncMessageBus<T, P extends IPublicationCommand> i\n     private final BusRuntime runtime;\n \n \n-    public AbstractSyncMessageBus(ISyncBusConfiguration configuration) {\n+    public AbstractPubSubSupport(ISyncBusConfiguration configuration) {\n         this.runtime = new BusRuntime(this);\n         this.runtime.add(\"error.handlers\", getRegisteredErrorHandlers());\n         this.subscriptionManager = configuration.getSubscriptionManagerProvider()\n@@ -45,7 +43,7 @@ public abstract class AbstractSyncMessageBus<T, P extends IPublicationCommand> i\n         return publicationFactory;\n     }\n \n-    @Override\n+\n     public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n         return Collections.unmodifiableCollection(errorHandlers);\n     }\n"
    },
    {
        "commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "previous commit hash": "d84b3877faa2596015c9efdfa119a4e456cac29a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java",
            "additions": 18,
            "deletions": 15
        },
        "diff content": "@@ -17,7 +17,8 @@ import java.util.concurrent.TimeUnit;\n  * @param <T>\n  * @param <P>\n  */\n-public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublicationCommand> extends AbstractSyncMessageBus<T, P> implements IMessageBus<T, P> {\n+public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublicationCommand>\n+        extends AbstractPubSubSupport<T> implements IMessageBus<T, P> {\n \n     // executor for asynchronous message handlers\n     private final ExecutorService executor;\n@@ -47,13 +48,15 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n             Thread dispatcher = configuration.getThreadFactoryForAsynchronousMessageDispatch().newThread(new Runnable() {\n                 public void run() {\n                     while (true) {\n+                        MessagePublication publication = null;\n                         try {\n-                            pendingMessages.take().execute();\n+                            publication = pendingMessages.take();\n+                            publication.execute();\n                         } catch (InterruptedException e) {\n                             Thread.currentThread().interrupt();\n                             return;\n                         } catch(Throwable t){\n-                            handlePublicationError(new PublicationError(t, \"Error in asynchronous dispatch\", null, null, null));\n+                            handlePublicationError(new PublicationError(t, \"Error in asynchronous dispatch\",publication));\n                         }\n                     }\n                 }\n@@ -64,26 +67,26 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublica\n     }\n \n \n-    // this method enqueues a message delivery request\n-    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request) {\n+    // this method queues a message delivery request\n+    protected MessagePublication addAsynchronousPublication(MessagePublication publication) {\n         try {\n-            pendingMessages.put(request);\n-            return request.markScheduled();\n+            pendingMessages.put(publication);\n+            return publication.markScheduled();\n         } catch (InterruptedException e) {\n-            // TODO: publication error\n-            return request;\n+            handlePublicationError(new PublicationError(e, \"Error while adding an asynchronous message publication\", publication));\n+            return publication;\n         }\n     }\n \n     // this method queues a message delivery request\n-    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit) {\n+    protected MessagePublication addAsynchronousPublication(MessagePublication publication, long timeout, TimeUnit unit) {\n         try {\n-            return pendingMessages.offer(request, timeout, unit)\n-                    ? request.markScheduled()\n-                    : request;\n+            return pendingMessages.offer(publication, timeout, unit)\n+                    ? publication.markScheduled()\n+                    : publication;\n         } catch (InterruptedException e) {\n-            // TODO: publication error\n-            return request;\n+            handlePublicationError(new PublicationError(e, \"Error while adding an asynchronous message publication\", publication));\n+            return publication;\n         }\n     }\n \n"
    },
    {
        "commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "previous commit hash": "d84b3877faa2596015c9efdfa119a4e456cac29a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/IMessageBus.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -57,7 +57,8 @@ import java.util.concurrent.Executor;\n  * @Author bennidi\n  * Date: 2/8/12\n  */\n-public interface IMessageBus<T, P extends ISyncAsyncPublicationCommand> extends PubSubSupport<T>, ErrorHandlingSupport, GenericMessagePublicationSupport<T, P> {\n+public interface IMessageBus<T, P extends ISyncAsyncPublicationCommand>\n+        extends PubSubSupport<T>, ErrorHandlingSupport, GenericMessagePublicationSupport<T, P>, ISyncMessageBus<T,P> {\n \n     /**\n      * {@inheritDoc}\n"
    },
    {
        "commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "previous commit hash": "d84b3877faa2596015c9efdfa119a4e456cac29a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MBassador.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -16,12 +16,12 @@ public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCo\n \n     @Override\n     public MessagePublication publishAsync(T message) {\n-        return addAsynchronousDeliveryRequest(createMessagePublication(message));\n+        return addAsynchronousPublication(createMessagePublication(message));\n     }\n \n     @Override\n     public MessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n-        return addAsynchronousDeliveryRequest(createMessagePublication(message), timeout, unit);\n+        return addAsynchronousPublication(createMessagePublication(message), timeout, unit);\n     }\n \n \n"
    },
    {
        "commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "previous commit hash": "d84b3877faa2596015c9efdfa119a4e456cac29a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MessagePublication.java",
            "additions": 5,
            "deletions": 1
        },
        "diff content": "@@ -23,7 +23,7 @@ public class MessagePublication {\n     private final Object message;\n     // message publications can be referenced by multiple threads to query publication progress\n     private volatile State state = State.Initial;\n-    private volatile boolean delivered = false;\n+    private volatile boolean delivered = false; // TODO: maybe replace with return value of subscription and dispatchers?\n     private final BusRuntime runtime;\n \n     protected MessagePublication(BusRuntime runtime, Collection<Subscription> subscriptions, Object message, State initialState) {\n@@ -86,6 +86,10 @@ public class MessagePublication {\n         return FilteredMessage.class.isAssignableFrom(message.getClass());\n     }\n \n+    public Object getMessage() {\n+        return message;\n+    }\n+\n     private enum State {\n         Initial, Scheduled, Running, Finished, Error\n     }\n"
    },
    {
        "commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "previous commit hash": "d84b3877faa2596015c9efdfa119a4e456cac29a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/SyncMessageBus.java",
            "additions": 5,
            "deletions": 14
        },
        "diff content": "@@ -5,25 +5,18 @@ import net.engio.mbassy.bus.config.ISyncBusConfiguration;\n import net.engio.mbassy.bus.publication.IPublicationCommand;\n \n /**\n- * Created with IntelliJ IDEA.\n- * User: benjamin\n- * Date: 4/3/13\n- * Time: 9:02 AM\n- * To change this template use File | Settings | File Templates.\n+ * A message bus implementation that offers only synchronous message publication. Using this bus\n+ * will not create any new threads.\n+ *\n  */\n-public class SyncMessageBus<T> extends AbstractSyncMessageBus<T, SyncMessageBus.SyncPostCommand>{\n+public class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements ISyncMessageBus<T, SyncMessageBus.SyncPostCommand>{\n \n \n     public SyncMessageBus(ISyncBusConfiguration configuration) {\n         super(configuration);\n     }\n \n-    /**\n-     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n-     * The call blocks until every messageHandler has processed the message.\n-     *\n-     * @param message\n-     */\n+    @Override\n     public void publish(T message) {\n         try {\n             MessagePublication publication = createMessagePublication(message);\n@@ -34,7 +27,6 @@ public class SyncMessageBus<T> extends AbstractSyncMessageBus<T, SyncMessageBus.\n                     .setCause(e)\n                     .setPublishedObject(message));\n         }\n-\n     }\n \n     @Override\n@@ -44,7 +36,6 @@ public class SyncMessageBus<T> extends AbstractSyncMessageBus<T, SyncMessageBus.\n \n     public class SyncPostCommand implements IPublicationCommand {\n \n-\n         private T message;\n \n         public SyncPostCommand(T message) {\n"
    },
    {
        "commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "previous commit hash": "d84b3877faa2596015c9efdfa119a4e456cac29a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Filters.java",
            "additions": 27,
            "deletions": 15
        },
        "diff content": "@@ -1,41 +1,53 @@\n package net.engio.mbassy.listener;\n \n /**\n- * Some sample filters that are not particularly useful in production environment\n- * but illustrate how filters are meant to be used.\n+ * A set of standard filters for common use cases.\n  *\n  * @author bennidi\n  *         Date: 12/12/12\n  */\n public class Filters {\n \n-    public static final class AllowAll implements IMessageFilter {\n \n-        @Override\n-        public boolean accepts(Object event, MessageHandler metadata) {\n-            return true;\n-        }\n-    }\n \n-    public static final class RejectAll implements IMessageFilter {\n+    /**\n+     * This filter will only accept messages of the exact same type\n+     * as specified for the handler. Subclasses (this includes interface implementations)\n+     * will be rejected.\n+     *\n+     * NOTE: The same functionality (with better performance) is achieved using {@code rejectSubtypes = true}\n+     * in the @Handler annotation\n+     */\n+    public static final class RejectSubtypes implements IMessageFilter {\n \n         @Override\n         public boolean accepts(Object event, MessageHandler metadata) {\n+            for (Class handledMessage : metadata.getHandledMessages()) {\n+                if (handledMessage.equals(event.getClass())) {\n+                    return true;\n+                }\n+            }\n             return false;\n         }\n     }\n \n-\n-    public static final class RejectSubtypes implements IMessageFilter {\n+    /**\n+     * This filter will only accept messages that are real subtypes\n+     * of the specified message types handled by the message handler.\n+     * Example: If the handler handles Object.class the filter accepts\n+     * all objects except any direct instance of Object.class {@code new Object()}\n+     */\n+    public static final class SubtypesOnly implements IMessageFilter{\n \n         @Override\n-        public boolean accepts(Object event, MessageHandler metadata) {\n-            for (Class handledMessage : metadata.getHandledMessages()) {\n-                if (handledMessage.equals(event.getClass())) {\n+        public boolean accepts(Object message, MessageHandler metadata) {\n+            for(Class acceptedClasses : metadata.getHandledMessages()){\n+                if(acceptedClasses.isAssignableFrom(message.getClass())\n+                        && ! acceptedClasses.equals(message.getClass()))\n                     return true;\n-                }\n             }\n             return false;\n         }\n     }\n+\n }\n"
    },
    {
        "commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "previous commit hash": "d84b3877faa2596015c9efdfa119a4e456cac29a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/FilterTest.java",
            "additions": 39,
            "deletions": 8
        },
        "diff content": "@@ -1,15 +1,11 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.bus.MBassador;\n-import net.engio.mbassy.common.DeadMessage;\n-import net.engio.mbassy.common.FilteredMessage;\n-import net.engio.mbassy.common.MessageBusTest;\n-import net.engio.mbassy.common.TestUtil;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.common.*;\n+import net.engio.mbassy.listener.*;\n import net.engio.mbassy.messages.SubTestMessage;\n import net.engio.mbassy.messages.TestMessage;\n-import net.engio.mbassy.listener.*;\n-import net.engio.mbassy.common.ListenerFactory;\n import org.junit.Test;\n \n import java.util.List;\n@@ -88,7 +84,7 @@ public class FilterTest extends MessageBusTest {\n         }\n \n         // will cause republication of a FilteredEvent\n-        @Handler(filters = {@Filter(Filters.RejectAll.class)})\n+        @Handler(filters = {@Filter(RejectAll.class)})\n         public void handleNone(Object any){\n             FilteredEventCounter.incrementAndGet();\n         }\n@@ -98,7 +94,34 @@ public class FilterTest extends MessageBusTest {\n         public void handleDead(DeadMessage dead){\n             DeadEventCounter.incrementAndGet();\n         }\n+    }\n+\n+    @Test\n+    public void testSubtypesOnly(){\n+        MBassador bus = getBus(BusConfiguration.Default());\n+        ListenerFactory listeners = new ListenerFactory()\n+                .create(100, TestMessageHandler.class);\n+\n+        // this will subscribe the listeners concurrently to the bus\n+        TestUtil.setup(bus, listeners, 10);\n+\n+        TestMessage supertype = new TestMessage();\n+        TestMessage subtype = new SubTestMessage();\n \n+        bus.publish(supertype);\n+        bus.publish(subtype);\n+\n+        assertEquals(100, subtype.counter.get());\n+        assertEquals(0, supertype.counter.get());\n+\n+    }\n+\n+    public static class TestMessageHandler{\n+\n+        @Handler(filters = @Filter(Filters.SubtypesOnly.class))\n+        public void handle(TestMessage message){\n+            message.counter.incrementAndGet();\n+        }\n \n     }\n \n@@ -113,4 +136,12 @@ public class FilterTest extends MessageBusTest {\n         }\n     }\n \n+    public static final class RejectAll implements IMessageFilter {\n+\n+        @Override\n+        public boolean accepts(Object event, MessageHandler metadata) {\n+            return false;\n+        }\n+    }\n+\n }\n"
    },
    {
        "commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "previous commit hash": "d84b3877faa2596015c9efdfa119a4e456cac29a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/TestUtil.java",
            "additions": 5,
            "deletions": 0
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy.common;\n \n+import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.bus.PubSubSupport;\n import net.engio.mbassy.subscription.SubscriptionManager;\n \n@@ -100,4 +101,8 @@ public class TestUtil {\n \n     }\n \n+    public static void setup(MBassador bus, ListenerFactory listeners, int numberOfThreads) {\n+        setup(bus, listeners.getAll(), numberOfThreads);\n+\n+    }\n }\n"
    },
    {
        "commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "previous commit hash": "d84b3877faa2596015c9efdfa119a4e456cac29a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/Overloading.java",
            "additions": 3,
            "deletions": 5
        },
        "diff content": "@@ -6,11 +6,9 @@ import net.engio.mbassy.listener.References;\n import net.engio.mbassy.messages.AbstractMessage;\n \n /**\n- * Created with IntelliJ IDEA.\n- * User: benjamin\n- * Date: 7/11/13\n- * Time: 10:11 AM\n- * To change this template use File | Settings | File Templates.\n+ * Some handlers and message types to test correct functioning of overloaded\n+ * message handlers\n+ *\n  */\n public class Overloading {\n \n"
    },
    {
        "commit hash": "54f7bd72b90ff7608c97b8ba4708ca95bc4de573",
        "previous commit hash": "d84b3877faa2596015c9efdfa119a4e456cac29a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/MessageTypes.java",
            "additions": 7,
            "deletions": 4
        },
        "diff content": "@@ -11,16 +11,19 @@ import java.util.concurrent.locks.ReentrantReadWriteLock;\n  *         Date: 5/24/13\n  */\n public enum MessageTypes implements IMessage{\n-    Simple,Persistent,Multipart;\n+\n+    Simple,\n+    Persistent,\n+    Multipart;\n+\n+    private Map<Class, Integer> handledByListener = new HashMap<Class, Integer>();\n+    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n \n     public static void resetAll(){\n         for(MessageTypes m : values())\n             m.reset();\n     }\n \n-    private Map<Class, Integer> handledByListener = new HashMap<Class, Integer>();\n-    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n-\n \n     @Override\n     public void reset() {\n"
    },
    {
        "commit hash": "d84b3877faa2596015c9efdfa119a4e456cac29a",
        "previous commit hash": "64974b7eefdf64581f048d4c691aa91d8949d45e",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -78,7 +78,8 @@ public class BusConfiguration implements IBusConfiguration {\n      * @return a Default BusConfiguration\n      */\n     public static BusConfiguration Default(int numberOfDispatchers, int initialCoreThreads, int maximumCoreThreads) {\n-    \tThreadPoolExecutor executor = new ThreadPoolExecutor(initialCoreThreads, maximumCoreThreads, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), AsynchronousHandlerThreadFactory);\n+    \tThreadPoolExecutor executor = new ThreadPoolExecutor(initialCoreThreads, maximumCoreThreads, 1,\n+                TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), AsynchronousHandlerThreadFactory);\n     \treturn Default(numberOfDispatchers, executor);\n     }\n     \n"
    },
    {
        "commit hash": "d84b3877faa2596015c9efdfa119a4e456cac29a",
        "previous commit hash": "64974b7eefdf64581f048d4c691aa91d8949d45e",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Synchronized.java",
            "additions": 8,
            "deletions": 1
        },
        "diff content": "@@ -4,7 +4,14 @@ import java.lang.annotation.*;\n \n /**\n  * A handler marked with this annotation is guaranteed to be invoked in a thread-safe manner, that is, no\n- * other running message publication will be able to invoke this handler as long as it has not done its work.\n+ * other running message publication will be able to invoke this or any other synchronized handler of the same\n+ * listener until the handler completed. It is equal to wrapping the handler code in a synchronized{} block.\n+ * This feature will reduce performance of message publication. Try to avoid shared mutable state whenever possible\n+ * and use immutable data instead.\n+ *\n+ * Note: Unsynchronized handlers may still be invoked concurrently with synchronized ones\n+ *\n+ *\n  *\n  * @author bennidi\n  *         Date: 3/31/13\n"
    },
    {
        "commit hash": "64974b7eefdf64581f048d4c691aa91d8949d45e",
        "previous commit hash": "6792d18f3aedf6f7f917a1c0fa56d31203801cd5",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 4,
            "deletions": 3
        },
        "diff content": "@@ -241,9 +241,10 @@ public class SubscriptionManagerTest extends AssertSupport {\n     }\n \n \n-\n-\n-\n+    /**\n+     *  define handlers with different priorities which need to be executed\n+     *  in their respective order\n+     */\n     public static class PrioritizedListener{\n \n \n"
    },
    {
        "commit hash": "6792d18f3aedf6f7f917a1c0fa56d31203801cd5",
        "previous commit hash": "5d7591ccdfaf09e8344d717bf26e43223ddd85b7",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -8,7 +8,8 @@ The performance win of this design is illustrated in <a href=\"http://codeblock.e\n The benchmarking code can be found <a href=\"https://github.com/bennidi/eventbus-performance\" target=\"_blank\">here</a>\n \n Read this documentation to get an overview of MBassadors features. There is also some documentation in the Wiki - although admittedly\n-not enough to make a developer happy (work is in progress). Additionally, you can browse the [javadoc](http://bennidi.github.io/mbassador/)\n+not enough to make a developer happy (work is in progress).\n+Additionally, you can browse the [javadoc](http://bennidi.github.io/mbassador/)\n \n The current version is 1.1.9 and it is available from the Maven Central Repository. See the release notes for more details.\n \n"
    },
    {
        "commit hash": "6792d18f3aedf6f7f917a1c0fa56d31203801cd5",
        "previous commit hash": "5d7591ccdfaf09e8344d717bf26e43223ddd85b7",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -212,7 +212,7 @@\n \t\t<footer>mbassador, ${project.version}</footer>\n \t\t<doctitle>mbassador, ${project.version}</doctitle>\n \t\t<links>\n-\t\t    <link>http://static.springsource.org/spring/docs/3.0.x/javadoc-api/</link>\n+\t\t    <link></link>\n \t\t</links>\n \t    </configuration>\n \t</plugin>\n@@ -226,7 +226,7 @@\n \t\t<content>${project.reporting.outputDirectory}/apidocs</content>\n \t\t<skipDeletedFiles>true</skipDeletedFiles>\n \t\t<pubScmUrl>scm:git:git@github.com:bennidi/mbassador.git</pubScmUrl>\n-\t\t<scmBranch>gh-pages</scmBranch> <!-- branch with static site -->\n+\t\t<scmBranch>gh-pages</scmBranch> <!-- branch with static site on github-->\n \t    </configuration>\n \t</plugin>\n         </plugins>\n"
    },
    {
        "commit hash": "6792d18f3aedf6f7f917a1c0fa56d31203801cd5",
        "previous commit hash": "5d7591ccdfaf09e8344d717bf26e43223ddd85b7",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/IMessageFilter.java",
            "additions": 28,
            "deletions": 9
        },
        "diff content": "@@ -1,21 +1,40 @@\n package net.engio.mbassy.listener;\n \n /**\n- * Message filters can be used to prevent certain messages to be delivered to a specific listener.\n- * If a filter is used the message will only be delivered if it passes the filter(s)\n- * <p/>\n- * NOTE: A message filter must provide either a no-arg constructor.\n+ * Message filters can be used to control what messages are delivered to a specific message handler.\n+ * Filters are attached to message handler using the @Listener annotation.\n+ * If a message handler specifies filters, the filters accepts(...) method will be checked before the actual handler is invoked.\n+ * The handler will be invoked only if each filter accepted the message.\n+ *\n+ * Example:\n+ *\n+ * @Lister\n+ * @Filters(Urlfilter.class)\n+ * public void someHandler(String message){...}\n+ *\n+ * class Urlfilter implements IMessageFilter<String>{\n+ *     public boolean accepts(String message, MessageHandler metadata){\n+ *         return message.startsWith(\"http\");\n+ *     }\n+ * }\n+ *\n+ * bus.post(\"http://www.infoq.com\"); // will be delivered\n+ * bus.post(\"www.stackoverflow.com\"); // will not be delivered\n+ *\n+ * NOTE: A message filter must provide a no-arg constructor!!!\n  *\n  * @author bennidi\n  *         Date: 2/8/12\n  */\n-public interface IMessageFilter {\n+public interface IMessageFilter<M> {\n \n     /**\n-     * Evaluate the message to ensure that it matches the handler configuration\n+     * Check the message for whatever criteria\n      *\n-     * @param message the message to be delivered\n-     * @return\n+     * @param message the message to be handled by the handler\n+     * @param  metadata the metadata object which describes the message handler\n+     * @return  true: if the message matches the criteria and should be delivered to the handler\n+     *          false: otherwise\n      */\n-    boolean accepts(Object message, MessageHandler metadata);\n+    boolean accepts(M message, MessageHandler metadata);\n }\n"
    },
    {
        "commit hash": "5d7591ccdfaf09e8344d717bf26e43223ddd85b7",
        "previous commit hash": "9ee3f11578d5d166cbbf1d83da4fb68c8a023aa2",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -8,8 +8,7 @@ The performance win of this design is illustrated in <a href=\"http://codeblock.e\n The benchmarking code can be found <a href=\"https://github.com/bennidi/eventbus-performance\" target=\"_blank\">here</a>\n \n Read this documentation to get an overview of MBassadors features. There is also some documentation in the Wiki - although admittedly\n-not enough to make a developer happy (work is in progress). Additionally, you can browse the javadocs.\n-[javadoc](http://bennidi.github.io/mbassador/)\n+not enough to make a developer happy (work is in progress). Additionally, you can browse the [javadoc](http://bennidi.github.io/mbassador/)\n \n The current version is 1.1.9 and it is available from the Maven Central Repository. See the release notes for more details.\n \n"
    },
    {
        "commit hash": "9ee3f11578d5d166cbbf1d83da4fb68c8a023aa2",
        "previous commit hash": "fe696c2f95a91ed60bd13627fba560e9134a2b00",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -8,8 +8,8 @@ The performance win of this design is illustrated in <a href=\"http://codeblock.e\n The benchmarking code can be found <a href=\"https://github.com/bennidi/eventbus-performance\" target=\"_blank\">here</a>\n \n Read this documentation to get an overview of MBassadors features. There is also some documentation in the Wiki - although admittedly\n-not enough to make a developer happy (work is in progress). But usage of publish subscribe pattern at its core is pretty straight forward and the basic\n-use cases are very easy to understand and implement.\n+not enough to make a developer happy (work is in progress). Additionally, you can browse the javadocs.\n+[javadoc](http://bennidi.github.io/mbassador/)\n \n The current version is 1.1.9 and it is available from the Maven Central Repository. See the release notes for more details.\n \n"
    },
    {
        "commit hash": "9ee3f11578d5d166cbbf1d83da4fb68c8a023aa2",
        "previous commit hash": "fe696c2f95a91ed60bd13627fba560e9134a2b00",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 33,
            "deletions": 0
        },
        "diff content": "@@ -196,6 +196,39 @@\n                 </executions>\n             </plugin>\n \n+\t<!-- \n+\tThese two plugins take care of building and publishing the javadoc, using\n+\t\tmvn clean javadoc:javadoc scm-publish:publish-scm\n+\t --> \n+\t<plugin>\n+\t    <groupId>org.apache.maven.plugins</groupId>\n+\t    <artifactId>maven-javadoc-plugin</artifactId>\n+\t    <version>2.9.1</version>\n+\t    <configuration>\n+\t\t<aggregate>true</aggregate>\n+\t\t<show>public</show>\n+\t\t<nohelp>true</nohelp>\n+\t\t<header>mbassador, ${project.version}</header>\n+\t\t<footer>mbassador, ${project.version}</footer>\n+\t\t<doctitle>mbassador, ${project.version}</doctitle>\n+\t\t<links>\n+\t\t    <link>http://static.springsource.org/spring/docs/3.0.x/javadoc-api/</link>\n+\t\t</links>\n+\t    </configuration>\n+\t</plugin>\n+\t<plugin>\n+\t    <groupId>org.apache.maven.plugins</groupId>\n+\t    <artifactId>maven-scm-publish-plugin</artifactId>\n+\t    <version>1.0-beta-2</version>\n+\t    <configuration>\n+\t\t<checkoutDirectory>${project.build.directory}/scmpublish</checkoutDirectory>\n+\t\t<checkinComment>Publishing javadoc for ${project.artifactId}:${project.version}</checkinComment>\n+\t\t<content>${project.reporting.outputDirectory}/apidocs</content>\n+\t\t<skipDeletedFiles>true</skipDeletedFiles>\n+\t\t<pubScmUrl>scm:git:git@github.com:bennidi/mbassador.git</pubScmUrl>\n+\t\t<scmBranch>gh-pages</scmBranch> <!-- branch with static site -->\n+\t    </configuration>\n+\t</plugin>\n         </plugins>\n     </build>\n \n"
    },
    {
        "commit hash": "d2175fa2152f0ddc64de362f717eee9829e42ee5",
        "previous commit hash": "0d36eb65c7491fc1e6d5bc70cde968b1ac1e8b79",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -10,7 +10,7 @@ import java.util.UUID;\n \n /**\n  * A subscription is a thread-safe container that manages exactly one message handler of all registered\n- * message listeners of the same class, i.e. all subscribed instances of a SingleMessageHandler.class\n+ * message listeners of the same class, i.e. all subscribed instances (exlcuding subclasses) of a SingleMessageHandler.class\n  * will be referenced in the subscription created for SingleMessageHandler.class.\n  *\n  * There will be as many unique subscription objects per message listener class as there are message handlers\n@@ -96,8 +96,8 @@ public class Subscription {\n     public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n         @Override\n         public int compare(Subscription o1, Subscription o2) {\n-            int byPriority = ((Integer)o1.getPriority()).compareTo(o2.getPriority());\n-            return byPriority == 0 ? o1.id.compareTo(o2.id) : byPriority;\n+            int byPriority = ((Integer)o2.getPriority()).compareTo(o1.getPriority());\n+            return byPriority == 0 ? o2.id.compareTo(o1.id) : byPriority;\n         }\n     };\n \n"
    },
    {
        "commit hash": "d2175fa2152f0ddc64de362f717eee9829e42ee5",
        "previous commit hash": "0d36eb65c7491fc1e6d5bc70cde968b1ac1e8b79",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 38,
            "deletions": 0
        },
        "diff content": "@@ -2,6 +2,7 @@ package net.engio.mbassy;\n \n import net.engio.mbassy.bus.BusRuntime;\n import net.engio.mbassy.common.*;\n+import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.listeners.*;\n import net.engio.mbassy.messages.*;\n@@ -198,6 +199,19 @@ public class SubscriptionManagerTest extends AssertSupport {\n         runTestWith(listeners, expectedSubscriptions);\n     }\n \n+    @Test\n+    public void testPrioritizedMessageHandlers(){\n+        ListenerFactory listeners = listeners(PrioritizedListener.class);\n+\n+        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n+        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n+\n+        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n+                .listener(PrioritizedListener.class).handles(IMessage.class, IMessage.class, IMessage.class, IMessage.class);\n+\n+        runTestWith(listeners, expectedSubscriptions);\n+    }\n+\n     private BusRuntime mockedRuntime(){\n         return new BusRuntime(null)\n                 .add(\"error.handlers\", Collections.EMPTY_SET)\n@@ -230,5 +244,29 @@ public class SubscriptionManagerTest extends AssertSupport {\n \n \n \n+    public static class PrioritizedListener{\n+\n+\n+        @Handler(priority = 1)\n+        public void handlePrio1(IMessage message){\n+            message.handled(this.getClass());\n+        }\n+\n+        @Handler(priority = 2)\n+        public void handlePrio2(IMessage message){\n+            message.handled(this.getClass());\n+        }\n+\n+        @Handler(priority = 3)\n+        public void handlePrio3(IMessage message){\n+            message.handled(this.getClass());\n+        }\n+\n+        @Handler(priority = 4)\n+        public void handlePrio4(IMessage message){\n+            message.handled(this.getClass());\n+        }\n+    }\n+\n \n }\n"
    },
    {
        "commit hash": "d2175fa2152f0ddc64de362f717eee9829e42ee5",
        "previous commit hash": "0d36eb65c7491fc1e6d5bc70cde968b1ac1e8b79",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/SubscriptionValidator.java",
            "additions": 9,
            "deletions": 0
        },
        "diff content": "@@ -36,6 +36,7 @@ public class SubscriptionValidator extends AssertSupport{\n     public void validate(SubscriptionManager manager){\n         for(Class messageType : messageTypes){\n             Collection<Subscription> subscriptions = manager.getSubscriptionsByMessageType(messageType);\n+            ensureOrdering(subscriptions);\n             Collection<ValidationEntry> validationEntries = getEntries(EntriesByMessageType(messageType));\n             assertEquals(subscriptions.size(), validationEntries.size());\n             for(ValidationEntry validationValidationEntry : validationEntries){\n@@ -53,6 +54,14 @@ public class SubscriptionValidator extends AssertSupport{\n         }\n     }\n \n+    private void ensureOrdering(Collection<Subscription> subscriptions){\n+        int lastPriority = Integer.MAX_VALUE;// highest priority possible\n+        for(Subscription sub : subscriptions){\n+            assertTrue(\"Subscriptions should be ordered by priority (DESC)\", lastPriority >= sub.getPriority());\n+            lastPriority = sub.getPriority();\n+        }\n+    }\n+\n \n     private Collection<ValidationEntry> getEntries(IPredicate<ValidationEntry> filter){\n         Collection<ValidationEntry> matching = new LinkedList<ValidationEntry>();\n"
    },
    {
        "commit hash": "d2175fa2152f0ddc64de362f717eee9829e42ee5",
        "previous commit hash": "0d36eb65c7491fc1e6d5bc70cde968b1ac1e8b79",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/AbstractMessageListener.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -29,7 +29,7 @@ public class AbstractMessageListener {\n \n     public static class NoSubtypesListener extends BaseListener {\n \n-        @Handler(rejectSubtypes = true)\n+        @Handler(rejectSubtypes = true, priority = 4)\n         public void handle(AbstractMessage message){\n             super.handle(message);\n         }\n@@ -38,7 +38,7 @@ public class AbstractMessageListener {\n \n     public static class AsyncListener extends BaseListener {\n \n-        @Handler(delivery = Invoke.Asynchronously)\n+        @Handler(delivery = Invoke.Asynchronously, priority = Integer.MAX_VALUE)\n         public void handle(AbstractMessage message){\n             super.handle(message);\n         }\n"
    },
    {
        "commit hash": "d2175fa2152f0ddc64de362f717eee9829e42ee5",
        "previous commit hash": "0d36eb65c7491fc1e6d5bc70cde968b1ac1e8b79",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/IMultipartMessageListener.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -29,7 +29,7 @@ public class IMultipartMessageListener {\n \n     public static class NoSubtypesListener extends BaseListener {\n \n-        @Handler(rejectSubtypes = true)\n+        @Handler(rejectSubtypes = true, priority = Integer.MIN_VALUE)\n         public void handle(IMultipartMessage message){\n             super.handle(message);\n         }\n@@ -38,7 +38,7 @@ public class IMultipartMessageListener {\n \n     public static class AsyncListener extends BaseListener {\n \n-        @Handler(delivery = Invoke.Asynchronously)\n+        @Handler(delivery = Invoke.Asynchronously, priority = Integer.MIN_VALUE)\n         public void handle(IMultipartMessage message){\n             super.handle(message);\n         }\n@@ -47,7 +47,7 @@ public class IMultipartMessageListener {\n \n     public static class DisabledListener extends BaseListener {\n \n-        @Handler(enabled = false)\n+        @Handler(enabled = false , priority = 4)\n         public void handle(IMultipartMessage message){\n             super.handle(message);\n         }\n"
    },
    {
        "commit hash": "d2175fa2152f0ddc64de362f717eee9829e42ee5",
        "previous commit hash": "0d36eb65c7491fc1e6d5bc70cde968b1ac1e8b79",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/ObjectListener.java",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,5 @@\n package net.engio.mbassy.listeners;\n \n-import net.engio.mbassy.common.DeadMessage;\n import net.engio.mbassy.listener.Handler;\n \n import java.util.Collections;\n@@ -12,7 +11,7 @@ public class ObjectListener {\n \n     private List handledMessages = Collections.synchronizedList(new LinkedList());\n \n-    @Handler\n+    @Handler(priority = Integer.MAX_VALUE)\n     public void handle(Object message){\n         handledMessages.add(message);\n     }\n"
    },
    {
        "commit hash": "d2175fa2152f0ddc64de362f717eee9829e42ee5",
        "previous commit hash": "0d36eb65c7491fc1e6d5bc70cde968b1ac1e8b79",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/StandardMessageListener.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -13,7 +13,7 @@ public class StandardMessageListener {\n \n     private static abstract class BaseListener {\n \n-        @Handler\n+        @Handler(priority = 3)\n         public void handle(StandardMessage message){\n             message.handled(this.getClass());\n         }\n@@ -29,7 +29,7 @@ public class StandardMessageListener {\n \n     public static class NoSubtypesListener extends BaseListener {\n \n-        @Handler(rejectSubtypes = true)\n+        @Handler(rejectSubtypes = true, priority = 4)\n         public void handle(StandardMessage message){\n             super.handle(message);\n         }\n@@ -38,7 +38,7 @@ public class StandardMessageListener {\n \n     public static class AsyncListener extends BaseListener {\n \n-        @Handler(delivery = Invoke.Asynchronously)\n+        @Handler(delivery = Invoke.Asynchronously, priority = -10)\n         public void handle(StandardMessage message){\n             super.handle(message);\n         }\n"
    },
    {
        "commit hash": "5612cbee517d2bd74afcab22fac2fe0f4f84f953",
        "previous commit hash": "eb555ca1afc102206118cfe4e22e267ed9d09cff",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -35,7 +35,8 @@ public abstract class AbstractSyncMessageBus<T, P extends IPublicationCommand> i\n     public AbstractSyncMessageBus(ISyncBusConfiguration configuration) {\n         this.runtime = new BusRuntime(this);\n         this.runtime.add(\"error.handlers\", getRegisteredErrorHandlers());\n-        this.subscriptionManager = new SubscriptionManager(configuration.getMetadataReader(),\n+        this.subscriptionManager = configuration.getSubscriptionManagerProvider()\n+        \t\t.createManager(configuration.getMetadataReader(),\n                 configuration.getSubscriptionFactory(), runtime);\n         this.publicationFactory = configuration.getMessagePublicationFactory();\n     }\n"
    },
    {
        "commit hash": "5612cbee517d2bd74afcab22fac2fe0f4f84f953",
        "previous commit hash": "eb555ca1afc102206118cfe4e22e267ed9d09cff",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java",
            "additions": 11,
            "deletions": 0
        },
        "diff content": "@@ -2,7 +2,9 @@ package net.engio.mbassy.bus.config;\n \n import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.listener.MetadataReader;\n+import net.engio.mbassy.subscription.ISubscriptionManagerProvider;\n import net.engio.mbassy.subscription.SubscriptionFactory;\n+import net.engio.mbassy.subscription.SubscriptionManagerProvider;\n \n import java.util.concurrent.*;\n import java.util.concurrent.atomic.AtomicInteger;\n@@ -95,6 +97,7 @@ public class BusConfiguration implements IBusConfiguration {\n         defaultConfig.setMessagePublicationFactory(new MessagePublication.Factory());\n         defaultConfig.setPendingMessagesQueue(new LinkedBlockingQueue<MessagePublication>(Integer.MAX_VALUE));\n         defaultConfig.setThreadFactoryForAsynchronousMessageDispatch(DispatcherThreadFactory);\n+        defaultConfig.setSubscriptionManagerProvider(new SubscriptionManagerProvider());\n         return defaultConfig;\n     }\n \n@@ -108,6 +111,7 @@ public class BusConfiguration implements IBusConfiguration {\n     protected MetadataReader metadataReader;\n     protected MessagePublication.Factory messagePublicationFactory;\n     protected ThreadFactory dispatcherThreadFactory;\n+    protected ISubscriptionManagerProvider subscriptionManagerProvider;\n \n     public void setPendingMessagesQueue(BlockingQueue<MessagePublication> pendingMessagesQueue) {\n         this.pendingMessagesQueue = pendingMessagesQueue;\n@@ -184,4 +188,11 @@ public class BusConfiguration implements IBusConfiguration {\n         return this;\n     }\n \n+    public ISubscriptionManagerProvider getSubscriptionManagerProvider() {\n+    \treturn subscriptionManagerProvider;\n+    }\n+    \n+    public void setSubscriptionManagerProvider(ISubscriptionManagerProvider subscriptionManagerProvider) {\n+    \tthis.subscriptionManagerProvider = subscriptionManagerProvider;\n+    }\n }\n"
    },
    {
        "commit hash": "5612cbee517d2bd74afcab22fac2fe0f4f84f953",
        "previous commit hash": "eb555ca1afc102206118cfe4e22e267ed9d09cff",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/ISyncBusConfiguration.java",
            "additions": 3,
            "deletions": 0
        },
        "diff content": "@@ -2,6 +2,7 @@ package net.engio.mbassy.bus.config;\n \r\n import net.engio.mbassy.bus.MessagePublication;\r\n import net.engio.mbassy.listener.MetadataReader;\r\n+import net.engio.mbassy.subscription.ISubscriptionManagerProvider;\r\n import net.engio.mbassy.subscription.SubscriptionFactory;\r\n \r\n public interface ISyncBusConfiguration {\r\n@@ -11,5 +12,7 @@ public interface ISyncBusConfiguration {\n \tMetadataReader getMetadataReader();\r\n \r\n \tSubscriptionFactory getSubscriptionFactory();\r\n+\t\r\n+\tISubscriptionManagerProvider getSubscriptionManagerProvider();\r\n \r\n }\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "5612cbee517d2bd74afcab22fac2fe0f4f84f953",
        "previous commit hash": "eb555ca1afc102206118cfe4e22e267ed9d09cff",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/SyncBusConfiguration.java",
            "additions": 13,
            "deletions": 0
        },
        "diff content": "@@ -2,7 +2,9 @@ package net.engio.mbassy.bus.config;\n \n import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.listener.MetadataReader;\n+import net.engio.mbassy.subscription.ISubscriptionManagerProvider;\n import net.engio.mbassy.subscription.SubscriptionFactory;\n+import net.engio.mbassy.subscription.SubscriptionManagerProvider;\n \n /**\n  * Todo: Add javadoc\n@@ -15,11 +17,13 @@ public class SyncBusConfiguration<C extends SyncBusConfiguration<C>> implements\n     protected SubscriptionFactory subscriptionFactory;\n     protected MetadataReader metadataReader;\n     protected MessagePublication.Factory messagePublicationFactory;\n+    protected ISubscriptionManagerProvider subscriptionManagerProvider;\n \n     public SyncBusConfiguration() {\n         this.metadataReader = new MetadataReader();\n         this.subscriptionFactory = new SubscriptionFactory();\n         this.messagePublicationFactory = new MessagePublication.Factory();\n+        this.subscriptionManagerProvider = new SubscriptionManagerProvider();\n     }\n \n     public MessagePublication.Factory getMessagePublicationFactory() {\n@@ -47,4 +51,13 @@ public class SyncBusConfiguration<C extends SyncBusConfiguration<C>> implements\n         this.subscriptionFactory = subscriptionFactory;\n         return (C) this;\n     }\n+    \n+    public ISubscriptionManagerProvider getSubscriptionManagerProvider() {\n+    \treturn subscriptionManagerProvider;\n+    }\n+    \n+    public C setSubscriptionManagerProvider(ISubscriptionManagerProvider subscriptionManagerProvider) {\n+    \tthis.subscriptionManagerProvider = subscriptionManagerProvider;\n+    \treturn (C) this;\n+    }\n }\n"
    },
    {
        "commit hash": "5612cbee517d2bd74afcab22fac2fe0f4f84f953",
        "previous commit hash": "eb555ca1afc102206118cfe4e22e267ed9d09cff",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/ISubscriptionManagerProvider.java",
            "additions": 9,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,9 @@\n+package net.engio.mbassy.subscription;\r\n+\r\n+import net.engio.mbassy.bus.BusRuntime;\r\n+import net.engio.mbassy.listener.MetadataReader;\r\n+\r\n+public interface ISubscriptionManagerProvider {\r\n+\tSubscriptionManager createManager(MetadataReader reader,\r\n+\t\t\tSubscriptionFactory factory, BusRuntime runtime);\r\n+}\r\n"
    },
    {
        "commit hash": "5612cbee517d2bd74afcab22fac2fe0f4f84f953",
        "previous commit hash": "eb555ca1afc102206118cfe4e22e267ed9d09cff",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionManagerProvider.java",
            "additions": 12,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,12 @@\n+package net.engio.mbassy.subscription;\r\n+\r\n+import net.engio.mbassy.bus.BusRuntime;\r\n+import net.engio.mbassy.listener.MetadataReader;\r\n+\r\n+public class SubscriptionManagerProvider implements ISubscriptionManagerProvider {\r\n+\t@Override\r\n+\tpublic SubscriptionManager createManager(MetadataReader reader,\r\n+\t\t\tSubscriptionFactory factory, BusRuntime runtime) {\r\n+\t\treturn new SubscriptionManager(reader, factory, runtime);\r\n+\t}\r\n+}\r\n"
    },
    {
        "commit hash": "0d36eb65c7491fc1e6d5bc70cde968b1ac1e8b79",
        "previous commit hash": "a48811455c057e7e0568f758ef8b831ac7b9f528",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -165,8 +165,8 @@ to avoid confusion and misunderstanding.\n \n  + Internal refactorings and code improvements\n  + Fixed #44 #45 #47\n- + NOTE: This release has a known issue with weak references which introduces a memory leak. A fix is on its way for 1.1.9\n- to be released soon\n+ + NOTE: This release has a known issue with weak references which introduces a memory leak and is fixed in 1.1.9. The\n+ version 1.1.8 is not available from the central repository\n \n \n <h3>1.1.7</h3>\n"
    },
    {
        "commit hash": "a48811455c057e7e0568f758ef8b831ac7b9f528",
        "previous commit hash": "cf0328ce005d048350f14a33168f0ee06341d9a0",
        "diff stats": {
            "file_path": "README.md",
            "additions": 15,
            "deletions": 10
        },
        "diff content": "@@ -11,7 +11,7 @@ Read this documentation to get an overview of MBassadors features. There is also\n not enough to make a developer happy (work is in progress). But usage of publish subscribe pattern at its core is pretty straight forward and the basic\n use cases are very easy to understand and implement.\n \n-The current version is 1.1.8 and it is available from the Maven Central Repository. See the release notes for more details.\n+The current version is 1.1.9 and it is available from the Maven Central Repository. See the release notes for more details.\n \n There is also an extension available to support CDI-like transactional message sending in a Spring environment. It's beta but\n stable enough to give it a try. See <a href=\"https://github.com/bennidi/mbassador-spring\" target=\"_blank\">here</a>.\n@@ -41,7 +41,7 @@ asynchronously. This is configurable for each handler via annotations. Message p\n blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch\n + <em><strong>Weak references</em></strong>: By default, MBassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister\n listeners that are not used anymore (of course it is also possible to explicitly unregister a listener if needed). This is very comfortable\n-in certain environments where listeners are managed by frameworks, i.e. spring, guice etc. Just stuff everything into the message bus, it will\n+in certain environments where listeners are managed by frameworks, i.e. Spring, Guice etc. Just stuff everything into the message bus, it will\n ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.\n + <em><strong>Strong references</em></strong>: Instead of using weak references, a listener can be configured to be referenced using strong references using @Listener\n + <em><strong>Filtering</em></strong>: MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to\n@@ -143,7 +143,7 @@ Beginning with version 1.1.0 MBassador is available from the Maven Central Repos\n     <dependency>\n         <groupId>net.engio</groupId>\n         <artifactId>mbassador</artifactId>\n-        <version>1.1.7</version>\n+        <version>1.1.9</version>\n     </dependency>\n ```\n \n@@ -151,12 +151,16 @@ Beginning with version 1.1.0 MBassador is available from the Maven Central Repos\n Of course you can always clone the repository and build from source.\n \n <h2>Wiki</h2>\n-There is ongoing afford to extend documentation and provide code samples and detailed explanations of how the message bus\n+There is ongoing effort to extend documentation and provide code samples and detailed explanations of how the message bus\n works. Code samples can also be found in the various test cases. Please read about the terminology used in this project\n to avoid confusion and misunderstanding.\n \n <h2>Release Notes</h2>\n \n+<h3>1.1.9</h3>\n+\n+ + Fixed memory leak reported in issue #53\n+\n <h3>1.1.8</h3>\n \n  + Internal refactorings and code improvements\n@@ -168,8 +172,8 @@ to avoid confusion and misunderstanding.\n <h3>1.1.7</h3>\n \n  + Console Logger not added to message bus instances by default -> use addErrorHandler(IPublicationErrorHandler.ConsoleLogger)\n- + Fixed race conditions in subscription and of WeakConcurrentSet.contains()\n- + Improved message hierarchy handling: Now interfaces, enums , (abstract) classes all work in all combinations\n+ + Fixed race conditions in net.engio.mbassy.subscription.Subscription and of WeakConcurrentSet.contains()\n+ + Improved message hierarchy handling: Now interfaces, enums , (abstract) classes should work in all combinations\n  + Prevented dispatcher threads from dying on exceptions\n  + Improved test-infrastructure and increased test-coverage\n  + Thanks for your feedback!\n@@ -232,13 +236,14 @@ First stable release!\n \n \n <h2>Roadmap</h2>\n-Check the issues marked with label enhancement. Comment if you would like to see the feature in a future release.\n+Check the issues labeled 'enhancement'. Comment if you would like to see the feature in a future release and/or want to share\n+your ideas on the feature (or a variation thereof).\n Please understand that I have limited time to include new features and that I will focus on stability and cleaner APIs.\n-Adding features only works well with well designed and thoroughly tested components especially with all this multi-threaded code\n-and I am still not 100 percent happy with the existing test coverage.\n+Adding features only works with well designed and thoroughly tested components. This is especially true for multi-threaded code\n+and I am still not 100 percent happy with the existing test design and some parts of the internal code layout.\n \n Planned for release:Spring integration with support for conditional message dispatch in transactional context (dispatch only after\n-successful commit etc.). Currently in beta, see <a href=\"https://github.com/bennidi/mbassador-spring\">this</a> repository\n+successful transaction commit etc.). Currently in beta, see <a href=\"https://github.com/bennidi/mbassador-spring\">this</a> repository\n \n \n <h2>Credits</h2>\n"
    },
    {
        "commit hash": "a48811455c057e7e0568f758ef8b831ac7b9f528",
        "previous commit hash": "cf0328ce005d048350f14a33168f0ee06341d9a0",
        "diff stats": {
            "file_path": "src/docs/wiki-listener-def.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-MBassador allows a variety of message handler configurations that will affect how a message\n+MBassador understands a variety of message handler configurations that will affect how a message\n is delivered to a specific listener. There are properties to control the handling of subclasses\n of the specified message (the method parameter), the execution order of handlers for the same message type,\n filters, delivery modes etc.\n"
    },
    {
        "commit hash": "a48811455c057e7e0568f758ef8b831ac7b9f528",
        "previous commit hash": "cf0328ce005d048350f14a33168f0ee06341d9a0",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Filters.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -12,7 +12,7 @@ public class Filters {\n     public static final class AllowAll implements IMessageFilter {\n \n         @Override\n-        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n+        public boolean accepts(Object event, MessageHandler metadata) {\n             return true;\n         }\n     }\n@@ -20,7 +20,7 @@ public class Filters {\n     public static final class RejectAll implements IMessageFilter {\n \n         @Override\n-        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n+        public boolean accepts(Object event, MessageHandler metadata) {\n             return false;\n         }\n     }\n@@ -29,7 +29,7 @@ public class Filters {\n     public static final class RejectSubtypes implements IMessageFilter {\n \n         @Override\n-        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n+        public boolean accepts(Object event, MessageHandler metadata) {\n             for (Class handledMessage : metadata.getHandledMessages()) {\n                 if (handledMessage.equals(event.getClass())) {\n                     return true;\n"
    },
    {
        "commit hash": "a48811455c057e7e0568f758ef8b831ac7b9f528",
        "previous commit hash": "cf0328ce005d048350f14a33168f0ee06341d9a0",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/IMessageFilter.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -17,5 +17,5 @@ public interface IMessageFilter {\n      * @param message the message to be delivered\n      * @return\n      */\n-    boolean accepts(Object message, MessageHandlerMetadata metadata);\n+    boolean accepts(Object message, MessageHandler metadata);\n }\n"
    },
    {
        "commit hash": "a48811455c057e7e0568f758ef8b831ac7b9f528",
        "previous commit hash": "cf0328ce005d048350f14a33168f0ee06341d9a0",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandler.java",
            "additions": 7,
            "deletions": 3
        },
        "diff content": "@@ -7,10 +7,14 @@ import java.util.LinkedList;\n import java.util.List;\n \n /**\n+ * Any method in any class annotated with the @Handler annotation represents a message handler. The class that contains\n+ * the handler defines the message listener and more generally, any class containing a message handler in its class hierarchy\n+ * defines a message listener.\n+ *\n  * @author bennidi\n  *         Date: 11/14/12\n  */\n-public class MessageHandlerMetadata {\n+public class MessageHandler {\n \n     private final Method handler;\n \n@@ -26,14 +30,14 @@ public class MessageHandlerMetadata {\n \n     private final boolean acceptsSubtypes;\n \n-    private final MessageListenerMetadata listenerConfig;\n+    private final MessageListener listenerConfig;\n \n     private final boolean isSynchronized;\n \n     private Class listeningClass;\n \n \n-    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Handler handlerConfig, MessageListenerMetadata listenerConfig) {\n+    public MessageHandler(Method handler, IMessageFilter[] filter, Handler handlerConfig, MessageListener listenerConfig) {\n         if(handler == null || handlerConfig == null){\n             throw new IllegalArgumentException(\"The message handler configuration may not be null\");\n         }\n"
    },
    {
        "commit hash": "a48811455c057e7e0568f758ef8b831ac7b9f528",
        "previous commit hash": "cf0328ce005d048350f14a33168f0ee06341d9a0",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageListener.java",
            "additions": 87,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,87 @@\n+package net.engio.mbassy.listener;\n+\n+import net.engio.mbassy.common.IPredicate;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * All instances of any class that defines at least one message handler (see @MessageHandler) are message listeners. Thus,\n+ * a message listener is any object capable of receiving messages by means of defined message handlers.\n+ * There are no restrictions about the number of allowed message handlers in a message listener.\n+ *\n+ * A message listener can be configured using the @Listener annotation but is always implicitly configured by the handler\n+ * definition it contains.\n+ *\n+ * This class is an internal representation of a message listener used to encapsulate all relevant objects\n+ * and data about that message listener, especially all its handlers.\n+ * There will be only one instance of MessageListener per message listener class and message bus instance.\n+ *\n+ * @author bennidi\n+ *         Date: 12/16/12\n+ */\n+public class MessageListener<T> {\n+\n+\n+    public static IPredicate<MessageHandler> ForMessage(final Class<?> messageType) {\n+        return new IPredicate<MessageHandler>() {\n+            @Override\n+            public boolean apply(MessageHandler target) {\n+                return target.handlesMessage(messageType);\n+            }\n+        };\n+    }\n+\n+    private List<MessageHandler> handlers = new ArrayList<MessageHandler>();\n+\n+    private Class<T> listenerDefinition;\n+\n+    private Listener listenerAnnotation;\n+\n+    public MessageListener(Class<T> listenerDefinition) {\n+       this.listenerDefinition = listenerDefinition;\n+       listenerAnnotation = listenerDefinition.getAnnotation(Listener.class);\n+    }\n+\n+\n+    public boolean isFromListener(Class listener){\n+        return listenerDefinition.equals(listener);\n+    }\n+\n+    public boolean useStrongReferences(){\n+        return listenerAnnotation != null && listenerAnnotation.references().equals(References.Strong);\n+    }\n+\n+    public MessageListener addHandlers(Collection<? extends MessageHandler> c) {\n+        handlers.addAll(c);\n+        return this;\n+    }\n+\n+    public boolean addHandler(MessageHandler messageHandler) {\n+        return handlers.add(messageHandler);\n+    }\n+\n+    public List<MessageHandler> getHandlers(){\n+        return handlers;\n+    }\n+\n+    public List<MessageHandler> getHandlers(IPredicate<MessageHandler> filter) {\n+        List<MessageHandler> matching = new LinkedList<MessageHandler>();\n+        for (MessageHandler handler : handlers) {\n+            if (filter.apply(handler)) {\n+                matching.add(handler);\n+            }\n+        }\n+        return matching;\n+    }\n+\n+    public boolean handles(Class<?> messageType) {\n+        return !getHandlers(ForMessage(messageType)).isEmpty();\n+    }\n+\n+    public Class<T> getListerDefinition() {\n+        return listenerDefinition;\n+    }\n+}\n"
    },
    {
        "commit hash": "a48811455c057e7e0568f758ef8b831ac7b9f528",
        "previous commit hash": "cf0328ce005d048350f14a33168f0ee06341d9a0",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java",
            "additions": 0,
            "deletions": 79
        },
        "diff content": "@@ -1,79 +0,0 @@\n-package net.engio.mbassy.listener;\n-\n-import net.engio.mbassy.common.IPredicate;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-/**\n- * Provides information about the message listeners of a specific class. Each message handler\n- * defined by the target class is represented as a single entity.\n- *\n- * @author bennidi\n- *         Date: 12/16/12\n- */\n-public class MessageListenerMetadata<T> {\n-\n-\n-    public static IPredicate<MessageHandlerMetadata> ForMessage(final Class<?> messageType) {\n-        return new IPredicate<MessageHandlerMetadata>() {\n-            @Override\n-            public boolean apply(MessageHandlerMetadata target) {\n-                return target.handlesMessage(messageType);\n-            }\n-        };\n-    }\n-\n-    private List<MessageHandlerMetadata> handlers = new ArrayList<MessageHandlerMetadata>();\n-\n-    private Class<T> listenerDefinition;\n-\n-    private Listener listenerAnnotation;\n-\n-    public MessageListenerMetadata(Class<T> listenerDefinition) {\n-       this.listenerDefinition = listenerDefinition;\n-       listenerAnnotation = listenerDefinition.getAnnotation(Listener.class);\n-    }\n-\n-\n-    public boolean isFromListener(Class listener){\n-        return listenerDefinition.equals(listener);\n-    }\n-\n-    public boolean useStrongReferences(){\n-        return listenerAnnotation != null && listenerAnnotation.references().equals(References.Strong);\n-    }\n-\n-    public MessageListenerMetadata addHandlers(Collection<? extends MessageHandlerMetadata> c) {\n-        handlers.addAll(c);\n-        return this;\n-    }\n-\n-    public boolean addHandler(MessageHandlerMetadata messageHandlerMetadata) {\n-        return handlers.add(messageHandlerMetadata);\n-    }\n-\n-    public List<MessageHandlerMetadata> getHandlers(){\n-        return handlers;\n-    }\n-\n-    public List<MessageHandlerMetadata> getHandlers(IPredicate<MessageHandlerMetadata> filter) {\n-        List<MessageHandlerMetadata> matching = new LinkedList<MessageHandlerMetadata>();\n-        for (MessageHandlerMetadata handler : handlers) {\n-            if (filter.apply(handler)) {\n-                matching.add(handler);\n-            }\n-        }\n-        return matching;\n-    }\n-\n-    public boolean handles(Class<?> messageType) {\n-        return !getHandlers(ForMessage(messageType)).isEmpty();\n-    }\n-\n-    public Class<T> getListerDefinition() {\n-        return listenerDefinition;\n-    }\n-}\n"
    },
    {
        "commit hash": "a48811455c057e7e0568f758ef8b831ac7b9f528",
        "previous commit hash": "cf0328ce005d048350f14a33168f0ee06341d9a0",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MetadataReader.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -55,8 +55,8 @@ public class MetadataReader {\n \n     // get all listeners defined by the given class (includes\n     // listeners defined in super classes)\n-    public MessageListenerMetadata getMessageListener(Class target) {\n-        MessageListenerMetadata listenerMetadata = new MessageListenerMetadata(target);\n+    public MessageListener getMessageListener(Class target) {\n+        MessageListener listenerMetadata = new MessageListener(target);\n         // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n         List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n         // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n@@ -76,7 +76,7 @@ public class MetadataReader {\n             }\n             Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n             // if a handler is overwritten it inherits the configuration of its parent method\n-            MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n+            MessageHandler handlerMetadata = new MessageHandler(overriddenHandler == null ? handler : overriddenHandler,\n                     getFilter(handlerConfig), handlerConfig, listenerMetadata);\n             listenerMetadata.addHandler(handlerMetadata);\n \n"
    },
    {
        "commit hash": "a48811455c057e7e0568f758ef8b831ac7b9f528",
        "previous commit hash": "cf0328ce005d048350f14a33168f0ee06341d9a0",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 26,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,16 @@ import java.util.List;\n import java.util.UUID;\n \n /**\n- * A subscription is a thread safe container for objects that contain message handlers\n+ * A subscription is a thread-safe container that manages exactly one message handler of all registered\n+ * message listeners of the same class, i.e. all subscribed instances of a SingleMessageHandler.class\n+ * will be referenced in the subscription created for SingleMessageHandler.class.\n+ *\n+ * There will be as many unique subscription objects per message listener class as there are message handlers\n+ * defined in the message listeners class hierarchy.\n+ *\n+ * The subscription provides functionality for message publication by means of delegation to the respective\n+ * message dispatcher.\n+ *\n  */\n public class Subscription {\n \n@@ -27,14 +36,30 @@ public class Subscription {\n         this.listeners = listeners;\n     }\n \n+    /**\n+     * Check whether this subscription manages a message handler of the given message listener class\n+     *\n+     * @param listener\n+     * @return\n+     */\n     public boolean belongsTo(Class listener){\n         return context.getHandlerMetadata().isFromListener(listener);\n     }\n \n+    /**\n+     * Check whether this subscriptions manages the given listener instance\n+     * @param listener\n+     * @return\n+     */\n     public boolean contains(Object listener){\n         return listeners.contains(listener);\n     }\n \n+    /**\n+     * Check whether this subscription manages a message handler\n+     * @param messageType\n+     * @return\n+     */\n     public boolean handlesMessageType(Class<?> messageType) {\n         return context.getHandlerMetadata().handlesMessage(messageType);\n     }\n"
    },
    {
        "commit hash": "a48811455c057e7e0568f758ef8b831ac7b9f528",
        "previous commit hash": "cf0328ce005d048350f14a33168f0ee06341d9a0",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -3,7 +3,7 @@ package net.engio.mbassy.subscription;\n import net.engio.mbassy.IPublicationErrorHandler;\n import net.engio.mbassy.bus.BusRuntime;\n import net.engio.mbassy.bus.RuntimeProvider;\n-import net.engio.mbassy.listener.MessageHandlerMetadata;\n+import net.engio.mbassy.listener.MessageHandler;\n \n import java.util.Collection;\n \n@@ -19,14 +19,14 @@ import java.util.Collection;\n public class SubscriptionContext implements RuntimeProvider {\n \n     // the handler's metadata -> for each handler in a listener, a unique subscription context is created\n-    private final MessageHandlerMetadata handlerMetadata;\n+    private final MessageHandler handlerMetadata;\n \n     // error handling is first-class functionality\n     private final Collection<IPublicationErrorHandler> errorHandlers;\n \n     private BusRuntime runtime;\n \n-    public SubscriptionContext(BusRuntime runtime, MessageHandlerMetadata handlerMetadata,\n+    public SubscriptionContext(BusRuntime runtime, MessageHandler handlerMetadata,\n                                Collection<IPublicationErrorHandler> errorHandlers) {\n         this.runtime = runtime;\n         this.handlerMetadata = handlerMetadata;\n@@ -39,7 +39,7 @@ public class SubscriptionContext implements RuntimeProvider {\n      *\n      * @return\n      */\n-    public MessageHandlerMetadata getHandlerMetadata() {\n+    public MessageHandler getHandlerMetadata() {\n         return handlerMetadata;\n     }\n \n"
    },
    {
        "commit hash": "a48811455c057e7e0568f758ef8b831ac7b9f528",
        "previous commit hash": "cf0328ce005d048350f14a33168f0ee06341d9a0",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -6,7 +6,7 @@ import net.engio.mbassy.bus.BusRuntime;\n import net.engio.mbassy.common.StrongConcurrentSet;\n import net.engio.mbassy.common.WeakConcurrentSet;\n import net.engio.mbassy.dispatch.*;\n-import net.engio.mbassy.listener.MessageHandlerMetadata;\n+import net.engio.mbassy.listener.MessageHandler;\n \n import java.lang.reflect.Constructor;\n import java.lang.reflect.Modifier;\n@@ -20,7 +20,7 @@ public class SubscriptionFactory {\n \n     private static final String ErrorHandlers = \"error.handlers\";\n \n-    public Subscription createSubscription(BusRuntime runtime, MessageHandlerMetadata handlerMetadata) throws MessageBusException{\n+    public Subscription createSubscription(BusRuntime runtime, MessageHandler handlerMetadata) throws MessageBusException{\n         try {\n             Collection<IPublicationErrorHandler> errorHandlers = runtime.get(ErrorHandlers);\n             SubscriptionContext context = new SubscriptionContext(runtime, handlerMetadata, errorHandlers);\n"
    },
    {
        "commit hash": "a48811455c057e7e0568f758ef8b831ac7b9f528",
        "previous commit hash": "cf0328ce005d048350f14a33168f0ee06341d9a0",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java",
            "additions": 24,
            "deletions": 18
        },
        "diff content": "@@ -3,16 +3,17 @@ package net.engio.mbassy.subscription;\n import net.engio.mbassy.bus.BusRuntime;\n import net.engio.mbassy.common.ReflectionUtils;\n import net.engio.mbassy.common.StrongConcurrentSet;\n-import net.engio.mbassy.listener.MessageHandlerMetadata;\n+import net.engio.mbassy.listener.MessageHandler;\n import net.engio.mbassy.listener.MetadataReader;\n \n import java.util.*;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n /**\n- * The subscription managers primary task is consistently handle new and existing subscriptions\n- * and to synchronize concurrent access to them efficiently. It takes care of properly registering and\n- * unregistering message listeners and is a core component of each bus implementation\n+ * The subscription managers responsibility is to consistently handle and synchronize the message listener subscription process.\n+ * It provides fast lookup of existing subscriptions when another instance of an already known\n+ * listener is subscribed and takes care of creating new set of subscriptions for any unknown class that defines\n+ * message handlers.\n  *\n  * @author bennidi\n  *         Date: 5/11/13\n@@ -42,6 +43,7 @@ public class SubscriptionManager {\n     // it can be customized by implementing the getSubscriptionFactory() method\n     private final SubscriptionFactory subscriptionFactory;\n \n+    // synchronize read/write acces to the subscription maps\n     private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n \n     private final BusRuntime runtime;\n@@ -88,14 +90,14 @@ public class SubscriptionManager {\n             Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n             // a listener is either subscribed for the first time\n             if (subscriptionsByListener == null) {\n-                List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageListener(listener.getClass()).getHandlers();\n+                List<MessageHandler> messageHandlers = metadataReader.getMessageListener(listener.getClass()).getHandlers();\n                 if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                     nonListeners.add(listener.getClass());\n                     return;\n                 }\n                 subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                 // create subscriptions for all detected message handlers\n-                for (MessageHandlerMetadata messageHandler : messageHandlers) {\n+                for (MessageHandler messageHandler : messageHandlers) {\n                     // create the subscription\n                     subscriptionsByListener.add(subscriptionFactory.createSubscription(runtime, messageHandler));\n                 }\n@@ -157,26 +159,30 @@ public class SubscriptionManager {\n     // Note: never returns null!\n     public Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n         Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n-        readWriteLock.readLock().lock();\n-        if (subscriptionsPerMessage.get(messageType) != null) {\n-            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n-        }\n-        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n-            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n-            if (subs != null) {\n-                for (Subscription sub : subs) {\n-                    if (sub.handlesMessageType(messageType)) {\n-                        subscriptions.add(sub);\n+        try{\n+            readWriteLock.readLock().lock();\n+\n+            if (subscriptionsPerMessage.get(messageType) != null) {\n+                subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n+            }\n+            for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n+                Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n+                if (subs != null) {\n+                    for (Subscription sub : subs) {\n+                        if (sub.handlesMessageType(messageType)) {\n+                            subscriptions.add(sub);\n+                        }\n                     }\n                 }\n             }\n+        }finally{\n+            readWriteLock.readLock().unlock();\n         }\n-        readWriteLock.readLock().unlock();\n         return subscriptions;\n     }\n \n \n-    // associate a suscription with a message type\n+    // associate a subscription with a message type\n     // NOTE: Not thread-safe! must be synchronized in outer scope\n     private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n         Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n"
    },
    {
        "commit hash": "a48811455c057e7e0568f758ef8b831ac7b9f528",
        "previous commit hash": "cf0328ce005d048350f14a33168f0ee06341d9a0",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/FilterTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -105,7 +105,7 @@ public class FilterTest extends MessageBusTest {\n     public static class RejectFilteredObjects implements IMessageFilter{\n \n         @Override\n-        public boolean accepts(Object message, MessageHandlerMetadata metadata) {\n+        public boolean accepts(Object message, MessageHandler metadata) {\n             if(message.getClass().equals(FilteredMessage.class) && ((FilteredMessage)message).getMessage().getClass().equals(Object.class)){\n                 return false;\n             }\n"
    },
    {
        "commit hash": "a48811455c057e7e0568f758ef8b831ac7b9f528",
        "previous commit hash": "cf0328ce005d048350f14a33168f0ee06341d9a0",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MetadataReaderTest.java",
            "additions": 8,
            "deletions": 8
        },
        "diff content": "@@ -1,10 +1,10 @@\n package net.engio.mbassy;\n \n import net.engio.mbassy.common.AssertSupport;\n+import net.engio.mbassy.listener.MessageListener;\n import org.junit.Test;\n import net.engio.mbassy.listener.Enveloped;\n import net.engio.mbassy.listener.Handler;\n-import net.engio.mbassy.listener.MessageListenerMetadata;\n import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.subscription.MessageEnvelope;\n \n@@ -13,7 +13,7 @@ import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n-import static net.engio.mbassy.listener.MessageListenerMetadata.ForMessage;\n+import static net.engio.mbassy.listener.MessageListener.ForMessage;\n \n /**\n  *\n@@ -26,7 +26,7 @@ public class MetadataReaderTest extends AssertSupport {\n \n     @Test\n     public void testListenerWithoutInheritance() {\n-        MessageListenerMetadata<MessageListener1> listener = reader.getMessageListener(MessageListener1.class);\n+        MessageListener<MessageListener1> listener = reader.getMessageListener(MessageListener1.class);\n         ListenerValidator validator = new ListenerValidator()\n                 .expectHandlers(2, String.class)\n                 .expectHandlers(2, Object.class)\n@@ -37,7 +37,7 @@ public class MetadataReaderTest extends AssertSupport {\n \n     @Test\n     public void testListenerWithInheritance() {\n-        MessageListenerMetadata<MessageListener2> listener = reader.getMessageListener(MessageListener2.class);\n+        MessageListener<MessageListener2> listener = reader.getMessageListener(MessageListener2.class);\n         ListenerValidator validator = new ListenerValidator()\n                 .expectHandlers(2, String.class)\n                 .expectHandlers(2, Object.class)\n@@ -47,7 +47,7 @@ public class MetadataReaderTest extends AssertSupport {\n \n     @Test\n     public void testListenerWithInheritanceOverriding() {\n-        MessageListenerMetadata<MessageListener3> listener = reader.getMessageListener(MessageListener3.class);\n+        MessageListener<MessageListener3> listener = reader.getMessageListener(MessageListener3.class);\n \n         ListenerValidator validator = new ListenerValidator()\n                 .expectHandlers(0, String.class)\n@@ -58,7 +58,7 @@ public class MetadataReaderTest extends AssertSupport {\n \n     @Test\n     public void testEnveloped() {\n-        MessageListenerMetadata<EnvelopedListener> listener = reader.getMessageListener(EnvelopedListener.class);\n+        MessageListener<EnvelopedListener> listener = reader.getMessageListener(EnvelopedListener.class);\n         ListenerValidator validator = new ListenerValidator()\n                 .expectHandlers(1, String.class)\n                 .expectHandlers(2, Integer.class)\n@@ -71,7 +71,7 @@ public class MetadataReaderTest extends AssertSupport {\n \n     @Test\n     public void testEnvelopedSubclass() {\n-        MessageListenerMetadata<EnvelopedListenerSubclass> listener = reader.getMessageListener(EnvelopedListenerSubclass.class);\n+        MessageListener<EnvelopedListenerSubclass> listener = reader.getMessageListener(EnvelopedListenerSubclass.class);\n         ListenerValidator validator = new ListenerValidator()\n                 .expectHandlers(1, String.class)\n                 .expectHandlers(2, Integer.class)\n@@ -91,7 +91,7 @@ public class MetadataReaderTest extends AssertSupport {\n             return this;\n         }\n \n-        public void check(MessageListenerMetadata listener){\n+        public void check(MessageListener listener){\n             for(Map.Entry<Class<?>, Integer> expectedHandler: handlers.entrySet()){\n                 if(expectedHandler.getValue() > 0){\n                     assertTrue(listener.handles(expectedHandler.getKey()));\n"
    },
    {
        "commit hash": "cf0328ce005d048350f14a33168f0ee06341d9a0",
        "previous commit hash": "7a139240b5d8270e71eaa5bce33664364495ddee",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.9</version>\n+    <version>1.1.10-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.9</tag>\n+        <tag>mbassador-1.1.4</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "7a139240b5d8270e71eaa5bce33664364495ddee",
        "previous commit hash": "a6d5daed0ecf33c25f27179a0601376cd191fb64",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.9-SNAPSHOT</version>\n+    <version>1.1.9</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.4</tag>\n+        <tag>mbassador-1.1.9</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "a6d5daed0ecf33c25f27179a0601376cd191fb64",
        "previous commit hash": "b0443680c601623450aea184bccb3dec37912054",
        "diff stats": {
            "file_path": "README.md",
            "additions": 15,
            "deletions": 2
        },
        "diff content": "@@ -11,7 +11,7 @@ Read this documentation to get an overview of MBassadors features. There is also\n not enough to make a developer happy (work is in progress). But usage of publish subscribe pattern at its core is pretty straight forward and the basic\n use cases are very easy to understand and implement.\n \n-The current version is 1.1.7 and it is available from the Maven Central Repository. See the release notes for more details.\n+The current version is 1.1.8 and it is available from the Maven Central Repository. See the release notes for more details.\n \n There is also an extension available to support CDI-like transactional message sending in a Spring environment. It's beta but\n stable enough to give it a try. See <a href=\"https://github.com/bennidi/mbassador-spring\" target=\"_blank\">here</a>.\n@@ -157,6 +157,14 @@ to avoid confusion and misunderstanding.\n \n <h2>Release Notes</h2>\n \n+<h3>1.1.8</h3>\n+\n+ + Internal refactorings and code improvements\n+ + Fixed #44 #45 #47\n+ + NOTE: This release has a known issue with weak references which introduces a memory leak. A fix is on its way for 1.1.9\n+ to be released soon\n+\n+\n <h3>1.1.7</h3>\n \n  + Console Logger not added to message bus instances by default -> use addErrorHandler(IPublicationErrorHandler.ConsoleLogger)\n@@ -224,7 +232,12 @@ First stable release!\n \n \n <h2>Roadmap</h2>\n-+ Spring integration with support for conditional message dispatch in transactional context (dispatch only after\n+Check the issues marked with label enhancement. Comment if you would like to see the feature in a future release.\n+Please understand that I have limited time to include new features and that I will focus on stability and cleaner APIs.\n+Adding features only works well with well designed and thoroughly tested components especially with all this multi-threaded code\n+and I am still not 100 percent happy with the existing test coverage.\n+\n+Planned for release:Spring integration with support for conditional message dispatch in transactional context (dispatch only after\n successful commit etc.). Currently in beta, see <a href=\"https://github.com/bennidi/mbassador-spring\">this</a> repository\n \n \n"
    },
    {
        "commit hash": "a6d5daed0ecf33c25f27179a0601376cd191fb64",
        "previous commit hash": "b0443680c601623450aea184bccb3dec37912054",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -17,7 +17,7 @@ import java.util.concurrent.locks.ReentrantReadWriteLock;\n public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n \n     // Internal state\n-    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+    protected final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n     private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(log n) lookup\n     protected Entry<T> head; // reference to the first element\n \n"
    },
    {
        "commit hash": "a6d5daed0ecf33c25f27179a0601376cd191fb64",
        "previous commit hash": "b0443680c601623450aea184bccb3dec37912054",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/WeakConcurrentSet.java",
            "additions": 29,
            "deletions": 8
        },
        "diff content": "@@ -4,6 +4,7 @@ package net.engio.mbassy.common;\n import java.lang.ref.WeakReference;\n import java.util.Iterator;\n import java.util.WeakHashMap;\n+import java.util.concurrent.locks.Lock;\n \n /**\n  * This implementation uses weak references to the elements. Iterators automatically perform cleanups of\n@@ -25,15 +26,36 @@ public class WeakConcurrentSet<T> extends AbstractConcurrentSet<T>{\n     public Iterator<T> iterator() {\n         return new Iterator<T>() {\n \n+            // the current listelement of this iterator\n+            // used to keep track of the iteration process\n             private ISetEntry<T> current = head;\n \n-            public boolean hasNext() {\n-                if (current == null) return false;\n-                if (current.getValue() == null) {    // auto-removal of orphan references\n+            // this method will remove all orphaned entries\n+            // until it finds the first entry whose value has not yet been garbage collected\n+            // the method assumes that the current element is already orphaned and will remove it\n+            private void removeOrphans(){\n+                Lock writelock = lock.writeLock();\n+                try{\n+                    writelock.lock();\n                     do {\n-                        remove();\n+                        ISetEntry orphaned = current;\n+                        current = current.next();\n+                        orphaned.remove();\n                     } while(current != null && current.getValue() == null);\n-                    return hasNext();\n+                }\n+                finally {\n+                    writelock.unlock();\n+                }\n+            }\n+\n+\n+            public boolean hasNext() {\n+                if (current == null) return false;\n+                if (current.getValue() == null) {\n+                // trigger removal of orphan references\n+                // because a null value indicates that the value has been garbage collected\n+                    removeOrphans();\n+                    return current != null; // if any entry is left then it will have a value\n                 } else {\n                     return true;\n                 }\n@@ -45,9 +67,7 @@ public class WeakConcurrentSet<T> extends AbstractConcurrentSet<T>{\n                 }\n                 T value = current.getValue();\n                 if (value == null) {    // auto-removal of orphan references\n-                    do {\n-                        remove();\n-                    } while(current != null && current.getValue() == null);\n+                    removeOrphans();\n                     return next();\n                 } else {\n                     current = current.next();\n@@ -56,6 +76,7 @@ public class WeakConcurrentSet<T> extends AbstractConcurrentSet<T>{\n             }\n \n             public void remove() {\n+                //throw new UnsupportedOperationException(\"Explicit removal of set elements is only allowed via the controlling set. Sorry!\");\n                 if (current == null) {\n                     return;\n                 }\n"
    },
    {
        "commit hash": "b0443680c601623450aea184bccb3dec37912054",
        "previous commit hash": "e215da51c83b38e77cd0ddf6b11cde24ec4424f6",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.8</version>\n+    <version>1.1.9-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.8</tag>\n+        <tag>mbassador-1.1.4</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "e215da51c83b38e77cd0ddf6b11cde24ec4424f6",
        "previous commit hash": "6d641f5056584469884503c33e1abd1606cdbe20",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.8-SNAPSHOT</version>\n+    <version>1.1.8</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.4</tag>\n+        <tag>mbassador-1.1.8</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "52f52864de3a0b9fc9b6a0459370f63a18510834",
        "previous commit hash": "bc267cde2b5fe078759d334048caff2c9f443c30",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -2,7 +2,7 @@ package net.engio.mbassy.bus;\n \n import net.engio.mbassy.IPublicationErrorHandler;\n import net.engio.mbassy.PublicationError;\n-import net.engio.mbassy.bus.config.IBusConfiguration;\n+import net.engio.mbassy.bus.config.ISyncBusConfiguration;\n import net.engio.mbassy.bus.publication.IPublicationCommand;\n import net.engio.mbassy.common.DeadMessage;\n import net.engio.mbassy.subscription.Subscription;\n@@ -32,7 +32,7 @@ public abstract class AbstractSyncMessageBus<T, P extends IPublicationCommand> i\n     private final BusRuntime runtime;\n \n \n-    public AbstractSyncMessageBus(IBusConfiguration configuration) {\n+    public AbstractSyncMessageBus(ISyncBusConfiguration configuration) {\n         this.runtime = new BusRuntime(this);\n         this.runtime.add(\"error.handlers\", getRegisteredErrorHandlers());\n         this.subscriptionManager = new SubscriptionManager(configuration.getMetadataReader(),\n"
    },
    {
        "commit hash": "52f52864de3a0b9fc9b6a0459370f63a18510834",
        "previous commit hash": "bc267cde2b5fe078759d334048caff2c9f443c30",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/SyncMessageBus.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.bus;\n \n import net.engio.mbassy.PublicationError;\n-import net.engio.mbassy.bus.config.IBusConfiguration;\n+import net.engio.mbassy.bus.config.ISyncBusConfiguration;\n import net.engio.mbassy.bus.publication.IPublicationCommand;\n \n /**\n@@ -14,7 +14,7 @@ import net.engio.mbassy.bus.publication.IPublicationCommand;\n public class SyncMessageBus<T> extends AbstractSyncMessageBus<T, SyncMessageBus.SyncPostCommand>{\n \n \n-    public SyncMessageBus(IBusConfiguration configuration) {\n+    public SyncMessageBus(ISyncBusConfiguration configuration) {\n         super(configuration);\n     }\n \n"
    },
    {
        "commit hash": "52f52864de3a0b9fc9b6a0459370f63a18510834",
        "previous commit hash": "bc267cde2b5fe078759d334048caff2c9f443c30",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/IBusConfiguration.java",
            "additions": 1,
            "deletions": 9
        },
        "diff content": "@@ -1,8 +1,6 @@\n package net.engio.mbassy.bus.config;\n \n import net.engio.mbassy.bus.MessagePublication;\n-import net.engio.mbassy.listener.MetadataReader;\n-import net.engio.mbassy.subscription.SubscriptionFactory;\n \n import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.ExecutorService;\n@@ -15,7 +13,7 @@ import java.util.concurrent.ThreadFactory;\n  * Time: 9:56 AM\n  * To change this template use File | Settings | File Templates.\n  */\n-public interface IBusConfiguration {\n+public interface IBusConfiguration extends ISyncBusConfiguration {\n \n     int getNumberOfMessageDispatchers();\n \n@@ -23,12 +21,6 @@ public interface IBusConfiguration {\n \n     BlockingQueue<MessagePublication> getPendingMessagesQueue();\n \n-    MessagePublication.Factory getMessagePublicationFactory();\n-\n-    MetadataReader getMetadataReader();\n-\n-    SubscriptionFactory getSubscriptionFactory();\n-\n     ThreadFactory getThreadFactoryForAsynchronousMessageDispatch();\n \n }\n"
    },
    {
        "commit hash": "52f52864de3a0b9fc9b6a0459370f63a18510834",
        "previous commit hash": "bc267cde2b5fe078759d334048caff2c9f443c30",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/ISyncBusConfiguration.java",
            "additions": 15,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,15 @@\n+package net.engio.mbassy.bus.config;\r\n+\r\n+import net.engio.mbassy.bus.MessagePublication;\r\n+import net.engio.mbassy.listener.MetadataReader;\r\n+import net.engio.mbassy.subscription.SubscriptionFactory;\r\n+\r\n+public interface ISyncBusConfiguration {\r\n+\r\n+\tMessagePublication.Factory getMessagePublicationFactory();\r\n+\r\n+\tMetadataReader getMetadataReader();\r\n+\r\n+\tSubscriptionFactory getSubscriptionFactory();\r\n+\r\n+}\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "52f52864de3a0b9fc9b6a0459370f63a18510834",
        "previous commit hash": "bc267cde2b5fe078759d334048caff2c9f443c30",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/SyncBusConfiguration.java",
            "additions": 5,
            "deletions": 5
        },
        "diff content": "@@ -10,7 +10,7 @@ import net.engio.mbassy.subscription.SubscriptionFactory;\n  * @author bennidi\n  *         Date: 3/29/13\n  */\n-public class SyncBusConfiguration<Config extends SyncBusConfiguration<Config>> {\n+public class SyncBusConfiguration<C extends SyncBusConfiguration<C>> implements ISyncBusConfiguration {\n \n     protected SubscriptionFactory subscriptionFactory;\n     protected MetadataReader metadataReader;\n@@ -34,17 +34,17 @@ public class SyncBusConfiguration<Config extends SyncBusConfiguration<Config>> {\n         return metadataReader;\n     }\n \n-    public Config setMetadataReader(MetadataReader metadataReader) {\n+    public C setMetadataReader(MetadataReader metadataReader) {\n         this.metadataReader = metadataReader;\n-        return (Config)this;\n+        return (C) this;\n     }\n \n     public SubscriptionFactory getSubscriptionFactory() {\n         return subscriptionFactory;\n     }\n \n-    public Config setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n+    public C setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n         this.subscriptionFactory = subscriptionFactory;\n-        return (Config)this;\n+        return (C) this;\n     }\n }\n"
    },
    {
        "commit hash": "52f52864de3a0b9fc9b6a0459370f63a18510834",
        "previous commit hash": "bc267cde2b5fe078759d334048caff2c9f443c30",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 3,
            "deletions": 1
        },
        "diff content": "@@ -4,6 +4,7 @@ import net.engio.mbassy.bus.ISyncMessageBus;\n import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.bus.SyncMessageBus;\n import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.config.SyncBusConfiguration;\n import net.engio.mbassy.common.ConcurrentExecutor;\n import net.engio.mbassy.common.ListenerFactory;\n import net.engio.mbassy.common.MessageBusTest;\n@@ -16,6 +17,7 @@ import net.engio.mbassy.listeners.MessagesListener;\n import net.engio.mbassy.messages.MessageTypes;\n import net.engio.mbassy.messages.MultipartMessage;\n import net.engio.mbassy.messages.StandardMessage;\n+\n import org.junit.Assert;\n import org.junit.Test;\n \n@@ -186,7 +188,7 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n         @Override\n         protected ISyncMessageBus getSyncMessageBus() {\n-            return new SyncMessageBus(BusConfiguration.Default());\n+            return new SyncMessageBus(new SyncBusConfiguration());\n         }\n     }\n \n"
    },
    {
        "commit hash": "69e6d57d73c976c9be0030400467c726d3518a28",
        "previous commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 19,
            "deletions": 0
        },
        "diff content": "@@ -3,6 +3,7 @@ package net.engio.mbassy.common;\n import junit.framework.Assert;\n import net.engio.mbassy.IPublicationErrorHandler;\n import net.engio.mbassy.PublicationError;\n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.messages.MessageTypes;\n@@ -33,6 +34,8 @@ public abstract class MessageBusTest extends AssertSupport {\n     };\n \n \n+    private StrongConcurrentSet<MessagePublication> issuedPublications = new StrongConcurrentSet<MessagePublication>();\n+\n     @Before\n     public void setUp(){\n         for(MessageTypes mes : MessageTypes.values())\n@@ -52,4 +55,20 @@ public abstract class MessageBusTest extends AssertSupport {\n         return bus;\n     }\n \n+    public void waitForPublications(long timeOutInMs){\n+        long start = System.currentTimeMillis();\n+        while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){\n+            for(MessagePublication pub : issuedPublications){\n+                if(pub.isFinished())\n+                    issuedPublications.remove(pub);\n+            }\n+        }\n+        if(issuedPublications.size() > 0)\n+            fail(\"Issued publications did not finish within specified timeout of \" + timeOutInMs + \" ms\");\n+    }\n+\n+    public void addPublication(MessagePublication publication){\n+        issuedPublications.add(publication);\n+    }\n+\n }\n"
    },
    {
        "commit hash": "9eda5ba450cd11b595735f4cc186be57446de68e",
        "previous commit hash": "02f18f8e4a120e05ab20cd1cc9a4f51d871394e3",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageManager.java",
            "additions": 7,
            "deletions": 2
        },
        "diff content": "@@ -4,6 +4,9 @@ import net.engio.mbassy.messages.IMessage;\n \n import java.util.Collection;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n /**\n  * Created with IntelliJ IDEA.\n  * User: benjamin\n@@ -12,6 +15,8 @@ import java.util.Collection;\n  * To change this template use File | Settings | File Templates.\n  */\n public class MessageManager {\n+\tprivate static final Logger LOG =\n+\t\t\tLoggerFactory.getLogger(MessageManager.class);\n \n \n     private StrongConcurrentSet<MessageContext> messages = new StrongConcurrentSet();\n@@ -90,7 +95,7 @@ public class MessageManager {\n     }\n \n    private void logSuccess(MessageContext mCtx){\n-       System.out.println(\"Message \" + mCtx.getMessage() + \" was successfully handled \" + mCtx.getExpectedCount() + \" times by \" + mCtx.printListeners());\n+       LOG.info(\"Message \" + mCtx.getMessage() + \" was successfully handled \" + mCtx.getExpectedCount() + \" times by \" + mCtx.printListeners());\n    }\n \n \n@@ -100,7 +105,7 @@ public class MessageManager {\n         errorMessage.append(\"Failing messages:\\n\");\n         for(MessageContext failingMessage : failing)\n             errorMessage.append(failingMessage);\n-        System.out.println(errorMessage.toString());\n+        LOG.info(errorMessage.toString());\n     }\n \n     private class MessageContext{\n"
    },
    {
        "commit hash": "02f18f8e4a120e05ab20cd1cc9a4f51d871394e3",
        "previous commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java",
            "additions": 47,
            "deletions": 3
        },
        "diff content": "@@ -41,13 +41,57 @@ public class BusConfiguration implements IBusConfiguration {\n         }\n     };\n \n+    /**\n+     * Creates a new instance, using the Default settings of 2 dispatchers, and\n+     * asynchronous handlers with an initial count equal to the number of\n+     * available processors in the machine, with maximum count equal to\n+     * 2 * the number of available processors. Uses {@link Runtime#availableProcessors()} to\n+     * determine the number of available processors\n+     * \n+     * @return a Default BusConfiguration\n+     */\n     public static BusConfiguration Default() {\n-        BusConfiguration defaultConfig = new BusConfiguration();\n+    \treturn Default(2);\n+    }\n+\n+    /**\n+     * Creates a new instance, using the specified number of dispatchers, and\n+     * asynchronous handlers with an initial count equal to the number of\n+     * available processors in the machine, with maximum count equal to\n+     * 2 * the number of available processors. Uses {@link Runtime#availableProcessors()} to\n+     * determine the number of available processors\n+     * \n+     * @return a Default BusConfiguration\n+     */\n+    public static BusConfiguration Default(int numberOfDispatchers) {\n         int numberOfCoreThreads = Runtime.getRuntime().availableProcessors();\n-        defaultConfig.setExecutorForAsynchronousHandlers(new ThreadPoolExecutor(numberOfCoreThreads, numberOfCoreThreads*2, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), AsynchronousHandlerThreadFactory));\n+        return Default(numberOfDispatchers, numberOfCoreThreads, numberOfCoreThreads * 2);\n+    }\n+    \n+    /**\n+     * Creates a new instance, using the specified number of dispatchers, and\n+     * asynchronous handlers with initial threads and maximum threads specified by the calling\n+     * parameters.\n+     * \n+     * @return a Default BusConfiguration\n+     */\n+    public static BusConfiguration Default(int numberOfDispatchers, int initialCoreThreads, int maximumCoreThreads) {\n+    \tThreadPoolExecutor executor = new ThreadPoolExecutor(initialCoreThreads, maximumCoreThreads, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), AsynchronousHandlerThreadFactory);\n+    \treturn Default(numberOfDispatchers, executor);\n+    }\n+    \n+    /**\n+     * Creates a new instance, using the specified number of dispatchers, and\n+     * asynchronous handlers that use the provided ThreadPoolExecutor.\n+     * \n+     * @return a Default BusConfiguration\n+     */\n+    public static BusConfiguration Default(int numberOfDispatchers, ThreadPoolExecutor executor) {\n+        BusConfiguration defaultConfig = new BusConfiguration();\n+        defaultConfig.setExecutorForAsynchronousHandlers(executor);\n         defaultConfig.setMetadataReader(new MetadataReader());\n         defaultConfig.setSubscriptionFactory(new SubscriptionFactory());\n-        defaultConfig.setNumberOfMessageDispatchers(2);\n+        defaultConfig.setNumberOfMessageDispatchers(numberOfDispatchers);\n         defaultConfig.setMessagePublicationFactory(new MessagePublication.Factory());\n         defaultConfig.setPendingMessagesQueue(new LinkedBlockingQueue<MessagePublication>(Integer.MAX_VALUE));\n         defaultConfig.setThreadFactoryForAsynchronousMessageDispatch(DispatcherThreadFactory);\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -18,7 +18,7 @@\n         while preserving resource efficiency and performance.\n \n         It features:\n-        declarative listener definition via annotations,\n+        declarative handler definition via annotations,\n         sync and/or async message delivery,\n         weak-references,\n         message filtering,\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/PublicationError.java",
            "additions": 19,
            "deletions": 18
        },
        "diff content": "@@ -12,34 +12,35 @@ import java.lang.reflect.Method;\n  *         Date: 2/22/12\n  *         Time: 4:59 PM\n  */\n-public class PublicationError {\n+public class PublicationError{\n \n     // Internal state\n     private Throwable cause;\n     private String message;\n-    private Method listener;\n-    private Object listeningObject;\n+    private Method handler;\n+    private Object listener;\n     private Object publishedObject;\n \n+\n     /**\n      * Compound constructor, creating a PublicationError from the supplied objects.\n      *\n      * @param cause           The Throwable giving rise to this PublicationError.\n      * @param message         The message to send.\n-     * @param listener        The method where the error was created.\n-     * @param listeningObject The object in which the PublicationError was generated.\n+     * @param handler        The method where the error was created.\n+     * @param listener The object in which the PublicationError was generated.\n      * @param publishedObject The published object which gave rise to the error.\n      */\n     public PublicationError(final Throwable cause,\n                             final String message,\n-                            final Method listener,\n-                            final Object listeningObject,\n+                            final Method handler,\n+                            final Object listener,\n                             final Object publishedObject) {\n \n         this.cause = cause;\n         this.message = message;\n+        this.handler = handler;\n         this.listener = listener;\n-        this.listeningObject = listeningObject;\n         this.publishedObject = publishedObject;\n     }\n \n@@ -77,21 +78,21 @@ public class PublicationError {\n         return this;\n     }\n \n-    public Method getListener() {\n-        return listener;\n+    public Method getHandler() {\n+        return handler;\n     }\n \n-    public PublicationError setListener(Method listener) {\n-        this.listener = listener;\n+    public PublicationError setHandler(Method handler) {\n+        this.handler = handler;\n         return this;\n     }\n \n-    public Object getListeningObject() {\n-        return listeningObject;\n+    public Object getListener() {\n+        return listener;\n     }\n \n-    public PublicationError setListeningObject(Object listeningObject) {\n-        this.listeningObject = listeningObject;\n+    public PublicationError setListener(Object listener) {\n+        this.listener = listener;\n         return this;\n     }\n \n@@ -116,9 +117,9 @@ public class PublicationError {\n                 newLine +\n                 \"\\tmessage='\" + message + '\\'' +\n                 newLine +\n-                \"\\tlistener=\" + listener +\n+                \"\\thandler=\" + handler +\n                 newLine +\n-                \"\\tlisteningObject=\" + listeningObject +\n+                \"\\tlistener=\" + listener +\n                 newLine +\n                 \"\\tpublishedObject=\" + publishedObject +\n                 '}';\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java",
            "additions": 25,
            "deletions": 19
        },
        "diff content": "@@ -1,11 +1,15 @@\n package net.engio.mbassy.bus;\n \n import net.engio.mbassy.PublicationError;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n+import net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n \n import java.util.ArrayList;\n import java.util.List;\n-import java.util.concurrent.*;\n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  * The base class for all async message bus implementations.\n@@ -13,7 +17,7 @@ import java.util.concurrent.atomic.AtomicInteger;\n  * @param <T>\n  * @param <P>\n  */\n-public abstract class AbstractSyncAsyncMessageBus<T, P extends IMessageBus.IPostCommand> extends AbstractSyncMessageBus<T, P> implements IMessageBus<T, P> {\n+public abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublicationCommand> extends AbstractSyncMessageBus<T, P> implements IMessageBus<T, P> {\n \n     // executor for asynchronous message handlers\n     private final ExecutorService executor;\n@@ -24,23 +28,23 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends IMessageBus.IPost\n     // all pending messages scheduled for asynchronous dispatch are queued here\n     private final BlockingQueue<MessagePublication> pendingMessages;\n \n-    private static final AtomicInteger threadID = new AtomicInteger();\n-    \n-    public AbstractSyncAsyncMessageBus(BusConfiguration configuration) {\n+    protected AbstractSyncAsyncMessageBus(IBusConfiguration configuration) {\n         super(configuration);\n-        this.executor = configuration.getExecutor();\n-        pendingMessages = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n-         dispatchers = new ArrayList<Thread>(configuration.getNumberOfMessageDispatchers());\n-        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n+        this.executor = configuration.getExecutorForAsynchronousHandlers();\n+        getRuntime().add(\"handler.async-service\", executor);\n+        pendingMessages = configuration.getPendingMessagesQueue();\n+        dispatchers = new ArrayList<Thread>(configuration.getNumberOfMessageDispatchers());\n+        initDispatcherThreads(configuration);\n     }\n \n \n     // initialize the dispatch workers\n-    private void initDispatcherThreads(int numberOfThreads) {\n-        for (int i = 0; i < numberOfThreads; i++) {\n+    private void initDispatcherThreads(IBusConfiguration configuration) {\n+        for (int i = 0; i < configuration.getNumberOfMessageDispatchers(); i++) {\n             // each thread will run forever and process incoming\n-            //dispatch requests\n-            Thread dispatcher = new Thread(new Runnable() {\n+            // message publication requests\n+\n+            Thread dispatcher = configuration.getThreadFactoryForAsynchronousMessageDispatch().newThread(new Runnable() {\n                 public void run() {\n                     while (true) {\n                         try {\n@@ -54,8 +58,6 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends IMessageBus.IPost\n                     }\n                 }\n             });\n-            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n-            dispatcher.setName(\"MBassyDispatch-\" + threadID.incrementAndGet());\n             dispatchers.add(dispatcher);\n             dispatcher.start();\n         }\n@@ -68,7 +70,8 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends IMessageBus.IPost\n             pendingMessages.put(request);\n             return request.markScheduled();\n         } catch (InterruptedException e) {\n-            return request.setError();\n+            // TODO: publication error\n+            return request;\n         }\n     }\n \n@@ -77,9 +80,10 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends IMessageBus.IPost\n         try {\n             return pendingMessages.offer(request, timeout, unit)\n                     ? request.markScheduled()\n-                    : request.setError();\n+                    : request;\n         } catch (InterruptedException e) {\n-            return request.setError();\n+            // TODO: publication error\n+            return request;\n         }\n     }\n \n@@ -89,6 +93,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends IMessageBus.IPost\n         super.finalize();\n     }\n \n+    @Override\n     public void shutdown() {\n         for (Thread dispatcher : dispatchers) {\n             dispatcher.interrupt();\n@@ -96,6 +101,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends IMessageBus.IPost\n         if(executor != null) executor.shutdown();\n     }\n \n+    @Override\n     public boolean hasPendingMessages() {\n         return pendingMessages.size() > 0;\n     }\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java",
            "additions": 16,
            "deletions": 8
        },
        "diff content": "@@ -2,16 +2,16 @@ package net.engio.mbassy.bus;\n \n import net.engio.mbassy.IPublicationErrorHandler;\n import net.engio.mbassy.PublicationError;\n-\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n+import net.engio.mbassy.bus.publication.IPublicationCommand;\n import net.engio.mbassy.common.DeadMessage;\n-\n import net.engio.mbassy.subscription.Subscription;\n import net.engio.mbassy.subscription.SubscriptionManager;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n-import java.util.*;\n \n /**\n  * The base class for all message bus implementations.\n@@ -19,7 +19,7 @@ import java.util.*;\n  * @param <T>\n  * @param <P>\n  */\n-public abstract class AbstractSyncMessageBus<T, P extends ISyncMessageBus.ISyncPostCommand> implements ISyncMessageBus<T, P> {\n+public abstract class AbstractSyncMessageBus<T, P extends IPublicationCommand> implements ISyncMessageBus<T, P>{\n \n \n     // this handler will receive all errors that occur during message dispatch or message handling\n@@ -29,10 +29,14 @@ public abstract class AbstractSyncMessageBus<T, P extends ISyncMessageBus.ISyncP\n \n     private final SubscriptionManager subscriptionManager;\n \n+    private final BusRuntime runtime;\n+\n \n-    public AbstractSyncMessageBus(SyncBusConfiguration configuration) {\n+    public AbstractSyncMessageBus(IBusConfiguration configuration) {\n+        this.runtime = new BusRuntime(this);\n+        this.runtime.add(\"error.handlers\", getRegisteredErrorHandlers());\n         this.subscriptionManager = new SubscriptionManager(configuration.getMetadataReader(),\n-                configuration.getSubscriptionFactory().setBus(this));\n+                configuration.getSubscriptionFactory(), runtime);\n         this.publicationFactory = configuration.getMessagePublicationFactory();\n     }\n \n@@ -61,15 +65,19 @@ public abstract class AbstractSyncMessageBus<T, P extends ISyncMessageBus.ISyncP\n         }\n     }\n \n+    @Override\n+    public BusRuntime getRuntime() {\n+        return runtime;\n+    }\n \n     protected MessagePublication createMessagePublication(T message) {\n         Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n         if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass().equals(DeadMessage.class)) {\n             // Dead Event\n             subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n-            return getPublicationFactory().createPublication(this, subscriptions, new DeadMessage(message));\n+            return getPublicationFactory().createPublication(runtime, subscriptions, new DeadMessage(message));\n         } else {\n-            return getPublicationFactory().createPublication(this, subscriptions, message);\n+            return getPublicationFactory().createPublication(runtime, subscriptions, message);\n         }\n     }\n \n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/BusConfiguration.java",
            "additions": 0,
            "deletions": 72
        },
        "diff content": "@@ -1,72 +0,0 @@\n-package net.engio.mbassy.bus;\n-\n-import java.util.concurrent.*;\n-\n-/**\n- * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n- *\n- * @author bennidi\n- *         Date: 12/8/12\n- */\n-public class BusConfiguration extends SyncBusConfiguration<BusConfiguration> {\n-\n-    private static final ThreadFactory DaemonThreadFactory = new ThreadFactory() {\n-        @Override\n-        public Thread newThread(Runnable r) {\n-            Thread thread = Executors.defaultThreadFactory().newThread(r);\n-            thread.setDaemon(true);\n-            return thread;\n-        }\n-    };\n-\n-    public static BusConfiguration Default() {\n-        return new BusConfiguration();\n-    }\n-\n-    private int numberOfMessageDispatchers;\n-\n-    private ExecutorService executor;\n-\n-    private int maximumNumberOfPendingMessages;\n-\n-    public BusConfiguration() {\n-        super();\n-        this.numberOfMessageDispatchers = 2;\n-        this.maximumNumberOfPendingMessages = Integer.MAX_VALUE;\n-        this.executor = new ThreadPoolExecutor(10, 10, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), DaemonThreadFactory);\n-    }\n-\n-    public int getNumberOfMessageDispatchers() {\n-        return numberOfMessageDispatchers > 0 ? numberOfMessageDispatchers : 2;\n-    }\n-\n-    public BusConfiguration setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n-        this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n-        return this;\n-    }\n-\n-    /**\n-     * By default an unbound queuing strategy is used to ensure that no events get lost\n-     * @return\n-     */\n-    public ExecutorService getExecutor() {\n-        return executor;\n-    }\n-\n-    public BusConfiguration setExecutor(ExecutorService executor) {\n-        this.executor = executor;\n-        return this;\n-    }\n-\n-    public int getMaximumNumberOfPendingMessages() {\n-        return maximumNumberOfPendingMessages;\n-    }\n-\n-    public BusConfiguration setMaximumNumberOfPendingMessages(int maximumNumberOfPendingMessages) {\n-        this.maximumNumberOfPendingMessages = maximumNumberOfPendingMessages > 0\n-                ? maximumNumberOfPendingMessages\n-                : Integer.MAX_VALUE;\n-        return this;\n-    }\n-\n-}\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/BusRuntime.java",
            "additions": 51,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,51 @@\n+package net.engio.mbassy.bus;\n+\n+import net.engio.mbassy.common.MissingPropertyException;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Message bus implementations potentially vary in the features they provide and consequently in the components and properties\n+ * they expose. The runtime is a container for all those dynamic properties and components and is meant to be passed around\n+ * between collaborating objects such that they may access the different functionality provided by the bus implementation\n+ * they all belong to.\n+ *\n+ * It is the responsibility of the bus implementation to create and configure the runtime according to its capabilities,\n+ *\n+ */\n+public class BusRuntime {\n+\n+    private PubSubSupport provider;\n+\n+    private Map<String, Object> properties = new HashMap<String, Object>();\n+\n+    public BusRuntime(PubSubSupport provider) {\n+        this.provider = provider;\n+    }\n+\n+    public <T> T get(String key){\n+         if(!contains(key))\n+             throw new MissingPropertyException(\"The property \" + key + \" is not available in this runtime\");\n+         else return (T) properties.get(key);\n+     }\n+\n+    public PubSubSupport getProvider(){\n+        return provider;\n+    }\n+\n+    public Collection<String> getKeys(){\n+        return properties.keySet();\n+    }\n+\n+    public BusRuntime add(String key, Object property){\n+        properties.put(key, property);\n+        return this;\n+    }\n+\n+    public boolean contains(String key){\n+        return properties.containsKey(key);\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/ErrorHandlingSupport.java",
            "additions": 27,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,27 @@\n+package net.engio.mbassy.bus;\n+\n+import net.engio.mbassy.IPublicationErrorHandler;\n+\n+import java.util.Collection;\n+\n+\n+public interface ErrorHandlingSupport {\n+\n+    /**\n+     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n+     * may not be accessible due to security constraints or is not annotated properly.\n+     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n+     * A call to this method will add the given error handler to the chain\n+     *\n+     * @param errorHandler\n+     */\n+    void addErrorHandler(IPublicationErrorHandler errorHandler);\n+\n+    /**\n+     * Returns an immutable collection containing all the registered error handlers\n+     *\n+     * @return\n+     */\n+    Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n+\n+}\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/GenericMessagePublicationSupport.java",
            "additions": 25,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,25 @@\n+package net.engio.mbassy.bus;\n+\n+import net.engio.mbassy.bus.publication.IPublicationCommand;\n+\n+/**\n+ * This interface is meant to be implemented by different bus implementations to offer a consistent way\n+ * to plugin different flavors of message publication.\n+ *\n+ * The parametrization of the IPostCommand influences which publication flavours are available.\n+ *\n+ */\n+public interface GenericMessagePublicationSupport<T, P extends IPublicationCommand> {\n+\n+    /**\n+     * Publish a message to the bus using on of its supported message publication mechanisms. The supported\n+     * mechanisms depend on the available implementation and are exposed as subclasses of IPublicationCommand.\n+     * The standard mechanism is the synchronous dispatch which will publish the message in the current thread\n+     * and returns after every matching handler has been invoked. @See IPublicationCommand.\n+     *\n+     * @param message\n+     * @return\n+     */\n+    P post(T message);\n+\n+}\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/IMBassador.java",
            "additions": 19,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,19 @@\n+package net.engio.mbassy.bus;\n+\n+import net.engio.mbassy.bus.publication.SyncAsyncPostCommand;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Created with IntelliJ IDEA.\n+ * User: benjamin\n+ * Date: 8/21/13\n+ * Time: 11:05 AM\n+ * To change this template use File | Settings | File Templates.\n+ */\n+public interface IMBassador<T> extends IMessageBus<T, SyncAsyncPostCommand<T>> {\n+\n+    MessagePublication publishAsync(T message);\n+\n+    MessagePublication publishAsync(T message, long timeout, TimeUnit unit);\n+}\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/IMessageBus.java",
            "additions": 30,
            "deletions": 43
        },
        "diff content": "@@ -1,42 +1,55 @@\n package net.engio.mbassy.bus;\n \n+import net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n+\n import java.util.concurrent.Executor;\n-import java.util.concurrent.TimeUnit;\n \n /**\n- * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n- * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n- * The dispatch mechanism can by controlled for per message handler and message publication.\n- * A message publication is the publication of any message using one of the bus' publication methods.\n+ * A message bus offers facilities for publishing messages to the message handlers of registered listeners.\n+ * A message publication starts when an object is send to the bus using one of the its publication methods.\n+ *\n+ * Messages can be published synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n+ * Message handlers can be invoked synchronously or asynchronously depending on their configuration. Thus, there\n+ * are two notions of synchronicity / asynchronicity. One on the caller side, e.g. the invocation of the message publishing\n+ * methods. The second on the handler side, e.g. whether the handler is invoked in the same or a different thread.\n+ *\n  * <p/>\n  * Each message publication is isolated from all other running publications such that it does not interfere with them.\n- * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n- * messages get published asynchronously.\n+ * Hence, the bus generally expects message handlers to be stateless as it may invoke them concurrently if multiple\n+ * messages get published asynchronously. If handlers are stateful and not thread-safe they can be marked to be invoked\n+ * in a synchronized fashion using @Synchronized annotation\n+ *\n  * <p/>\n  * A listener is any object that defines at least one message handler and that has been subscribed to at least\n  * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n  * as a message handler using the @Handler annotation.\n+ *\n  * <p/>\n- * The bus uses weak references to all listeners such that registered listeners do not need to\n+ * By default, the bus uses weak references to all listeners such that registered listeners do not need to\n  * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n- * removed on-the-fly as messages get dispatched.\n+ * removed on-the-fly as messages get dispatched. This can be changed using the @Listener annotation.\n+ *\n  * <p/>\n  * Generally message handlers will be invoked in inverse sequence of subscription but any\n  * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n- * a specific message exactly once to each of the subscribed message handlers.\n+ * a specific message exactly once to each of the respective message handlers.\n+ *\n  * <p/>\n  * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n  * a message handler may define filters to narrow the set of messages that it accepts.\n+ *\n  * <p/>\n  * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n  * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n  * will be silently ignored)\n+ *\n  * <p/>\n  * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n  * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n  * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n  * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n  * after the remove operation completed.\n+ *\n  * <p/>\n  * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n  * get dispatched to all message handlers that take an instance of List as their parameter\n@@ -44,7 +57,13 @@ import java.util.concurrent.TimeUnit;\n  * @Author bennidi\n  * Date: 2/8/12\n  */\n-public interface IMessageBus<T, P extends IMessageBus.IPostCommand> extends ISyncMessageBus<T,P> {\n+public interface IMessageBus<T, P extends ISyncAsyncPublicationCommand> extends PubSubSupport<T>, ErrorHandlingSupport, GenericMessagePublicationSupport<T, P> {\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    P post(T message);\n \n     /**\n      * Get the executor service that is used for asynchronous message publications.\n@@ -68,37 +87,5 @@ public interface IMessageBus<T, P extends IMessageBus.IPostCommand> extends ISyn\n      */\n     void shutdown();\n \n-    /**\n-     * @param message\n-     * @return\n-     */\n-    P post(T message);\n-\n-\n-    interface IPostCommand extends ISyncPostCommand {\n-\n-        /**\n-         * Execute the message publication asynchronously. The behaviour of this method depends on the\n-         * configured queuing strategy:\n-         * <p/>\n-         * If an unbound queuing strategy is used the call returns immediately.\n-         * If a bounded queue is used the call might block until the message can be placed in the queue.\n-         *\n-         * @return A message publication that can be used to access information about the state of\n-         */\n-        MessagePublication asynchronously();\n-\n-        /**\n-         * Execute the message publication asynchronously. The behaviour of this method depends on the\n-         * configured queuing strategy:\n-         * <p/>\n-         * If an unbound queuing strategy is used the call returns immediately.\n-         * If a bounded queue is used the call will block until the message can be placed in the queue\n-         * or the timeout is reached.\n-         *\n-         * @return A message publication that wraps up the publication request\n-         */\n-        MessagePublication asynchronously(long timeout, TimeUnit unit);\n-    }\n \n }\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/ISyncMessageBus.java",
            "additions": 2,
            "deletions": 45
        },
        "diff content": "@@ -1,55 +1,12 @@\n package net.engio.mbassy.bus;\n \n-import net.engio.mbassy.IPublicationErrorHandler;\n-import net.engio.mbassy.PubSubSupport;\n-\n-import java.util.Collection;\n+import net.engio.mbassy.bus.publication.IPublicationCommand;\n \n /**\n- *\n- *\n  * @author bennidi\n  *         Date: 3/29/13\n  */\n-public interface ISyncMessageBus<T, P extends ISyncMessageBus.ISyncPostCommand> extends PubSubSupport<T>{\n-\n-\n-    /**\n-     * @param message\n-     * @return\n-     */\n-    P post(T message);\n-\n-    /**\n-     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n-     * may not be accessible due to security constraints or is not annotated properly.\n-     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n-     * A call to this method will add the given error handler to the chain\n-     *\n-     * @param errorHandler\n-     */\n-    void addErrorHandler(IPublicationErrorHandler errorHandler);\n-\n-    /**\n-     * Returns an immutable collection containing all the registered error handlers\n-     *\n-     * @return\n-     */\n-    Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n-\n-\n+public interface ISyncMessageBus<T, P extends IPublicationCommand> extends PubSubSupport<T>, ErrorHandlingSupport, GenericMessagePublicationSupport<T, P>{\n \n-    /**\n-     * A post command is used as an intermediate object created by a call to the message bus' post method.\n-     * It encapsulates the functionality provided by the message bus that created the command.\n-     * Subclasses may extend this interface and add functionality, e.g. different dispatch schemes.\n-     */\n-    interface ISyncPostCommand {\n \n-        /**\n-         * Execute the message publication immediately. This call blocks until every matching message handler\n-         * has been invoked.\n-         */\n-        void now();\n-    }\n }\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MBassador.java",
            "additions": 5,
            "deletions": 1
        },
        "diff content": "@@ -1,21 +1,25 @@\n package net.engio.mbassy.bus;\n \n import net.engio.mbassy.PublicationError;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n+import net.engio.mbassy.bus.publication.SyncAsyncPostCommand;\n \n import java.util.concurrent.TimeUnit;\n \n \n-public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> {\n+public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> implements IMBassador<T> {\n \n     public MBassador(BusConfiguration configuration) {\n         super(configuration);\n     }\n \n \n+    @Override\n     public MessagePublication publishAsync(T message) {\n         return addAsynchronousDeliveryRequest(createMessagePublication(message));\n     }\n \n+    @Override\n     public MessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n         return addAsynchronousDeliveryRequest(createMessagePublication(message), timeout, unit);\n     }\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MessagePublication.java",
            "additions": 22,
            "deletions": 30
        },
        "diff content": "@@ -19,26 +19,15 @@ import java.util.Collection;\n  */\n public class MessagePublication {\n \n-    public static class Factory {\n-\n-        public MessagePublication createPublication(ISyncMessageBus owningBus, Collection<Subscription> subscriptions, Object message) {\n-            return new MessagePublication(owningBus, subscriptions, message, State.Initial);\n-        }\n-\n-    }\n-\n-    private Collection<Subscription> subscriptions;\n-\n-    private Object message;\n-\n-    private State state = State.Initial;\n-\n-    private boolean delivered = false;\n-\n-    private ISyncMessageBus bus;\n-\n-    protected MessagePublication(ISyncMessageBus bus, Collection<Subscription> subscriptions, Object message, State initialState) {\n-        this.bus = bus;\n+    private final Collection<Subscription> subscriptions;\n+    private final Object message;\n+    // message publications can be referenced by multiple threads to query publication progress\n+    private volatile State state = State.Initial;\n+    private volatile boolean delivered = false;\n+    private final BusRuntime runtime;\n+\n+    protected MessagePublication(BusRuntime runtime, Collection<Subscription> subscriptions, Object message, State initialState) {\n+        this.runtime = runtime;\n         this.subscriptions = subscriptions;\n         this.message = message;\n         this.state = initialState;\n@@ -51,15 +40,15 @@ public class MessagePublication {\n     protected void execute() {\n         state = State.Running;\n         for (Subscription sub : subscriptions) {\n-            sub.publish(this, message);\n+           sub.publish(this, message);\n         }\n         state = State.Finished;\n         // if the message has not been marked delivered by the dispatcher\n         if (!delivered) {\n             if (!isFilteredEvent() && !isDeadEvent()) {\n-                bus.post(new FilteredMessage(message)).now();\n+                runtime.getProvider().publish(new FilteredMessage(message));\n             } else if (!isDeadEvent()) {\n-                bus.post(new DeadMessage(message)).now();\n+                runtime.getProvider().publish(new DeadMessage(message));\n             }\n \n         }\n@@ -82,17 +71,12 @@ public class MessagePublication {\n     }\n \n     public MessagePublication markScheduled() {\n-        if (!state.equals(State.Initial)) {\n-            return this;\n+        if (state.equals(State.Initial)) {\n+            state = State.Scheduled;\n         }\n-        state = State.Scheduled;\n         return this;\n     }\n \n-    public MessagePublication setError() {\n-        state = State.Error;\n-        return this;\n-    }\n \n     public boolean isDeadEvent() {\n         return DeadMessage.class.isAssignableFrom(message.getClass());\n@@ -106,4 +90,12 @@ public class MessagePublication {\n         Initial, Scheduled, Running, Finished, Error\n     }\n \n+    public static class Factory {\n+\n+        public MessagePublication createPublication(BusRuntime runtime, Collection<Subscription> subscriptions, Object message) {\n+            return new MessagePublication(runtime, subscriptions, message, State.Initial);\n+        }\n+\n+    }\n+\n }\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/PostCommand.java",
            "additions": 0,
            "deletions": 9
        },
        "diff content": "@@ -1,9 +0,0 @@\n-package net.engio.mbassy.bus;\n-\n-/**\n- *\n- * @author bennidi\n- *         Date: 5/25/13\n- */\n-public interface PostCommand {\n-}\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/PubSubSupport.java",
            "additions": 11,
            "deletions": 11
        },
        "diff content": "@@ -1,17 +1,16 @@\n-package net.engio.mbassy;\n+package net.engio.mbassy.bus;\n \n /**\n  * This interface defines the very basic message publication semantics according to the publish subscribe pattern.\n- *\n- * Listeners can be subscribed and unsubscribed using the corresponding methods. When a listener is subscribed\n- *\n+ * Listeners can be subscribed and unsubscribed using the corresponding methods. When a listener is subscribed its\n+ * handlers will be registered and start to receive matching message publications.\n  *\n  */\n-public interface PubSubSupport<T> {\n+public interface PubSubSupport<T> extends RuntimeProvider{\n \n     /**\n-     * Subscribe all handler of the given listener. Any listener may only be subscribed once\n-     * -> subsequent subscriptions of an already subscribed listener will be silently ignored)\n+     * Subscribe all handlers of the given listener. Any listener is only subscribed once\n+     * -> subsequent subscriptions of an already subscribed listener will be silently ignored\n      *\n      * @param listener\n      */\n@@ -19,8 +18,8 @@ public interface PubSubSupport<T> {\n \n     /**\n      * Immediately remove all registered message handlers (if any) of the given listener. When this call returns all handlers\n-     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n-     * publications that have been published when the message listener was still subscribed).\n+     * have effectively been removed and will not receive any messages (provided that running publications (iterators) in other threads\n+     * have not yet obtained a reference to the listener)\n      * <p/>\n      * A call to this method passing any object that is not subscribed will not have any effect and is silently ignored.\n      *\n@@ -32,8 +31,9 @@ public interface PubSubSupport<T> {\n \n \n     /**\n-     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n-     * The call blocks until every messageHandler has processed the message.\n+     * Synchronously publish a message to all registered listeners. This includes listeners defined for super types of the\n+     * given message type, provided they are not configured to reject valid subtype. The call returns when all matching handlers\n+     * of all registered listeners have been notified (invoked) of the message.\n      *\n      * @param message\n      */\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/RuntimeProvider.java",
            "additions": 9,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,9 @@\n+package net.engio.mbassy.bus;\n+\n+/**\n+ * Each message bus provides a runtime object to access its dynamic features and runtime configuration.\n+ */\n+public interface RuntimeProvider {\n+\n+    BusRuntime getRuntime();\n+}\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/SyncMessageBus.java",
            "additions": 4,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,8 @@\n package net.engio.mbassy.bus;\n \n import net.engio.mbassy.PublicationError;\n+import net.engio.mbassy.bus.config.IBusConfiguration;\n+import net.engio.mbassy.bus.publication.IPublicationCommand;\n \n /**\n  * Created with IntelliJ IDEA.\n@@ -12,7 +14,7 @@ import net.engio.mbassy.PublicationError;\n public class SyncMessageBus<T> extends AbstractSyncMessageBus<T, SyncMessageBus.SyncPostCommand>{\n \n \n-    public SyncMessageBus(SyncBusConfiguration configuration) {\n+    public SyncMessageBus(IBusConfiguration configuration) {\n         super(configuration);\n     }\n \n@@ -40,7 +42,7 @@ public class SyncMessageBus<T> extends AbstractSyncMessageBus<T, SyncMessageBus.\n         return new SyncPostCommand(message);\n     }\n \n-    public class SyncPostCommand implements ISyncMessageBus.ISyncPostCommand{\n+    public class SyncPostCommand implements IPublicationCommand {\n \n \n         private T message;\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java",
            "additions": 143,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,143 @@\n+package net.engio.mbassy.bus.config;\n+\n+import net.engio.mbassy.bus.MessagePublication;\n+import net.engio.mbassy.listener.MetadataReader;\n+import net.engio.mbassy.subscription.SubscriptionFactory;\n+\n+import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n+ *\n+ * @author bennidi\n+ *         Date: 12/8/12\n+ */\n+public class BusConfiguration implements IBusConfiguration {\n+\n+    protected static final ThreadFactory AsynchronousHandlerThreadFactory = new ThreadFactory() {\n+\n+        private final AtomicInteger threadID = new AtomicInteger(0);\n+\n+        @Override\n+        public Thread newThread(Runnable r) {\n+            Thread thread = Executors.defaultThreadFactory().newThread(r);\n+            thread.setName(\"AsyncHandler-\" + threadID.getAndIncrement());\n+            thread.setDaemon(true);\n+            return thread;\n+        }\n+    };\n+\n+    protected static final ThreadFactory DispatcherThreadFactory = new ThreadFactory() {\n+\n+        private final AtomicInteger threadID = new AtomicInteger(0);\n+\n+        @Override\n+        public Thread newThread(Runnable r) {\n+            Thread thread = Executors.defaultThreadFactory().newThread(r);\n+            thread.setDaemon(true);// do not prevent the JVM from exiting\n+            thread.setName(\"Dispatcher-\" + threadID.getAndIncrement());\n+            return thread;\n+        }\n+    };\n+\n+    public static BusConfiguration Default() {\n+        BusConfiguration defaultConfig = new BusConfiguration();\n+        int numberOfCoreThreads = Runtime.getRuntime().availableProcessors();\n+        defaultConfig.setExecutorForAsynchronousHandlers(new ThreadPoolExecutor(numberOfCoreThreads, numberOfCoreThreads*2, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), AsynchronousHandlerThreadFactory));\n+        defaultConfig.setMetadataReader(new MetadataReader());\n+        defaultConfig.setSubscriptionFactory(new SubscriptionFactory());\n+        defaultConfig.setNumberOfMessageDispatchers(2);\n+        defaultConfig.setMessagePublicationFactory(new MessagePublication.Factory());\n+        defaultConfig.setPendingMessagesQueue(new LinkedBlockingQueue<MessagePublication>(Integer.MAX_VALUE));\n+        defaultConfig.setThreadFactoryForAsynchronousMessageDispatch(DispatcherThreadFactory);\n+        return defaultConfig;\n+    }\n+\n+    public static BusConfiguration Empty(){\n+        return new BusConfiguration();\n+    }\n+\n+    protected int numberOfMessageDispatchers;\n+    protected ExecutorService executor;\n+    protected SubscriptionFactory subscriptionFactory;\n+    protected MetadataReader metadataReader;\n+    protected MessagePublication.Factory messagePublicationFactory;\n+    protected ThreadFactory dispatcherThreadFactory;\n+\n+    public void setPendingMessagesQueue(BlockingQueue<MessagePublication> pendingMessagesQueue) {\n+        this.pendingMessagesQueue = pendingMessagesQueue;\n+    }\n+\n+    protected BlockingQueue<MessagePublication> pendingMessagesQueue;\n+\n+    private BusConfiguration() {\n+        super();\n+    }\n+\n+    @Override\n+    public int getNumberOfMessageDispatchers() {\n+        return numberOfMessageDispatchers > 0 ? numberOfMessageDispatchers : 2;\n+    }\n+\n+    public BusConfiguration setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n+        this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n+        return this;\n+    }\n+\n+\n+    @Override\n+    public ExecutorService getExecutorForAsynchronousHandlers() {\n+        return executor;\n+    }\n+\n+    @Override\n+    public BlockingQueue<MessagePublication> getPendingMessagesQueue() {\n+        return new LinkedBlockingQueue<MessagePublication>(Integer.MAX_VALUE);\n+    }\n+\n+    @Override\n+    public ThreadFactory getThreadFactoryForAsynchronousMessageDispatch() {\n+        return dispatcherThreadFactory;\n+    }\n+\n+    public BusConfiguration setThreadFactoryForAsynchronousMessageDispatch(ThreadFactory factory) {\n+        dispatcherThreadFactory = factory;\n+        return this;\n+    }\n+\n+    public BusConfiguration setExecutorForAsynchronousHandlers(ExecutorService executor) {\n+        this.executor = executor;\n+        return this;\n+    }\n+\n+    @Override\n+    public MessagePublication.Factory getMessagePublicationFactory() {\n+        return messagePublicationFactory;\n+    }\n+\n+    public BusConfiguration setMessagePublicationFactory(MessagePublication.Factory messagePublicationFactory) {\n+        this.messagePublicationFactory = messagePublicationFactory;\n+        return this;\n+    }\n+\n+    @Override\n+    public MetadataReader getMetadataReader() {\n+        return metadataReader;\n+    }\n+\n+    public void setMetadataReader(MetadataReader metadataReader) {\n+        this.metadataReader = metadataReader;\n+    }\n+\n+    @Override\n+    public SubscriptionFactory getSubscriptionFactory() {\n+        return subscriptionFactory;\n+    }\n+\n+    public BusConfiguration setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n+        this.subscriptionFactory = subscriptionFactory;\n+        return this;\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/IBusConfiguration.java",
            "additions": 34,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,34 @@\n+package net.engio.mbassy.bus.config;\n+\n+import net.engio.mbassy.bus.MessagePublication;\n+import net.engio.mbassy.listener.MetadataReader;\n+import net.engio.mbassy.subscription.SubscriptionFactory;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+\n+/**\n+ * Created with IntelliJ IDEA.\n+ * User: benjamin\n+ * Date: 8/16/13\n+ * Time: 9:56 AM\n+ * To change this template use File | Settings | File Templates.\n+ */\n+public interface IBusConfiguration {\n+\n+    int getNumberOfMessageDispatchers();\n+\n+    ExecutorService getExecutorForAsynchronousHandlers();\n+\n+    BlockingQueue<MessagePublication> getPendingMessagesQueue();\n+\n+    MessagePublication.Factory getMessagePublicationFactory();\n+\n+    MetadataReader getMetadataReader();\n+\n+    SubscriptionFactory getSubscriptionFactory();\n+\n+    ThreadFactory getThreadFactoryForAsynchronousMessageDispatch();\n+\n+}\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/config/SyncBusConfiguration.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -1,5 +1,6 @@\n-package net.engio.mbassy.bus;\n+package net.engio.mbassy.bus.config;\n \n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.subscription.SubscriptionFactory;\n \n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/publication/IPublicationCommand.java",
            "additions": 15,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,15 @@\n+package net.engio.mbassy.bus.publication;\n+\n+/**\n+ * A publication command is used as an intermediate object created by a call to the message bus' post method.\n+ * It encapsulates the message publication flavors provided by the message bus implementation that created the command.\n+ * Subclasses may extend this interface and add functionality, e.g. different dispatch schemes.\n+ */\n+public interface IPublicationCommand {\n+\n+    /**\n+     * Execute the message publication immediately. This call blocks until every matching message handler\n+     * has been invoked.\n+     */\n+    void now();\n+}\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/publication/ISyncAsyncPublicationCommand.java",
            "additions": 35,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,35 @@\n+package net.engio.mbassy.bus.publication;\n+\n+import net.engio.mbassy.bus.MessagePublication;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ *\n+ *\n+*/\n+public interface ISyncAsyncPublicationCommand extends IPublicationCommand {\n+\n+    /**\n+     * Execute the message publication asynchronously. The behaviour of this method depends on the\n+     * configured queuing strategy:\n+     * <p/>\n+     * If an unbound queuing strategy is used the call returns immediately.\n+     * If a bounded queue is used the call might block until the message can be placed in the queue.\n+     *\n+     * @return A message publication that can be used to access information about the state of\n+     */\n+    MessagePublication asynchronously();\n+\n+    /**\n+     * Execute the message publication asynchronously. The behaviour of this method depends on the\n+     * configured queuing strategy:\n+     * <p/>\n+     * If an unbound queuing strategy is used the call returns immediately.\n+     * If a bounded queue is used the call will block until the message can be placed in the queue\n+     * or the timeout is reached.\n+     *\n+     * @return A message publication that wraps up the publication request\n+     */\n+    MessagePublication asynchronously(long timeout, TimeUnit unit);\n+}\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/publication/SyncAsyncPostCommand.java",
            "additions": 5,
            "deletions": 2
        },
        "diff content": "@@ -1,4 +1,7 @@\n-package net.engio.mbassy.bus;\n+package net.engio.mbassy.bus.publication;\n+\n+import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.bus.MessagePublication;\n \n import java.util.concurrent.TimeUnit;\n \n@@ -8,7 +11,7 @@ import java.util.concurrent.TimeUnit;\n  * @author bennidi\n  *         Date: 11/12/12\n  */\n-public class SyncAsyncPostCommand<T> implements IMessageBus.IPostCommand {\n+public class SyncAsyncPostCommand<T> implements ISyncAsyncPublicationCommand {\n \n     private T message;\n     private MBassador<T> mBassador;\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/MissingPropertyException.java",
            "additions": 14,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,14 @@\n+package net.engio.mbassy.common;\n+\n+/**\n+ * This exception is thrown when a property value that is unavailable at runtime is accessed.\n+ * It indicates that some parts of the runtime configuration are actually incompatible,\n+ * i.e. one component is trying to access a feature of another component that does not\n+ * provide the feature (e.g. asynchronous functionality within a synchronous bus)\n+ */\n+public class MissingPropertyException extends RuntimeException{\n+\n+    public MissingPropertyException(String message) {\n+        super(message);\n+    }\n+}\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java",
            "additions": 10,
            "deletions": 6
        },
        "diff content": "@@ -1,32 +1,36 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.bus.IMessageBus;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n \n+import java.util.concurrent.ExecutorService;\n+\n /**\n  * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n  *\n  * @author bennidi\n  *         Date: 11/23/12\n  */\n-public class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware<IMessageBus> implements IHandlerInvocation<Object,Object,IMessageBus> {\n+public class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n+\n+    private final IHandlerInvocation delegate;\n \n-    private IHandlerInvocation delegate;\n+    private final ExecutorService executor;\n \n     public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n         super(delegate.getContext());\n         this.delegate = delegate;\n+        this.executor = delegate.getContext().getRuntime().get(\"handler.async-service\");\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public void invoke(final Object listener, final Object message) {\n-        getContext().getOwningBus().getExecutor().execute(new Runnable() {\n+    public void invoke(final Object listener, final Object message){\n+        executor.execute(new Runnable() {\n             @Override\n             public void run() {\n-                delegate.invoke(listener, message);\n+                    delegate.invoke(listener, message);\n             }\n         });\n     }\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -20,7 +20,7 @@ public class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher {\n     }\n \n     @Override\n-    public void dispatch(MessagePublication publication, Object message, Iterable listeners) {\n+    public void dispatch(MessagePublication publication, Object message, Iterable listeners){\n         getDelegate().dispatch(publication, new MessageEnvelope(message), listeners);\n     }\n }\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -36,7 +36,7 @@ public class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n \n \n     @Override\n-    public void dispatch(MessagePublication publication, Object message, Iterable listeners) {\n+    public void dispatch(MessagePublication publication, Object message, Iterable listeners){\n         if (passesFilter(message)) {\n             getDelegate().dispatch(publication, message, listeners);\n         }\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/HandlerInvocation.java",
            "additions": 13,
            "deletions": 2
        },
        "diff content": "@@ -1,19 +1,30 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.bus.ISyncMessageBus;\n+import net.engio.mbassy.IPublicationErrorHandler;\n+import net.engio.mbassy.PublicationError;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n import net.engio.mbassy.subscription.SubscriptionContext;\n \n+import java.util.Collection;\n+\n /**\n  * Todo: Add javadoc\n  *\n  * @author bennidi\n  *         Date: 3/29/13\n  */\n-public abstract class HandlerInvocation<Listener, Message> extends AbstractSubscriptionContextAware<ISyncMessageBus> implements IHandlerInvocation<Listener, Message,ISyncMessageBus>{\n+public abstract class HandlerInvocation<HANDLER, MESSAGE> extends AbstractSubscriptionContextAware implements IHandlerInvocation<HANDLER, MESSAGE>{\n+\n \n+    private final Collection<IPublicationErrorHandler> errorHandlers;\n \n     public HandlerInvocation(SubscriptionContext context) {\n         super(context);\n+        errorHandlers = context.getErrorHandlers();\n+    }\n+\n+    protected void handlePublicationError(PublicationError error){\n+        for(IPublicationErrorHandler handler : errorHandlers)\n+            handler.handleError(error);\n     }\n }\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java",
            "additions": 12,
            "deletions": 6
        },
        "diff content": "@@ -1,23 +1,29 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.bus.ISyncMessageBus;\n+import net.engio.mbassy.subscription.ISubscriptionContextAware;\n \n /**\n  * A handler invocation encapsulates the logic that is used to invoke a single\n  * message handler to process a given message.\n+ *\n  * A handler invocation might come in different flavours and can be composed\n- * of various independent invocations be means of delegation (decorator pattern)\n+ * of various independent invocations by means of delegation (-> decorator pattern)\n+ *\n+ * If an exception is thrown during handler invocation it is wrapped and propagated\n+ * as a publication error\n  *\n  * @author bennidi\n  *         Date: 11/23/12\n  */\n-public interface IHandlerInvocation<Listener, Message, Bus extends ISyncMessageBus> extends ISubscriptionContextAware<Bus> {\n+public interface IHandlerInvocation<HANDLER, MESSAGE> extends ISubscriptionContextAware {\n \n     /**\n      * Invoke the message delivery logic of this handler\n      *\n-     * @param listener The listener that will receive the message\n-     * @param message  The message to be delivered to the listener\n+     * @param handler The listener that will receive the message. This can be a reference to a method object\n+     *                 from the java reflection api or any other wrapper that can be used to invoke the handler\n+     * @param message  The message to be delivered to the handler. This can be any object compatible with the object\n+     *                 type that the handler consumes\n      */\n-    void invoke(Listener listener, Message message);\n+    void invoke(HANDLER handler, MESSAGE message);\n }\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IMessageBusAware.java",
            "additions": 0,
            "deletions": 14
        },
        "diff content": "@@ -1,14 +0,0 @@\n-package net.engio.mbassy.dispatch;\n-\n-import net.engio.mbassy.bus.ISyncMessageBus;\n-\n-/**\n- * This interface marks components that have access to the message bus that they belong to.\n- *\n- * @author bennidi\n- *         Date: 3/1/13\n- */\n-public interface IMessageBusAware<Bus extends ISyncMessageBus> {\n-\n-    Bus getBus();\n-}\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.dispatch;\n \n import net.engio.mbassy.bus.MessagePublication;\n+import net.engio.mbassy.subscription.ISubscriptionContextAware;\n \n /**\n  * A message dispatcher provides the functionality to deliver a single message\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -24,7 +24,7 @@ public class MessageDispatcher extends AbstractSubscriptionContextAware implemen\n     }\n \n     @Override\n-    public void dispatch(final MessagePublication publication, final Object message, final Iterable listeners) {\n+    public void dispatch(final MessagePublication publication, final Object message, final Iterable listeners){\n         publication.markDelivered();\n         for (Object listener : listeners) {\n             getInvocation().invoke(listener, message);\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java",
            "additions": 7,
            "deletions": 20
        },
        "diff content": "@@ -1,12 +1,10 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.IPublicationErrorHandler;\n import net.engio.mbassy.PublicationError;\n import net.engio.mbassy.subscription.SubscriptionContext;\n \n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n-import java.util.Collection;\n \n /**\n  * Uses reflection to invoke a message handler for a given message.\n@@ -20,36 +18,25 @@ public class ReflectiveHandlerInvocation extends HandlerInvocation{\n         super(context);\n     }\n \n-    protected void handlePublicationError(PublicationError error) {\n-        Collection<IPublicationErrorHandler> handlers = getContext().getOwningBus().getRegisteredErrorHandlers();\n-        for (IPublicationErrorHandler handler : handlers) {\n-            handler.handleError(error);\n-        }\n-    }\n-\n-    protected void invokeHandler(final Object message, final Object listener, Method handler) {\n+    protected void invokeHandler(final Object message, final Object listener, Method handler){\n         try {\n             handler.invoke(listener, message);\n         } catch (IllegalAccessException e) {\n-            handlePublicationError(\n-                    new PublicationError(e, \"Error during messageHandler notification. \" +\n+            handlePublicationError(new PublicationError(e, \"Error during invocation of message handler. \" +\n                             \"The class or method is not accessible\",\n                             handler, listener, message));\n         } catch (IllegalArgumentException e) {\n-            handlePublicationError(\n-                    new PublicationError(e, \"Error during messageHandler notification. \" +\n+            handlePublicationError(new PublicationError(e, \"Error during invocation of message handler. \" +\n                             \"Wrong arguments passed to method. Was: \" + message.getClass()\n                             + \"Expected: \" + handler.getParameterTypes()[0],\n                             handler, listener, message));\n         } catch (InvocationTargetException e) {\n-            handlePublicationError(\n-                    new PublicationError(e, \"Error during messageHandler notification. \" +\n+            handlePublicationError( new PublicationError(e, \"Error during invocation of message handler. \" +\n                             \"Message handler threw exception\",\n                             handler, listener, message));\n         } catch (Throwable e) {\n-            handlePublicationError(\n-                    new PublicationError(e, \"Error during messageHandler notification. \" +\n-                            \"Unexpected exception\",\n+            handlePublicationError( new PublicationError(e, \"Error during invocation of message handler. \" +\n+                            \"The handler code threw an exception\",\n                             handler, listener, message));\n         }\n     }\n@@ -58,7 +45,7 @@ public class ReflectiveHandlerInvocation extends HandlerInvocation{\n      * {@inheritDoc}\n      */\n     @Override\n-    public void invoke(final Object listener, final Object message) {\n+    public void invoke(final Object listener, final Object message){\n         invokeHandler(message, listener, getContext().getHandlerMetadata().getHandler());\n     }\n }\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/SynchronizedHandlerInvocation.java",
            "additions": 2,
            "deletions": 3
        },
        "diff content": "@@ -1,6 +1,5 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.bus.IMessageBus;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n \n /**\n@@ -9,7 +8,7 @@ import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n  * @author bennidi\n  *         Date: 3/31/13\n  */\n-public class SynchronizedHandlerInvocation extends AbstractSubscriptionContextAware<IMessageBus> implements IHandlerInvocation<Object,Object,IMessageBus>  {\n+public class SynchronizedHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation<Object,Object>  {\n \n     private IHandlerInvocation delegate;\n \n@@ -22,7 +21,7 @@ public class SynchronizedHandlerInvocation extends AbstractSubscriptionContextAw\n      * {@inheritDoc}\n      */\n     @Override\n-    public void invoke(final Object listener, final Object message) {\n+    public void invoke(final Object listener, final Object message){\n         synchronized (listener){\n             delegate.invoke(listener, message);\n         }\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java",
            "additions": 4,
            "deletions": 11
        },
        "diff content": "@@ -1,28 +1,21 @@\n package net.engio.mbassy.subscription;\n \n-import net.engio.mbassy.bus.ISyncMessageBus;\n-import net.engio.mbassy.dispatch.ISubscriptionContextAware;\n-\n /**\n  * The base implementation for subscription context aware objects (mightily obvious :)\n  *\n  * @author bennidi\n  *         Date: 3/1/13\n  */\n-public class AbstractSubscriptionContextAware<Bus extends ISyncMessageBus> implements ISubscriptionContextAware<Bus> {\n+public class AbstractSubscriptionContextAware implements ISubscriptionContextAware {\n \n-    private final SubscriptionContext<Bus> context;\n+    private final SubscriptionContext context;\n \n-    public AbstractSubscriptionContextAware(SubscriptionContext<Bus> context) {\n+    public AbstractSubscriptionContextAware(SubscriptionContext context) {\n         this.context = context;\n     }\n \n-    public SubscriptionContext<Bus> getContext() {\n+    public SubscriptionContext getContext() {\n         return context;\n     }\n \n-    @Override\n-    public Bus getBus() {\n-        return context.getOwningBus();\n-    }\n }\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/ISubscriptionContextAware.java",
            "additions": 2,
            "deletions": 5
        },
        "diff content": "@@ -1,7 +1,4 @@\n-package net.engio.mbassy.dispatch;\n-\n-import net.engio.mbassy.bus.ISyncMessageBus;\n-import net.engio.mbassy.subscription.SubscriptionContext;\n+package net.engio.mbassy.subscription;\n \n /**\n  * This interface marks components that have access to the subscription context.\n@@ -9,7 +6,7 @@ import net.engio.mbassy.subscription.SubscriptionContext;\n  * @author bennidi\n  *         Date: 3/1/13\n  */\n-public interface ISubscriptionContextAware<Bus extends ISyncMessageBus> extends IMessageBusAware<Bus> {\n+public interface ISubscriptionContextAware{\n \n     /**\n      * Get the subscription context associated with this object\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 3,
            "deletions": 2
        },
        "diff content": "@@ -44,8 +44,9 @@ public class Subscription {\n     }\n \n \n-    public void publish(MessagePublication publication, Object message) {\n-        dispatcher.dispatch(publication, message, listeners);\n+    public void publish(MessagePublication publication, Object message){\n+        if(listeners.size() > 0)\n+            dispatcher.dispatch(publication, message, listeners);\n     }\n \n     public int getPriority() {\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java",
            "additions": 28,
            "deletions": 15
        },
        "diff content": "@@ -1,8 +1,12 @@\n package net.engio.mbassy.subscription;\n \n-import net.engio.mbassy.bus.ISyncMessageBus;\n+import net.engio.mbassy.IPublicationErrorHandler;\n+import net.engio.mbassy.bus.BusRuntime;\n+import net.engio.mbassy.bus.RuntimeProvider;\n import net.engio.mbassy.listener.MessageHandlerMetadata;\n \n+import java.util.Collection;\n+\n /**\n  * The subscription context holds all (meta)data/objects that are relevant to successfully publish\n  * a message within a subscription. A one-to-one relation between a subscription and\n@@ -12,35 +16,44 @@ import net.engio.mbassy.listener.MessageHandlerMetadata;\n  * @author bennidi\n  *         Date: 11/23/12\n  */\n-public class SubscriptionContext<Bus extends ISyncMessageBus> {\n+public class SubscriptionContext implements RuntimeProvider {\n+\n+    // the handler's metadata -> for each handler in a listener, a unique subscription context is created\n+    private final MessageHandlerMetadata handlerMetadata;\n \n-    private Bus owningBus;\n+    // error handling is first-class functionality\n+    private final Collection<IPublicationErrorHandler> errorHandlers;\n \n-    private MessageHandlerMetadata handlerMetadata;\n+    private BusRuntime runtime;\n \n-    public SubscriptionContext(Bus owningBus, MessageHandlerMetadata handlerMetadata) {\n-        this.owningBus = owningBus;\n+    public SubscriptionContext(BusRuntime runtime, MessageHandlerMetadata handlerMetadata,\n+                               Collection<IPublicationErrorHandler> errorHandlers) {\n+        this.runtime = runtime;\n         this.handlerMetadata = handlerMetadata;\n+        this.errorHandlers = errorHandlers;\n     }\n \n     /**\n-     * Get a reference to the message bus this context belongs to\n+     * Get the meta data that specifies the characteristics of the message handler\n+     * that is associated with this context\n      *\n      * @return\n      */\n-    public Bus getOwningBus() {\n-        return owningBus;\n+    public MessageHandlerMetadata getHandlerMetadata() {\n+        return handlerMetadata;\n     }\n \n-\n     /**\n-     * Get the meta data that specifies the characteristics of the message handler\n-     * that is associated with this context\n-     *\n+     * Get the error handlers registered with the enclosing bus.\n      * @return\n      */\n-    public MessageHandlerMetadata getHandlerMetadata() {\n-        return handlerMetadata;\n+    public Collection<IPublicationErrorHandler> getErrorHandlers(){\n+        return errorHandlers;\n+    }\n+\n+    @Override\n+    public BusRuntime getRuntime() {\n+        return runtime;\n     }\n \n }\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java",
            "additions": 7,
            "deletions": 10
        },
        "diff content": "@@ -1,15 +1,16 @@\n package net.engio.mbassy.subscription;\n \n+import net.engio.mbassy.IPublicationErrorHandler;\n import net.engio.mbassy.MessageBusException;\n-import net.engio.mbassy.bus.ISyncMessageBus;\n+import net.engio.mbassy.bus.BusRuntime;\n import net.engio.mbassy.common.StrongConcurrentSet;\n import net.engio.mbassy.common.WeakConcurrentSet;\n import net.engio.mbassy.dispatch.*;\n import net.engio.mbassy.listener.MessageHandlerMetadata;\n \n import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Modifier;\n+import java.util.Collection;\n \n /**\n  * The subscription factory is used to create an empty subscription for specific message handler.\n@@ -17,16 +18,12 @@ import java.lang.reflect.Modifier;\n  */\n public class SubscriptionFactory {\n \n-    private ISyncMessageBus bus;\n+    private static final String ErrorHandlers = \"error.handlers\";\n \n-    public SubscriptionFactory setBus(ISyncMessageBus bus) {\n-        this.bus = bus;\n-        return this;\n-    }\n-\n-    public Subscription createSubscription(MessageHandlerMetadata handlerMetadata) throws MessageBusException{\n+    public Subscription createSubscription(BusRuntime runtime, MessageHandlerMetadata handlerMetadata) throws MessageBusException{\n         try {\n-            SubscriptionContext context = new SubscriptionContext(bus, handlerMetadata);\n+            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(ErrorHandlers);\n+            SubscriptionContext context = new SubscriptionContext(runtime, handlerMetadata, errorHandlers);\n             IHandlerInvocation invocation = buildInvocationForHandler(context);\n             IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n             return new Subscription(context, dispatcher, handlerMetadata.useStrongReferences()\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java",
            "additions": 12,
            "deletions": 4
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy.subscription;\n \n+import net.engio.mbassy.bus.BusRuntime;\n import net.engio.mbassy.common.ReflectionUtils;\n import net.engio.mbassy.common.StrongConcurrentSet;\n import net.engio.mbassy.listener.MessageHandlerMetadata;\n@@ -9,7 +10,9 @@ import java.util.*;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n /**\n- * Todo: Add javadoc\n+ * The subscription managers primary task is consistently handle new and existing subscriptions\n+ * and to synchronize concurrent access to them efficiently. It takes care of properly registering and\n+ * unregistering message listeners and is a core component of each bus implementation\n  *\n  * @author bennidi\n  *         Date: 5/11/13\n@@ -41,9 +44,12 @@ public class SubscriptionManager {\n \n     private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n \n-    public SubscriptionManager(MetadataReader metadataReader, SubscriptionFactory subscriptionFactory) {\n+    private final BusRuntime runtime;\n+\n+    public SubscriptionManager(MetadataReader metadataReader, SubscriptionFactory subscriptionFactory, BusRuntime runtime) {\n         this.metadataReader = metadataReader;\n         this.subscriptionFactory = subscriptionFactory;\n+        this.runtime = runtime;\n     }\n \n \n@@ -91,7 +97,7 @@ public class SubscriptionManager {\n                 // create subscriptions for all detected message handlers\n                 for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                     // create the subscription\n-                    subscriptionsByListener.add(subscriptionFactory.createSubscription(messageHandler));\n+                    subscriptionsByListener.add(subscriptionFactory.createSubscription(runtime, messageHandler));\n                 }\n                 // this will acquire a write lock and handle the case when another thread already subscribed\n                 // this particular listener in the mean-time\n@@ -114,7 +120,9 @@ public class SubscriptionManager {\n             readWriteLock.writeLock().lock();\n             // basically this is a deferred double check\n             // it's an ugly pattern but necessary because atomic upgrade from read to write lock\n-            // is not possible and using a write lock from the beginning with will dramatically decrease performance\n+            // is not possible\n+            // the alternative of using a write lock from the beginning would decrease performance dramatically\n+            // because of the huge number of reads compared to writes\n             Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n \n             if (subscriptionsByListener == null) {\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConcurrentSetTest.java",
            "additions": 50,
            "deletions": 33
        },
        "diff content": "@@ -4,6 +4,7 @@ import junit.framework.Assert;\n import net.engio.mbassy.common.AssertSupport;\n import net.engio.mbassy.common.ConcurrentExecutor;\n import net.engio.mbassy.common.IConcurrentSet;\n+import org.junit.Before;\n import org.junit.Test;\n \n import java.util.*;\n@@ -26,7 +27,14 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n     // Shared state\n     protected final int numberOfElements = 100000;\n     protected final int numberOfThreads = 50;\n-    \n+\n+    protected Set gcProtector = new HashSet();\n+\n+    @Before\n+    public void beforeTest(){\n+        super.beforeTest();\n+        gcProtector = new HashSet();\n+    }\n     \n     protected abstract IConcurrentSet createSet();\n \n@@ -36,7 +44,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n         final LinkedList<Object> duplicates = new LinkedList<Object>();\n         final HashSet<Object> distinct = new HashSet<Object>();\n \n-        final IConcurrentSet testSetWeak = createSet();\n+        final IConcurrentSet testSet = createSet();\n         Random rand = new Random();\n \n         // getAll set of distinct objects and list of duplicates\n@@ -54,32 +62,34 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n             @Override\n             public void run() {\n                 for (Object src : duplicates) {\n-                    testSetWeak.add(src);\n+                    testSet.add(src);\n                 }\n             }\n         }, numberOfThreads);\n \n         // check that the control set and the test set contain the exact same elements\n-        assertEquals(distinct.size(), testSetWeak.size());\n+        assertEquals(distinct.size(), testSet.size());\n         for (Object uniqueObject : distinct) {\n-            assertTrue(testSetWeak.contains(uniqueObject));\n+            assertTrue(testSet.contains(uniqueObject));\n         }\n     }\n \n-    @Test\n+    @Test()\n     public void testIterationWithConcurrentRemoval() {\n-        final IConcurrentSet<AtomicInteger> testSetWeak = createSet();\n+        final IConcurrentSet<AtomicInteger> testSet = createSet();\n         final Random rand = new Random();\n \n         for (int i = 0; i < numberOfElements; i++) {\n-            testSetWeak.add(new AtomicInteger());\n+            AtomicInteger element = new AtomicInteger();\n+            testSet.add(element);\n+            gcProtector.add(element);\n         }\n \n         Runnable incrementer = new Runnable() {\n             @Override\n             public void run() {\n-                while(testSetWeak.size() > 100){\n-                    for(AtomicInteger element : testSetWeak)\n+                while(testSet.size() > 100){\n+                    for(AtomicInteger element : testSet)\n                         element.incrementAndGet();\n                 }\n \n@@ -89,10 +99,10 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n         Runnable remover = new Runnable() {\n             @Override\n             public void run() {\n-                while(testSetWeak.size() > 100){\n-                    for(AtomicInteger element : testSetWeak)\n-                        if(rand.nextInt() % 3 == 0)\n-                            testSetWeak.remove(element);\n+                while(testSet.size() > 100){\n+                    for(AtomicInteger element : testSet)\n+                        if(rand.nextInt() % 3 == 0 && testSet.size() > 100)\n+                            testSet.remove(element);\n                 }\n             }\n         };\n@@ -100,9 +110,13 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n         ConcurrentExecutor.runConcurrent(20, incrementer, incrementer, remover);\n \n         Set<Integer> counts = new HashSet<Integer>();\n-        for (AtomicInteger count : testSetWeak) {\n+        for (AtomicInteger count : testSet) {\n             counts.add(count.get());\n         }\n+        // all atomic integers should have been visited by the the incrementer\n+        // the same number of times\n+        // in other words: they have either been removed at some point or incremented in each\n+        // iteration such that all remaining atomic integers must share the same value\n         assertEquals(1, counts.size());\n     }\n \n@@ -113,7 +127,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n         final HashSet<Object> source = new HashSet<Object>();\n         final HashSet<Object> toRemove = new HashSet<Object>();\n \n-        final IConcurrentSet testSetWeak = createSet();\n+        final IConcurrentSet testSet = createSet();\n         // getAll set of distinct objects and mark a subset of those for removal\n         for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n@@ -128,7 +142,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n             @Override\n             public void run() {\n                 for (Object src : source) {\n-                    testSetWeak.add(src);\n+                    testSet.add(src);\n                 }\n             }\n         }, numberOfThreads);\n@@ -138,20 +152,20 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n             @Override\n             public void run() {\n                 for (Object src : toRemove) {\n-                    testSetWeak.remove(src);\n+                    testSet.remove(src);\n                 }\n             }\n         }, numberOfThreads);\n \n         // ensure that the test set does not contain any of the elements that have been removed from it\n-        for (Object tar : testSetWeak) {\n+        for (Object tar : testSet) {\n             Assert.assertTrue(!toRemove.contains(tar));\n         }\n         // ensure that the test set still contains all objects from the source set that have not been marked\n         // for removal\n-        assertEquals(source.size() - toRemove.size(), testSetWeak.size());\n+        assertEquals(source.size() - toRemove.size(), testSet.size());\n         for (Object src : source) {\n-            if (!toRemove.contains(src)) assertTrue(testSetWeak.contains(src));\n+            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n         }\n     }\n \n@@ -160,7 +174,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n         final HashSet<Object> source = new HashSet<Object>();\n         final HashSet<Object> toRemove = new HashSet<Object>();\n \n-        final IConcurrentSet testSetWeak = createSet();\n+        final IConcurrentSet testSet = createSet();\n         // getAll set of candidates and mark subset for removal\n         for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n@@ -176,35 +190,35 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n             @Override\n             public void run() {\n                 for (Object src : source) {\n-                    testSetWeak.add(src);\n+                    testSet.add(src);\n                     if (toRemove.contains(src))\n-                        testSetWeak.remove(src);\n+                        testSet.remove(src);\n                 }\n             }\n         }, numberOfThreads);\n \n         // ensure that the test set does not contain any of the elements that have been removed from it\n-        for (Object tar : testSetWeak) {\n+        for (Object tar : testSet) {\n             Assert.assertTrue(!toRemove.contains(tar));\n         }\n         // ensure that the test set still contains all objects from the source set that have not been marked\n         // for removal\n-        assertEquals(source.size() - toRemove.size(), testSetWeak.size());\n+        assertEquals(source.size() - toRemove.size(), testSet.size());\n         for (Object src : source) {\n-            if (!toRemove.contains(src)) assertTrue(testSetWeak.contains(src));\n+            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n         }\n     }\n \n     @Test\n     public void testCompleteRemoval() {\n         final HashSet<Object> source = new HashSet<Object>();\n-        final IConcurrentSet testSetWeak = createSet();\n+        final IConcurrentSet testSet = createSet();\n \n         // getAll set of candidates and mark subset for removal\n         for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n             source.add(candidate);\n-            testSetWeak.add(candidate);\n+            testSet.add(candidate);\n         }\n \n         // getAll test set by adding the candidates\n@@ -213,7 +227,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n             @Override\n             public void run() {\n                 for (Object src : source) {\n-                    testSetWeak.remove(src);\n+                    testSet.remove(src);\n                 }\n             }\n         }, numberOfThreads);\n@@ -221,9 +235,9 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n \n         // ensure that the test set still contains all objects from the source set that have not been marked\n         // for removal\n-        assertEquals(0, testSetWeak.size());\n+        assertEquals(0, testSet.size());\n         for(Object src : source){\n-            assertFalse(testSetWeak.contains(src));\n+            assertFalse(testSet.contains(src));\n         }\n     }\n \n@@ -340,5 +354,8 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n         return result;\n     }\n \n-\n+    protected void protectFromGarbageCollector(Set elements){\n+        for(Object element : elements)\n+            gcProtector.add(element);\n+    }\n }\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/DeadMessageTest.java",
            "additions": 49,
            "deletions": 5
        },
        "diff content": "@@ -1,12 +1,14 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.bus.BusConfiguration;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.common.*;\n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listeners.IMessageListener;\n import net.engio.mbassy.common.ListenerFactory;\n import net.engio.mbassy.listeners.MessagesListener;\n+import net.engio.mbassy.listeners.ObjectListener;\n+import org.junit.Before;\n import org.junit.Test;\n \n import java.util.concurrent.atomic.AtomicInteger;\n@@ -19,6 +21,11 @@ import java.util.concurrent.atomic.AtomicInteger;\n  */\n public class DeadMessageTest extends MessageBusTest{\n \n+    @Before\n+    public void beforeTest(){\n+        DeadMessagHandler.deadMessages.set(0);\n+    }\n+\n \n     @Test\n     public void testDeadMessage(){\n@@ -56,15 +63,52 @@ public class DeadMessageTest extends MessageBusTest{\n         assertEquals(InstancesPerListener * IterationsPerThread * ConcurrentUnits, DeadMessagHandler.deadMessages.get());\n     }\n \n+\n+\n+    @Test\n+    public void testUnsubscribingAllListeners() {\n+        final MBassador bus = getBus(BusConfiguration.Default());\n+        ListenerFactory deadMessageListener = new ListenerFactory()\n+                .create(InstancesPerListener, DeadMessagHandler.class)\n+                .create(InstancesPerListener, Object.class);\n+        ListenerFactory objectListener = new ListenerFactory()\n+                .create(InstancesPerListener, ObjectListener.class);\n+        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, deadMessageListener), ConcurrentUnits);\n+\n+        // Only dead message handlers available\n+        bus.post(new Object()).now();\n+\n+        // The message should be caught as dead message since there are no subscribed listeners\n+        assertEquals(InstancesPerListener, DeadMessagHandler.deadMessages.get());\n+\n+        // Clear deadmessage for future tests\n+        DeadMessagHandler.deadMessages.set(0);\n+\n+        // Add object listeners and publish again\n+        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, objectListener), ConcurrentUnits);\n+        bus.post(new Object()).now();\n+\n+        // verify that no dead message events were produced\n+        assertEquals(0, DeadMessagHandler.deadMessages.get());\n+\n+        // Unsubscribe all object listeners\n+        ConcurrentExecutor.runConcurrent(TestUtil.unsubscriber(bus, objectListener), ConcurrentUnits);\n+\n+        // Only dead message handlers available\n+        bus.post(new Object()).now();\n+\n+        // The message should be caught, as it's the only listener\n+        assertEquals(InstancesPerListener, DeadMessagHandler.deadMessages.get());\n+    }\n+\n     public static class DeadMessagHandler {\n \n         private static final AtomicInteger deadMessages = new AtomicInteger(0);\n \n-\n         @Handler\n-         public void handle(DeadMessage message){\n-             deadMessages.incrementAndGet();\n-         }\n+        public void handle(DeadMessage message){\n+            deadMessages.incrementAndGet();\n+        }\n \n     }\n \n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/FilterTest.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.bus.BusConfiguration;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.common.DeadMessage;\n import net.engio.mbassy.common.FilteredMessage;\n@@ -31,7 +31,7 @@ public class FilterTest extends MessageBusTest {\n         FilteredEventCounter.set(0);\n         DeadEventCounter.set(0);\n \n-        MBassador bus = getBus(new BusConfiguration());\n+        MBassador bus = getBus(BusConfiguration.Default());\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(100, FilteredMessageListener.class);\n \n@@ -56,7 +56,7 @@ public class FilterTest extends MessageBusTest {\n         FilteredEventCounter.set(0);\n         DeadEventCounter.set(0);\n \n-        MBassador bus = getBus(new BusConfiguration());\n+        MBassador bus = getBus(BusConfiguration.Default());\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(100, FilteredMessageListener.class);\n \n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MBassadorTest.java",
            "additions": 5,
            "deletions": 5
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.bus.BusConfiguration;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.common.*;\n import net.engio.mbassy.listeners.*;\n@@ -26,7 +26,7 @@ public class MBassadorTest extends MessageBusTest {\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, Listeners.synchronous())\n                 .create(InstancesPerListener, Listeners.noHandlers());\n-        final MBassador bus = getBus(new BusConfiguration(), listeners);\n+        final MBassador bus = getBus(BusConfiguration.Default(), listeners);\n \n \n         Runnable publishAndCheck = new Runnable() {\n@@ -60,7 +60,7 @@ public class MBassadorTest extends MessageBusTest {\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, Listeners.asynchronous())\n                 .create(InstancesPerListener, Listeners.noHandlers());\n-        final MBassador bus = getBus(new BusConfiguration(), listeners);\n+        final MBassador bus = getBus(BusConfiguration.Default(), listeners);\n \n         final MessageManager messageManager = new MessageManager();\n         Runnable publishAndCheck = new Runnable() {\n@@ -92,7 +92,7 @@ public class MBassadorTest extends MessageBusTest {\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, Listeners.asynchronous())\n                 .create(InstancesPerListener, Listeners.noHandlers());\n-        final MBassador bus = getBus(new BusConfiguration(), listeners);\n+        final MBassador bus = getBus(BusConfiguration.Default(), listeners);\n \n \n         final MessageManager messageManager = new MessageManager();\n@@ -130,7 +130,7 @@ public class MBassadorTest extends MessageBusTest {\n             }\n         };\n \n-        final MBassador bus = new MBassador(new BusConfiguration());\n+        final MBassador bus = new MBassador(BusConfiguration.Default());\n         bus.addErrorHandler(ExceptionCounter);\n         ListenerFactory listeners = new ListenerFactory()\n                 .create(InstancesPerListener, ExceptionThrowingListener.class);\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MethodDispatchTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.bus.BusConfiguration;\n import net.engio.mbassy.bus.IMessageBus;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.listener.Handler;\n import org.junit.Test;\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 11,
            "deletions": 3
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy;\n \n+import net.engio.mbassy.bus.BusRuntime;\n import net.engio.mbassy.common.*;\n import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.listeners.*;\n@@ -10,6 +11,7 @@ import net.engio.mbassy.subscription.SubscriptionManager;\n import org.junit.Test;\n \n import java.util.Collection;\n+import java.util.Collections;\n \n /**\n  *\n@@ -168,7 +170,7 @@ public class SubscriptionManagerTest extends AssertSupport {\n     @Test\n     public void testStrongListenerSubscription() throws Exception {\n         ListenerFactory listeners = listeners(CustomInvocationListener.class);\n-        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n+        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n         ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n \n         listeners.clear();\n@@ -186,7 +188,7 @@ public class SubscriptionManagerTest extends AssertSupport {\n                 Overloading.ListenerBase.class,\n                 Overloading.ListenerSub.class);\n \n-        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n+        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n         ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n \n         SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n@@ -196,6 +198,12 @@ public class SubscriptionManagerTest extends AssertSupport {\n         runTestWith(listeners, expectedSubscriptions);\n     }\n \n+    private BusRuntime mockedRuntime(){\n+        return new BusRuntime(null)\n+                .add(\"error.handlers\", Collections.EMPTY_SET)\n+                .add(\"handler.async-service\", null);\n+    }\n+\n     private ListenerFactory listeners(Class ...listeners){\n         ListenerFactory factory = new ListenerFactory();\n         for(Class listener : listeners){\n@@ -205,7 +213,7 @@ public class SubscriptionManagerTest extends AssertSupport {\n     }\n \n     private void runTestWith(final ListenerFactory listeners, final SubscriptionValidator validator){\n-        final SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n+        final SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n \n         ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n \n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 5,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,9 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.bus.*;\n+import net.engio.mbassy.bus.ISyncMessageBus;\n+import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.bus.SyncMessageBus;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.common.ConcurrentExecutor;\n import net.engio.mbassy.common.ListenerFactory;\n import net.engio.mbassy.common.MessageBusTest;\n@@ -183,7 +186,7 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n         @Override\n         protected ISyncMessageBus getSyncMessageBus() {\n-            return new SyncMessageBus(new SyncBusConfiguration());\n+            return new SyncMessageBus(BusConfiguration.Default());\n         }\n     }\n \n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.bus.BusConfiguration;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.bus.IMessageBus;\n import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.common.MessageBusTest;\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/WeakConcurrentSetTest.java",
            "additions": 6,
            "deletions": 0
        },
        "diff content": "@@ -3,10 +3,12 @@ package net.engio.mbassy;\n import net.engio.mbassy.common.ConcurrentExecutor;\n import net.engio.mbassy.common.IConcurrentSet;\n import net.engio.mbassy.common.WeakConcurrentSet;\n+import org.junit.Before;\n import org.junit.Test;\n \n import java.util.HashSet;\n import java.util.Random;\n+import java.util.Set;\n \n /**\n  *\n@@ -16,6 +18,10 @@ import java.util.Random;\n  */\n public class WeakConcurrentSetTest extends ConcurrentSetTest{\n \n+\n+\n+\n+\n     @Override\n     protected IConcurrentSet createSet() {\n         return new WeakConcurrentSet();\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/AssertSupport.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -17,7 +17,7 @@ public class AssertSupport {\n \n     private Runtime runtime = Runtime.getRuntime();\n     protected Logger logger = LoggerFactory.getLogger(getClass().getSimpleName());\n-    private long testExecutionStart;\n+    private volatile long testExecutionStart;\n \n     @Rule\n     public TestName name = new TestName();\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 2,
            "deletions": 3
        },
        "diff content": "@@ -3,8 +3,7 @@ package net.engio.mbassy.common;\n import junit.framework.Assert;\n import net.engio.mbassy.IPublicationErrorHandler;\n import net.engio.mbassy.PublicationError;\n-import net.engio.mbassy.bus.BusConfiguration;\n-import net.engio.mbassy.bus.ISyncMessageBus;\n+import net.engio.mbassy.bus.config.BusConfiguration;\n import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.messages.MessageTypes;\n import org.junit.Before;\n@@ -16,7 +15,7 @@ import org.junit.Before;\n  * @author bennidi\n  *         Date: 3/2/13\n  */\n-public abstract class MessageBusTest<Bus extends ISyncMessageBus> extends AssertSupport {\n+public abstract class MessageBusTest extends AssertSupport {\n \n     // this value probably needs to be adjusted depending on the performance of the underlying plattform\n     // otherwise the tests will fail since asynchronous processing might not have finished when\n"
    },
    {
        "commit hash": "d6aa291b8662849033a1d8ec0772babd6e3ef166",
        "previous commit hash": "8aa3fca57fae4bc24f9675268d4db84a8c0ff06b",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/TestUtil.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.common;\n \n-import net.engio.mbassy.bus.ISyncMessageBus;\n+import net.engio.mbassy.bus.PubSubSupport;\n import net.engio.mbassy.subscription.SubscriptionManager;\n \n import java.util.Iterator;\n@@ -41,7 +41,7 @@ public class TestUtil {\n         };\n     }\n \n-    public static Runnable subscriber(final ISyncMessageBus bus, final ListenerFactory listeners){\n+    public static Runnable subscriber(final PubSubSupport bus, final ListenerFactory listeners){\n         final Iterator source = listeners.iterator();\n         return new Runnable() {\n             @Override\n@@ -54,7 +54,7 @@ public class TestUtil {\n         };\n     }\n \n-    public static Runnable unsubscriber(final ISyncMessageBus bus, final ListenerFactory listeners){\n+    public static Runnable unsubscriber(final PubSubSupport bus, final ListenerFactory listeners){\n         final Iterator source = listeners.iterator();\n         return new Runnable() {\n             @Override\n@@ -67,7 +67,7 @@ public class TestUtil {\n         };\n     }\n \n-    public static void setup(final ISyncMessageBus bus, final List<Object> listeners, int numberOfThreads) {\n+    public static void setup(final PubSubSupport bus, final List<Object> listeners, int numberOfThreads) {\n         Runnable[] setupUnits = new Runnable[numberOfThreads];\n         int partitionSize;\n         if(listeners.size() >= numberOfThreads){\n"
    },
    {
        "commit hash": "e4b6a84ab8d2487fe610d294535f3f593b2f819c",
        "previous commit hash": "033d31d9144b14bb9a733514efa368723a33bb52",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java",
            "additions": 5,
            "deletions": 1
        },
        "diff content": "@@ -5,6 +5,7 @@ import net.engio.mbassy.PublicationError;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n  * The base class for all async message bus implementations.\n@@ -23,6 +24,8 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends IMessageBus.IPost\n     // all pending messages scheduled for asynchronous dispatch are queued here\n     private final BlockingQueue<MessagePublication> pendingMessages;\n \n+    private static final AtomicInteger threadID = new AtomicInteger();\n+    \n     public AbstractSyncAsyncMessageBus(BusConfiguration configuration) {\n         super(configuration);\n         this.executor = configuration.getExecutor();\n@@ -52,6 +55,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends IMessageBus.IPost\n                 }\n             });\n             dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n+            dispatcher.setName(\"MBassyDispatch-\" + threadID.incrementAndGet());\n             dispatchers.add(dispatcher);\n             dispatcher.start();\n         }\n@@ -89,7 +93,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends IMessageBus.IPost\n         for (Thread dispatcher : dispatchers) {\n             dispatcher.interrupt();\n         }\n-        executor.shutdown();\n+        if(executor != null) executor.shutdown();\n     }\n \n     public boolean hasPendingMessages() {\n"
    },
    {
        "commit hash": "65fcf85829a522f7d36cc7e3e9ee98b5b44ca8fc",
        "previous commit hash": "6e4f838d10c2d0d0259940da89da9308d814b8e9",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ReflectionUtils.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -86,7 +86,7 @@ public class ReflectionUtils {\n         }\n \n         Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n-        Class[] subClassMethodParameters = superclassMethod.getParameterTypes();\n+        Class[] subClassMethodParameters = subclassMethod.getParameterTypes();\n         // method must specify the same number of parameters\n         //the parameters must occur in the exact same order\n         for (int i = 0; i < subClassMethodParameters.length; i++) {\n"
    },
    {
        "commit hash": "65fcf85829a522f7d36cc7e3e9ee98b5b44ca8fc",
        "previous commit hash": "6e4f838d10c2d0d0259940da89da9308d814b8e9",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Listener.java",
            "additions": 2,
            "deletions": 4
        },
        "diff content": "@@ -1,9 +1,6 @@\n package net.engio.mbassy.listener;\n \n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n+import java.lang.annotation.*;\n \n /**\n  * @author bennidi\n@@ -11,6 +8,7 @@ import java.lang.annotation.Target;\n  */\n @Retention(value = RetentionPolicy.RUNTIME)\n @Target(value = {ElementType.TYPE})\n+@Inherited\n public @interface Listener {\n \n     /**\n"
    },
    {
        "commit hash": "65fcf85829a522f7d36cc7e3e9ee98b5b44ca8fc",
        "previous commit hash": "6e4f838d10c2d0d0259940da89da9308d814b8e9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 14,
            "deletions": 0
        },
        "diff content": "@@ -180,7 +180,21 @@ public class SubscriptionManagerTest extends AssertSupport {\n             assertEquals(InstancesPerListener,  sub.size());\n     }\n \n+    @Test\n+    public void testOverloadedMessageHandlers(){\n+        ListenerFactory listeners = listeners(\n+                Overloading.ListenerBase.class,\n+                Overloading.ListenerSub.class);\n+\n+        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n+        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n \n+        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n+                .listener(Overloading.ListenerBase.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class)\n+                .listener(Overloading.ListenerSub.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class, Overloading.TestMessageB.class);\n+\n+        runTestWith(listeners, expectedSubscriptions);\n+    }\n \n     private ListenerFactory listeners(Class ...listeners){\n         ListenerFactory factory = new ListenerFactory();\n"
    },
    {
        "commit hash": "65fcf85829a522f7d36cc7e3e9ee98b5b44ca8fc",
        "previous commit hash": "6e4f838d10c2d0d0259940da89da9308d814b8e9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/SubscriptionValidator.java",
            "additions": 2,
            "deletions": 11
        },
        "diff content": "@@ -15,8 +15,7 @@ public class SubscriptionValidator extends AssertSupport{\n \n     private List<ValidationEntry> validations = new LinkedList<ValidationEntry>();\n     private Set<Class> messageTypes = new HashSet<Class>();\n-    private Set<Class> subscribers = new HashSet<Class>();\n-    private ListenerFactory subscribedListener;\n+    private ListenerFactory subscribedListener; // the subscribed listeners are used to assert the size of the subscriptions\n \n     public SubscriptionValidator(ListenerFactory subscribedListener) {\n         this.subscribedListener = subscribedListener;\n@@ -29,7 +28,6 @@ public class SubscriptionValidator extends AssertSupport{\n     private SubscriptionValidator expect(Class subscriber, Class messageType){\n         validations.add(new ValidationEntry(messageType, subscriber));\n         messageTypes.add(messageType);\n-        subscribers.add(subscriber);\n         return this;\n     }\n \n@@ -73,14 +71,7 @@ public class SubscriptionValidator extends AssertSupport{\n         };\n     }\n \n-    private IPredicate<ValidationEntry> EntriesBySubscriberType(final Class subscriberType){\n-        return new IPredicate<ValidationEntry>() {\n-            @Override\n-            public boolean apply(ValidationEntry target) {\n-                return target.subscriber.equals(subscriberType);\n-            }\n-        };\n-    }\n+\n \n     public class Expectation{\n \n"
    },
    {
        "commit hash": "65fcf85829a522f7d36cc7e3e9ee98b5b44ca8fc",
        "previous commit hash": "6e4f838d10c2d0d0259940da89da9308d814b8e9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/Overloading.java",
            "additions": 49,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,49 @@\n+package net.engio.mbassy.listeners;\n+\n+import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.References;\n+import net.engio.mbassy.messages.AbstractMessage;\n+\n+/**\n+ * Created with IntelliJ IDEA.\n+ * User: benjamin\n+ * Date: 7/11/13\n+ * Time: 10:11 AM\n+ * To change this template use File | Settings | File Templates.\n+ */\n+public class Overloading {\n+\n+    public static class TestMessageA extends AbstractMessage {}\n+\n+    public static class TestMessageB extends AbstractMessage {}\n+\n+    public static class ListenerSub extends ListenerBase {\n+\n+        @Handler\n+        public void handleEvent(TestMessageB event) {\n+            event.handled(this.getClass());\n+        }\n+\n+    }\n+\n+    @Listener(references = References.Strong)\n+    public static class ListenerBase {\n+\n+\n+        /**\n+         * (!) If this method is removed, NO event handler will be called.\n+         */\n+        @Handler\n+        public void handleEventWithNonOverloadedMethodName(TestMessageA event) {\n+            event.handled(this.getClass());\n+        }\n+\n+        @Handler\n+        public void handleEvent(TestMessageA event) {\n+            event.handled(this.getClass());\n+        }\n+\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "65fcf85829a522f7d36cc7e3e9ee98b5b44ca8fc",
        "previous commit hash": "6e4f838d10c2d0d0259940da89da9308d814b8e9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/TestMessage2.java",
            "additions": 0,
            "deletions": 15
        },
        "diff content": "@@ -1,15 +0,0 @@\n-package net.engio.mbassy.messages;\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-/**\n- *\n- *\n-* @author bennidi\n-* Date: 11/22/12\n-*/\n-public class TestMessage2 {\n-\n-    public AtomicInteger counter = new AtomicInteger();\n-\n-}\n"
    },
    {
        "commit hash": "ca9f931d0d7925f2bbc37f11501f015e1a78d92f",
        "previous commit hash": "5915038acaea1d38e61b13257a56d86e196b21dc",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -143,7 +143,7 @@ Beginning with version 1.1.0 MBassador is available from the Maven Central Repos\n     <dependency>\n         <groupId>net.engio</groupId>\n         <artifactId>mbassador</artifactId>\n-        <version>1.1.6</version>\n+        <version>1.1.7</version>\n     </dependency>\n ```\n \n"
    },
    {
        "commit hash": "5915038acaea1d38e61b13257a56d86e196b21dc",
        "previous commit hash": "46cedcee46155f7394256becf0fc36a972337886",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Handler.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -6,7 +6,7 @@ import net.engio.mbassy.dispatch.ReflectiveHandlerInvocation;\n import java.lang.annotation.*;\n \n /**\n- * Mark any method of any object(=listener) as a message handler and configure the handler\n+ * Mark any method of any class(=listener) as a message handler and configure the handler\n  * using different properties.\n  *\n  * @author bennidi\n"
    },
    {
        "commit hash": "5915038acaea1d38e61b13257a56d86e196b21dc",
        "previous commit hash": "46cedcee46155f7394256becf0fc36a972337886",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -70,8 +70,8 @@ public class Subscription {\n     public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n         @Override\n         public int compare(Subscription o1, Subscription o2) {\n-            int result = o1.getPriority() - o2.getPriority();\n-            return result == 0 ? o1.id.compareTo(o2.id) : result;\n+            int byPriority = ((Integer)o1.getPriority()).compareTo(o2.getPriority());\n+            return byPriority == 0 ? o1.id.compareTo(o2.id) : byPriority;\n         }\n     };\n \n"
    },
    {
        "commit hash": "5915038acaea1d38e61b13257a56d86e196b21dc",
        "previous commit hash": "46cedcee46155f7394256becf0fc36a972337886",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 7,
            "deletions": 1
        },
        "diff content": "@@ -12,6 +12,11 @@ import org.junit.Test;\n import java.util.Collection;\n \n /**\n+ *\n+ * Test the subscriptions as generated and organized by the subscription manager. Tests use different sets of listeners\n+ * and corresponding expected set of subscriptions that should result from subscribing the listeners. The subscriptions\n+ * are tested for the type of messages they should handle and\n+ *\n  * @author bennidi\n  *         Date: 5/12/13\n  */\n@@ -166,7 +171,6 @@ public class SubscriptionManagerTest extends AssertSupport {\n         SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n         ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n \n-\n         listeners.clear();\n         runGC();\n \n@@ -177,6 +181,7 @@ public class SubscriptionManagerTest extends AssertSupport {\n     }\n \n \n+\n     private ListenerFactory listeners(Class ...listeners){\n         ListenerFactory factory = new ListenerFactory();\n         for(Class listener : listeners){\n@@ -203,4 +208,5 @@ public class SubscriptionManagerTest extends AssertSupport {\n \n \n \n+\n }\n"
    },
    {
        "commit hash": "5915038acaea1d38e61b13257a56d86e196b21dc",
        "previous commit hash": "46cedcee46155f7394256becf0fc36a972337886",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 74,
            "deletions": 1
        },
        "diff content": "@@ -5,10 +5,15 @@ import net.engio.mbassy.common.ConcurrentExecutor;\n import net.engio.mbassy.common.ListenerFactory;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.common.TestUtil;\n-import net.engio.mbassy.listeners.*;\n+import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listeners.CustomInvocationListener;\n+import net.engio.mbassy.listeners.ExceptionThrowingListener;\n+import net.engio.mbassy.listeners.IMessageListener;\n+import net.engio.mbassy.listeners.MessagesListener;\n import net.engio.mbassy.messages.MessageTypes;\n import net.engio.mbassy.messages.MultipartMessage;\n import net.engio.mbassy.messages.StandardMessage;\n+import org.junit.Assert;\n import org.junit.Test;\n \n import java.util.concurrent.atomic.AtomicInteger;\n@@ -67,6 +72,7 @@ public abstract class SyncBusTest extends MessageBusTest {\n     }\n \n \n+\n     @Test\n     public void testExceptionInHandlerInvocation(){\n         final AtomicInteger exceptionCount = new AtomicInteger(0);\n@@ -135,6 +141,32 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n     }\n \n+    @Test\n+    public void testHandlerPriorities(){\n+        final ISyncMessageBus bus = getSyncMessageBus();\n+        ListenerFactory listeners = new ListenerFactory()\n+                .create(InstancesPerListener, PrioritizedListener.class)\n+                .create(InstancesPerListener, Object.class);\n+\n+        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n+\n+        Runnable publishAndCheck = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                bus.post(new IncrementingMessage()).now();\n+\n+            }\n+        };\n+\n+        // single threaded\n+        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n+\n+        // multi threaded\n+        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n+\n+    }\n+\n \n     public static class MBassadorTest extends SyncBusTest {\n \n@@ -155,4 +187,45 @@ public abstract class SyncBusTest extends MessageBusTest {\n         }\n     }\n \n+\n+\n+    static class IncrementingMessage{\n+\n+        private int count = 1;\n+\n+        public void markHandled(int newVal){\n+            // only transitions by the next handler are allowed\n+            if(count == newVal || count + 1 == newVal) count = newVal;\n+            else Assert.fail(\"Message was handled out of order\");\n+        }\n+    }\n+\n+\n+    public static class PrioritizedListener{\n+\n+        @Handler(priority = Integer.MIN_VALUE)\n+        public void handle1(IncrementingMessage message) {\n+            message.markHandled(1);\n+        }\n+\n+        @Handler(priority = -2)\n+        public void handle2(IncrementingMessage message) {\n+            message.markHandled(2);\n+        }\n+\n+        @Handler\n+        public void handle3(IncrementingMessage message) {\n+            message.markHandled(3);\n+        }\n+\n+        @Handler(priority = Integer.MAX_VALUE)\n+        public void handle4(IncrementingMessage message) {\n+            message.markHandled(4);\n+        }\n+\n+\n+    }\n+\n+\n+\n }\n"
    },
    {
        "commit hash": "5915038acaea1d38e61b13257a56d86e196b21dc",
        "previous commit hash": "46cedcee46155f7394256becf0fc36a972337886",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/SubscriptionValidator.java",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -6,7 +6,6 @@ import net.engio.mbassy.subscription.SubscriptionManager;\n import java.util.*;\n \n /**\n-* Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 5/25/13\n"
    },
    {
        "commit hash": "46cedcee46155f7394256becf0fc36a972337886",
        "previous commit hash": "7bfc426a678fa9523dba098f81d9d7d94e8f44de",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java",
            "additions": 5,
            "deletions": 3
        },
        "diff content": "@@ -101,7 +101,7 @@ public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n                 } else {\n                     ISetEntry<T> oldHead = head;\n                     head = head.next();\n-                    oldHead.clear(); // optimize for GC\n+                    //oldHead.clear(); // optimize for GC not possible because of potentially running iterators\n                 }\n                 entries.remove(element);\n             } finally {\n@@ -137,8 +137,10 @@ public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n             } else if (next != null) {\n                 next.predecessor = null;\n             }\n-            next = null;\n-            predecessor = null;\n+            // can not nullify references to help GC since running iterators might not see the entire set\n+            // if this element is their current element\n+            //next = null;\n+            //predecessor = null;\n         }\n \n         @Override\n"
    },
    {
        "commit hash": "46cedcee46155f7394256becf0fc36a972337886",
        "previous commit hash": "7bfc426a678fa9523dba098f81d9d7d94e8f44de",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConcurrentSetTest.java",
            "additions": 46,
            "deletions": 3
        },
        "diff content": "@@ -8,6 +8,7 @@ import org.junit.Test;\n \n import java.util.*;\n import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n  * This test ensures the correct behaviour of the set implementation that is the building\n@@ -65,6 +66,47 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n         }\n     }\n \n+    @Test\n+    public void testIterationWithConcurrentRemoval() {\n+        final IConcurrentSet<AtomicInteger> testSetWeak = createSet();\n+        final Random rand = new Random();\n+\n+        for (int i = 0; i < numberOfElements; i++) {\n+            testSetWeak.add(new AtomicInteger());\n+        }\n+\n+        Runnable incrementer = new Runnable() {\n+            @Override\n+            public void run() {\n+                while(testSetWeak.size() > 100){\n+                    for(AtomicInteger element : testSetWeak)\n+                        element.incrementAndGet();\n+                }\n+\n+            }\n+        };\n+\n+        Runnable remover = new Runnable() {\n+            @Override\n+            public void run() {\n+                while(testSetWeak.size() > 100){\n+                    for(AtomicInteger element : testSetWeak)\n+                        if(rand.nextInt() % 3 == 0)\n+                            testSetWeak.remove(element);\n+                }\n+            }\n+        };\n+\n+        ConcurrentExecutor.runConcurrent(20, incrementer, incrementer, remover);\n+\n+        Set<Integer> counts = new HashSet<Integer>();\n+        for (AtomicInteger count : testSetWeak) {\n+            counts.add(count.get());\n+        }\n+        assertEquals(1, counts.size());\n+    }\n+\n+\n \n     @Test\n     public void testRandomRemoval() {\n@@ -248,7 +290,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n \n         // Adds and removes items\n         // thus forcing constant rehashing of the backing hashtable\n-        Runnable updatingThread = new Runnable() {\n+        Runnable rehasher = new Runnable() {\n             public void run() {\n                 Random rand = new Random();\n                 for(int times = 0; times < 1000 ; times++){\n@@ -266,7 +308,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n             };\n         };\n \n-        Runnable lookupThread = new Runnable() {\n+        Runnable lookup = new Runnable() {\n             @Override\n             public void run() {\n                 for (int i = 0; i < 10000; i++) {\n@@ -280,7 +322,7 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n             }\n         };\n \n-        ConcurrentExecutor.runConcurrent(updatingThread, lookupThread, lookupThread, lookupThread);\n+        ConcurrentExecutor.runConcurrent(rehasher, lookup, lookup, lookup);\n         assertTrue(\"There where items temporarily unavailable: \" + missing.size(), missing.size() == 0);\n \n     }\n@@ -298,4 +340,5 @@ public abstract class ConcurrentSetTest extends AssertSupport {\n         return result;\n     }\n \n+\n }\n"
    },
    {
        "commit hash": "46cedcee46155f7394256becf0fc36a972337886",
        "previous commit hash": "7bfc426a678fa9523dba098f81d9d7d94e8f44de",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/ConcurrentExecutor.java",
            "additions": 13,
            "deletions": 2
        },
        "diff content": "@@ -23,10 +23,21 @@ public class ConcurrentExecutor {\n \t\t\tunits[i] = unit;\n \t\t}\n \t\trunConcurrent(units);\n-\n \t}\n \n-\tpublic static void runConcurrent(final Runnable... units) {\n+\n+    public static void runConcurrent(int numberOfConcurrentExecutions, final Runnable... units) {\n+        Runnable[] runnables = new Runnable[numberOfConcurrentExecutions * units.length];\n+        // create the tasks and schedule for execution\n+        for (int i = 0; i < numberOfConcurrentExecutions; i++) {\n+            for(int k = 0; k < units.length; k++)\n+                runnables[k * numberOfConcurrentExecutions +i] = units[k];\n+        }\n+        runConcurrent(runnables);\n+    }\n+\n+\n+    public static void runConcurrent(final Runnable... units) {\n \t\tExecutorService executor = Executors.newCachedThreadPool();\n \t\tList<Future<Long>> returnValues = new ArrayList<Future<Long>>();\n \n"
    },
    {
        "commit hash": "7bfc426a678fa9523dba098f81d9d7d94e8f44de",
        "previous commit hash": "1ecf5ebef807c0c3d0194a8630369b1f824a994b",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 14,
            "deletions": 0
        },
        "diff content": "@@ -67,6 +67,20 @@\n             <scope>test</scope>\n         </dependency>\n \n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>slf4j-api</artifactId>\n+            <version>1.7.5</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>slf4j-log4j12</artifactId>\n+            <version>1.7.5</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n     </dependencies>\n \n     <!--  Local repository (for testing)\n"
    },
    {
        "commit hash": "7bfc426a678fa9523dba098f81d9d7d94e8f44de",
        "previous commit hash": "1ecf5ebef807c0c3d0194a8630369b1f824a994b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MessagePublication.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -31,7 +31,7 @@ public class MessagePublication {\n \n     private Object message;\n \n-    private State state = State.Scheduled;\n+    private State state = State.Initial;\n \n     private boolean delivered = false;\n \n"
    },
    {
        "commit hash": "7bfc426a678fa9523dba098f81d9d7d94e8f44de",
        "previous commit hash": "1ecf5ebef807c0c3d0194a8630369b1f824a994b",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/AssertSupport.java",
            "additions": 27,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,12 @@\n package net.engio.mbassy.common;\n \n+import org.junit.After;\n import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TestName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import java.lang.ref.WeakReference;\n \n@@ -9,8 +15,25 @@ import java.lang.ref.WeakReference;\n  */\n public class AssertSupport {\n \n-    // Internal state\n     private Runtime runtime = Runtime.getRuntime();\n+    protected Logger logger = LoggerFactory.getLogger(getClass().getSimpleName());\n+    private long testExecutionStart;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+\n+    @Before\n+    public void beforeTest(){\n+        logger.info(\"Running test \" + getTestName());\n+        testExecutionStart = System.currentTimeMillis();\n+    }\n+\n+    @After\n+    public void afterTest(){\n+        logger.info(String.format(\"Finished \" + getTestName() + \": \" + (System.currentTimeMillis() - testExecutionStart) + \" ms\"));\n+    }\n+\n \n     public void pause(long ms) {\n         try {\n@@ -24,6 +47,9 @@ public class AssertSupport {\n         pause(10);\n     }\n \n+    public String getTestName(){\n+        return getClass().getSimpleName() + \".\" + name.getMethodName();\n+    }\n \n     public void runGC() {\n         WeakReference ref = new WeakReference<Object>(new Object());\n"
    },
    {
        "commit hash": "7bfc426a678fa9523dba098f81d9d7d94e8f44de",
        "previous commit hash": "1ecf5ebef807c0c3d0194a8630369b1f824a994b",
        "diff stats": {
            "file_path": "src/test/resources/log4j.xml",
            "additions": 32,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,32 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n+<!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\">\n+\n+<log4j:configuration xmlns:log4j=\"http://jakarta.apache.org/log4j/\">\n+\n+\t<appender name=\"console\" class=\"org.apache.log4j.ConsoleAppender\">\n+\t\t<layout class=\"org.apache.log4j.PatternLayout\">\n+\t\t\t<param name=\"ConversionPattern\" value=\"%d{HH:mm:ss,SSS} %-5p - %m%n\"/>\n+\t\t</layout>\n+\t</appender>\n+\n+\t<category name=\"org.springframework\" additivity=\"false\">\n+\t\t<priority value=\"info\"/>\n+\t\t<appender-ref ref=\"console\"/>\n+\t</category>\n+\n+\t<category name=\"de.safetynet\" additivity=\"false\">\n+\t\t<priority value=\"info\"/>\n+\t\t<appender-ref ref=\"console\"/>\n+\t</category>\n+\n+\t<category name=\"de.safetynet.tracking\" additivity=\"false\">\n+\t\t<priority value=\"debug\"/>\n+\t\t<appender-ref ref=\"console\"/>\n+\t</category>\n+\n+\t<root>\n+\t\t<priority value =\"info\" />\n+\t\t<appender-ref ref=\"console\"/>\n+\t</root>\n+\n+</log4j:configuration>\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "1ecf5ebef807c0c3d0194a8630369b1f824a994b",
        "previous commit hash": "40109de6ee20c24ddf98e4c9ceed1375d213dffc",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MBassadorTest.java",
            "additions": 49,
            "deletions": 51
        },
        "diff content": "@@ -2,13 +2,8 @@ package net.engio.mbassy;\n \n import net.engio.mbassy.bus.BusConfiguration;\n import net.engio.mbassy.bus.MBassador;\n-import net.engio.mbassy.common.ConcurrentExecutor;\n-import net.engio.mbassy.common.MessageBusTest;\n-import net.engio.mbassy.common.TestUtil;\n-import net.engio.mbassy.listeners.ExceptionThrowingListener;\n-import net.engio.mbassy.listeners.IMessageListener;\n-import net.engio.mbassy.common.ListenerFactory;\n-import net.engio.mbassy.listeners.MessagesListener;\n+import net.engio.mbassy.common.*;\n+import net.engio.mbassy.listeners.*;\n import net.engio.mbassy.messages.MessageTypes;\n import net.engio.mbassy.messages.MultipartMessage;\n import net.engio.mbassy.messages.StandardMessage;\n@@ -26,21 +21,14 @@ public class MBassadorTest extends MessageBusTest {\n \n \n     @Test\n-    public void testSynchronousMessagePublication() throws Exception {\n+    public void testSyncPublicationSyncHandlers() throws Exception {\n \n-        final MBassador bus = getBus(new BusConfiguration());\n         ListenerFactory listeners = new ListenerFactory()\n-                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n-                .create(InstancesPerListener, IMessageListener.AsyncListener.class)\n-                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n-                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n-                .create(InstancesPerListener, MessagesListener.AsyncListener.class)\n-                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n-                .create(InstancesPerListener, Object.class);\n+                .create(InstancesPerListener, Listeners.synchronous())\n+                .create(InstancesPerListener, Listeners.noHandlers());\n+        final MBassador bus = getBus(new BusConfiguration(), listeners);\n \n \n-        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n-\n         Runnable publishAndCheck = new Runnable() {\n             @Override\n             public void run() {\n@@ -51,74 +39,84 @@ public class MBassadorTest extends MessageBusTest {\n                 bus.post(multipartMessage).now();\n                 bus.post(MessageTypes.Simple).now();\n \n-                pause(processingTimeInMS);\n-\n                 assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n-                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.AsyncListener.class));\n-\n                 assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n-                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.AsyncListener.class));\n-\n-\n             }\n         };\n \n+        // test single-threaded\n         ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n \n+        // test multi-threaded\n         MessageTypes.resetAll();\n         ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n         assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n-        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.AsyncListener.class));\n         assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n-        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.AsyncListener.class));\n+    }\n+\n+\n+    @Test\n+    public void testSyncPublicationAsyncHandlers() throws Exception {\n+        ListenerFactory listeners = new ListenerFactory()\n+                .create(InstancesPerListener, Listeners.asynchronous())\n+                .create(InstancesPerListener, Listeners.noHandlers());\n+        final MBassador bus = getBus(new BusConfiguration(), listeners);\n+\n+        final MessageManager messageManager = new MessageManager();\n+        Runnable publishAndCheck = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, Listeners.join(Listeners.asynchronous(), Listeners.handlesStandardMessage()));\n+                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);\n+\n+                bus.post(standardMessage).now();\n+                bus.post(multipartMessage).now();\n+                bus.post(MessageTypes.Simple).now();\n+\n+            }\n+        };\n+\n+        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n+        messageManager.waitForMessages(processingTimeInMS);\n+\n+        MessageTypes.resetAll();\n+        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesListener.AsyncListener.class);\n+        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n+        messageManager.waitForMessages(processingTimeInMS);\n     }\n \n     @Test\n     public void testAsynchronousMessagePublication() throws Exception {\n \n-        final MBassador bus = getBus(new BusConfiguration());\n         ListenerFactory listeners = new ListenerFactory()\n-                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n-                .create(InstancesPerListener, IMessageListener.AsyncListener.class)\n-                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n-                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n-                .create(InstancesPerListener, MessagesListener.AsyncListener.class)\n-                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n-                .create(InstancesPerListener, Object.class);\n+                .create(InstancesPerListener, Listeners.asynchronous())\n+                .create(InstancesPerListener, Listeners.noHandlers());\n+        final MBassador bus = getBus(new BusConfiguration(), listeners);\n \n \n-        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n+        final MessageManager messageManager = new MessageManager();\n \n         Runnable publishAndCheck = new Runnable() {\n             @Override\n             public void run() {\n-                StandardMessage standardMessage = new StandardMessage();\n-                MultipartMessage multipartMessage = new MultipartMessage();\n+                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n+                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n \n                 bus.post(standardMessage).asynchronously();\n                 bus.post(multipartMessage).asynchronously();\n                 bus.post(MessageTypes.Simple).asynchronously();\n \n-                pause(processingTimeInMS);\n-\n-                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n-                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.AsyncListener.class));\n-\n-                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n-                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.AsyncListener.class));\n-\n-\n             }\n         };\n \n         ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n+        messageManager.waitForMessages(processingTimeInMS);\n \n         MessageTypes.resetAll();\n         ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n-        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n-        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.AsyncListener.class));\n-        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n-        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.AsyncListener.class));\n+        messageManager.waitForMessages(processingTimeInMS);\n+\n     }\n \n \n"
    },
    {
        "commit hash": "1ecf5ebef807c0c3d0194a8630369b1f824a994b",
        "previous commit hash": "40109de6ee20c24ddf98e4c9ceed1375d213dffc",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/ListenerFactory.java",
            "additions": 12,
            "deletions": 0
        },
        "diff content": "@@ -30,6 +30,18 @@ public class ListenerFactory {\n         return this;\n     }\n \n+    public ListenerFactory create(int numberOfInstances, Class[] classes){\n+        for(Class clazz : classes)\n+            create(numberOfInstances,clazz);\n+        return this;\n+    }\n+\n+    public ListenerFactory create(int numberOfInstances, Collection<Class> classes){\n+        for(Class clazz : classes)\n+            create(numberOfInstances,clazz);\n+        return this;\n+    }\n+\n \n     public synchronized List<Object> getAll(){\n         if(generatedListeners != null)\n"
    },
    {
        "commit hash": "1ecf5ebef807c0c3d0194a8630369b1f824a994b",
        "previous commit hash": "40109de6ee20c24ddf98e4c9ceed1375d213dffc",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 7,
            "deletions": 0
        },
        "diff content": "@@ -46,4 +46,11 @@ public abstract class MessageBusTest<Bus extends ISyncMessageBus> extends Assert\n         return bus;\n     }\n \n+    public MBassador getBus(BusConfiguration configuration, ListenerFactory listeners) {\n+        MBassador bus = new MBassador(configuration);\n+        bus.addErrorHandler(TestFailingHandler);\n+        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n+        return bus;\n+    }\n+\n }\n"
    },
    {
        "commit hash": "1ecf5ebef807c0c3d0194a8630369b1f824a994b",
        "previous commit hash": "40109de6ee20c24ddf98e4c9ceed1375d213dffc",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageManager.java",
            "additions": 156,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,156 @@\n+package net.engio.mbassy.common;\n+\n+import net.engio.mbassy.messages.IMessage;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Created with IntelliJ IDEA.\n+ * User: benjamin\n+ * Date: 6/26/13\n+ * Time: 12:23 PM\n+ * To change this template use File | Settings | File Templates.\n+ */\n+public class MessageManager {\n+\n+\n+    private StrongConcurrentSet<MessageContext> messages = new StrongConcurrentSet();\n+\n+\n+    public <T extends IMessage> T create(Class<T> messageType, int expectedCount, Class ...listeners){\n+        T message;\n+        try {\n+            message = messageType.newInstance();\n+            register(message, expectedCount, listeners);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        return message;\n+    }\n+\n+    public <T extends IMessage> T create(Class<T> messageType, int expectedCount, Collection<Class> listeners){\n+        T message;\n+        try {\n+            message = messageType.newInstance();\n+            register(message, expectedCount, listeners);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        return message;\n+    }\n+\n+    public <T extends IMessage> void register(T message, int expectedCount, Class ...listeners){\n+        try {\n+            messages.add(new MessageContext(expectedCount, message, listeners));\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public <T extends IMessage> void register(T message, int expectedCount, Collection<Class> listeners){\n+        try {\n+            messages.add(new MessageContext(expectedCount, message, listeners));\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public void waitForMessages(int timeoutInMs){\n+        long start = System.currentTimeMillis();\n+        while(System.currentTimeMillis() - start < timeoutInMs && messages.size() > 0){\n+            // check each created message once\n+            for(MessageContext messageCtx : messages){\n+                boolean handledCompletely = true;\n+                for(Class listener : messageCtx.getListeners()){\n+                    handledCompletely &= messageCtx.getMessage().getTimesHandled(listener) == messageCtx.getExpectedCount();\n+                }\n+                // remove the ones that were handled as expected\n+                if(handledCompletely){\n+                    logSuccess(messageCtx);\n+                    messages.remove(messageCtx);\n+                }\n+\n+            }\n+            pause(100);\n+        }\n+        if(messages.size() > 0){\n+            logFailingMessages(messages);\n+            throw new RuntimeException(\"Message were not fully processed in given time\");\n+        }\n+\n+\n+    }\n+\n+    private void pause(long ms) {\n+        try {\n+            Thread.sleep(ms);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+   private void logSuccess(MessageContext mCtx){\n+       System.out.println(\"Message \" + mCtx.getMessage() + \" was successfully handled \" + mCtx.getExpectedCount() + \" times by \" + mCtx.printListeners());\n+   }\n+\n+\n+\n+    private void logFailingMessages(StrongConcurrentSet<MessageContext> failing){\n+        StringBuilder errorMessage = new StringBuilder();\n+        errorMessage.append(\"Failing messages:\\n\");\n+        for(MessageContext failingMessage : failing)\n+            errorMessage.append(failingMessage);\n+        System.out.println(errorMessage.toString());\n+    }\n+\n+    private class MessageContext{\n+\n+        private long expectedCount;\n+        private IMessage message;\n+        private Class[] listeners;\n+\n+        private MessageContext(long expectedCount, IMessage message, Class[] listeners) {\n+            this.expectedCount = expectedCount;\n+            this.message = message;\n+            this.listeners = listeners;\n+        }\n+\n+        private MessageContext(long expectedCount, IMessage message, Collection<Class> listeners) {\n+            this.expectedCount = expectedCount;\n+            this.message = message;\n+            this.listeners = listeners.toArray(new Class[]{});\n+        }\n+\n+        private long getExpectedCount() {\n+            return expectedCount;\n+        }\n+\n+        private IMessage getMessage() {\n+            return message;\n+        }\n+\n+        private Class[] getListeners() {\n+            return listeners;\n+        }\n+\n+        private String printListeners(){\n+            StringBuilder listenersAsString = new StringBuilder();\n+            for(Class listener : listeners){\n+                listenersAsString.append(listener.getName());\n+                listenersAsString.append(\",\");\n+            }\n+            return listenersAsString.toString();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            // TODO: actual count of listeners\n+            return message.getClass().getSimpleName() + \"{\" +\n+                    \"expectedCount=\" + expectedCount +\n+                    \", listeners=\" + printListeners() +\n+                    '}';\n+        }\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "1ecf5ebef807c0c3d0194a8630369b1f824a994b",
        "previous commit hash": "40109de6ee20c24ddf98e4c9ceed1375d213dffc",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/Listeners.java",
            "additions": 112,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,112 @@\n+package net.engio.mbassy.listeners;\n+\n+import java.util.*;\n+\n+/**\n+ * Created with IntelliJ IDEA.\n+ * User: benjamin\n+ * Date: 6/26/13\n+ * Time: 11:48 AM\n+ * To change this template use File | Settings | File Templates.\n+ */\n+public class Listeners {\n+\n+    private static final List<Class> Synchronous = Collections.unmodifiableList(Arrays.asList(new Class[]{\n+            MessagesListener.DefaultListener.class,\n+            IMessageListener.DefaultListener.class,\n+            StandardMessageListener.DefaultListener.class,\n+            MultipartMessageListener.DefaultListener.class,\n+            ICountableListener.DefaultListener.class,\n+            IMultipartMessageListener.DefaultListener.class}));\n+\n+    private static final List<Class> Asynchronous = Collections.unmodifiableList(Arrays.asList(new Class[]{\n+            MessagesListener.AsyncListener.class,\n+            IMessageListener.AsyncListener.class,\n+            StandardMessageListener.AsyncListener.class,\n+            MultipartMessageListener.AsyncListener.class,\n+            ICountableListener.AsyncListener.class,\n+            IMultipartMessageListener.AsyncListener.class}));\n+\n+    private static final List<Class> SubtypeRejecting = Collections.unmodifiableList(Arrays.asList(new Class[]{\n+            MessagesListener.NoSubtypesListener.class,\n+            IMessageListener.NoSubtypesListener.class,\n+            StandardMessageListener.NoSubtypesListener.class,\n+            MultipartMessageListener.NoSubtypesListener.class,\n+            ICountableListener.NoSubtypesListener.class,\n+            IMultipartMessageListener.NoSubtypesListener.class}));\n+\n+    private static final List<Class> NoHandlers = Collections.unmodifiableList(Arrays.asList(new Class[]{\n+            MessagesListener.DisabledListener.class,\n+            IMessageListener.DisabledListener.class,\n+            StandardMessageListener.DisabledListener.class,\n+            MultipartMessageListener.DisabledListener.class,\n+            ICountableListener.DisabledListener.class,\n+            IMultipartMessageListener.DisabledListener.class,\n+            Object.class,String.class}));\n+\n+\n+    private static final List<Class> HandlesIMessage = Collections.unmodifiableList(Arrays.asList(new Class[]{\n+            IMessageListener.DefaultListener.class,\n+            IMessageListener.AsyncListener.class,\n+            IMessageListener.NoSubtypesListener.class,\n+            IMultipartMessageListener.DefaultListener.class,\n+            IMultipartMessageListener.AsyncListener.class,\n+            IMultipartMessageListener.NoSubtypesListener.class,\n+            MessagesListener.DefaultListener.class,\n+            MessagesListener.AsyncListener.class,\n+            MessagesListener.NoSubtypesListener.class,\n+            StandardMessageListener.DefaultListener.class,\n+            StandardMessageListener.AsyncListener.class,\n+            StandardMessageListener.NoSubtypesListener.class,\n+            MultipartMessageListener.DefaultListener.class,\n+            MultipartMessageListener.AsyncListener.class,\n+            MultipartMessageListener.NoSubtypesListener.class}));\n+\n+    private static final List<Class> HandlesStandardessage = Collections.unmodifiableList(Arrays.asList(new Class[]{\n+            IMessageListener.DefaultListener.class,\n+            IMessageListener.AsyncListener.class,\n+            ICountableListener.DefaultListener.class,\n+            ICountableListener.AsyncListener.class,\n+            StandardMessageListener.DefaultListener.class,\n+            StandardMessageListener.AsyncListener.class,\n+            StandardMessageListener.NoSubtypesListener.class}));\n+\n+\n+    public static Collection<Class> synchronous(){\n+        return Synchronous;\n+    }\n+\n+    public static Collection<Class> asynchronous(){\n+        return Asynchronous;\n+    }\n+\n+    public static Collection<Class> subtypeRejecting(){\n+        return SubtypeRejecting;\n+    }\n+\n+    public static Collection<Class> noHandlers(){\n+        return NoHandlers;\n+    }\n+\n+    public static Collection<Class> handlesIMessage(){\n+        return HandlesIMessage;\n+    }\n+\n+    public static Collection<Class> handlesStandardMessage(){\n+        return HandlesStandardessage;\n+    }\n+\n+\n+    public static Collection<Class> join(Collection<Class>...listenerSets){\n+        Set<Class> join = new HashSet<Class>();\n+        for(Collection<Class> listeners : listenerSets)\n+            join.addAll(listeners);\n+        for(Collection<Class> listeners : listenerSets)\n+            join.retainAll(listeners);\n+        return join;\n+    }\n+\n+\n+\n+\n+}\n"
    },
    {
        "commit hash": "1ecf5ebef807c0c3d0194a8630369b1f824a994b",
        "previous commit hash": "40109de6ee20c24ddf98e4c9ceed1375d213dffc",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/MessageTypes.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -24,8 +24,8 @@ public enum MessageTypes implements IMessage{\n \n     @Override\n     public void reset() {\n-        lock.writeLock().lock();\n         try {\n+            lock.writeLock().lock();\n             handledByListener.clear();\n         }finally {\n             lock.writeLock().unlock();\n@@ -34,8 +34,8 @@ public enum MessageTypes implements IMessage{\n \n     @Override\n     public void handled(Class listener) {\n-        lock.writeLock().lock();\n         try {\n+            lock.writeLock().lock();\n             Integer count = handledByListener.get(listener);\n             if(count == null){\n                 handledByListener.put(listener, 1);\n@@ -50,8 +50,8 @@ public enum MessageTypes implements IMessage{\n \n     @Override\n     public int getTimesHandled(Class listener) {\n-        lock.readLock().lock();\n         try {\n+            lock.readLock().lock();\n             return handledByListener.containsKey(listener)\n                     ? handledByListener.get(listener)\n                     : 0;\n"
    },
    {
        "commit hash": "5c2fc81e7af7b18b2077a87e9d9abdb6916373ee",
        "previous commit hash": "3a6814ac5c74a60ca662f9985f0f936d25521035",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/ListenerFactory.java",
            "additions": 18,
            "deletions": 9
        },
        "diff content": "@@ -1,5 +1,7 @@\n package net.engio.mbassy.common;\n \n+import junit.framework.Assert;\n+\n import java.util.*;\n import java.util.concurrent.atomic.AtomicInteger;\n \n@@ -15,7 +17,7 @@ import java.util.concurrent.atomic.AtomicInteger;\n public class ListenerFactory {\n \n     private Map<Class, Integer> requiredBeans = new HashMap<Class, Integer>();\n-    private List generatedListeners;\n+    private volatile List generatedListeners;\n     private int requiredSize = 0;\n \n     public int getNumberOfListeners(Class listener){\n@@ -29,35 +31,42 @@ public class ListenerFactory {\n     }\n \n \n-    public List<Object> getAll(){\n-        generatedListeners = new ArrayList(requiredSize);\n+    public synchronized List<Object> getAll(){\n+        if(generatedListeners != null)\n+            return generatedListeners;\n+        List listeners = new ArrayList(requiredSize);\n         try {\n             for(Class clazz : requiredBeans.keySet()){\n                 int numberOfRequiredBeans = requiredBeans.get(clazz);\n                 for(int i = 0; i < numberOfRequiredBeans; i++){\n-                    generatedListeners.add(clazz.newInstance());\n+                    listeners.add(clazz.newInstance());\n                 }\n             }\n         } catch (Exception e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(e);\n+            // if instantiation fails, counts will be incorrect\n+            // -> fail early here\n+            Assert.fail(\"There was a problem instantiating a listener \" + e);\n         }\n-        Collections.shuffle(generatedListeners);\n+        Collections.shuffle(listeners);\n+        generatedListeners  = Collections.unmodifiableList(listeners);\n         return generatedListeners;\n     }\n \n     // not thread-safe but not yet used concurrently\n-    public void clear(){\n+    public synchronized  void clear(){\n         generatedListeners = null;\n         requiredBeans.clear();\n     }\n \n     /**\n      * Create a thread-safe read-only iterator\n+     *\n+     * NOTE: Iterator is not perfectly synchronized with mutator methods of the list of generated listeners\n+     * In theory, it is possible that the list is changed while iterators are still running which should be avoided.\n      * @return\n      */\n     public Iterator iterator(){\n-        if(generatedListeners == null)getAll();\n+        getAll();\n         final AtomicInteger current = new AtomicInteger(0);\n \n         return new Iterator() {\n"
    },
    {
        "commit hash": "033d31d9144b14bb9a733514efa368723a33bb52",
        "previous commit hash": "3a6814ac5c74a60ca662f9985f0f936d25521035",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/PublicationError.java",
            "additions": 6,
            "deletions": 5
        },
        "diff content": "@@ -109,16 +109,17 @@ public class PublicationError {\n      */\n     @Override\n     public String toString() {\n+    \tString newLine = System.getProperty(\"line.separator\");\n         return \"PublicationError{\" +\n-                \"\\n\" +\n+                newLine +\n                 \"\\tcause=\" + cause +\n-                \"\\n\" +\n+                newLine +\n                 \"\\tmessage='\" + message + '\\'' +\n-                \"\\n\" +\n+                newLine +\n                 \"\\tlistener=\" + listener +\n-                \"\\n\" +\n+                newLine +\n                 \"\\tlisteningObject=\" + listeningObject +\n-                \"\\n\" +\n+                newLine +\n                 \"\\tpublishedObject=\" + publishedObject +\n                 '}';\n     }\n"
    },
    {
        "commit hash": "3a6814ac5c74a60ca662f9985f0f936d25521035",
        "previous commit hash": "e021af4ace8b30092fb714105690f594ca042c6f",
        "diff stats": {
            "file_path": "README.md",
            "additions": 10,
            "deletions": 4
        },
        "diff content": "@@ -2,14 +2,20 @@ MBassador\n =========\n \n MBassador is a very light-weight message (event) bus implementation following the publish subscribe pattern. It is designed\n-for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. It uses a specialized\n-data structure to allow high throughput for concurrent access.\n+for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. The core of MBassador's\n+high performance is a specialized data structure that minimizes lock contention such that performance degradation of concurrent access is minimal.\n+The performance win of this design is illustrated in <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>.\n+The benchmarking code can be found <a href=\"https://github.com/bennidi/eventbus-performance\" target=\"_blank\">here</a>\n \n-Read this documentation to get an overview of its features. You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n-which also contains a partial list of the features of the compared implementations.\n+Read this documentation to get an overview of MBassadors features. There is also some documentation in the Wiki - although admittedly\n+not enough to make a developer happy (work is in progress). But usage of publish subscribe pattern at its core is pretty straight forward and the basic\n+use cases are very easy to understand and implement.\n \n The current version is 1.1.7 and it is available from the Maven Central Repository. See the release notes for more details.\n \n+There is also an extension available to support CDI-like transactional message sending in a Spring environment. It's beta but\n+stable enough to give it a try. See <a href=\"https://github.com/bennidi/mbassador-spring\" target=\"_blank\">here</a>.\n+\n Table of contents:\n + [Features](#features)\n + [Usage](#usage)\n"
    },
    {
        "commit hash": "41309cca1c63026813ec8c4d53e594b252960660",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/StrongConcurrentSet.java",
            "additions": 1,
            "deletions": 4
        },
        "diff content": "@@ -5,10 +5,7 @@ import java.util.HashMap;\n import java.util.Iterator;\n \n /**\n- * This implementation uses weak references to the elements. Iterators automatically perform cleanups of\n- * garbage collected objects during iteration -> no dedicated maintenance operations need to be called or run in background.\n- * <p/>\n- * <p/>\n+ * This implementation uses strong references to the elements.\n  * <p/>\n  *\n  * @author bennidi\n"
    },
    {
        "commit hash": "41309cca1c63026813ec8c4d53e594b252960660",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n import net.engio.mbassy.bus.MessagePublication;\n-import net.engio.mbassy.common.IConcurrentSet;\n import net.engio.mbassy.subscription.MessageEnvelope;\n \n /**\n@@ -21,7 +20,7 @@ public class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher {\n     }\n \n     @Override\n-    public void dispatch(MessagePublication publication, Object message, IConcurrentSet listeners) {\n+    public void dispatch(MessagePublication publication, Object message, Iterable listeners) {\n         getDelegate().dispatch(publication, new MessageEnvelope(message), listeners);\n     }\n }\n"
    },
    {
        "commit hash": "41309cca1c63026813ec8c4d53e594b252960660",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n import net.engio.mbassy.bus.MessagePublication;\n-import net.engio.mbassy.common.IConcurrentSet;\n import net.engio.mbassy.listener.IMessageFilter;\n \n /**\n@@ -37,7 +36,7 @@ public class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n \n \n     @Override\n-    public void dispatch(MessagePublication publication, Object message, IConcurrentSet listeners) {\n+    public void dispatch(MessagePublication publication, Object message, Iterable listeners) {\n         if (passesFilter(message)) {\n             getDelegate().dispatch(publication, message, listeners);\n         }\n"
    },
    {
        "commit hash": "41309cca1c63026813ec8c4d53e594b252960660",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n import net.engio.mbassy.bus.MessagePublication;\n-import net.engio.mbassy.common.IConcurrentSet;\n \n /**\n  * A message dispatcher provides the functionality to deliver a single message\n@@ -29,7 +28,7 @@ public interface IMessageDispatcher extends ISubscriptionContextAware {\n      * @param message     The message that should be delivered to the listeners\n      * @param listeners   The listeners that should receive the message\n      */\n-    void dispatch(MessagePublication publication, Object message, IConcurrentSet listeners);\n+    void dispatch(MessagePublication publication, Object message, Iterable listeners);\n \n     /**\n      * Get the handler invocation that will be used to deliver the\n"
    },
    {
        "commit hash": "41309cca1c63026813ec8c4d53e594b252960660",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n import net.engio.mbassy.bus.MessagePublication;\n-import net.engio.mbassy.common.IConcurrentSet;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n import net.engio.mbassy.subscription.SubscriptionContext;\n \n@@ -25,7 +24,7 @@ public class MessageDispatcher extends AbstractSubscriptionContextAware implemen\n     }\n \n     @Override\n-    public void dispatch(final MessagePublication publication, final Object message, final IConcurrentSet listeners) {\n+    public void dispatch(final MessagePublication publication, final Object message, final Iterable listeners) {\n         publication.markDelivered();\n         for (Object listener : listeners) {\n             getInvocation().invoke(listener, message);\n"
    },
    {
        "commit hash": "41309cca1c63026813ec8c4d53e594b252960660",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 2,
            "deletions": 0
        },
        "diff content": "@@ -75,4 +75,6 @@ public class Subscription {\n         }\n     };\n \n+\n+\n }\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 4,
            "deletions": 0
        },
        "diff content": "@@ -148,6 +148,10 @@\n                 <artifactId>maven-surefire-plugin</artifactId>\n                 <configuration>\n                     <skipTests>false</skipTests>\n+                    <excludes>\n+                        <!-- exclude the suite which is a convenience class for running all tests from IDE or using scripts -->\n+                        <exclude>AllTests.java</exclude>\n+                    </excludes>\n                 </configuration>\n             </plugin>\n \n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AllTests.java",
            "additions": 1,
            "deletions": 3
        },
        "diff content": "@@ -1,6 +1,5 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.bus.ListenerSubscriptionTest;\n import org.junit.runner.RunWith;\n import org.junit.runners.Suite;\n \n@@ -19,9 +18,8 @@ import org.junit.runners.Suite;\n         SyncBusTest.SyncMessageBusTest.class,\n         FilterTest.class,\n         MetadataReaderTest.class,\n-        ListenerSubscriptionTest.class,\n         MethodDispatchTest.class,\n-        DeadEventTest.class,\n+        DeadMessageTest.class,\n         SynchronizedHandlerTest.class,\n         SubscriptionManagerTest.class\n })\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/DeadEventTest.java",
            "additions": 0,
            "deletions": 50
        },
        "diff content": "@@ -1,50 +0,0 @@\n-package net.engio.mbassy;\n-\n-import net.engio.mbassy.bus.BusConfiguration;\n-import net.engio.mbassy.bus.MBassador;\n-import net.engio.mbassy.common.WeakConcurrentSet;\n-import net.engio.mbassy.common.DeadMessage;\n-import net.engio.mbassy.common.MessageBusTest;\n-import net.engio.mbassy.listener.Handler;\n-import org.junit.Test;\n-\n-/**\n- * Verify correct behaviour in case of message publications that do not have any matching subscriptions\n- *\n- * @author bennidi\n- *         Date: 1/18/13\n- */\n-public class DeadEventTest extends MessageBusTest{\n-\n-\n-    @Test\n-    public void testDeadEvent(){\n-        MBassador bus = getBus(BusConfiguration.Default());\n-        DeadEventHandler deadEventHandler = new DeadEventHandler();\n-        bus.subscribe(deadEventHandler);\n-        assertEquals(0, deadEventHandler.getDeadEventCount());\n-        bus.post(new Object()).now();\n-        assertEquals(1, deadEventHandler.getDeadEventCount());\n-        bus.post(323).now();\n-        assertEquals(2, deadEventHandler.getDeadEventCount());\n-        bus.publish(\"fkdfdk\");\n-        assertEquals(3, deadEventHandler.getDeadEventCount());\n-    }\n-\n-    public class DeadEventHandler{\n-\n-         private WeakConcurrentSet deadEvents = new WeakConcurrentSet();\n-\n-        @Handler\n-         public void handle(DeadMessage message){\n-             deadEvents.add(message);\n-         }\n-\n-\n-        public int getDeadEventCount(){\n-            return deadEvents.size();\n-        }\n-\n-    }\n-\n-}\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/DeadMessageTest.java",
            "additions": 71,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,71 @@\n+package net.engio.mbassy;\n+\n+import net.engio.mbassy.bus.BusConfiguration;\n+import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.common.*;\n+import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listeners.IMessageListener;\n+import net.engio.mbassy.common.ListenerFactory;\n+import net.engio.mbassy.listeners.MessagesListener;\n+import org.junit.Test;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Verify correct behaviour in case of message publications that do not have any matching subscriptions\n+ *\n+ * @author bennidi\n+ *         Date: 1/18/13\n+ */\n+public class DeadMessageTest extends MessageBusTest{\n+\n+\n+    @Test\n+    public void testDeadMessage(){\n+        final MBassador bus = getBus(BusConfiguration.Default());\n+        ListenerFactory listeners = new ListenerFactory()\n+                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n+                .create(InstancesPerListener, IMessageListener.AsyncListener.class)\n+                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n+                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n+                .create(InstancesPerListener, MessagesListener.AsyncListener.class)\n+                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n+                .create(InstancesPerListener, DeadMessagHandler.class)\n+                .create(InstancesPerListener, Object.class);\n+\n+\n+        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n+\n+        Runnable publishUnhandledMessage = new Runnable() {\n+            @Override\n+            public void run() {\n+                for(int i=0; i < IterationsPerThread; i++){\n+                    int variation = i % 3;\n+                    switch (variation){\n+                        case 0:bus.publish(new Object());break;\n+                        case 1:bus.publish(i);break;\n+                        case 2:bus.publish(String.valueOf(i));break;\n+                    }\n+                }\n+\n+            }\n+        };\n+\n+        ConcurrentExecutor.runConcurrent(publishUnhandledMessage, ConcurrentUnits);\n+\n+        assertEquals(InstancesPerListener * IterationsPerThread * ConcurrentUnits, DeadMessagHandler.deadMessages.get());\n+    }\n+\n+    public static class DeadMessagHandler {\n+\n+        private static final AtomicInteger deadMessages = new AtomicInteger(0);\n+\n+\n+        @Handler\n+         public void handle(DeadMessage message){\n+             deadMessages.incrementAndGet();\n+         }\n+\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/FilterTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@ import net.engio.mbassy.common.TestUtil;\n import net.engio.mbassy.messages.SubTestMessage;\n import net.engio.mbassy.messages.TestMessage;\n import net.engio.mbassy.listener.*;\n-import net.engio.mbassy.listeners.ListenerFactory;\n+import net.engio.mbassy.common.ListenerFactory;\n import org.junit.Test;\n \n import java.util.List;\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MBassadorTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -7,7 +7,7 @@ import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.common.TestUtil;\n import net.engio.mbassy.listeners.ExceptionThrowingListener;\n import net.engio.mbassy.listeners.IMessageListener;\n-import net.engio.mbassy.listeners.ListenerFactory;\n+import net.engio.mbassy.common.ListenerFactory;\n import net.engio.mbassy.listeners.MessagesListener;\n import net.engio.mbassy.messages.MessageTypes;\n import net.engio.mbassy.messages.MultipartMessage;\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 1,
            "deletions": 4
        },
        "diff content": "@@ -1,9 +1,6 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.common.AssertSupport;\n-import net.engio.mbassy.common.ConcurrentExecutor;\n-import net.engio.mbassy.common.SubscriptionValidator;\n-import net.engio.mbassy.common.TestUtil;\n+import net.engio.mbassy.common.*;\n import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.listeners.*;\n import net.engio.mbassy.messages.*;\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -2,6 +2,7 @@ package net.engio.mbassy;\n \n import net.engio.mbassy.bus.*;\n import net.engio.mbassy.common.ConcurrentExecutor;\n+import net.engio.mbassy.common.ListenerFactory;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.common.TestUtil;\n import net.engio.mbassy.listeners.*;\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/bus/ListenerSubscriptionTest.java",
            "additions": 0,
            "deletions": 108
        },
        "diff content": "@@ -1,108 +0,0 @@\n-package net.engio.mbassy.bus;\n-\n-import net.engio.mbassy.common.MessageBusTest;\n-import net.engio.mbassy.common.TestUtil;\n-import net.engio.mbassy.messages.SubTestMessage;\n-import net.engio.mbassy.messages.TestMessage;\n-import net.engio.mbassy.listeners.EventingTestBean;\n-import net.engio.mbassy.listeners.EventingTestBean2;\n-import net.engio.mbassy.listeners.EventingTestBean3;\n-import net.engio.mbassy.listeners.ListenerFactory;\n-import net.engio.mbassy.listeners.NonListeningBean;\n-import net.engio.mbassy.subscription.Subscription;\n-import org.junit.Test;\n-\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-/**\n- * Testing different scenarios of subscribing objects (listeners and non-listeners) to the message bus.\n- *\n- * @author bennidi\n- *         Date: 1/9/13\n- */\n-public class ListenerSubscriptionTest extends MessageBusTest{\n-\n-\n-    // this is a single threaded test for subscribing and unsubscribing of a single listener\n-    @Test\n-    public void testSubscribeSimple() throws InterruptedException {\n-        MBassador bus = getBus(new BusConfiguration());\n-        List<Object> listeners = new LinkedList<Object>();\n-        int listenerCount = 200000;\n-\n-        // subscribe a number of listeners to the bus\n-        for (int i = 1; i <= listenerCount; i++) {\n-            EventingTestBean listener = new EventingTestBean();\n-            NonListeningBean nonListener = new NonListeningBean();\n-            listeners.add(listener);\n-\n-            bus.subscribe(listener);\n-            bus.subscribe(nonListener);\n-\n-            assertFalse(bus.unsubscribe(nonListener)); // these are not expected to be subscribed listeners\n-            assertFalse(bus.unsubscribe(new EventingTestBean()));\n-\n-        }\n-\n-        // check the generated subscriptions for existence of all previously subscribed valid listeners\n-        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n-        assertEquals(1, testEventsubscriptions.size());\n-        assertEquals(listenerCount, getNumberOfSubscribedListeners(testEventsubscriptions));\n-\n-        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n-        assertEquals(3, subTestEventsubscriptions.size());\n-        assertEquals(3 * listenerCount, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n-\n-        // unsubscribe the listeners\n-        for(Object listener : listeners){\n-            assertTrue(bus.unsubscribe(listener)); // this listener is expected to exist\n-        }\n-\n-        // no listener should be left\n-        testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n-        assertEquals(1, testEventsubscriptions.size());\n-        assertEquals(0, getNumberOfSubscribedListeners(testEventsubscriptions));\n-\n-        subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n-        assertEquals(3, subTestEventsubscriptions.size());\n-        assertEquals(0, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n-\n-    }\n-\n-    private int getNumberOfSubscribedListeners(Collection<Subscription> subscriptions) {\n-        int listeners = 0;\n-        for (Subscription sub : subscriptions) {\n-            listeners += sub.size();\n-        }\n-        return listeners;\n-    }\n-\n-    @Test\n-    public void testConcurrentSubscription() throws Exception {\n-\n-        MBassador bus = getBus(new BusConfiguration());\n-        ListenerFactory listenerFactory = new ListenerFactory()\n-                .create(10000, EventingTestBean.class)\n-                .create(10000, EventingTestBean2.class)\n-                .create(10000, EventingTestBean3.class)\n-                .create(10000, Object.class)\n-                .create(10000, NonListeningBean.class);\n-\n-        List<Object> listeners = listenerFactory.getAll();\n-\n-        // this will subscribe the listeners concurrently to the bus\n-        TestUtil.setup(bus, listeners, 10);\n-\n-        // check the generated subscriptions for existence of all previously subscribed valid listeners\n-        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n-        assertEquals(3, testEventsubscriptions.size());\n-        assertEquals(30000, getNumberOfSubscribedListeners(testEventsubscriptions));\n-\n-        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n-        assertEquals(10, subTestEventsubscriptions.size());\n-        assertEquals(100000, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n-\n-    }\n-}\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/ListenerFactory.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package net.engio.mbassy.listeners;\n+package net.engio.mbassy.common;\n \n import java.util.*;\n import java.util.concurrent.atomic.AtomicInteger;\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -24,6 +24,7 @@ public abstract class MessageBusTest<Bus extends ISyncMessageBus> extends Assert\n     protected static final int processingTimeInMS = 6000;\n     protected static final int InstancesPerListener = 5000;\n     protected static final int ConcurrentUnits = 10;\n+    protected static final int IterationsPerThread = 100;\n \n     protected static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n         @Override\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/SubscriptionValidator.java",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,5 @@\n package net.engio.mbassy.common;\n \n-import net.engio.mbassy.listeners.ListenerFactory;\n import net.engio.mbassy.subscription.Subscription;\n import net.engio.mbassy.subscription.SubscriptionManager;\n \n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/TestUtil.java",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1,7 +1,6 @@\n package net.engio.mbassy.common;\n \n import net.engio.mbassy.bus.ISyncMessageBus;\n-import net.engio.mbassy.listeners.ListenerFactory;\n import net.engio.mbassy.subscription.SubscriptionManager;\n \n import java.util.Iterator;\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean.java",
            "additions": 0,
            "deletions": 51
        },
        "diff content": "@@ -1,51 +0,0 @@\n-package net.engio.mbassy.listeners;\n-\n-import net.engio.mbassy.dispatch.HandlerInvocation;\n-import net.engio.mbassy.messages.SubTestMessage;\n-import net.engio.mbassy.messages.TestMessage;\n-import net.engio.mbassy.listener.*;\n-import net.engio.mbassy.subscription.SubscriptionContext;\n-\n-/**\n- * Basic bean that defines some event handlers to be used for different unit testting scenarios\n- *\n- * @author bennidi\n- * Date: 11/22/12\n- */\n-public class EventingTestBean {\n-\n-    // every event of type TestEvent or any subtype will be delivered\n-    // to this listener\n-    @Handler\n-    public void handleTestEvent(TestMessage message) {\n-        message.counter.incrementAndGet();\n-    }\n-\n-    // this handler will be invoked asynchronously\n-    @Handler(priority = 0, delivery = Invoke.Asynchronously, invocation = HandleSubTestEventInvocation.class)\n-    public void handleSubTestEvent(SubTestMessage message) {\n-        message.counter.incrementAndGet();\n-    }\n-\n-    // this handler will receive events of type SubTestEvent\n-    // or any subtabe and that passes the given filter\n-    @Handler(\n-            priority = 10,\n-            delivery = Invoke.Synchronously,\n-            filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n-    public void handleFiltered(SubTestMessage message) {\n-        message.counter.incrementAndGet();\n-    }\n-\n-    public static class HandleSubTestEventInvocation extends HandlerInvocation<EventingTestBean, SubTestMessage> {\n-\n-        public HandleSubTestEventInvocation(SubscriptionContext context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public void invoke(EventingTestBean listener, SubTestMessage message) {\n-            listener.handleSubTestEvent(message);\n-        }\n-    }\n-}\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java",
            "additions": 0,
            "deletions": 22
        },
        "diff content": "@@ -1,22 +0,0 @@\n-package net.engio.mbassy.listeners;\n-\n-import net.engio.mbassy.messages.SubTestMessage;\n-import net.engio.mbassy.listener.Handler;\n-import net.engio.mbassy.listener.Invoke;\n-import net.engio.mbassy.listener.Listener;\n-import net.engio.mbassy.listener.References;\n-\n-/**\n- * @author bennidi\n- * Date: 11/22/12\n- */\n-@Listener(references = References.Strong)\n-public class EventingTestBean2 extends EventingTestBean{\n-\n-    // redefine the configuration for this handler\n-    @Handler(delivery = Invoke.Synchronously)\n-    public void handleSubTestEvent(SubTestMessage message) {\n-        super.handleSubTestEvent(message);\n-    }\n-\n-}\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java",
            "additions": 0,
            "deletions": 23
        },
        "diff content": "@@ -1,23 +0,0 @@\n-package net.engio.mbassy.listeners;\n-\n-import net.engio.mbassy.messages.SubTestMessage;\n-import net.engio.mbassy.listener.Handler;\n-import net.engio.mbassy.listener.Invoke;\n-import net.engio.mbassy.listener.Listener;\n-import net.engio.mbassy.listener.References;\n-\n-/**\n- * @author bennidi\n- * Date: 11/22/12\n- */\n-@Listener(references = References.Strong)\n-public class EventingTestBean3 extends EventingTestBean2{\n-\n-\n-    // this handler will be invoked asynchronously\n-    @Handler(priority = 0, delivery = Invoke.Synchronously)\n-    public void handleSubTestEventAgain(SubTestMessage message) {\n-        message.counter.incrementAndGet();\n-    }\n-\n-}\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java",
            "additions": 0,
            "deletions": 44
        },
        "diff content": "@@ -1,44 +0,0 @@\n-package net.engio.mbassy.listeners;\n-\n-import net.engio.mbassy.messages.TestMessage;\n-import net.engio.mbassy.messages.TestMessage2;\n-import net.engio.mbassy.listener.*;\n-import net.engio.mbassy.listener.Invoke;\n-import net.engio.mbassy.subscription.MessageEnvelope;\n-\n-/**\n- * Todo: Add javadoc\n- *\n- * @author bennidi\n- *         Date: 12/12/12\n- */\n-public class MultiEventHandler {\n-\n-\n-    @Handler(delivery = Invoke.Synchronously)\n-    @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n-    public void handleEvents(MessageEnvelope envelope) {\n-        if(TestMessage.class.isAssignableFrom(envelope.getMessage().getClass())){\n-            TestMessage message = envelope.getMessage();\n-            message.counter.incrementAndGet();\n-        }\n-        if(envelope.getMessage().getClass().equals(TestMessage2.class)){\n-            TestMessage2 message = envelope.getMessage();\n-            message.counter.incrementAndGet();\n-        }\n-    }\n-\n-    @Handler(delivery = Invoke.Synchronously, filters = @Filter(Filters.RejectSubtypes.class))\n-    @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n-    public void handleSuperTypeEvents(MessageEnvelope envelope) {\n-        if(TestMessage.class.isAssignableFrom(envelope.getMessage().getClass())){\n-            TestMessage message = envelope.getMessage();\n-            message.counter.incrementAndGet();\n-        }\n-        if(envelope.getMessage().getClass().equals(TestMessage2.class)){\n-            TestMessage2 message = envelope.getMessage();\n-            message.counter.incrementAndGet();\n-        }\n-    }\n-\n-}\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/NonListeningBean.java",
            "additions": 0,
            "deletions": 34
        },
        "diff content": "@@ -1,34 +0,0 @@\n-package net.engio.mbassy.listeners;\n-\n-import net.engio.mbassy.messages.SubTestMessage;\n-import net.engio.mbassy.messages.TestMessage;\n-import net.engio.mbassy.listener.Handler;\n-\n-/**\n- * This bean overrides all the handlers defined in its superclass. Since it does not specify any annotations\n- * it should not be considered a message listener\n- *\n- * @author bennidi\n- * Date: 11/22/12\n- */\n-public class NonListeningBean extends EventingTestBean{\n-\n-\n-    @Override\n-    @Handler(enabled = false)\n-    public void handleTestEvent(TestMessage message) {\n-        message.counter.incrementAndGet();   // should never be called\n-    }\n-\n-    @Override\n-    @Handler(enabled = false)\n-    public void handleSubTestEvent(SubTestMessage message) {\n-        message.counter.incrementAndGet();   // should never be called\n-    }\n-\n-    @Override\n-    @Handler(enabled = false)\n-    public void handleFiltered(SubTestMessage message) {\n-        message.counter.incrementAndGet();   // should never be called\n-    }\n-}\n"
    },
    {
        "commit hash": "b25b9dae2cf1b7e0c9a1b5d83c5923d8542adf33",
        "previous commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/ObjectListener.java",
            "additions": 20,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,20 @@\n+package net.engio.mbassy.listeners;\n+\n+import net.engio.mbassy.common.DeadMessage;\n+import net.engio.mbassy.listener.Handler;\n+\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+public class ObjectListener {\n+\n+    private List handledMessages = Collections.synchronizedList(new LinkedList());\n+\n+    @Handler\n+    public void handle(Object message){\n+        handledMessages.add(message);\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "b7c580432619aa4de9e43c0990173325e786fb24",
        "previous commit hash": "247a0686f087a91df024c08b332ff5f568b47e33",
        "diff stats": {
            "file_path": "README.md",
            "additions": 10,
            "deletions": 1
        },
        "diff content": "@@ -8,7 +8,7 @@ data structure to allow high throughput for concurrent access.\n Read this documentation to get an overview of its features. You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n which also contains a partial list of the features of the compared implementations.\n \n-The current version is 1.1.6 and it is available from the Maven Central Repository. See the release notes for more details.\n+The current version is 1.1.7 and it is available from the Maven Central Repository. See the release notes for more details.\n \n Table of contents:\n + [Features](#features)\n@@ -151,6 +151,15 @@ to avoid confusion and misunderstanding.\n \n <h2>Release Notes</h2>\n \n+<h3>1.1.7</h3>\n+\n+ + Console Logger not added to message bus instances by default -> use addErrorHandler(IPublicationErrorHandler.ConsoleLogger)\n+ + Fixed race conditions in subscription and of WeakConcurrentSet.contains()\n+ + Improved message hierarchy handling: Now interfaces, enums , (abstract) classes all work in all combinations\n+ + Prevented dispatcher threads from dying on exceptions\n+ + Improved test-infrastructure and increased test-coverage\n+ + Thanks for your feedback!\n+\n <h3>1.1.6</h3>\n \n  + Added support for choosing between strong and weak references using the new @Listener annotation. @Listener can be\n"
    },
    {
        "commit hash": "247a0686f087a91df024c08b332ff5f568b47e33",
        "previous commit hash": "72c0f60a5061fa713a755304a4255bf82645fdfd",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.7</version>\n+    <version>1.1.8-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.7</tag>\n+        <tag>mbassador-1.1.4</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "72c0f60a5061fa713a755304a4255bf82645fdfd",
        "previous commit hash": "cc58fa6ff76a0d800ac17ddd4efbcbba24f11c0c",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.7-SNAPSHOT</version>\n+    <version>1.1.7</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.4</tag>\n+        <tag>mbassador-1.1.7</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java",
            "additions": 5,
            "deletions": 1
        },
        "diff content": "@@ -1,5 +1,7 @@\n package net.engio.mbassy.bus;\n \n+import net.engio.mbassy.PublicationError;\n+\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.*;\n@@ -43,6 +45,8 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends IMessageBus.IPost\n                         } catch (InterruptedException e) {\n                             Thread.currentThread().interrupt();\n                             return;\n+                        } catch(Throwable t){\n+                            handlePublicationError(new PublicationError(t, \"Error in asynchronous dispatch\", null, null, null));\n                         }\n                     }\n                 }\n@@ -64,7 +68,7 @@ public abstract class AbstractSyncAsyncMessageBus<T, P extends IMessageBus.IPost\n         }\n     }\n \n-    // this method enqueues a message delivery request\n+    // this method queues a message delivery request\n     protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit) {\n         try {\n             return pendingMessages.offer(request, timeout, unit)\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -34,7 +34,6 @@ public abstract class AbstractSyncMessageBus<T, P extends ISyncMessageBus.ISyncP\n         this.subscriptionManager = new SubscriptionManager(configuration.getMetadataReader(),\n                 configuration.getSubscriptionFactory().setBus(this));\n         this.publicationFactory = configuration.getMessagePublicationFactory();\n-        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n     }\n \n     protected MessagePublication.Factory getPublicationFactory() {\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/ISyncMessageBus.java",
            "additions": 2,
            "deletions": 24
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.bus;\n \n import net.engio.mbassy.IPublicationErrorHandler;\n+import net.engio.mbassy.PubSubSupport;\n \n import java.util.Collection;\n \n@@ -10,32 +11,9 @@ import java.util.Collection;\n  * @author bennidi\n  *         Date: 3/29/13\n  */\n-public interface ISyncMessageBus<T, P extends ISyncMessageBus.ISyncPostCommand> {\n+public interface ISyncMessageBus<T, P extends ISyncMessageBus.ISyncPostCommand> extends PubSubSupport<T>{\n \n \n-    /**\n-     * Subscribe all listeners of the given message to receive message publications.\n-     * Any message may only be subscribed once (subsequent subscriptions of an already subscribed\n-     * message will be silently ignored)\n-     *\n-     * @param listener\n-     */\n-    void subscribe(Object listener);\n-\n-    /**\n-     * Immediately remove all registered message handlers (if any) of the given listener. When this call returns all handlers\n-     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n-     * publications that have been published when the message listener was still subscribed).\n-     * <p/>\n-     * A call to this method passing null, an already unsubscribed listener or any object that does not define any message\n-     * handlers will not have any effect and is silently ignored.\n-     *\n-     * @param listener\n-     * @return true, if the listener was found and successfully removed\n-     *         false otherwise\n-     */\n-    boolean unsubscribe(Object listener);\n-\n     /**\n      * @param message\n      * @return\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/PostCommand.java",
            "additions": 9,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,9 @@\n+package net.engio.mbassy.bus;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 5/25/13\n+ */\n+public interface PostCommand {\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ReflectionUtils.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -53,8 +53,8 @@ public class ReflectionUtils {\n         collectInterfaces(from, superclasses);\n         while (!from.equals(Object.class) && !from.isInterface()) {\n             superclasses.add(from.getSuperclass());\n-\n             from = from.getSuperclass();\n+            collectInterfaces(from, superclasses);\n         }\n         return superclasses;\n     }\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java",
            "additions": 12,
            "deletions": 3
        },
        "diff content": "@@ -8,6 +8,7 @@ import net.engio.mbassy.dispatch.*;\n import net.engio.mbassy.listener.MessageHandlerMetadata;\n \n import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Modifier;\n \n /**\n@@ -58,12 +59,20 @@ public class SubscriptionFactory {\n         return dispatcher;\n     }\n \n-    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws Exception {\n+    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws MessageBusException {\n         Class<? extends HandlerInvocation> invocation = context.getHandlerMetadata().getHandlerInvocation();\n         if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){\n             throw new MessageBusException(\"The handler invocation must be top level class or nested STATIC inner class\");\n         }\n-        Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);\n-        return constructor.newInstance(context);\n+        try {\n+            Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);\n+            return constructor.newInstance(context);\n+        } catch (NoSuchMethodException e) {\n+            throw new MessageBusException(\"The provided handler invocation did not specify the necessary constructor \"\n+                    + invocation.getSimpleName() + \"(SubscriptionContext);\", e);\n+        } catch (Exception e) {\n+            throw new MessageBusException(\"Could not instantiate the provided handler invocation \"\n+                    + invocation.getSimpleName(), e);\n+        }\n     }\n }\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AllTests.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -14,7 +14,7 @@ import org.junit.runners.Suite;\n @Suite.SuiteClasses({\n         StrongConcurrentSetTest.class,\n         WeakConcurrentSetTest.class,\n-        AsynchronousMessageBusTest.class,\n+        MBassadorTest.class,\n         SyncBusTest.MBassadorTest.class,\n         SyncBusTest.SyncMessageBusTest.class,\n         FilterTest.class,\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AsynchronousMessageBusTest.java",
            "additions": 0,
            "deletions": 113
        },
        "diff content": "@@ -1,113 +0,0 @@\n-package net.engio.mbassy;\n-\n-import net.engio.mbassy.bus.BusConfiguration;\n-import net.engio.mbassy.bus.MBassador;\n-import net.engio.mbassy.common.ConcurrentExecutor;\n-import net.engio.mbassy.common.MessageBusTest;\n-import net.engio.mbassy.common.TestUtil;\n-import net.engio.mbassy.messages.SubTestMessage;\n-import net.engio.mbassy.messages.TestMessage;\n-import net.engio.mbassy.messages.TestMessage2;\n-import net.engio.mbassy.listeners.*;\n-import org.junit.Test;\n-\n-import java.util.List;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-\n-/**\n- * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n- *\n- * @author bennidi\n- *         Date: 2/8/12\n- */\n-public class AsynchronousMessageBusTest extends MessageBusTest {\n-\n-    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n-    // otherwise the tests will fail since asynchronous processing might not have finished when\n-    // evaluation is run\n-    private int processingTimeInMS = 4000;\n-\n-\n-    @Test\n-    public void testAsynchronousMessagePublication() throws Exception {\n-\n-        MBassador bus = getBus(new BusConfiguration());\n-        ListenerFactory listenerFactory = new ListenerFactory()\n-                .create(10000, EventingTestBean.class)\n-                .create(10000, EventingTestBean2.class)\n-                .create(10000, EventingTestBean3.class)\n-                .create(10000, Object.class)\n-                .create(10000, NonListeningBean.class)\n-                .create(10000, MultiEventHandler.class);\n-\n-        List<Object> listeners = listenerFactory.build();\n-\n-        // this will subscribe the listeners concurrently to the bus\n-        TestUtil.setup(bus, listeners, 10);\n-\n-        TestMessage message = new TestMessage();\n-        TestMessage subMessage = new SubTestMessage();\n-        TestMessage2 message2 = new TestMessage2();\n-\n-        bus.publishAsync(message);\n-        bus.publishAsync(subMessage);\n-        bus.publishAsync(message2);\n-\n-        pause(processingTimeInMS);\n-\n-        assertEquals(50000, message.counter.get());\n-        assertEquals(80000, subMessage.counter.get());\n-        assertEquals(20000, message2.counter.get());\n-\n-    }\n-\n-\n-    @Test\n-    public void testConcurrentMixedMessagePublication() throws Exception {\n-        final CopyOnWriteArrayList<TestMessage> testMessages = new CopyOnWriteArrayList<TestMessage>();\n-        final CopyOnWriteArrayList<SubTestMessage> subtestMessages = new CopyOnWriteArrayList<SubTestMessage>();\n-        final int eventLoopsPerTHread = 100;\n-\n-\n-        final MBassador bus = getBus(new BusConfiguration());\n-        ListenerFactory listenerFactory = new ListenerFactory()\n-                .create(10000, EventingTestBean.class)\n-                .create(10000, EventingTestBean2.class)\n-                .create(10000, EventingTestBean3.class)\n-                .create(10000, Object.class)\n-                .create(10000, NonListeningBean.class);\n-\n-        List<Object> listeners = listenerFactory.build();\n-\n-        // this will subscribe the listeners concurrently to the bus\n-        TestUtil.setup(bus, listeners, 10);\n-\n-        ConcurrentExecutor.runConcurrent(new Runnable() {\n-            @Override\n-            public void run() {\n-                for (int i = 0; i < eventLoopsPerTHread; i++) {\n-                    TestMessage message = new TestMessage();\n-                    SubTestMessage subMessage = new SubTestMessage();\n-                    testMessages.add(message);\n-                    subtestMessages.add(subMessage);\n-\n-                    bus.publishAsync(message);\n-                    bus.publish(subMessage);\n-                }\n-            }\n-        }, 10);\n-\n-        pause(processingTimeInMS);\n-\n-        for (TestMessage message : testMessages) {\n-            assertEquals(30000, message.counter.get());\n-        }\n-\n-        for (SubTestMessage message : subtestMessages) {\n-            assertEquals(70000, message.counter.get());\n-        }\n-\n-    }\n-\n-\n-}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConcurrentSetTest.java",
            "additions": 11,
            "deletions": 11
        },
        "diff content": "@@ -1,9 +1,9 @@\n package net.engio.mbassy;\n \n import junit.framework.Assert;\n+import net.engio.mbassy.common.AssertSupport;\n import net.engio.mbassy.common.ConcurrentExecutor;\n import net.engio.mbassy.common.IConcurrentSet;\n-import net.engio.mbassy.common.UnitTest;\n import org.junit.Test;\n \n import java.util.*;\n@@ -20,7 +20,7 @@ import java.util.concurrent.CopyOnWriteArraySet;\n  * @author bennidi\n  *         Date: 11/12/12\n  */\n-public abstract class ConcurrentSetTest extends UnitTest {\n+public abstract class ConcurrentSetTest extends AssertSupport {\n \n     // Shared state\n     protected final int numberOfElements = 100000;\n@@ -38,7 +38,7 @@ public abstract class ConcurrentSetTest extends UnitTest {\n         final IConcurrentSet testSetWeak = createSet();\n         Random rand = new Random();\n \n-        // build set of distinct objects and list of duplicates\n+        // getAll set of distinct objects and list of duplicates\n         Object candidate = new Object();\n         for (int i = 0; i < numberOfElements; i++) {\n             if (rand.nextInt() % 3 == 0) {\n@@ -72,7 +72,7 @@ public abstract class ConcurrentSetTest extends UnitTest {\n         final HashSet<Object> toRemove = new HashSet<Object>();\n \n         final IConcurrentSet testSetWeak = createSet();\n-        // build set of distinct objects and mark a subset of those for removal\n+        // getAll set of distinct objects and mark a subset of those for removal\n         for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n             source.add(candidate);\n@@ -81,7 +81,7 @@ public abstract class ConcurrentSetTest extends UnitTest {\n             }\n         }\n \n-        // build the test set from the set of candidates\n+        // getAll the test set from the set of candidates\n         ConcurrentExecutor.runConcurrent(new Runnable() {\n             @Override\n             public void run() {\n@@ -119,7 +119,7 @@ public abstract class ConcurrentSetTest extends UnitTest {\n         final HashSet<Object> toRemove = new HashSet<Object>();\n \n         final IConcurrentSet testSetWeak = createSet();\n-        // build set of candidates and mark subset for removal\n+        // getAll set of candidates and mark subset for removal\n         for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n             source.add(candidate);\n@@ -128,7 +128,7 @@ public abstract class ConcurrentSetTest extends UnitTest {\n             }\n         }\n \n-        // build test set by adding the candidates\n+        // getAll test set by adding the candidates\n         // and subsequently removing those marked for removal\n         ConcurrentExecutor.runConcurrent(new Runnable() {\n             @Override\n@@ -158,14 +158,14 @@ public abstract class ConcurrentSetTest extends UnitTest {\n         final HashSet<Object> source = new HashSet<Object>();\n         final IConcurrentSet testSetWeak = createSet();\n \n-        // build set of candidates and mark subset for removal\n+        // getAll set of candidates and mark subset for removal\n         for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n             source.add(candidate);\n             testSetWeak.add(candidate);\n         }\n \n-        // build test set by adding the candidates\n+        // getAll test set by adding the candidates\n         // and subsequently removing those marked for removal\n         ConcurrentExecutor.runConcurrent(new Runnable() {\n             @Override\n@@ -190,14 +190,14 @@ public abstract class ConcurrentSetTest extends UnitTest {\n         final HashSet<Object> source = new HashSet<Object>();\n         final IConcurrentSet setUnderTest = createSet();\n \n-        // build set of candidates and mark subset for removal\n+        // getAll set of candidates and mark subset for removal\n         for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n             source.add(candidate);\n             setUnderTest.add(candidate);\n         }\n \n-        // build test set by adding the candidates\n+        // getAll test set by adding the candidates\n         // and subsequently removing those marked for removal\n         ConcurrentExecutor.runConcurrent(new Runnable() {\n             @Override\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/FilterTest.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -35,7 +35,7 @@ public class FilterTest extends MessageBusTest {\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(100, FilteredMessageListener.class);\n \n-        List<Object> listeners = listenerFactory.build();\n+        List<Object> listeners = listenerFactory.getAll();\n \n         // this will subscribe the listeners concurrently to the bus\n         TestUtil.setup(bus, listeners, 10);\n@@ -60,7 +60,7 @@ public class FilterTest extends MessageBusTest {\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(100, FilteredMessageListener.class);\n \n-        List<Object> listeners = listenerFactory.build();\n+        List<Object> listeners = listenerFactory.getAll();\n \n         // this will subscribe the listeners concurrently to the bus\n         TestUtil.setup(bus, listeners, 10);\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MBassadorTest.java",
            "additions": 166,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,166 @@\n+package net.engio.mbassy;\n+\n+import net.engio.mbassy.bus.BusConfiguration;\n+import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.common.ConcurrentExecutor;\n+import net.engio.mbassy.common.MessageBusTest;\n+import net.engio.mbassy.common.TestUtil;\n+import net.engio.mbassy.listeners.ExceptionThrowingListener;\n+import net.engio.mbassy.listeners.IMessageListener;\n+import net.engio.mbassy.listeners.ListenerFactory;\n+import net.engio.mbassy.listeners.MessagesListener;\n+import net.engio.mbassy.messages.MessageTypes;\n+import net.engio.mbassy.messages.MultipartMessage;\n+import net.engio.mbassy.messages.StandardMessage;\n+import org.junit.Test;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n+ *\n+ * @author bennidi\n+ *         Date: 2/8/12\n+ */\n+public class MBassadorTest extends MessageBusTest {\n+\n+\n+    @Test\n+    public void testSynchronousMessagePublication() throws Exception {\n+\n+        final MBassador bus = getBus(new BusConfiguration());\n+        ListenerFactory listeners = new ListenerFactory()\n+                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n+                .create(InstancesPerListener, IMessageListener.AsyncListener.class)\n+                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n+                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n+                .create(InstancesPerListener, MessagesListener.AsyncListener.class)\n+                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n+                .create(InstancesPerListener, Object.class);\n+\n+\n+        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n+\n+        Runnable publishAndCheck = new Runnable() {\n+            @Override\n+            public void run() {\n+                StandardMessage standardMessage = new StandardMessage();\n+                MultipartMessage multipartMessage = new MultipartMessage();\n+\n+                bus.post(standardMessage).now();\n+                bus.post(multipartMessage).now();\n+                bus.post(MessageTypes.Simple).now();\n+\n+                pause(processingTimeInMS);\n+\n+                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n+                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.AsyncListener.class));\n+\n+                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n+                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.AsyncListener.class));\n+\n+\n+            }\n+        };\n+\n+        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n+\n+        MessageTypes.resetAll();\n+        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n+        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n+        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.AsyncListener.class));\n+        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n+        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.AsyncListener.class));\n+    }\n+\n+    @Test\n+    public void testAsynchronousMessagePublication() throws Exception {\n+\n+        final MBassador bus = getBus(new BusConfiguration());\n+        ListenerFactory listeners = new ListenerFactory()\n+                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n+                .create(InstancesPerListener, IMessageListener.AsyncListener.class)\n+                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n+                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n+                .create(InstancesPerListener, MessagesListener.AsyncListener.class)\n+                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n+                .create(InstancesPerListener, Object.class);\n+\n+\n+        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n+\n+        Runnable publishAndCheck = new Runnable() {\n+            @Override\n+            public void run() {\n+                StandardMessage standardMessage = new StandardMessage();\n+                MultipartMessage multipartMessage = new MultipartMessage();\n+\n+                bus.post(standardMessage).asynchronously();\n+                bus.post(multipartMessage).asynchronously();\n+                bus.post(MessageTypes.Simple).asynchronously();\n+\n+                pause(processingTimeInMS);\n+\n+                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n+                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.AsyncListener.class));\n+\n+                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n+                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.AsyncListener.class));\n+\n+\n+            }\n+        };\n+\n+        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n+\n+        MessageTypes.resetAll();\n+        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n+        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n+        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.AsyncListener.class));\n+        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n+        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.AsyncListener.class));\n+    }\n+\n+\n+    @Test\n+    public void testExceptionInHandlerInvocation(){\n+        final AtomicInteger exceptionCount = new AtomicInteger(0);\n+        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n+            @Override\n+            public void handleError(PublicationError error) {\n+                exceptionCount.incrementAndGet();\n+            }\n+        };\n+\n+        final MBassador bus = new MBassador(new BusConfiguration());\n+        bus.addErrorHandler(ExceptionCounter);\n+        ListenerFactory listeners = new ListenerFactory()\n+                .create(InstancesPerListener, ExceptionThrowingListener.class);\n+        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n+\n+        Runnable publishAndCheck = new Runnable() {\n+            @Override\n+            public void run() {\n+                bus.post(new StandardMessage()).asynchronously();\n+\n+            }\n+        };\n+\n+        // single threaded\n+        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n+        pause(processingTimeInMS);\n+        assertEquals(InstancesPerListener, exceptionCount.get());\n+\n+\n+        // multi threaded\n+        exceptionCount.set(0);\n+        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n+        pause(processingTimeInMS);\n+        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n+\n+    }\n+\n+\n+\n+\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MetadataReaderTest.java",
            "additions": 2,
            "deletions": 3
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy;\n \n+import net.engio.mbassy.common.AssertSupport;\n import org.junit.Test;\n-import net.engio.mbassy.common.UnitTest;\n import net.engio.mbassy.listener.Enveloped;\n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.MessageListenerMetadata;\n@@ -16,12 +16,11 @@ import java.util.Map;\n import static net.engio.mbassy.listener.MessageListenerMetadata.ForMessage;\n \n /**\n- * Todo: Add javadoc\n  *\n  * @author bennidi\n  *         Date: 12/16/12\n  */\n-public class MetadataReaderTest extends UnitTest {\n+public class MetadataReaderTest extends AssertSupport {\n \n     private MetadataReader reader = new MetadataReader();\n \n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 165,
            "deletions": 123
        },
        "diff content": "@@ -1,167 +1,209 @@\n package net.engio.mbassy;\n \n+import net.engio.mbassy.common.AssertSupport;\n import net.engio.mbassy.common.ConcurrentExecutor;\n-import net.engio.mbassy.common.IPredicate;\n-import net.engio.mbassy.common.UnitTest;\n-import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.common.SubscriptionValidator;\n+import net.engio.mbassy.common.TestUtil;\n import net.engio.mbassy.listener.MetadataReader;\n-import net.engio.mbassy.messages.ITestMessage;\n-import net.engio.mbassy.messages.TestMessage;\n+import net.engio.mbassy.listeners.*;\n+import net.engio.mbassy.messages.*;\n import net.engio.mbassy.subscription.Subscription;\n import net.engio.mbassy.subscription.SubscriptionFactory;\n import net.engio.mbassy.subscription.SubscriptionManager;\n import org.junit.Test;\n \n-import java.util.*;\n+import java.util.Collection;\n \n /**\n- * Todo: Add javadoc\n- *\n  * @author bennidi\n  *         Date: 5/12/13\n  */\n-public class SubscriptionManagerTest extends UnitTest{\n+public class SubscriptionManagerTest extends AssertSupport {\n \n+    private static final int InstancesPerListener = 5000;\n+    private static final int ConcurrentUnits = 10;\n \n     @Test\n-    public void testSimpleSynchronousHandler(){\n-        final SubscriptionManager subMan = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n-        final Set listeners = Collections.synchronizedSet(new HashSet());\n-        final int concurrentUnits = 5;\n-        final int numberOfLoops = 100;\n-        final int numberOfListeners =  numberOfLoops * concurrentUnits;\n-\n-        ConcurrentExecutor.runConcurrent(new Runnable() {\n-            @Override\n-            public void run() {\n-                for(int i = 0 ; i < numberOfLoops ; i++){\n-                    SimpleSynchronousMessageHandler\n-                            listener1 = new SimpleSynchronousMessageHandler();\n-                    SimpleSynchronousMessageHandler2 listener2 = new SimpleSynchronousMessageHandler2();\n-                    subMan.subscribe(listener1);\n-                    subMan.subscribe(listener2);\n-                    listeners.add(listener1);\n-                    listeners.add(listener2);\n-                }\n-\n-            }\n-        }, concurrentUnits);\n-\n-        SubscriptionValidator validator = new SubscriptionValidator();\n-        validator.expect(numberOfListeners, SimpleSynchronousMessageHandler.class, ITestMessage.class);\n-        validator.expect(numberOfListeners, SimpleSynchronousMessageHandler2.class, ITestMessage.class);\n-        validator.expect(numberOfListeners, SimpleSynchronousMessageHandler.class, TestMessage.class);\n-        validator.expect(numberOfListeners, SimpleSynchronousMessageHandler2.class, TestMessage.class);\n-\n-        validator.validate(subMan);\n-\n+    public void testIMessageListener(){\n+        ListenerFactory listeners = listeners(\n+                IMessageListener.DefaultListener.class,\n+                IMessageListener.AsyncListener.class,\n+                IMessageListener.DisabledListener.class,\n+                IMessageListener.NoSubtypesListener.class);\n+\n+        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n+                .listener(IMessageListener.DefaultListener.class).handles(IMessage.class,\n+                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n+                .listener(IMessageListener.AsyncListener.class).handles(IMessage.class,\n+                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n+                .listener(IMessageListener.NoSubtypesListener.class).handles(IMessage.class);\n+\n+        runTestWith(listeners, expectedSubscriptions);\n     }\n \n+    @Test\n+    public void testAbstractMessageListener(){\n+        ListenerFactory listeners = listeners(\n+                AbstractMessageListener.DefaultListener.class,\n+                AbstractMessageListener.AsyncListener.class,\n+                AbstractMessageListener.DisabledListener.class,\n+                AbstractMessageListener.NoSubtypesListener.class);\n+\n+        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n+                .listener(AbstractMessageListener.NoSubtypesListener.class).handles(AbstractMessage.class)\n+                .listener(AbstractMessageListener.DefaultListener.class).handles(StandardMessage.class, AbstractMessage.class)\n+                .listener(AbstractMessageListener.AsyncListener.class).handles(StandardMessage.class, AbstractMessage.class);\n+\n+        runTestWith(listeners, expectedSubscriptions);\n+    }\n \n-    class SubscriptionValidator{\n-\n-\n-        private List<Entry> validations = new LinkedList<Entry>();\n-        private Set<Class> messageTypes = new HashSet<Class>();\n-        private Set<Class> subsribers = new HashSet<Class>();\n+    @Test\n+    public void testMessagesListener(){\n+        ListenerFactory listeners = listeners(\n+                MessagesListener.DefaultListener.class,\n+                MessagesListener.AsyncListener.class,\n+                MessagesListener.DisabledListener.class,\n+                MessagesListener.NoSubtypesListener.class);\n+\n+        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n+                .listener(MessagesListener.NoSubtypesListener.class).handles(MessageTypes.class)\n+                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)\n+                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);\n+\n+        runTestWith(listeners, expectedSubscriptions);\n+    }\n \n+    @Test\n+    public void testMultipartMessageListener(){\n+        ListenerFactory listeners = listeners(\n+                MultipartMessageListener.DefaultListener.class,\n+                MultipartMessageListener.AsyncListener.class,\n+                MultipartMessageListener.DisabledListener.class,\n+                MultipartMessageListener.NoSubtypesListener.class);\n+\n+        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n+                .listener(MultipartMessageListener.NoSubtypesListener.class).handles(MultipartMessage.class)\n+                .listener(MultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class)\n+                .listener(MultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class);\n+\n+        runTestWith(listeners, expectedSubscriptions);\n+    }\n \n-        public SubscriptionValidator expect(int numberOfSubscriber, Class subscriber, Class messageType){\n-            validations.add(new Entry(messageType, numberOfSubscriber, subscriber));\n-            messageTypes.add(messageType);\n-            subsribers.add(subscriber);\n-            return this;\n-        }\n+    @Test\n+    public void testIMultipartMessageListener(){\n+        ListenerFactory listeners = listeners(\n+                IMultipartMessageListener.DefaultListener.class,\n+                IMultipartMessageListener.AsyncListener.class,\n+                IMultipartMessageListener.DisabledListener.class,\n+                IMultipartMessageListener.NoSubtypesListener.class);\n+\n+        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n+                .listener(IMultipartMessageListener.NoSubtypesListener.class).handles(IMultipartMessage.class)\n+                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n+                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class);\n+\n+        runTestWith(listeners, expectedSubscriptions);\n+    }\n \n-        public void validate(SubscriptionManager manager){\n-            for(Class messageType : messageTypes){\n-                Collection<Subscription> subscriptions = manager.getSubscriptionsByMessageType(messageType);\n-                Collection<Entry> validationEntries = getEntries(EntriesByMessageType(messageType));\n-                assertEquals(subscriptions.size(), validationEntries.size());\n-                for(Entry validationEntry : validationEntries){\n-                    Subscription matchingSub = null;\n-                    // one of the subscriptions must belong to the subscriber type\n-                    for(Subscription sub : subscriptions){\n-                        if(sub.belongsTo(validationEntry.subscriber)){\n-                            matchingSub = sub;\n-                            break;\n-                        }\n-                    }\n-                    assertNotNull(matchingSub);\n-                    assertEquals(validationEntry.numberOfSubscribers, matchingSub.size());\n-                }\n-            }\n-        }\n+    @Test\n+    public void testStandardMessageListener(){\n+        ListenerFactory listeners = listeners(\n+                StandardMessageListener.DefaultListener.class,\n+                StandardMessageListener.AsyncListener.class,\n+                StandardMessageListener.DisabledListener.class,\n+                StandardMessageListener.NoSubtypesListener.class);\n+\n+        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n+                .listener(StandardMessageListener.NoSubtypesListener.class).handles(StandardMessage.class)\n+                .listener(StandardMessageListener.DefaultListener.class).handles(StandardMessage.class)\n+                .listener(StandardMessageListener.AsyncListener.class).handles(StandardMessage.class);\n+\n+        runTestWith(listeners, expectedSubscriptions);\n+    }\n \n+    @Test\n+    public void testICountableListener(){\n+        ListenerFactory listeners = listeners(\n+                ICountableListener.DefaultListener.class,\n+                ICountableListener.AsyncListener.class,\n+                ICountableListener.DisabledListener.class,\n+                ICountableListener.NoSubtypesListener.class);\n+\n+        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n+                .listener(ICountableListener.DefaultListener.class).handles(ICountable.class)\n+                .listener(ICountableListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n+                .listener(ICountableListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class);\n+\n+        runTestWith(listeners, expectedSubscriptions);\n+    }\n \n-        private Collection<Entry> getEntries(IPredicate<Entry> filter){\n-            Collection<Entry> matching = new LinkedList<Entry>();\n-            for (Entry validationEntry : validations){\n-                if(filter.apply(validationEntry))matching.add(validationEntry);\n-            }\n-            return matching;\n-        }\n+    @Test\n+    public void testMultipleMessageListeners(){\n+        ListenerFactory listeners = listeners(\n+                ICountableListener.DefaultListener.class,\n+                ICountableListener.AsyncListener.class,\n+                ICountableListener.DisabledListener.class,\n+                IMultipartMessageListener.DefaultListener.class,\n+                IMultipartMessageListener.AsyncListener.class,\n+                IMultipartMessageListener.DisabledListener.class,\n+                MessagesListener.DefaultListener.class,\n+                MessagesListener.AsyncListener.class,\n+                MessagesListener.DisabledListener.class);\n+\n+        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n+                .listener(ICountableListener.DefaultListener.class)\n+                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n+                .listener(ICountableListener.AsyncListener.class)\n+                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class)\n+                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n+                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n+                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)\n+                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);\n+\n+        runTestWith(listeners, expectedSubscriptions);\n+    }\n \n-        private IPredicate<Entry> EntriesByMessageType(final Class messageType){\n-            return new IPredicate<Entry>() {\n-                @Override\n-                public boolean apply(Entry target) {\n-                    return target.messageType.equals(messageType);\n-                }\n-            };\n-        }\n+    @Test\n+    public void testStrongListenerSubscription() throws Exception {\n+        ListenerFactory listeners = listeners(CustomInvocationListener.class);\n+        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n+        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n \n-        private IPredicate<Entry> EntriesBySubscriberType(final Class subscriberType){\n-            return new IPredicate<Entry>() {\n-                @Override\n-                public boolean apply(Entry target) {\n-                    return target.subscriber.equals(subscriberType);\n-                }\n-            };\n-        }\n \n+        listeners.clear();\n+        runGC();\n \n+        Collection<Subscription> subscriptions = subscriptionManager.getSubscriptionsByMessageType(StandardMessage.class);\n+        assertEquals(1, subscriptions.size());\n+        for(Subscription sub : subscriptions)\n+            assertEquals(InstancesPerListener,  sub.size());\n+    }\n \n-        private class Entry{\n \n-            private int numberOfSubscribers;\n+    private ListenerFactory listeners(Class ...listeners){\n+        ListenerFactory factory = new ListenerFactory();\n+        for(Class listener : listeners){\n+            factory.create(InstancesPerListener, listener);\n+        }\n+        return factory;\n+    }\n \n-            private Class subscriber;\n+    private void runTestWith(final ListenerFactory listeners, final SubscriptionValidator validator){\n+        final SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n \n-            private Class messageType;\n+        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n \n-            private Entry(Class messageType, int numberOfSubscribers, Class subscriber) {\n-                this.messageType = messageType;\n-                this.numberOfSubscribers = numberOfSubscribers;\n-                this.subscriber = subscriber;\n-            }\n+        validator.validate(subscriptionManager);\n \n+        ConcurrentExecutor.runConcurrent(TestUtil.unsubscriber(subscriptionManager, listeners), ConcurrentUnits);\n \n-        }\n+        listeners.clear();\n \n+        validator.validate(subscriptionManager);\n     }\n \n \n-    static class SimpleSynchronousMessageHandler{\n-\n-        @Handler\n-        public void handle(TestMessage message) {\n-        }\n-\n-        @Handler\n-        public void handle(ITestMessage message) {\n-        }\n-    }\n \n \n-    static class SimpleSynchronousMessageHandler2{\n \n-        @Handler\n-        public void handle(TestMessage message) {\n-        }\n-\n-        @Handler\n-        public void handle(ITestMessage message) {\n-        }\n-    }\n }\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 98,
            "deletions": 138
        },
        "diff content": "@@ -1,21 +1,16 @@\n package net.engio.mbassy;\n \n import net.engio.mbassy.bus.*;\n-import net.engio.mbassy.common.DeadMessage;\n+import net.engio.mbassy.common.ConcurrentExecutor;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.common.TestUtil;\n-import net.engio.mbassy.dispatch.HandlerInvocation;\n-import net.engio.mbassy.messages.ITestMessage;\n-import net.engio.mbassy.messages.SubTestMessage;\n-import net.engio.mbassy.messages.TestMessage;\n-import net.engio.mbassy.listener.*;\n import net.engio.mbassy.listeners.*;\n-import net.engio.mbassy.messages.TestMessage3;\n-import net.engio.mbassy.subscription.SubscriptionContext;\n-import org.junit.Assert;\n+import net.engio.mbassy.messages.MessageTypes;\n+import net.engio.mbassy.messages.MultipartMessage;\n+import net.engio.mbassy.messages.StandardMessage;\n import org.junit.Test;\n \n-import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n  * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n@@ -25,152 +20,117 @@ import java.util.List;\n  */\n public abstract class SyncBusTest extends MessageBusTest {\n \n-    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n-    // otherwise the tests will fail since asynchronous processing might not have finished when\n-    // evaluation is run\n-    private int processingTimeInMS = 4000;\n \n+    protected abstract ISyncMessageBus getSyncMessageBus();\n \n     @Test\n     public void testSynchronousMessagePublication() throws Exception {\n \n-        ISyncMessageBus bus = getSyncMessageBus();\n-        ListenerFactory listenerFactory = new ListenerFactory()\n-                .create(10000, MessageListener1.class)\n-                .create(10000, MessageListener2.class)\n-                .create(10000, MessageListener3.class)\n-                .create(10000, Object.class)\n-                .create(10000, NonListeningBean.class);\n-\n-        List<Object> listeners = listenerFactory.build();\n-\n-        // this will subscribe the listeners concurrently to the bus\n-        TestUtil.setup(bus, listeners, 10);\n-\n-        TestMessage message = new TestMessage();\n-        TestMessage subMessage = new SubTestMessage();\n-\n-        bus.post(message).now();\n-        bus.post(subMessage).now();\n-\n-        pause(processingTimeInMS);\n-\n-        assertEquals(30000, message.counter.get());\n-        assertEquals(70000, subMessage.counter.get());\n-\n+        final ISyncMessageBus bus = getSyncMessageBus();\n+        ListenerFactory listeners = new ListenerFactory()\n+                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n+                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n+                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n+                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n+                .create(InstancesPerListener, Object.class);\n+\n+\n+        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n+\n+        Runnable publishAndCheck = new Runnable() {\n+            @Override\n+            public void run() {\n+                StandardMessage standardMessage = new StandardMessage();\n+                MultipartMessage multipartMessage = new MultipartMessage();\n+\n+                bus.post(standardMessage).now();\n+                bus.post(multipartMessage).now();\n+                bus.post(MessageTypes.Simple).now();\n+                bus.post(MessageTypes.Multipart).now();\n+\n+                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n+                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n+            }\n+        };\n+\n+        // single threaded\n+        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n+\n+        // multi threaded\n+        MessageTypes.resetAll();\n+        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n+        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n+        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));\n+        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n+        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesListener.DefaultListener.class));\n     }\n \n-    @Test\n-    public void testStrongListenerSubscription() throws Exception {\n-\n-        ISyncMessageBus bus = getSyncMessageBus();\n-\n-        for(int i = 0; i< 10000; i++){\n-            bus.subscribe(new MessageListener2());\n-        }\n-\n-        runGC();\n-\n-        TestMessage message = new TestMessage();\n-        TestMessage subMessage = new SubTestMessage();\n-\n-        bus.post(message).now();\n-        bus.post(subMessage).now();\n-\n-        pause(processingTimeInMS);\n-\n-        assertEquals(10000, message.counter.get());\n-        assertEquals(20000, subMessage.counter.get());\n-\n-    }\n-\n-    protected abstract ISyncMessageBus getSyncMessageBus();\n-\n-\n \n     @Test\n-    public void testHandlerUsingInterface() {\n-        MBassador<ITestMessage> bus = new MBassador<ITestMessage>(BusConfiguration.Default());\n-        bus.subscribe(new InterfaceMessageListener());\n-        bus.publish(new TestMessage3());\n-    }\n-\n-    @Listener(references = References.Strong)\n-    static class InterfaceMessageListener{\n-\n-    @Handler\n-    public void handleFoo(ITestMessage f) {\n-        Assert.assertTrue(f instanceof TestMessage3);\n-    }\n-\n-    @Handler\n-    public void handleDead(DeadMessage d) {\n-        Assert.fail(\"This class should handle this message appropriately!\");\n+    public void testExceptionInHandlerInvocation(){\n+        final AtomicInteger exceptionCount = new AtomicInteger(0);\n+        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n+            @Override\n+            public void handleError(PublicationError error) {\n+                exceptionCount.incrementAndGet();\n+            }\n+        };\n+\n+        final ISyncMessageBus bus = getSyncMessageBus();\n+        bus.addErrorHandler(ExceptionCounter);\n+        ListenerFactory listeners = new ListenerFactory()\n+                .create(InstancesPerListener, ExceptionThrowingListener.class);\n+\n+        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n+\n+        Runnable publish = new Runnable() {\n+            @Override\n+            public void run() {\n+                bus.post(new StandardMessage()).now();\n+            }\n+        };\n+\n+        // single threaded\n+        ConcurrentExecutor.runConcurrent(publish, 1);\n+\n+        exceptionCount.set(0);\n+\n+        // multi threaded\n+        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n+        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n     }\n \n-    }\n-\n-\n-    public static class MessageListener1 {\n-\n-        // every event of type TestEvent or any subtype will be delivered\n-        // to this listener\n-        @Handler\n-        public void handleTestEvent(TestMessage message) {\n-            message.counter.incrementAndGet();\n-        }\n-\n-        // this handler will be invoked asynchronously\n-        @Handler(priority = 0, invocation = HandleSubTestEventInvocation.class)\n-        public void handleSubTestEvent(SubTestMessage message) {\n-            message.counter.incrementAndGet();\n-        }\n-\n-        // this handler will receive events of type SubTestEvent\n-        // or any subtabe and that passes the given filter\n-        @Handler(\n-                priority = 10,\n-                delivery = Invoke.Synchronously,\n-                filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n-        public void handleFiltered(SubTestMessage message) {\n-            message.counter.incrementAndGet();\n-        }\n-\n-\n-    }\n-\n-    public static class HandleSubTestEventInvocation extends HandlerInvocation<MessageListener1, SubTestMessage> {\n-\n-        public HandleSubTestEventInvocation(SubscriptionContext context) {\n-            super(context);\n-        }\n+    @Test\n+    public void testCustomHandlerInvocation(){\n+        final ISyncMessageBus bus = getSyncMessageBus();\n+        ListenerFactory listeners = new ListenerFactory()\n+                .create(InstancesPerListener, CustomInvocationListener.class)\n+                .create(InstancesPerListener, Object.class);\n \n-        @Override\n-        public void invoke(MessageListener1 listener, SubTestMessage message) {\n-            listener.handleSubTestEvent(message);\n-        }\n-    }\n \n-    @Listener(references = References.Strong)\n-    public static class MessageListener2 extends net.engio.mbassy.listeners.EventingTestBean {\n+        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n \n-        // redefine the configuration for this handler\n-        @Handler(delivery = Invoke.Synchronously)\n-        public void handleSubTestEvent(SubTestMessage message) {\n-            super.handleSubTestEvent(message);\n-        }\n+        Runnable publishAndCheck = new Runnable() {\n+            @Override\n+            public void run() {\n+                StandardMessage standardMessage = new StandardMessage();\n+                MultipartMessage multipartMessage = new MultipartMessage();\n \n-    }\n+                bus.post(standardMessage).now();\n+                bus.post(multipartMessage).now();\n+                bus.post(MessageTypes.Simple).now();\n \n-    @Listener(references = References.Strong)\n-    public static class MessageListener3 extends net.engio.mbassy.listeners.EventingTestBean2 {\n+                assertEquals(InstancesPerListener * 2, standardMessage.getTimesHandled(CustomInvocationListener.class));\n+                assertEquals(0, multipartMessage.getTimesHandled(CustomInvocationListener.class));\n+                assertEquals(0, MessageTypes.Simple.getTimesHandled(CustomInvocationListener.class));\n+            }\n+        };\n \n+        // single threaded\n+        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n \n-        // this handler will be invoked asynchronously\n-        @Handler(priority = 0, delivery = Invoke.Synchronously)\n-        public void handleSubTestEventAgain(SubTestMessage message) {\n-            message.counter.incrementAndGet();\n-        }\n+        // multi threaded\n+        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n \n     }\n \n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java",
            "additions": 22,
            "deletions": 21
        },
        "diff content": "@@ -21,17 +21,17 @@ import java.util.List;\n public class SynchronizedHandlerTest extends MessageBusTest {\n \n \n-    private static int incrementsPerHandler = 10000;\n+    private static int incrementsPerMessage = 10000;\n     private static int numberOfMessages = 1000;\n-    private static int numberOfHandlers = 1000;\n+    private static int numberOfListeners = 1000;\n \n     @Test\n     public void testSynchronizedWithSynchronousInvocation(){\n-        List<SynchronizedMessageHandlerSync> handlers = new LinkedList<SynchronizedMessageHandlerSync>();\n+        List<SynchronizedWithSynchronousDelivery> handlers = new LinkedList<SynchronizedWithSynchronousDelivery>();\n         IMessageBus bus = getBus(BusConfiguration.Default()\n                 .setNumberOfMessageDispatchers(6));\n-        for(int i = 0; i < numberOfHandlers; i++){\n-            SynchronizedMessageHandlerSync handler = new SynchronizedMessageHandlerSync();\n+        for(int i = 0; i < numberOfListeners; i++){\n+            SynchronizedWithSynchronousDelivery handler = new SynchronizedWithSynchronousDelivery();\n             handlers.add(handler);\n             bus.subscribe(handler);\n         }\n@@ -40,23 +40,24 @@ public class SynchronizedHandlerTest extends MessageBusTest {\n         for(int i = 0; i < numberOfMessages; i++){\n            publication =  bus.post(new Object()).asynchronously();\n         }\n+        // wait for last publication\n         while (!publication.isFinished()){\n-            pause(2000);\n+            pause(100);\n         }\n \n-        for(SynchronizedMessageHandlerSync handler : handlers){\n-            assertEquals(incrementsPerHandler * numberOfMessages, handler.Counter);\n+        for(SynchronizedWithSynchronousDelivery handler : handlers){\n+            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n         }\n \n     }\n \n     @Test\n     public void testSynchronizedWithAsSynchronousInvocation(){\n-        List<SynchronizedMessageHandlerAsyn> handlers = new LinkedList<SynchronizedMessageHandlerAsyn>();\n+        List<SynchronizedWithAsynchronousDelivery> handlers = new LinkedList<SynchronizedWithAsynchronousDelivery>();\n         IMessageBus bus = getBus(BusConfiguration.Default()\n                 .setNumberOfMessageDispatchers(6));\n-        for(int i = 0; i < numberOfHandlers; i++){\n-            SynchronizedMessageHandlerAsyn handler = new SynchronizedMessageHandlerAsyn();\n+        for(int i = 0; i < numberOfListeners; i++){\n+            SynchronizedWithAsynchronousDelivery handler = new SynchronizedWithAsynchronousDelivery();\n             handlers.add(handler);\n             bus.subscribe(handler);\n         }\n@@ -67,35 +68,35 @@ public class SynchronizedHandlerTest extends MessageBusTest {\n \n         pause(10000);\n \n-        for(SynchronizedMessageHandlerAsyn handler : handlers){\n-            assertEquals(incrementsPerHandler * numberOfMessages, handler.Counter);\n+        for(SynchronizedWithAsynchronousDelivery handler : handlers){\n+            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n         }\n \n     }\n \n-    public static class SynchronizedMessageHandlerSync{\n+    public static class SynchronizedWithSynchronousDelivery {\n \n-        private int Counter = 0;\n+        private int counter = 0;\n \n         @Handler\n         @Synchronized\n         public void handleMessage(Object o){\n-           for(int i = 0; i < incrementsPerHandler; i++){\n-               Counter++;\n+           for(int i = 0; i < incrementsPerMessage; i++){\n+               counter++;\n            }\n         }\n \n     }\n \n-    public static class SynchronizedMessageHandlerAsyn{\n+    public static class SynchronizedWithAsynchronousDelivery {\n \n-        private int Counter = 0;\n+        private int counter = 0;\n \n         @Handler(delivery = Invoke.Asynchronously)\n         @Synchronized\n         public void handleMessage(Object o){\n-            for(int i = 0; i < incrementsPerHandler; i++){\n-                Counter++;\n+            for(int i = 0; i < incrementsPerMessage; i++){\n+                counter++;\n             }\n         }\n \n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/bus/ListenerSubscriptionTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -90,7 +90,7 @@ public class ListenerSubscriptionTest extends MessageBusTest{\n                 .create(10000, Object.class)\n                 .create(10000, NonListeningBean.class);\n \n-        List<Object> listeners = listenerFactory.build();\n+        List<Object> listeners = listenerFactory.getAll();\n \n         // this will subscribe the listeners concurrently to the bus\n         TestUtil.setup(bus, listeners, 10);\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/AssertSupport.java",
            "additions": 3,
            "deletions": 5
        },
        "diff content": "@@ -5,13 +5,9 @@ import org.junit.Assert;\n import java.lang.ref.WeakReference;\n \n /**\n- * Created with IntelliJ IDEA.\n  * @author bennidi\n- * Date: 11/12/12\n- * Time: 3:16 PM\n- * To change this template use File | Settings | File Templates.\n  */\n-public class UnitTest {\n+public class AssertSupport {\n \n     // Internal state\n     private Runtime runtime = Runtime.getRuntime();\n@@ -31,7 +27,9 @@ public class UnitTest {\n \n     public void runGC() {\n         WeakReference ref = new WeakReference<Object>(new Object());\n+        pause(100);\n         while(ref.get() != null) {\n+            pause(10);\n             runtime.gc();\n         }\n     }\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/ConcurrentExecutor.java",
            "additions": 10,
            "deletions": 0
        },
        "diff content": "@@ -43,6 +43,7 @@ public class ConcurrentExecutor {\n \t\t\treturnValues.add(executor.submit(wrapper));\n \t\t}\n \n+\n \t\t// wait until all tasks have been executed\n \t\ttry {\n \t\t\texecutor.shutdown();// tells the thread pool to execute all waiting tasks\n@@ -51,6 +52,15 @@ public class ConcurrentExecutor {\n \t\t\t// unlikely that this will happen\n \t\t\te.printStackTrace();\n \t\t}\n+\n+        for(Future task : returnValues){\n+            try {\n+                task.get();\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n \t}\n \n \n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 17,
            "deletions": 1
        },
        "diff content": "@@ -6,6 +6,8 @@ import net.engio.mbassy.PublicationError;\n import net.engio.mbassy.bus.BusConfiguration;\n import net.engio.mbassy.bus.ISyncMessageBus;\n import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.messages.MessageTypes;\n+import org.junit.Before;\n \n /**\n  * A base test that provides a factory for message bus that makes tests fail if any\n@@ -14,7 +16,14 @@ import net.engio.mbassy.bus.MBassador;\n  * @author bennidi\n  *         Date: 3/2/13\n  */\n-public class MessageBusTest<Bus extends ISyncMessageBus> extends UnitTest {\n+public abstract class MessageBusTest<Bus extends ISyncMessageBus> extends AssertSupport {\n+\n+    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n+    // otherwise the tests will fail since asynchronous processing might not have finished when\n+    // evaluation is run\n+    protected static final int processingTimeInMS = 6000;\n+    protected static final int InstancesPerListener = 5000;\n+    protected static final int ConcurrentUnits = 10;\n \n     protected static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n         @Override\n@@ -23,6 +32,13 @@ public class MessageBusTest<Bus extends ISyncMessageBus> extends UnitTest {\n         }\n     };\n \n+\n+    @Before\n+    public void setUp(){\n+        for(MessageTypes mes : MessageTypes.values())\n+            mes.reset();\n+    }\n+\n     public MBassador getBus(BusConfiguration configuration) {\n         MBassador bus = new MBassador(configuration);\n         bus.addErrorHandler(TestFailingHandler);\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/SubscriptionValidator.java",
            "additions": 117,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,117 @@\n+package net.engio.mbassy.common;\n+\n+import net.engio.mbassy.listeners.ListenerFactory;\n+import net.engio.mbassy.subscription.Subscription;\n+import net.engio.mbassy.subscription.SubscriptionManager;\n+\n+import java.util.*;\n+\n+/**\n+* Todo: Add javadoc\n+*\n+* @author bennidi\n+*         Date: 5/25/13\n+*/\n+public class SubscriptionValidator extends AssertSupport{\n+\n+\n+    private List<ValidationEntry> validations = new LinkedList<ValidationEntry>();\n+    private Set<Class> messageTypes = new HashSet<Class>();\n+    private Set<Class> subscribers = new HashSet<Class>();\n+    private ListenerFactory subscribedListener;\n+\n+    public SubscriptionValidator(ListenerFactory subscribedListener) {\n+        this.subscribedListener = subscribedListener;\n+    }\n+\n+    public Expectation listener(Class subscriber){\n+        return new Expectation(subscriber);\n+    }\n+\n+    private SubscriptionValidator expect(Class subscriber, Class messageType){\n+        validations.add(new ValidationEntry(messageType, subscriber));\n+        messageTypes.add(messageType);\n+        subscribers.add(subscriber);\n+        return this;\n+    }\n+\n+    // match subscriptions with existing validation entries\n+    // for each tuple of subscriber and message type the specified number of listeners must exist\n+    public void validate(SubscriptionManager manager){\n+        for(Class messageType : messageTypes){\n+            Collection<Subscription> subscriptions = manager.getSubscriptionsByMessageType(messageType);\n+            Collection<ValidationEntry> validationEntries = getEntries(EntriesByMessageType(messageType));\n+            assertEquals(subscriptions.size(), validationEntries.size());\n+            for(ValidationEntry validationValidationEntry : validationEntries){\n+                Subscription matchingSub = null;\n+                // one of the subscriptions must belong to the subscriber type\n+                for(Subscription sub : subscriptions){\n+                    if(sub.belongsTo(validationValidationEntry.subscriber)){\n+                        matchingSub = sub;\n+                        break;\n+                    }\n+                }\n+                assertNotNull(matchingSub);\n+                assertEquals(subscribedListener.getNumberOfListeners(validationValidationEntry.subscriber), matchingSub.size());\n+            }\n+        }\n+    }\n+\n+\n+    private Collection<ValidationEntry> getEntries(IPredicate<ValidationEntry> filter){\n+        Collection<ValidationEntry> matching = new LinkedList<ValidationEntry>();\n+        for (ValidationEntry validationValidationEntry : validations){\n+            if(filter.apply(validationValidationEntry))matching.add(validationValidationEntry);\n+        }\n+        return matching;\n+    }\n+\n+    private IPredicate<ValidationEntry> EntriesByMessageType(final Class messageType){\n+        return new IPredicate<ValidationEntry>() {\n+            @Override\n+            public boolean apply(ValidationEntry target) {\n+                return target.messageType.equals(messageType);\n+            }\n+        };\n+    }\n+\n+    private IPredicate<ValidationEntry> EntriesBySubscriberType(final Class subscriberType){\n+        return new IPredicate<ValidationEntry>() {\n+            @Override\n+            public boolean apply(ValidationEntry target) {\n+                return target.subscriber.equals(subscriberType);\n+            }\n+        };\n+    }\n+\n+    public class Expectation{\n+\n+        private Class listener;\n+\n+        private Expectation(Class listener) {\n+            this.listener = listener;\n+        }\n+\n+        public SubscriptionValidator handles(Class ...messages){\n+            for(Class message : messages)\n+                expect(listener, message);\n+            return SubscriptionValidator.this;\n+        }\n+    }\n+\n+    private class ValidationEntry {\n+\n+\n+        private Class subscriber;\n+\n+        private Class messageType;\n+\n+        private ValidationEntry(Class messageType, Class subscriber) {\n+            this.messageType = messageType;\n+            this.subscriber = subscriber;\n+        }\n+\n+\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/TestUtil.java",
            "additions": 55,
            "deletions": 1
        },
        "diff content": "@@ -1,8 +1,10 @@\n package net.engio.mbassy.common;\n \n-import net.engio.mbassy.bus.IMessageBus;\n import net.engio.mbassy.bus.ISyncMessageBus;\n+import net.engio.mbassy.listeners.ListenerFactory;\n+import net.engio.mbassy.subscription.SubscriptionManager;\n \n+import java.util.Iterator;\n import java.util.List;\n \n /**\n@@ -14,6 +16,58 @@ import java.util.List;\n public class TestUtil {\n \n \n+    public static Runnable subscriber(final SubscriptionManager manager, final ListenerFactory listeners){\n+        final Iterator source = listeners.iterator();\n+        return new Runnable() {\n+            @Override\n+            public void run() {\n+                Object next;\n+                while((next = source.next()) != null){\n+                    manager.subscribe(next);\n+                }\n+            }\n+        };\n+    }\n+\n+    public static Runnable unsubscriber(final SubscriptionManager manager, final ListenerFactory listeners){\n+        final Iterator source = listeners.iterator();\n+        return new Runnable() {\n+            @Override\n+            public void run() {\n+                Object next;\n+                while((next = source.next()) != null){\n+                    manager.unsubscribe(next);\n+                }\n+            }\n+        };\n+    }\n+\n+    public static Runnable subscriber(final ISyncMessageBus bus, final ListenerFactory listeners){\n+        final Iterator source = listeners.iterator();\n+        return new Runnable() {\n+            @Override\n+            public void run() {\n+                Object next;\n+                while((next = source.next()) != null){\n+                    bus.subscribe(next);\n+                }\n+            }\n+        };\n+    }\n+\n+    public static Runnable unsubscriber(final ISyncMessageBus bus, final ListenerFactory listeners){\n+        final Iterator source = listeners.iterator();\n+        return new Runnable() {\n+            @Override\n+            public void run() {\n+                Object next;\n+                while((next = source.next()) != null){\n+                    bus.unsubscribe(next);\n+                }\n+            }\n+        };\n+    }\n+\n     public static void setup(final ISyncMessageBus bus, final List<Object> listeners, int numberOfThreads) {\n         Runnable[] setupUnits = new Runnable[numberOfThreads];\n         int partitionSize;\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/AbstractMessageListener.java",
            "additions": 58,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,58 @@\n+package net.engio.mbassy.listeners;\n+\n+import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.messages.AbstractMessage;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 5/24/13\n+ */\n+public class AbstractMessageListener {\n+\n+    private static abstract class BaseListener {\n+\n+        @Handler\n+        public void handle(AbstractMessage message){\n+            message.handled(this.getClass());\n+        }\n+\n+    }\n+\n+    public static class DefaultListener extends BaseListener {\n+\n+        public void handle(AbstractMessage message){\n+            super.handle(message);\n+        }\n+    }\n+\n+    public static class NoSubtypesListener extends BaseListener {\n+\n+        @Handler(rejectSubtypes = true)\n+        public void handle(AbstractMessage message){\n+            super.handle(message);\n+        }\n+    }\n+\n+\n+    public static class AsyncListener extends BaseListener {\n+\n+        @Handler(delivery = Invoke.Asynchronously)\n+        public void handle(AbstractMessage message){\n+            super.handle(message);\n+        }\n+\n+    }\n+\n+    public static class DisabledListener extends BaseListener {\n+\n+        @Handler(enabled = false)\n+        public void handle(AbstractMessage message){\n+            super.handle(message);\n+        }\n+\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/CustomInvocationListener.java",
            "additions": 37,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,37 @@\n+package net.engio.mbassy.listeners;\n+\n+import net.engio.mbassy.dispatch.HandlerInvocation;\n+import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.References;\n+import net.engio.mbassy.messages.StandardMessage;\n+import net.engio.mbassy.subscription.SubscriptionContext;\n+\n+/**\n+ * @author bennidi\n+ *         Date: 5/25/13\n+ */\n+@Listener(references = References.Strong)\n+public class CustomInvocationListener {\n+\n+\n+    // this handler will be invoked asynchronously\n+    @Handler(invocation = HandleSubTestEventInvocation.class)\n+    public void handle(StandardMessage message) {\n+        message.handled(this.getClass());\n+        message.handled(this.getClass());\n+    }\n+\n+    public static class HandleSubTestEventInvocation extends HandlerInvocation<CustomInvocationListener, StandardMessage> {\n+\n+        public HandleSubTestEventInvocation(SubscriptionContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        public void invoke(CustomInvocationListener listener, StandardMessage message) {\n+            listener.handle(message);\n+        }\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/ExceptionThrowingListener.java",
            "additions": 23,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,23 @@\n+package net.engio.mbassy.listeners;\n+\n+import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.References;\n+import net.engio.mbassy.messages.StandardMessage;\n+\n+/**\n+ * @author bennidi\n+ *         Date: 5/25/13\n+ */\n+@Listener(references = References.Strong)\n+public class ExceptionThrowingListener {\n+\n+\n+    // this handler will be invoked asynchronously\n+    @Handler()\n+    public void handle(StandardMessage message) {\n+        throw new RuntimeException(\"This is an expected exception\");\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/ICountableListener.java",
            "additions": 58,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,58 @@\n+package net.engio.mbassy.listeners;\n+\n+import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.messages.ICountable;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 5/24/13\n+ */\n+public class ICountableListener {\n+\n+    private static abstract class BaseListener {\n+\n+        @Handler\n+        public void handle(ICountable message){\n+            message.handled(this.getClass());\n+        }\n+\n+    }\n+\n+    public static class DefaultListener extends BaseListener {\n+\n+        public void handle(ICountable message){\n+            super.handle(message);\n+        }\n+    }\n+\n+    public static class NoSubtypesListener extends BaseListener {\n+\n+        @Handler(rejectSubtypes = true)\n+        public void handle(ICountable message){\n+            super.handle(message);\n+        }\n+    }\n+\n+\n+    public static class AsyncListener extends BaseListener {\n+\n+        @Handler(delivery = Invoke.Asynchronously)\n+        public void handle(ICountable message){\n+            super.handle(message);\n+        }\n+\n+    }\n+\n+    public static class DisabledListener extends BaseListener {\n+\n+        @Handler(enabled = false)\n+        public void handle(ICountable message){\n+            super.handle(message);\n+        }\n+\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/IMessageListener.java",
            "additions": 58,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,58 @@\n+package net.engio.mbassy.listeners;\n+\n+import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.messages.IMessage;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 5/24/13\n+ */\n+public class IMessageListener {\n+\n+    private static abstract class BaseListener {\n+\n+        @Handler\n+        public void handle(IMessage message){\n+            message.handled(this.getClass());\n+        }\n+\n+    }\n+\n+    public static class DefaultListener extends BaseListener {\n+\n+        public void handle(IMessage message){\n+            super.handle(message);\n+        }\n+    }\n+\n+    public static class NoSubtypesListener extends BaseListener {\n+\n+        @Handler(rejectSubtypes = true)\n+        public void handle(IMessage message){\n+            super.handle(message);\n+        }\n+    }\n+\n+\n+    public static class AsyncListener extends BaseListener {\n+\n+        @Handler(delivery = Invoke.Asynchronously)\n+        public void handle(IMessage message){\n+            super.handle(message);\n+        }\n+\n+    }\n+\n+    public static class DisabledListener extends BaseListener {\n+\n+        @Handler(enabled = false)\n+        public void handle(IMessage message){\n+            super.handle(message);\n+        }\n+\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/IMultipartMessageListener.java",
            "additions": 58,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,58 @@\n+package net.engio.mbassy.listeners;\n+\n+import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.messages.IMultipartMessage;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 5/24/13\n+ */\n+public class IMultipartMessageListener {\n+\n+    private static abstract class BaseListener {\n+\n+        @Handler\n+        public void handle(IMultipartMessage message){\n+            message.handled(this.getClass());\n+        }\n+\n+    }\n+\n+    public static class DefaultListener extends BaseListener {\n+\n+        public void handle(IMultipartMessage message){\n+            super.handle(message);\n+        }\n+    }\n+\n+    public static class NoSubtypesListener extends BaseListener {\n+\n+        @Handler(rejectSubtypes = true)\n+        public void handle(IMultipartMessage message){\n+            super.handle(message);\n+        }\n+    }\n+\n+\n+    public static class AsyncListener extends BaseListener {\n+\n+        @Handler(delivery = Invoke.Asynchronously)\n+        public void handle(IMultipartMessage message){\n+            super.handle(message);\n+        }\n+\n+    }\n+\n+    public static class DisabledListener extends BaseListener {\n+\n+        @Handler(enabled = false)\n+        public void handle(IMultipartMessage message){\n+            super.handle(message);\n+        }\n+\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/ListenerFactory.java",
            "additions": 60,
            "deletions": 16
        },
        "diff content": "@@ -1,13 +1,13 @@\n package net.engio.mbassy.listeners;\n \n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n- * This factory will create a list of beans according to some specified configuration.\n- * It can be used to setup different test scenarios.\n+ * The factory can be used to declaratively specify how many instances of some given classes\n+ * should be created. It will create those instances using reflection and provide a list containing those instances.\n+ * The factory also holds strong references to the instances such that GC will not interfere with tests unless the\n+ * factory is explicitly cleared.\n  *\n  * @author bennidi\n  *         Date: 11/22/12\n@@ -15,24 +15,68 @@ import java.util.Map;\n public class ListenerFactory {\n \n     private Map<Class, Integer> requiredBeans = new HashMap<Class, Integer>();\n+    private List generatedListeners;\n+    private int requiredSize = 0;\n \n+    public int getNumberOfListeners(Class listener){\n+        return requiredBeans.containsKey(listener) ? requiredBeans.get(listener) : 0;\n+    }\n \n-\n-    public ListenerFactory create(int numberOfInstance, Class clazz){\n-        requiredBeans.put(clazz, numberOfInstance);\n+    public ListenerFactory create(int numberOfInstances, Class clazz){\n+        requiredBeans.put(clazz, numberOfInstances);\n+        requiredSize +=numberOfInstances;\n         return this;\n     }\n \n \n-    public List<Object> build() throws Exception{\n-        List<Object> beans = new LinkedList<Object>();\n-        for(Class clazz : requiredBeans.keySet()){\n-            int numberOfRequiredBeans = requiredBeans.get(clazz);\n-            for(int i = 0; i < numberOfRequiredBeans; i++){\n-                beans.add(clazz.newInstance());\n+    public List<Object> getAll(){\n+        generatedListeners = new ArrayList(requiredSize);\n+        try {\n+            for(Class clazz : requiredBeans.keySet()){\n+                int numberOfRequiredBeans = requiredBeans.get(clazz);\n+                for(int i = 0; i < numberOfRequiredBeans; i++){\n+                    generatedListeners.add(clazz.newInstance());\n+                }\n             }\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(e);\n         }\n-        return beans;\n+        Collections.shuffle(generatedListeners);\n+        return generatedListeners;\n+    }\n+\n+    // not thread-safe but not yet used concurrently\n+    public void clear(){\n+        generatedListeners = null;\n+        requiredBeans.clear();\n+    }\n+\n+    /**\n+     * Create a thread-safe read-only iterator\n+     * @return\n+     */\n+    public Iterator iterator(){\n+        if(generatedListeners == null)getAll();\n+        final AtomicInteger current = new AtomicInteger(0);\n+\n+        return new Iterator() {\n+            @Override\n+            public boolean hasNext() {\n+                return current.get() < generatedListeners.size();\n+            }\n+\n+            @Override\n+            public Object next() {\n+                int index =  current.getAndIncrement();\n+                return index < generatedListeners.size() ? generatedListeners.get(index) : null;\n+            }\n+\n+            @Override\n+            public void remove() {\n+                throw new UnsupportedOperationException(\"Iterator is read only\");\n+            }\n+        };\n     }\n \n \n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/MessagesListener.java",
            "additions": 58,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,58 @@\n+package net.engio.mbassy.listeners;\n+\n+import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.messages.MessageTypes;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 5/24/13\n+ */\n+public class MessagesListener {\n+\n+    private static abstract class BaseListener {\n+\n+        @Handler\n+        public void handle(MessageTypes message){\n+            message.handled(this.getClass());\n+        }\n+\n+    }\n+\n+    public static class DefaultListener extends BaseListener {\n+\n+        public void handle(MessageTypes message){\n+            super.handle(message);\n+        }\n+    }\n+\n+    public static class NoSubtypesListener extends BaseListener {\n+\n+        @Handler(rejectSubtypes = true)\n+        public void handle(MessageTypes message){\n+            super.handle(message);\n+        }\n+    }\n+\n+\n+    public static class AsyncListener extends BaseListener {\n+\n+        @Handler(delivery = Invoke.Asynchronously)\n+        public void handle(MessageTypes message){\n+            super.handle(message);\n+        }\n+\n+    }\n+\n+    public static class DisabledListener extends BaseListener {\n+\n+        @Handler(enabled = false)\n+        public void handle(MessageTypes message){\n+            super.handle(message);\n+        }\n+\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/MultipartMessageListener.java",
            "additions": 58,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,58 @@\n+package net.engio.mbassy.listeners;\n+\n+import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.messages.MultipartMessage;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 5/24/13\n+ */\n+public class MultipartMessageListener {\n+\n+    private static abstract class BaseListener {\n+\n+        @Handler\n+        public void handle(MultipartMessage message){\n+            message.handled(this.getClass());\n+        }\n+\n+    }\n+\n+    public static class DefaultListener extends BaseListener {\n+\n+        public void handle(MultipartMessage message){\n+            super.handle(message);\n+        }\n+    }\n+\n+    public static class NoSubtypesListener extends BaseListener {\n+\n+        @Handler(rejectSubtypes = true)\n+        public void handle(MultipartMessage message){\n+            super.handle(message);\n+        }\n+    }\n+\n+\n+    public static class AsyncListener extends BaseListener {\n+\n+        @Handler(delivery = Invoke.Asynchronously)\n+        public void handle(MultipartMessage message){\n+            super.handle(message);\n+        }\n+\n+    }\n+\n+    public static class DisabledListener extends BaseListener {\n+\n+        @Handler(enabled = false)\n+        public void handle(MultipartMessage message){\n+            super.handle(message);\n+        }\n+\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/StandardMessageListener.java",
            "additions": 58,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,58 @@\n+package net.engio.mbassy.listeners;\n+\n+import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.messages.StandardMessage;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 5/24/13\n+ */\n+public class StandardMessageListener {\n+\n+    private static abstract class BaseListener {\n+\n+        @Handler\n+        public void handle(StandardMessage message){\n+            message.handled(this.getClass());\n+        }\n+\n+    }\n+\n+    public static class DefaultListener extends BaseListener {\n+\n+        public void handle(StandardMessage message){\n+            super.handle(message);\n+        }\n+    }\n+\n+    public static class NoSubtypesListener extends BaseListener {\n+\n+        @Handler(rejectSubtypes = true)\n+        public void handle(StandardMessage message){\n+            super.handle(message);\n+        }\n+    }\n+\n+\n+    public static class AsyncListener extends BaseListener {\n+\n+        @Handler(delivery = Invoke.Asynchronously)\n+        public void handle(StandardMessage message){\n+            super.handle(message);\n+        }\n+\n+    }\n+\n+    public static class DisabledListener extends BaseListener {\n+\n+        @Handler(enabled = false)\n+        public void handle(StandardMessage message){\n+            super.handle(message);\n+        }\n+\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/AbstractMessage.java",
            "additions": 55,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,55 @@\n+package net.engio.mbassy.messages;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 5/24/13\n+ */\n+public abstract class AbstractMessage implements IMessage{\n+\n+    private Map<Class, Integer> handledByListener = new HashMap<Class, Integer>();\n+    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+\n+    @Override\n+    public void reset() {\n+        lock.writeLock().lock();\n+        try {\n+            handledByListener.clear();\n+        }finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void handled(Class listener) {\n+        lock.writeLock().lock();\n+        try {\n+            Integer count = handledByListener.get(listener);\n+            if(count == null){\n+                handledByListener.put(listener, 1);\n+            }\n+            else{\n+                handledByListener.put(listener, count + 1);\n+            }\n+        }finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public int getTimesHandled(Class listener) {\n+        lock.readLock().lock();\n+        try {\n+            return handledByListener.containsKey(listener)\n+                ? handledByListener.get(listener)\n+                : 0;\n+        }finally {\n+            lock.readLock().unlock();\n+        }\n+    }\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/CountableMessage.java",
            "additions": 9,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,9 @@\n+package net.engio.mbassy.messages;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 5/24/13\n+ */\n+public class CountableMessage extends AbstractMessage implements ICountable{\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/ICountable.java",
            "additions": 16,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,16 @@\n+package net.engio.mbassy.messages;\n+\n+/**\n+ * Interface analogous to IMessage. Exists to test more complex class/interface hierarchies\n+ *\n+ * @author bennidi\n+ *         Date: 5/24/13\n+ */\n+public interface ICountable {\n+\n+    void reset();\n+\n+    void handled(Class listener);\n+\n+    int getTimesHandled(Class listener);\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/IMessage.java",
            "additions": 16,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,16 @@\n+package net.engio.mbassy.messages;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 5/24/13\n+ */\n+public interface IMessage {\n+\n+    void reset();\n+\n+    void handled(Class listener);\n+\n+    int getTimesHandled(Class listener);\n+\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/IMultipartMessage.java",
            "additions": 9,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,9 @@\n+package net.engio.mbassy.messages;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 5/24/13\n+ */\n+public interface IMultipartMessage extends IMessage, ICountable{\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/ITestMessage.java",
            "additions": 0,
            "deletions": 10
        },
        "diff content": "@@ -1,10 +0,0 @@\n-package net.engio.mbassy.messages;\n-\n-/**\n- * Todo: Add javadoc\n- *\n- * @author bennidi\n- *         Date: 5/12/13\n- */\n-public interface ITestMessage {\n-}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/MessageTypes.java",
            "additions": 62,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,62 @@\n+package net.engio.mbassy.messages;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Enum used to test handlers that consume enumerations.\n+ *\n+ * @author bennidi\n+ *         Date: 5/24/13\n+ */\n+public enum MessageTypes implements IMessage{\n+    Simple,Persistent,Multipart;\n+\n+    public static void resetAll(){\n+        for(MessageTypes m : values())\n+            m.reset();\n+    }\n+\n+    private Map<Class, Integer> handledByListener = new HashMap<Class, Integer>();\n+    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+\n+    @Override\n+    public void reset() {\n+        lock.writeLock().lock();\n+        try {\n+            handledByListener.clear();\n+        }finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void handled(Class listener) {\n+        lock.writeLock().lock();\n+        try {\n+            Integer count = handledByListener.get(listener);\n+            if(count == null){\n+                handledByListener.put(listener, 1);\n+            }\n+            else{\n+                handledByListener.put(listener, count + 1);\n+            }\n+        }finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public int getTimesHandled(Class listener) {\n+        lock.readLock().lock();\n+        try {\n+            return handledByListener.containsKey(listener)\n+                    ? handledByListener.get(listener)\n+                    : 0;\n+        }finally {\n+            lock.readLock().unlock();\n+        }\n+    }\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/MultipartMessage.java",
            "additions": 9,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,9 @@\n+package net.engio.mbassy.messages;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 5/24/13\n+ */\n+public class MultipartMessage extends AbstractMessage implements IMultipartMessage, ICountable{\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/StandardMessage.java",
            "additions": 8,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,8 @@\n+package net.engio.mbassy.messages;\n+\n+/**\n+ * @author bennidi\n+ *         Date: 5/24/13\n+ */\n+public class StandardMessage extends AbstractMessage implements ICountable{\n+}\n"
    },
    {
        "commit hash": "6100c657187dd654474fe2db2badab7876f919b7",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/TestMessage3.java",
            "additions": 0,
            "deletions": 10
        },
        "diff content": "@@ -1,10 +0,0 @@\n-package net.engio.mbassy.messages;\r\n-\r\n-/**\r\n- * A test message that uses an interface\r\n- * \r\n- * @author durron597\r\n- */\r\n-public class TestMessage3 implements ITestMessage {\r\n-\r\n-}\r\n"
    },
    {
        "commit hash": "b50b25bf210861948025be47be5f9962bf8e6f8f",
        "previous commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/WeakConcurrentSetTest.java",
            "additions": 10,
            "deletions": 7
        },
        "diff content": "@@ -9,7 +9,7 @@ import java.util.HashSet;\n import java.util.Random;\n \n /**\n- * Todo: Add javadoc\n+ *\n  *\n  * @author bennidi\n  *         Date: 3/29/13\n@@ -21,12 +21,11 @@ public class WeakConcurrentSetTest extends ConcurrentSetTest{\n         return new WeakConcurrentSet();\n     }\n \n-    //@Ignore(\"Currently fails when building as a suite with JDK 1.7.0_15 and Maven 3.0.5 on a Mac\")\n     @Test\n     public void testIteratorCleanup() {\n \n         // Assemble\n-        final HashSet<Object> persistingCandidates = new HashSet<Object>();\n+        final HashSet<Object> permanentElements = new HashSet<Object>();\n         final IConcurrentSet testSetWeak = createSet();\n         final Random rand = new Random();\n \n@@ -34,13 +33,13 @@ public class WeakConcurrentSetTest extends ConcurrentSetTest{\n             Object candidate = new Object();\n \n             if (rand.nextInt() % 3 == 0) {\n-                persistingCandidates.add(candidate);\n+                permanentElements.add(candidate);\n             }\n             testSetWeak.add(candidate);\n         }\n \n         // Remove/Garbage collect all objects that have not\n-        // been inserted into the set of persisting candidates.\n+        // been inserted into the set of permanent candidates.\n         runGC();\n \n         ConcurrentExecutor.runConcurrent(new Runnable() {\n@@ -54,9 +53,13 @@ public class WeakConcurrentSetTest extends ConcurrentSetTest{\n             }\n         }, numberOfThreads);\n \n-        assertEquals(persistingCandidates.size(), testSetWeak.size());\n+        // the set should have cleaned up the garbage collected elements\n+        // it must still contain all of the permanent objects\n+        // since different GC mechanisms can be used (not necessarily full, stop-the-world) not all dead objects\n+        // must have been collected\n+        assertTrue(permanentElements.size() <= testSetWeak.size() && testSetWeak.size() < numberOfElements);\n         for (Object test : testSetWeak) {\n-            assertTrue(persistingCandidates.contains(test));\n+            assertTrue(permanentElements.contains(test));\n         }\n     }\n \n"
    },
    {
        "commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "previous commit hash": "0a7ed2e651b04756ff210eacb68671d5cd0c2f2b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -33,8 +33,8 @@ public class MessageListenerMetadata<T> {\n     private Listener listenerAnnotation;\n \n     public MessageListenerMetadata(Class<T> listenerDefinition) {\n-        this.listenerDefinition = listenerDefinition;\n-        Listener listenerAnnotation = listenerDefinition.getAnnotation(Listener.class);\n+       this.listenerDefinition = listenerDefinition;\n+       listenerAnnotation = listenerDefinition.getAnnotation(Listener.class);\n     }\n \n \n"
    },
    {
        "commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "previous commit hash": "0a7ed2e651b04756ff210eacb68671d5cd0c2f2b",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -28,7 +28,7 @@ public class SubscriptionFactory {\n             SubscriptionContext context = new SubscriptionContext(bus, handlerMetadata);\n             IHandlerInvocation invocation = buildInvocationForHandler(context);\n             IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n-            return new Subscription(context, dispatcher, context.getHandlerMetadata().useStrongReferences()\n+            return new Subscription(context, dispatcher, handlerMetadata.useStrongReferences()\n                 ? new StrongConcurrentSet<Object>()\n                 : new WeakConcurrentSet<Object>());\n         } catch (Exception e) {\n"
    },
    {
        "commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "previous commit hash": "0a7ed2e651b04756ff210eacb68671d5cd0c2f2b",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConcurrentSetTest.java",
            "additions": 20,
            "deletions": 47
        },
        "diff content": "@@ -65,37 +65,9 @@ public abstract class ConcurrentSetTest extends UnitTest {\n         }\n     }\n \n-    @Test\n-    public void testPerformance() {\n-        final HashSet<Object> source = new HashSet<Object>();\n-\n-        final HashSet<Object> hashSet = new HashSet<Object>();\n-\n-        final IConcurrentSet weakConcurrentSet = createSet();\n-\n-        for (int i = 0; i < 1000000; i++) {\n-            source.add(new Object());\n-        }\n-\n-\n-        long start = System.currentTimeMillis();\n-        for (Object o : source) {\n-            hashSet.add(o);\n-        }\n-        long duration = System.currentTimeMillis() - start;\n-        System.out.println(\"Performance of HashSet for 1.000.000 object insertions \" + duration);\n-\n-        start = System.currentTimeMillis();\n-        for (Object o : source) {\n-            weakConcurrentSet.add(o);\n-        }\n-        duration = System.currentTimeMillis() - start;\n-        System.out.println(\"Performance of ConcurrentSet for 1.000.000 object insertions \" + duration);\n-    }\n-\n \n     @Test\n-    public void testRemove2() {\n+    public void testRandomRemoval() {\n         final HashSet<Object> source = new HashSet<Object>();\n         final HashSet<Object> toRemove = new HashSet<Object>();\n \n@@ -142,7 +114,7 @@ public abstract class ConcurrentSetTest extends UnitTest {\n     }\n \n     @Test\n-    public void testRemoval() {\n+    public void testRemovalOfHead() {\n         final HashSet<Object> source = new HashSet<Object>();\n         final HashSet<Object> toRemove = new HashSet<Object>();\n \n@@ -259,34 +231,36 @@ public abstract class ConcurrentSetTest extends UnitTest {\n      */\n     @Test\n     public void testConcurrentAddRemove() {\n-        final IConcurrentSet set = createSet();\n-        final List permanentObjects = createWithRandomIntegers(80, null);\n-        final List volatileObjects = createWithRandomIntegers(10000, permanentObjects);\n+        final IConcurrentSet testSet = createSet();\n+        // a set of unique integers that will stay permanently in the test set\n+        final List permanentObjects = new ArrayList();\n+        // a set of objects that will be added and removed at random to the test set to force rehashing\n+        final List volatileObjects = new ArrayList();\n+        permanentObjects.addAll(createWithRandomIntegers(80, null));\n+        volatileObjects.addAll(createWithRandomIntegers(10000, permanentObjects));\n         final CopyOnWriteArraySet missing = new CopyOnWriteArraySet();\n         final int mutatorThreshold = 1000;\n \n         // Add elements that will not be touched by the constantly running mutating thread\n-        final int numItems = 8;\n         for (Object permanent : permanentObjects) {\n-            set.add(permanent);\n+            testSet.add(permanent);\n         }\n \n-        // Adds and removes items >= numItems\n+        // Adds and removes items\n         // thus forcing constant rehashing of the backing hashtable\n         Runnable updatingThread = new Runnable() {\n             public void run() {\n                 Random rand = new Random();\n                 for(int times = 0; times < 1000 ; times++){\n-                    System.out.println(\"New mutator cycle: \" + times);\n                     HashSet elements = new HashSet(mutatorThreshold);\n \n-                    for (int i = numItems; i < mutatorThreshold; i++) {\n+                    for (int i = 0; i < mutatorThreshold; i++) {\n                         Object volatileObject = volatileObjects.get(Math.abs(rand.nextInt()) % volatileObjects.size());\n-                        set.add(volatileObject);\n+                        testSet.add(volatileObject);\n                         elements.add(volatileObject);\n                     }\n                     for (Object volObj : elements) {\n-                        set.remove(volObj);\n+                        testSet.remove(volObj);\n                     }\n                 }\n             };\n@@ -296,11 +270,10 @@ public abstract class ConcurrentSetTest extends UnitTest {\n             @Override\n             public void run() {\n                 for (int i = 0; i < 10000; i++) {\n-                    System.out.println(\"New lookup cycle: \" + i);\n                     for (Object permanent : permanentObjects) {\n                         // permanent items are never touched,\n                         // --> set.contains(j) should always return true\n-                        if(!set.contains(permanent))\n+                        if(!testSet.contains(permanent))\n                             missing.add(permanent);\n                     }\n                 }\n@@ -313,14 +286,14 @@ public abstract class ConcurrentSetTest extends UnitTest {\n     }\n \n \n-    public List createWithRandomIntegers(int size, List<Integer> exluding){\n-        if(exluding == null) exluding = new ArrayList<Integer>();\n-        List<Integer> result = new ArrayList<Integer>(size);\n+    public Set createWithRandomIntegers(int size, List<Integer> excluding){\n+        if(excluding == null) excluding = new ArrayList<Integer>();\n+        Set<Integer> result = new HashSet<Integer>(size);\n         Random rand = new Random();\n-        for(int i = 0; i < size;i++){\n+        while(result.size() < size){\n             result.add(rand.nextInt());\n         }\n-        for(Integer excluded : exluding)\n+        for(Integer excluded : excluding)\n             result.remove(excluded);\n         return result;\n     }\n"
    },
    {
        "commit hash": "55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9",
        "previous commit hash": "0a7ed2e651b04756ff210eacb68671d5cd0c2f2b",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/ConcurrentExecutor.java",
            "additions": 0,
            "deletions": 11
        },
        "diff content": "@@ -51,17 +51,6 @@ public class ConcurrentExecutor {\n \t\t\t// unlikely that this will happen\n \t\t\te.printStackTrace();\n \t\t}\n-\n-\t\t// print results\n-\t\tfor (Future<Long> result : returnValues)\n-\t\t\ttry {\n-\t\t\t\tSystem.out.println(\"Execution of unit of work to \" + result.get() + \"ms.\");\n-\t\t\t} catch (Exception e) {\n-\t\t\t\t//should never happen\n-\t\t\t\t// since the code waits until all tasks are processed\n-\t\t\t\te.printStackTrace();\n-\t\t\t}\n-\n \t}\n \n \n"
    },
    {
        "commit hash": "0a7ed2e651b04756ff210eacb68671d5cd0c2f2b",
        "previous commit hash": "e5b13ba8e6ea5fbdf8de1c8858e060059778c886",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -27,7 +27,7 @@ public class Subscription {\n         this.listeners = listeners;\n     }\n \n-    public boolean isFromListener(Class listener){\n+    public boolean belongsTo(Class listener){\n         return context.getHandlerMetadata().isFromListener(listener);\n     }\n \n"
    },
    {
        "commit hash": "0a7ed2e651b04756ff210eacb68671d5cd0c2f2b",
        "previous commit hash": "e5b13ba8e6ea5fbdf8de1c8858e060059778c886",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 14,
            "deletions": 23
        },
        "diff content": "@@ -13,7 +13,6 @@ import net.engio.mbassy.subscription.SubscriptionManager;\n import org.junit.Test;\n \n import java.util.*;\n-import java.util.concurrent.ConcurrentHashMap;\n \n /**\n  * Todo: Add javadoc\n@@ -30,7 +29,7 @@ public class SubscriptionManagerTest extends UnitTest{\n         final Set listeners = Collections.synchronizedSet(new HashSet());\n         final int concurrentUnits = 5;\n         final int numberOfLoops = 100;\n-        final int numberOfListeners =  numberOfLoops * concurrentUnits * 2;\n+        final int numberOfListeners =  numberOfLoops * concurrentUnits;\n \n         ConcurrentExecutor.runConcurrent(new Runnable() {\n             @Override\n@@ -48,26 +47,14 @@ public class SubscriptionManagerTest extends UnitTest{\n             }\n         }, concurrentUnits);\n \n+        SubscriptionValidator validator = new SubscriptionValidator();\n+        validator.expect(numberOfListeners, SimpleSynchronousMessageHandler.class, ITestMessage.class);\n+        validator.expect(numberOfListeners, SimpleSynchronousMessageHandler2.class, ITestMessage.class);\n+        validator.expect(numberOfListeners, SimpleSynchronousMessageHandler.class, TestMessage.class);\n+        validator.expect(numberOfListeners, SimpleSynchronousMessageHandler2.class, TestMessage.class);\n \n-        Collection<Subscription> subscriptions = subMan.getSubscriptionsByMessageType(TestMessage.class);\n-        assertEquals(2, subscriptions.size());\n+        validator.validate(subMan);\n \n-        for(Subscription sub : subscriptions){\n-            assertEquals(numberOfListeners, sub.size());\n-            for(Object listener : listeners){\n-\n-                if(sub.isFromListener(listener))assertTrue(sub.contains(listener));\n-            }\n-        }\n-\n-        subscriptions = subMan.getSubscriptionsByMessageType(ITestMessage.class);\n-        assertEquals(2, subscriptions.size());\n-        for(Subscription sub : subscriptions){\n-            assertEquals(numberOfListeners, sub.size());\n-            for(Object listener : listeners){\n-                if(sub.isFromListener(listener))assertTrue(sub.contains(listener));\n-            }\n-        }\n     }\n \n \n@@ -93,13 +80,17 @@ public class SubscriptionManagerTest extends UnitTest{\n                 assertEquals(subscriptions.size(), validationEntries.size());\n                 for(Entry validationEntry : validationEntries){\n                     Subscription matchingSub = null;\n+                    // one of the subscriptions must belong to the subscriber type\n                     for(Subscription sub : subscriptions){\n-                        if(sub.isFromListener(validationEntry.subscriber));\n+                        if(sub.belongsTo(validationEntry.subscriber)){\n+                            matchingSub = sub;\n+                            break;\n+                        }\n                     }\n+                    assertNotNull(matchingSub);\n+                    assertEquals(validationEntry.numberOfSubscribers, matchingSub.size());\n                 }\n             }\n-\n-\n         }\n \n \n"
    },
    {
        "commit hash": "a6462b4d174f124e05aef1b98f9c64494a1fd7bb",
        "previous commit hash": "7c08bd02993694b115474f63ba0b3f91f0beeaab",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ReflectionUtils.java",
            "additions": 6,
            "deletions": 17
        },
        "diff content": "@@ -1,9 +1,7 @@\n package net.engio.mbassy.common;\n \n import java.lang.reflect.Method;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n+import java.util.*;\n \n /**\n  * @author bennidi\n@@ -50,27 +48,18 @@ public class ReflectionUtils {\n         return null;\n     }\n \n-    public static List<Method> withoutOverridenSuperclassMethods(final List<Method> allMethods) {\n-        List<Method> filtered = new LinkedList<Method>();\n-        for (Method method : allMethods) {\n-            if (!containsOverridingMethod(allMethods, method)) {\n-                filtered.add(method);\n-            }\n-        }\n-        return filtered;\n-    }\n-\n-    public static Collection<Class> getSuperclasses(Class from) {\n-        Collection<Class> superclasses = new LinkedList<Class>();\n+    public static Set<Class> getSuperclasses(Class from) {\n+        Set<Class> superclasses = new HashSet<Class>();\n+        collectInterfaces(from, superclasses);\n         while (!from.equals(Object.class) && !from.isInterface()) {\n             superclasses.add(from.getSuperclass());\n-            collectInterfaces(from, superclasses);\n+\n             from = from.getSuperclass();\n         }\n         return superclasses;\n     }\n \n-    public static void collectInterfaces(Class from, Collection<Class> accumulator){\n+    public static void collectInterfaces(Class from, Set<Class> accumulator){\n         for(Class intface : from.getInterfaces()){\n             accumulator.add(intface);\n             collectInterfaces(intface, accumulator);\n"
    },
    {
        "commit hash": "a6462b4d174f124e05aef1b98f9c64494a1fd7bb",
        "previous commit hash": "7c08bd02993694b115474f63ba0b3f91f0beeaab",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -63,7 +63,7 @@ public class MessageHandlerMetadata {\n         return listenerConfig.useStrongReferences();\n     }\n \n-    public boolean isFromListener(Object listener){\n+    public boolean isFromListener(Class listener){\n         return listenerConfig.isFromListener(listener);\n     }\n \n"
    },
    {
        "commit hash": "a6462b4d174f124e05aef1b98f9c64494a1fd7bb",
        "previous commit hash": "7c08bd02993694b115474f63ba0b3f91f0beeaab",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -38,8 +38,8 @@ public class MessageListenerMetadata<T> {\n     }\n \n \n-    public boolean isFromListener(Object listener){\n-        return listenerDefinition.equals(listener.getClass());\n+    public boolean isFromListener(Class listener){\n+        return listenerDefinition.equals(listener);\n     }\n \n     public boolean useStrongReferences(){\n"
    },
    {
        "commit hash": "a6462b4d174f124e05aef1b98f9c64494a1fd7bb",
        "previous commit hash": "7c08bd02993694b115474f63ba0b3f91f0beeaab",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -27,7 +27,7 @@ public class Subscription {\n         this.listeners = listeners;\n     }\n \n-    public boolean isFromListener(Object listener){\n+    public boolean isFromListener(Class listener){\n         return context.getHandlerMetadata().isFromListener(listener);\n     }\n \n"
    },
    {
        "commit hash": "a6462b4d174f124e05aef1b98f9c64494a1fd7bb",
        "previous commit hash": "7c08bd02993694b115474f63ba0b3f91f0beeaab",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 83,
            "deletions": 4
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy;\n \n import net.engio.mbassy.common.ConcurrentExecutor;\n+import net.engio.mbassy.common.IPredicate;\n import net.engio.mbassy.common.UnitTest;\n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.MetadataReader;\n@@ -11,10 +12,7 @@ import net.engio.mbassy.subscription.SubscriptionFactory;\n import net.engio.mbassy.subscription.SubscriptionManager;\n import org.junit.Test;\n \n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.*;\n import java.util.concurrent.ConcurrentHashMap;\n \n /**\n@@ -25,6 +23,7 @@ import java.util.concurrent.ConcurrentHashMap;\n  */\n public class SubscriptionManagerTest extends UnitTest{\n \n+\n     @Test\n     public void testSimpleSynchronousHandler(){\n         final SubscriptionManager subMan = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n@@ -72,6 +71,86 @@ public class SubscriptionManagerTest extends UnitTest{\n     }\n \n \n+    class SubscriptionValidator{\n+\n+\n+        private List<Entry> validations = new LinkedList<Entry>();\n+        private Set<Class> messageTypes = new HashSet<Class>();\n+        private Set<Class> subsribers = new HashSet<Class>();\n+\n+\n+        public SubscriptionValidator expect(int numberOfSubscriber, Class subscriber, Class messageType){\n+            validations.add(new Entry(messageType, numberOfSubscriber, subscriber));\n+            messageTypes.add(messageType);\n+            subsribers.add(subscriber);\n+            return this;\n+        }\n+\n+        public void validate(SubscriptionManager manager){\n+            for(Class messageType : messageTypes){\n+                Collection<Subscription> subscriptions = manager.getSubscriptionsByMessageType(messageType);\n+                Collection<Entry> validationEntries = getEntries(EntriesByMessageType(messageType));\n+                assertEquals(subscriptions.size(), validationEntries.size());\n+                for(Entry validationEntry : validationEntries){\n+                    Subscription matchingSub = null;\n+                    for(Subscription sub : subscriptions){\n+                        if(sub.isFromListener(validationEntry.subscriber));\n+                    }\n+                }\n+            }\n+\n+\n+        }\n+\n+\n+        private Collection<Entry> getEntries(IPredicate<Entry> filter){\n+            Collection<Entry> matching = new LinkedList<Entry>();\n+            for (Entry validationEntry : validations){\n+                if(filter.apply(validationEntry))matching.add(validationEntry);\n+            }\n+            return matching;\n+        }\n+\n+        private IPredicate<Entry> EntriesByMessageType(final Class messageType){\n+            return new IPredicate<Entry>() {\n+                @Override\n+                public boolean apply(Entry target) {\n+                    return target.messageType.equals(messageType);\n+                }\n+            };\n+        }\n+\n+        private IPredicate<Entry> EntriesBySubscriberType(final Class subscriberType){\n+            return new IPredicate<Entry>() {\n+                @Override\n+                public boolean apply(Entry target) {\n+                    return target.subscriber.equals(subscriberType);\n+                }\n+            };\n+        }\n+\n+\n+\n+        private class Entry{\n+\n+            private int numberOfSubscribers;\n+\n+            private Class subscriber;\n+\n+            private Class messageType;\n+\n+            private Entry(Class messageType, int numberOfSubscribers, Class subscriber) {\n+                this.messageType = messageType;\n+                this.numberOfSubscribers = numberOfSubscribers;\n+                this.subscriber = subscriber;\n+            }\n+\n+\n+        }\n+\n+    }\n+\n+\n     static class SimpleSynchronousMessageHandler{\n \n         @Handler\n"
    },
    {
        "commit hash": "1e445adb0450056511e1ee3cbd16fa9147d394be",
        "previous commit hash": "16f92eee06c54530221af77a97eff21b55588ee0",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java",
            "additions": 6,
            "deletions": 6
        },
        "diff content": "@@ -28,18 +28,18 @@ public class MessageListenerMetadata<T> {\n \n     private List<MessageHandlerMetadata> handlers = new ArrayList<MessageHandlerMetadata>();\n \n-    private Class<T> listenerDefinition;\n+    private Class<T> listenerClass;\n \n     private Listener listenerAnnotation;\n \n-    public MessageListenerMetadata(Class<T> listenerDefinition) {\n-        this.listenerDefinition = listenerDefinition;\n-        Listener listenerAnnotation = listenerDefinition.getAnnotation(Listener.class);\n+    public MessageListenerMetadata(Class<T> listenerClass) {\n+        this.listenerClass = listenerClass;\n+        this.listenerAnnotation = listenerClass.getAnnotation(Listener.class);\n     }\n \n \n     public boolean isFromListener(Object listener){\n-        return listenerDefinition.equals(listener.getClass());\n+        return listenerClass.equals(listener.getClass());\n     }\n \n     public boolean useStrongReferences(){\n@@ -74,6 +74,6 @@ public class MessageListenerMetadata<T> {\n     }\n \n     public Class<T> getListerDefinition() {\n-        return listenerDefinition;\n+        return listenerClass;\n     }\n }\n"
    },
    {
        "commit hash": "1e445adb0450056511e1ee3cbd16fa9147d394be",
        "previous commit hash": "16f92eee06c54530221af77a97eff21b55588ee0",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/InterfaceTest.java",
            "additions": 0,
            "deletions": 36
        },
        "diff content": "@@ -1,36 +0,0 @@\n-package net.engio.mbassy;\r\n-\r\n-import net.engio.mbassy.bus.BusConfiguration;\r\n-import net.engio.mbassy.bus.MBassador;\r\n-import net.engio.mbassy.common.DeadMessage;\r\n-import net.engio.mbassy.listener.Handler;\r\n-import net.engio.mbassy.messages.ITestMessage;\r\n-import net.engio.mbassy.messages.TestMessage3;\r\n-\r\n-import org.junit.Assert;\r\n-import org.junit.Test;\r\n-\r\n-/**\r\n- * A test to make sure that Interface subscriptions are working correctly\r\n- * \r\n- * @author durron597\r\n- */\r\n-public class InterfaceTest {\r\n-\t@Test\r\n-\tpublic void testMBassador() {\r\n-\t\tMBassador<ITestMessage> bus = new MBassador<ITestMessage>(BusConfiguration.Default());\r\n-\t\tbus.subscribe(this);\r\n-\t\tTestMessage3 myFoo = new TestMessage3();\r\n-\t\tbus.publish(myFoo);\r\n-\t}\r\n-\r\n-\t@Handler\r\n-\tpublic void handleFoo(ITestMessage f) {\r\n-\t\tAssert.assertTrue(f instanceof TestMessage3);\r\n-\t}\r\n-\t\r\n-\t@Handler\r\n-\tpublic void handleDead(DeadMessage d) {\r\n-\t\tAssert.fail(\"This class should handle this message appropriately!\");\r\n-\t}\r\n-}\r\n"
    },
    {
        "commit hash": "1e445adb0450056511e1ee3cbd16fa9147d394be",
        "previous commit hash": "16f92eee06c54530221af77a97eff21b55588ee0",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 24,
            "deletions": 5
        },
        "diff content": "@@ -6,6 +6,7 @@ import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.messages.ITestMessage;\n import net.engio.mbassy.messages.TestMessage;\n+import net.engio.mbassy.messages.TestMessage3;\n import net.engio.mbassy.subscription.Subscription;\n import net.engio.mbassy.subscription.SubscriptionFactory;\n import net.engio.mbassy.subscription.SubscriptionManager;\n@@ -15,7 +16,6 @@ import java.util.Collection;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n \n /**\n  * Todo: Add javadoc\n@@ -54,17 +54,25 @@ public class SubscriptionManagerTest extends UnitTest{\n         assertEquals(2, subscriptions.size());\n \n         for(Subscription sub : subscriptions){\n-            assertEquals(numberOfListeners, sub.size());\n+            assertEquals(numberOfListeners / 2, sub.size());\n             for(Object listener : listeners){\n-\n                 if(sub.isFromListener(listener))assertTrue(sub.contains(listener));\n             }\n         }\n \n         subscriptions = subMan.getSubscriptionsByMessageType(ITestMessage.class);\n-        assertEquals(2, subscriptions.size());\n+        assertEquals(2 , subscriptions.size());\n         for(Subscription sub : subscriptions){\n-            assertEquals(numberOfListeners, sub.size());\n+            assertEquals(numberOfListeners / 2, sub.size());\n+            for(Object listener : listeners){\n+                if(sub.isFromListener(listener))assertTrue(sub.contains(listener));\n+            }\n+        }\n+\n+        subscriptions = subMan.getSubscriptionsByMessageType(TestMessage3.class);\n+        assertEquals(4 , subscriptions.size());\n+        for(Subscription sub : subscriptions){\n+            assertEquals(numberOfListeners / 2, sub.size());\n             for(Object listener : listeners){\n                 if(sub.isFromListener(listener))assertTrue(sub.contains(listener));\n             }\n@@ -72,6 +80,9 @@ public class SubscriptionManagerTest extends UnitTest{\n     }\n \n \n+\n+\n+\n     static class SimpleSynchronousMessageHandler{\n \n         @Handler\n@@ -81,6 +92,10 @@ public class SubscriptionManagerTest extends UnitTest{\n         @Handler\n         public void handle(ITestMessage message) {\n         }\n+\n+        @Handler\n+        public void handle(TestMessage3 message) {\n+        }\n     }\n \n \n@@ -93,5 +108,9 @@ public class SubscriptionManagerTest extends UnitTest{\n         @Handler\n         public void handle(ITestMessage message) {\n         }\n+\n+        @Handler\n+        public void handle(TestMessage3 message) {\n+        }\n     }\n }\n"
    },
    {
        "commit hash": "1e445adb0450056511e1ee3cbd16fa9147d394be",
        "previous commit hash": "16f92eee06c54530221af77a97eff21b55588ee0",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 28,
            "deletions": 1
        },
        "diff content": "@@ -1,14 +1,18 @@\n package net.engio.mbassy;\n \n import net.engio.mbassy.bus.*;\n+import net.engio.mbassy.common.DeadMessage;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.common.TestUtil;\n import net.engio.mbassy.dispatch.HandlerInvocation;\n+import net.engio.mbassy.messages.ITestMessage;\n import net.engio.mbassy.messages.SubTestMessage;\n import net.engio.mbassy.messages.TestMessage;\n import net.engio.mbassy.listener.*;\n import net.engio.mbassy.listeners.*;\n+import net.engio.mbassy.messages.TestMessage3;\n import net.engio.mbassy.subscription.SubscriptionContext;\n+import org.junit.Assert;\n import org.junit.Test;\n \n import java.util.List;\n@@ -61,7 +65,6 @@ public abstract class SyncBusTest extends MessageBusTest {\n \n         ISyncMessageBus bus = getSyncMessageBus();\n \n-\n         for(int i = 0; i< 10000; i++){\n             bus.subscribe(new MessageListener2());\n         }\n@@ -84,6 +87,30 @@ public abstract class SyncBusTest extends MessageBusTest {\n     protected abstract ISyncMessageBus getSyncMessageBus();\n \n \n+\n+    @Test\n+    public void testHandlerUsingInterface() {\n+        MBassador<ITestMessage> bus = new MBassador<ITestMessage>(BusConfiguration.Default());\n+        bus.subscribe(new InterfaceMessageListener());\n+        bus.publish(new TestMessage3());\n+    }\n+\n+    @Listener(references = References.Strong)\n+    static class InterfaceMessageListener{\n+\n+    @Handler\n+    public void handleFoo(ITestMessage f) {\n+        Assert.assertTrue(f instanceof TestMessage3);\n+    }\n+\n+    @Handler\n+    public void handleDead(DeadMessage d) {\n+        Assert.fail(\"This class should handle this message appropriately!\");\n+    }\n+\n+    }\n+\n+\n     public static class MessageListener1 {\n \n         // every event of type TestEvent or any subtype will be delivered\n"
    },
    {
        "commit hash": "7c08bd02993694b115474f63ba0b3f91f0beeaab",
        "previous commit hash": "2ecefc9b0413d5d02890d992faf43719ee058064",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MessagePublication.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -37,7 +37,7 @@ public class MessagePublication {\n \n     private ISyncMessageBus bus;\n \n-    public MessagePublication(ISyncMessageBus bus, Collection<Subscription> subscriptions, Object message, State initialState) {\n+    protected MessagePublication(ISyncMessageBus bus, Collection<Subscription> subscriptions, Object message, State initialState) {\n         this.bus = bus;\n         this.subscriptions = subscriptions;\n         this.message = message;\n"
    },
    {
        "commit hash": "7c08bd02993694b115474f63ba0b3f91f0beeaab",
        "previous commit hash": "2ecefc9b0413d5d02890d992faf43719ee058064",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ReflectionUtils.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -64,9 +64,9 @@ public class ReflectionUtils {\n         Collection<Class> superclasses = new LinkedList<Class>();\n         while (!from.equals(Object.class) && !from.isInterface()) {\n             superclasses.add(from.getSuperclass());\n+            collectInterfaces(from, superclasses);\n             from = from.getSuperclass();\n         }\n-        collectInterfaces(from, superclasses);\n         return superclasses;\n     }\n \n"
    },
    {
        "commit hash": "7c08bd02993694b115474f63ba0b3f91f0beeaab",
        "previous commit hash": "2ecefc9b0413d5d02890d992faf43719ee058064",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java",
            "additions": 9,
            "deletions": 3
        },
        "diff content": "@@ -26,12 +26,14 @@ public class MessageHandlerMetadata {\n \n     private final boolean acceptsSubtypes;\n \n-    private final Listener listenerConfig;\n+    private final MessageListenerMetadata listenerConfig;\n \n     private final boolean isSynchronized;\n \n+    private Class listeningClass;\n \n-    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Handler handlerConfig, Listener listenerConfig) {\n+\n+    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Handler handlerConfig, MessageListenerMetadata listenerConfig) {\n         if(handler == null || handlerConfig == null){\n             throw new IllegalArgumentException(\"The message handler configuration may not be null\");\n         }\n@@ -58,7 +60,11 @@ public class MessageHandlerMetadata {\n     }\n \n     public boolean useStrongReferences(){\n-        return listenerConfig != null && listenerConfig.references().equals(References.Strong);\n+        return listenerConfig.useStrongReferences();\n+    }\n+\n+    public boolean isFromListener(Object listener){\n+        return listenerConfig.isFromListener(listener);\n     }\n \n     public boolean isAsynchronous() {\n"
    },
    {
        "commit hash": "7c08bd02993694b115474f63ba0b3f91f0beeaab",
        "previous commit hash": "2ecefc9b0413d5d02890d992faf43719ee058064",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java",
            "additions": 28,
            "deletions": 3
        },
        "diff content": "@@ -2,6 +2,8 @@ package net.engio.mbassy.listener;\n \n import net.engio.mbassy.common.IPredicate;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.LinkedList;\n import java.util.List;\n \n@@ -24,15 +26,38 @@ public class MessageListenerMetadata<T> {\n         };\n     }\n \n-    private List<MessageHandlerMetadata> handlers;\n+    private List<MessageHandlerMetadata> handlers = new ArrayList<MessageHandlerMetadata>();\n \n     private Class<T> listenerDefinition;\n \n-    public MessageListenerMetadata(List<MessageHandlerMetadata> handlers, Class<T> listenerDefinition) {\n-        this.handlers = handlers;\n+    private Listener listenerAnnotation;\n+\n+    public MessageListenerMetadata(Class<T> listenerDefinition) {\n         this.listenerDefinition = listenerDefinition;\n+        Listener listenerAnnotation = listenerDefinition.getAnnotation(Listener.class);\n+    }\n+\n+\n+    public boolean isFromListener(Object listener){\n+        return listenerDefinition.equals(listener.getClass());\n+    }\n+\n+    public boolean useStrongReferences(){\n+        return listenerAnnotation != null && listenerAnnotation.references().equals(References.Strong);\n     }\n \n+    public MessageListenerMetadata addHandlers(Collection<? extends MessageHandlerMetadata> c) {\n+        handlers.addAll(c);\n+        return this;\n+    }\n+\n+    public boolean addHandler(MessageHandlerMetadata messageHandlerMetadata) {\n+        return handlers.add(messageHandlerMetadata);\n+    }\n+\n+    public List<MessageHandlerMetadata> getHandlers(){\n+        return handlers;\n+    }\n \n     public List<MessageHandlerMetadata> getHandlers(IPredicate<MessageHandlerMetadata> filter) {\n         List<MessageHandlerMetadata> matching = new LinkedList<MessageHandlerMetadata>();\n"
    },
    {
        "commit hash": "7c08bd02993694b115474f63ba0b3f91f0beeaab",
        "previous commit hash": "2ecefc9b0413d5d02890d992faf43719ee058064",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MetadataReader.java",
            "additions": 5,
            "deletions": 13
        },
        "diff content": "@@ -45,7 +45,6 @@ public class MetadataReader {\n                 } catch (Exception e) {\n                     throw new RuntimeException(e);// propagate as runtime exception\n                 }\n-\n             }\n             filters[i] = filter;\n             i++;\n@@ -54,13 +53,10 @@ public class MetadataReader {\n     }\n \n \n-\n-\n     // get all listeners defined by the given class (includes\n     // listeners defined in super classes)\n-    public List<MessageHandlerMetadata> getMessageHandlers(Object listener) {\n-        Class<?> target = listener.getClass();\n-        Listener listenerConfig = target.getAnnotation(Listener.class);\n+    public MessageListenerMetadata getMessageListener(Class target) {\n+        MessageListenerMetadata listenerMetadata = new MessageListenerMetadata(target);\n         // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n         List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n         // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n@@ -71,7 +67,6 @@ public class MetadataReader {\n             }\n         }\n \n-        List<MessageHandlerMetadata> filteredHandlers = new LinkedList<MessageHandlerMetadata>();\n         // for each handler there will be no overriding method that specifies @Handler annotation\n         // but an overriding method does inherit the listener configuration of the overwritten method\n         for (Method handler : bottomMostHandlers) {\n@@ -82,17 +77,14 @@ public class MetadataReader {\n             Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n             // if a handler is overwritten it inherits the configuration of its parent method\n             MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n-                    getFilter(handlerConfig), handlerConfig, listenerConfig);\n-            filteredHandlers.add(handlerMetadata);\n+                    getFilter(handlerConfig), handlerConfig, listenerMetadata);\n+            listenerMetadata.addHandler(handlerMetadata);\n \n         }\n-        return filteredHandlers;\n+        return listenerMetadata;\n     }\n \n \n-    public <T> MessageListenerMetadata<T> getMessageListener(Object listener) {\n-        return new MessageListenerMetadata(getMessageHandlers(listener), listener.getClass());\n-    }\n \n \n     private boolean isValidMessageHandler(Method handler) {\n"
    },
    {
        "commit hash": "7c08bd02993694b115474f63ba0b3f91f0beeaab",
        "previous commit hash": "2ecefc9b0413d5d02890d992faf43719ee058064",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 4,
            "deletions": 0
        },
        "diff content": "@@ -27,6 +27,10 @@ public class Subscription {\n         this.listeners = listeners;\n     }\n \n+    public boolean isFromListener(Object listener){\n+        return context.getHandlerMetadata().isFromListener(listener);\n+    }\n+\n     public boolean contains(Object listener){\n         return listeners.contains(listener);\n     }\n"
    },
    {
        "commit hash": "7c08bd02993694b115474f63ba0b3f91f0beeaab",
        "previous commit hash": "2ecefc9b0413d5d02890d992faf43719ee058064",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -82,7 +82,7 @@ public class SubscriptionManager {\n             Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n             // a listener is either subscribed for the first time\n             if (subscriptionsByListener == null) {\n-                List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listener);\n+                List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageListener(listener.getClass()).getHandlers();\n                 if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                     nonListeners.add(listener.getClass());\n                     return;\n"
    },
    {
        "commit hash": "7c08bd02993694b115474f63ba0b3f91f0beeaab",
        "previous commit hash": "2ecefc9b0413d5d02890d992faf43719ee058064",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AllTests.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -22,7 +22,8 @@ import org.junit.runners.Suite;\n         ListenerSubscriptionTest.class,\n         MethodDispatchTest.class,\n         DeadEventTest.class,\n-        SynchronizedHandlerTest.class\n+        SynchronizedHandlerTest.class,\n+        SubscriptionManagerTest.class\n })\n public class AllTests {\n }\n"
    },
    {
        "commit hash": "7c08bd02993694b115474f63ba0b3f91f0beeaab",
        "previous commit hash": "2ecefc9b0413d5d02890d992faf43719ee058064",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MetadataReaderTest.java",
            "additions": 5,
            "deletions": 5
        },
        "diff content": "@@ -27,7 +27,7 @@ public class MetadataReaderTest extends UnitTest {\n \n     @Test\n     public void testListenerWithoutInheritance() {\n-        MessageListenerMetadata<MessageListener1> listener = reader.getMessageListener(new MessageListener1());\n+        MessageListenerMetadata<MessageListener1> listener = reader.getMessageListener(MessageListener1.class);\n         ListenerValidator validator = new ListenerValidator()\n                 .expectHandlers(2, String.class)\n                 .expectHandlers(2, Object.class)\n@@ -38,7 +38,7 @@ public class MetadataReaderTest extends UnitTest {\n \n     @Test\n     public void testListenerWithInheritance() {\n-        MessageListenerMetadata<MessageListener2> listener = reader.getMessageListener(new MessageListener2());\n+        MessageListenerMetadata<MessageListener2> listener = reader.getMessageListener(MessageListener2.class);\n         ListenerValidator validator = new ListenerValidator()\n                 .expectHandlers(2, String.class)\n                 .expectHandlers(2, Object.class)\n@@ -48,7 +48,7 @@ public class MetadataReaderTest extends UnitTest {\n \n     @Test\n     public void testListenerWithInheritanceOverriding() {\n-        MessageListenerMetadata<MessageListener3> listener = reader.getMessageListener(new MessageListener3());\n+        MessageListenerMetadata<MessageListener3> listener = reader.getMessageListener(MessageListener3.class);\n \n         ListenerValidator validator = new ListenerValidator()\n                 .expectHandlers(0, String.class)\n@@ -59,7 +59,7 @@ public class MetadataReaderTest extends UnitTest {\n \n     @Test\n     public void testEnveloped() {\n-        MessageListenerMetadata<EnvelopedListener> listener = reader.getMessageListener(new EnvelopedListener());\n+        MessageListenerMetadata<EnvelopedListener> listener = reader.getMessageListener(EnvelopedListener.class);\n         ListenerValidator validator = new ListenerValidator()\n                 .expectHandlers(1, String.class)\n                 .expectHandlers(2, Integer.class)\n@@ -72,7 +72,7 @@ public class MetadataReaderTest extends UnitTest {\n \n     @Test\n     public void testEnvelopedSubclass() {\n-        MessageListenerMetadata<EnvelopedListenerSubclass> listener = reader.getMessageListener(new EnvelopedListenerSubclass());\n+        MessageListenerMetadata<EnvelopedListenerSubclass> listener = reader.getMessageListener(EnvelopedListenerSubclass.class);\n         ListenerValidator validator = new ListenerValidator()\n                 .expectHandlers(1, String.class)\n                 .expectHandlers(2, Integer.class)\n"
    },
    {
        "commit hash": "7c08bd02993694b115474f63ba0b3f91f0beeaab",
        "previous commit hash": "2ecefc9b0413d5d02890d992faf43719ee058064",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 51,
            "deletions": 14
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy;\n \n+import net.engio.mbassy.common.ConcurrentExecutor;\n import net.engio.mbassy.common.UnitTest;\n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.MetadataReader;\n@@ -11,6 +12,10 @@ import net.engio.mbassy.subscription.SubscriptionManager;\n import org.junit.Test;\n \n import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n \n /**\n  * Todo: Add javadoc\n@@ -22,27 +27,47 @@ public class SubscriptionManagerTest extends UnitTest{\n \n     @Test\n     public void testSimpleSynchronousHandler(){\n-        SubscriptionManager subMan = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n-        SimpleSynchronousMessageHandler\n-                listener1 = new SimpleSynchronousMessageHandler(),\n-                listener2 = new SimpleSynchronousMessageHandler();\n-        subMan.subscribe(listener1);\n-        subMan.subscribe(listener2);\n+        final SubscriptionManager subMan = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n+        final Set listeners = Collections.synchronizedSet(new HashSet());\n+        final int concurrentUnits = 5;\n+        final int numberOfLoops = 100;\n+        final int numberOfListeners =  numberOfLoops * concurrentUnits * 2;\n+\n+        ConcurrentExecutor.runConcurrent(new Runnable() {\n+            @Override\n+            public void run() {\n+                for(int i = 0 ; i < numberOfLoops ; i++){\n+                    SimpleSynchronousMessageHandler\n+                            listener1 = new SimpleSynchronousMessageHandler();\n+                    SimpleSynchronousMessageHandler2 listener2 = new SimpleSynchronousMessageHandler2();\n+                    subMan.subscribe(listener1);\n+                    subMan.subscribe(listener2);\n+                    listeners.add(listener1);\n+                    listeners.add(listener2);\n+                }\n+\n+            }\n+        }, concurrentUnits);\n+\n \n         Collection<Subscription> subscriptions = subMan.getSubscriptionsByMessageType(TestMessage.class);\n-        assertEquals(1, subscriptions.size());\n+        assertEquals(2, subscriptions.size());\n+\n         for(Subscription sub : subscriptions){\n-            assertEquals(2, sub.size());\n-            assertTrue(sub.contains(listener1));\n-            assertTrue(sub.contains(listener2));\n+            assertEquals(numberOfListeners, sub.size());\n+            for(Object listener : listeners){\n+\n+                if(sub.isFromListener(listener))assertTrue(sub.contains(listener));\n+            }\n         }\n \n         subscriptions = subMan.getSubscriptionsByMessageType(ITestMessage.class);\n-        assertEquals(1, subscriptions.size());\n+        assertEquals(2, subscriptions.size());\n         for(Subscription sub : subscriptions){\n-            assertEquals(2, sub.size());\n-            assertTrue(sub.contains(listener1));\n-            assertTrue(sub.contains(listener2));\n+            assertEquals(numberOfListeners, sub.size());\n+            for(Object listener : listeners){\n+                if(sub.isFromListener(listener))assertTrue(sub.contains(listener));\n+            }\n         }\n     }\n \n@@ -57,4 +82,16 @@ public class SubscriptionManagerTest extends UnitTest{\n         public void handle(ITestMessage message) {\n         }\n     }\n+\n+\n+    static class SimpleSynchronousMessageHandler2{\n+\n+        @Handler\n+        public void handle(TestMessage message) {\n+        }\n+\n+        @Handler\n+        public void handle(ITestMessage message) {\n+        }\n+    }\n }\n"
    },
    {
        "commit hash": "7c08bd02993694b115474f63ba0b3f91f0beeaab",
        "previous commit hash": "2ecefc9b0413d5d02890d992faf43719ee058064",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -4,8 +4,8 @@ import net.engio.mbassy.bus.*;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.common.TestUtil;\n import net.engio.mbassy.dispatch.HandlerInvocation;\n-import net.engio.mbassy.events.SubTestMessage;\n-import net.engio.mbassy.events.TestMessage;\n+import net.engio.mbassy.messages.SubTestMessage;\n+import net.engio.mbassy.messages.TestMessage;\n import net.engio.mbassy.listener.*;\n import net.engio.mbassy.listeners.*;\n import net.engio.mbassy.subscription.SubscriptionContext;\n"
    },
    {
        "commit hash": "8f30ea6c53f9f9f998860248857705ac567a318f",
        "previous commit hash": "2ecefc9b0413d5d02890d992faf43719ee058064",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ReflectionUtils.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -62,11 +62,12 @@ public class ReflectionUtils {\n \n     public static Collection<Class> getSuperclasses(Class from) {\n         Collection<Class> superclasses = new LinkedList<Class>();\n+        // collectInterfaces needs to come first otherwise you call it on class \"Object\"\n+        collectInterfaces(from, superclasses);\n         while (!from.equals(Object.class) && !from.isInterface()) {\n             superclasses.add(from.getSuperclass());\n             from = from.getSuperclass();\n         }\n-        collectInterfaces(from, superclasses);\n         return superclasses;\n     }\n \n"
    },
    {
        "commit hash": "8f30ea6c53f9f9f998860248857705ac567a318f",
        "previous commit hash": "2ecefc9b0413d5d02890d992faf43719ee058064",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/InterfaceTest.java",
            "additions": 36,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,36 @@\n+package net.engio.mbassy;\r\n+\r\n+import net.engio.mbassy.bus.BusConfiguration;\r\n+import net.engio.mbassy.bus.MBassador;\r\n+import net.engio.mbassy.common.DeadMessage;\r\n+import net.engio.mbassy.listener.Handler;\r\n+import net.engio.mbassy.messages.ITestMessage;\r\n+import net.engio.mbassy.messages.TestMessage3;\r\n+\r\n+import org.junit.Assert;\r\n+import org.junit.Test;\r\n+\r\n+/**\r\n+ * A test to make sure that Interface subscriptions are working correctly\r\n+ * \r\n+ * @author durron597\r\n+ */\r\n+public class InterfaceTest {\r\n+\t@Test\r\n+\tpublic void testMBassador() {\r\n+\t\tMBassador<ITestMessage> bus = new MBassador<ITestMessage>(BusConfiguration.Default());\r\n+\t\tbus.subscribe(this);\r\n+\t\tTestMessage3 myFoo = new TestMessage3();\r\n+\t\tbus.publish(myFoo);\r\n+\t}\r\n+\r\n+\t@Handler\r\n+\tpublic void handleFoo(ITestMessage f) {\r\n+\t\tAssert.assertTrue(f instanceof TestMessage3);\r\n+\t}\r\n+\t\r\n+\t@Handler\r\n+\tpublic void handleDead(DeadMessage d) {\r\n+\t\tAssert.fail(\"This class should handle this message appropriately!\");\r\n+\t}\r\n+}\r\n"
    },
    {
        "commit hash": "8f30ea6c53f9f9f998860248857705ac567a318f",
        "previous commit hash": "2ecefc9b0413d5d02890d992faf43719ee058064",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -4,8 +4,8 @@ import net.engio.mbassy.bus.*;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.common.TestUtil;\n import net.engio.mbassy.dispatch.HandlerInvocation;\n-import net.engio.mbassy.events.SubTestMessage;\n-import net.engio.mbassy.events.TestMessage;\n+import net.engio.mbassy.messages.SubTestMessage;\n+import net.engio.mbassy.messages.TestMessage;\n import net.engio.mbassy.listener.*;\n import net.engio.mbassy.listeners.*;\n import net.engio.mbassy.subscription.SubscriptionContext;\n"
    },
    {
        "commit hash": "8f30ea6c53f9f9f998860248857705ac567a318f",
        "previous commit hash": "2ecefc9b0413d5d02890d992faf43719ee058064",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/TestMessage3.java",
            "additions": 10,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,10 @@\n+package net.engio.mbassy.messages;\r\n+\r\n+/**\r\n+ * A test message that uses an interface\r\n+ * \r\n+ * @author durron597\r\n+ */\r\n+public class TestMessage3 implements ITestMessage {\r\n+\r\n+}\r\n"
    },
    {
        "commit hash": "2ecefc9b0413d5d02890d992faf43719ee058064",
        "previous commit hash": "3b215115fbcce09a734f6e700ee5cc9e1b211fc1",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/PubSubSupport.java",
            "additions": 41,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,41 @@\n+package net.engio.mbassy;\n+\n+/**\n+ * This interface defines the very basic message publication semantics according to the publish subscribe pattern.\n+ *\n+ * Listeners can be subscribed and unsubscribed using the corresponding methods. When a listener is subscribed\n+ *\n+ *\n+ */\n+public interface PubSubSupport<T> {\n+\n+    /**\n+     * Subscribe all handler of the given listener. Any listener may only be subscribed once\n+     * -> subsequent subscriptions of an already subscribed listener will be silently ignored)\n+     *\n+     * @param listener\n+     */\n+    void subscribe(Object listener);\n+\n+    /**\n+     * Immediately remove all registered message handlers (if any) of the given listener. When this call returns all handlers\n+     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n+     * publications that have been published when the message listener was still subscribed).\n+     * <p/>\n+     * A call to this method passing any object that is not subscribed will not have any effect and is silently ignored.\n+     *\n+     * @param listener\n+     * @return true, if the listener was found and successfully removed\n+     *         false otherwise\n+     */\n+    boolean unsubscribe(Object listener);\n+\n+\n+    /**\n+     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n+     * The call blocks until every messageHandler has processed the message.\n+     *\n+     * @param message\n+     */\n+    void publish(T message);\n+}\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java",
            "additions": 12,
            "deletions": 114
        },
        "diff content": "@@ -2,15 +2,13 @@ package net.engio.mbassy.bus;\n \n import net.engio.mbassy.IPublicationErrorHandler;\n import net.engio.mbassy.PublicationError;\n-import net.engio.mbassy.common.ReflectionUtils;\n-import net.engio.mbassy.listener.MessageHandlerMetadata;\n-import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.subscription.Subscription;\n-import net.engio.mbassy.subscription.SubscriptionContext;\n-import net.engio.mbassy.subscription.SubscriptionFactory;\n+import net.engio.mbassy.subscription.SubscriptionManager;\n \n-import java.util.*;\n-import java.util.concurrent.*;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n \n /**\n  * The base class for all message bus implementations.\n@@ -21,37 +19,17 @@ import java.util.concurrent.*;\n public abstract class AbstractSyncMessageBus<T, P extends ISyncMessageBus.ISyncPostCommand> implements ISyncMessageBus<T, P> {\n \n \n-    // the metadata reader that is used to parse objects passed to the subscribe method\n-    private final MetadataReader metadataReader;\n-\n-    // all subscriptions per message type\n-    // this is the primary list for dispatching a specific message\n-    // write access is synchronized and happens very infrequently\n-    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage\n-            = new HashMap<Class, Collection<Subscription>>(50);\n-\n-    // all subscriptions per messageHandler type\n-    // this list provides fast access for subscribing and unsubscribing\n-    // write access is synchronized and happens very infrequently\n-    private final Map<Class, Collection<Subscription>> subscriptionsPerListener\n-            = new HashMap<Class, Collection<Subscription>>(50);\n-\n-    // remember already processed classes that do not contain any listeners\n-    private final Collection<Class> nonListeners = new HashSet<Class>();\n-\n     // this handler will receive all errors that occur during message dispatch or message handling\n     private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n \n-    // this factory is used to create specialized subscriptions based on the given message handler configuration\n-    // it can be customized by implementing the getSubscriptionFactory() method\n-    private final SubscriptionFactory subscriptionFactory;\n-\n     private final MessagePublication.Factory publicationFactory;\n \n+    private final SubscriptionManager subscriptionManager;\n+\n \n     public AbstractSyncMessageBus(SyncBusConfiguration configuration) {\n-        subscriptionFactory = configuration.getSubscriptionFactory();\n-        this.metadataReader = configuration.getMetadataReader();\n+        this.subscriptionManager = new SubscriptionManager(configuration.getMetadataReader(),\n+                configuration.getSubscriptionFactory().setBus(this));\n         this.publicationFactory = configuration.getMessagePublicationFactory();\n         addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n     }\n@@ -66,63 +44,12 @@ public abstract class AbstractSyncMessageBus<T, P extends ISyncMessageBus.ISyncP\n     }\n \n     public boolean unsubscribe(Object listener) {\n-        if (listener == null) {\n-            return false;\n-        }\n-        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n-        if (subscriptions == null) {\n-            return false;\n-        }\n-        boolean isRemoved = true;\n-        for (Subscription subscription : subscriptions) {\n-            isRemoved = isRemoved && subscription.unsubscribe(listener);\n-        }\n-        return isRemoved;\n+        return subscriptionManager.unsubscribe(listener);\n     }\n \n \n     public void subscribe(Object listener) {\n-        try {\n-            Class listeningClass = listener.getClass();\n-            if (nonListeners.contains(listeningClass)) {\n-                return; // early reject of known classes that do not participate in eventing\n-            }\n-            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n-            if (subscriptionsByListener == null) { // if the type is registered for the first time\n-                synchronized (this) { // new subscriptions must be processed sequentially\n-                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n-                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n-                        List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listeningClass);\n-                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n-                            nonListeners.add(listeningClass);\n-                            return;\n-                        }\n-                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n-                        // create subscriptions for all detected listeners\n-                        for (MessageHandlerMetadata messageHandler : messageHandlers) {\n-                            // create the subscription\n-                            Subscription subscription = subscriptionFactory\n-                                    .createSubscription(new SubscriptionContext(this, messageHandler));\n-                            subscription.subscribe(listener);\n-                            subscriptionsByListener.add(subscription);// add it for the listener type (for future subscriptions)\n-\n-                            List<Class<?>> messageTypes = messageHandler.getHandledMessages();\n-                            for (Class<?> messageType : messageTypes) {\n-                                addMessageTypeSubscription(messageType, subscription);\n-                            }\n-                            //updateMessageTypeHierarchy(eventType);\n-                        }\n-                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n-                    }\n-                }\n-            }\n-            // register the listener to the existing subscriptions\n-            for (Subscription sub : subscriptionsByListener) {\n-                sub.subscribe(listener);\n-            }\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n+        subscriptionManager.subscribe(listener);\n     }\n \n \n@@ -131,39 +58,10 @@ public abstract class AbstractSyncMessageBus<T, P extends ISyncMessageBus.ISyncP\n     }\n \n \n-\n     // obtain the set of subscriptions for the given message type\n     // Note: never returns null!\n     protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n-        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n-\n-        if (subscriptionsPerMessage.get(messageType) != null) {\n-            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n-        }\n-        // TODO: get superclasses is eligible for caching\n-        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n-            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n-            if (subs != null) {\n-                for (Subscription sub : subs) {\n-                    if (sub.handlesMessageType(messageType)) {\n-                        subscriptions.add(sub);\n-                    }\n-                }\n-            }\n-        }\n-        return subscriptions;\n-    }\n-\n-\n-    // associate a suscription with a message type\n-    // NOTE: Not thread-safe! must be synchronized in outer scope\n-    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n-        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n-        if (subscriptions == null) {\n-            subscriptions = new LinkedList<Subscription>();\n-            subscriptionsPerMessage.put(messageType, subscriptions);\n-        }\n-        subscriptions.add(subscription);\n+        return subscriptionManager.getSubscriptionsByMessageType(messageType);\n     }\n \n \n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/IMessageBus.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -55,7 +55,7 @@ public interface IMessageBus<T, P extends IMessageBus.IPostCommand> extends ISyn\n     Executor getExecutor();\n \n     /**\n-     * Check whether any asynchronous message publications are pending for being processed\n+     * Check whether any asynchronous message publications are pending to be processed\n      *\n      * @return\n      */\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java",
            "additions": 48,
            "deletions": 28
        },
        "diff content": "@@ -2,6 +2,8 @@ package net.engio.mbassy.common;\n \n \n import java.util.Map;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n /**\n  * This data structure is optimized for non-blocking reads even when write operations occur.\n@@ -15,7 +17,7 @@ import java.util.Map;\n public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n \n     // Internal state\n-    private final Object lock = new Object();\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n     private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(log n) lookup\n     protected Entry<T> head; // reference to the first element\n \n@@ -27,27 +29,38 @@ public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n \n     @Override\n     public IConcurrentSet<T> add(T element) {\n+        if (element == null) return this;\n+        Lock writeLock = lock.writeLock();\n+        writeLock.lock();\n         if (element == null || entries.containsKey(element)) {\n+            writeLock.unlock();\n             return this;\n-        }\n-        synchronized (lock) {\n+        } else {\n             insert(element);\n+            writeLock.unlock();\n         }\n         return this;\n     }\n \n     @Override\n     public boolean contains(T element) {\n-        ISetEntry<T> entry = entries.get(element);\n+        Lock readLock = lock.readLock();\n+        ISetEntry<T> entry;\n+        try {\n+            readLock.lock();\n+            entry = entries.get(element);\n+\n+        } finally {\n+            readLock.unlock();\n+        }\n         return entry != null && entry.getValue() != null;\n     }\n \n     private void insert(T element) {\n-        if (entries.containsKey(element)) {\n-            return;\n+        if (!entries.containsKey(element)) {\n+            head = createEntry(element, head);\n+            entries.put(element, head);\n         }\n-        head = createEntry(element, head);\n-        entries.put(element, head);\n     }\n \n     @Override\n@@ -57,38 +70,45 @@ public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n \n     @Override\n     public IConcurrentSet<T> addAll(Iterable<T> elements) {\n-        synchronized (lock) {\n+        Lock writeLock = lock.writeLock();\n+        try {\n+            writeLock.lock();\n             for (T element : elements) {\n-                if (element == null || entries.containsKey(element)) {\n-                    return this;\n+                if (element != null) {\n+                    insert(element);\n                 }\n-\n-                insert(element);\n             }\n+        } finally {\n+            writeLock.unlock();\n         }\n         return this;\n     }\n \n     @Override\n     public boolean remove(T element) {\n-        if (!entries.containsKey(element)) {\n+        if (!contains(element)) {\n             return false;\n-        }\n-        synchronized (lock) {\n-            ISetEntry<T> listelement = entries.get(element);\n-            if (listelement == null) {\n-                return false; //removed by other thread\n-            }\n-            if (listelement != head) {\n-                listelement.remove();\n-            } else {\n-                ISetEntry<T> oldHead = head;\n-                head = head.next();\n-                oldHead.clear(); // optimize for GC\n+        } else {\n+            Lock writeLock = lock.writeLock();\n+            try {\n+                writeLock.lock();\n+                ISetEntry<T> listelement = entries.get(element);\n+                if (listelement == null) {\n+                    return false; //removed by other thread\n+                }\n+                if (listelement != head) {\n+                    listelement.remove();\n+                } else {\n+                    ISetEntry<T> oldHead = head;\n+                    head = head.next();\n+                    oldHead.clear(); // optimize for GC\n+                }\n+                entries.remove(element);\n+            } finally {\n+                writeLock.unlock();\n             }\n-            entries.remove(element);\n+            return true;\n         }\n-        return true;\n     }\n \n \n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ReflectionUtils.java",
            "additions": 9,
            "deletions": 1
        },
        "diff content": "@@ -62,13 +62,21 @@ public class ReflectionUtils {\n \n     public static Collection<Class> getSuperclasses(Class from) {\n         Collection<Class> superclasses = new LinkedList<Class>();\n-        while (!from.equals(Object.class)) {\n+        while (!from.equals(Object.class) && !from.isInterface()) {\n             superclasses.add(from.getSuperclass());\n             from = from.getSuperclass();\n         }\n+        collectInterfaces(from, superclasses);\n         return superclasses;\n     }\n \n+    public static void collectInterfaces(Class from, Collection<Class> accumulator){\n+        for(Class intface : from.getInterfaces()){\n+            accumulator.add(intface);\n+            collectInterfaces(intface, accumulator);\n+        }\n+    }\n+\n     public static boolean containsOverridingMethod(final List<Method> allMethods, final Method methodToCheck) {\n         for (Method method : allMethods) {\n             if (isOverriddenBy(methodToCheck, method)) {\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MetadataReader.java",
            "additions": 4,
            "deletions": 3
        },
        "diff content": "@@ -58,7 +58,8 @@ public class MetadataReader {\n \n     // get all listeners defined by the given class (includes\n     // listeners defined in super classes)\n-    public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n+    public List<MessageHandlerMetadata> getMessageHandlers(Object listener) {\n+        Class<?> target = listener.getClass();\n         Listener listenerConfig = target.getAnnotation(Listener.class);\n         // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n         List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n@@ -89,8 +90,8 @@ public class MetadataReader {\n     }\n \n \n-    public <T> MessageListenerMetadata<T> getMessageListener(Class<T> target) {\n-        return new MessageListenerMetadata(getMessageHandlers(target), target);\n+    public <T> MessageListenerMetadata<T> getMessageListener(Object listener) {\n+        return new MessageListenerMetadata(getMessageHandlers(listener), listener.getClass());\n     }\n \n \n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 8,
            "deletions": 0
        },
        "diff content": "@@ -5,6 +5,7 @@ import net.engio.mbassy.common.IConcurrentSet;\n import net.engio.mbassy.dispatch.IMessageDispatcher;\n \n import java.util.Comparator;\n+import java.util.List;\n import java.util.UUID;\n \n /**\n@@ -26,11 +27,18 @@ public class Subscription {\n         this.listeners = listeners;\n     }\n \n+    public boolean contains(Object listener){\n+        return listeners.contains(listener);\n+    }\n \n     public boolean handlesMessageType(Class<?> messageType) {\n         return context.getHandlerMetadata().handlesMessage(messageType);\n     }\n \n+    public List<Class<?>> getHandledMessageTypes(){\n+        return context.getHandlerMetadata().getHandledMessages();\n+    }\n+\n \n     public void publish(MessagePublication publication, Object message) {\n         dispatcher.dispatch(publication, message, listeners);\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -7,7 +7,7 @@ import net.engio.mbassy.listener.MessageHandlerMetadata;\n  * The subscription context holds all (meta)data/objects that are relevant to successfully publish\n  * a message within a subscription. A one-to-one relation between a subscription and\n  * subscription context holds -> a subscription context is created for each distinct subscription\n- * that lives inside a message bus.\n+ * managed by the subscription manager.\n  *\n  * @author bennidi\n  *         Date: 11/23/12\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java",
            "additions": 13,
            "deletions": 7
        },
        "diff content": "@@ -1,25 +1,31 @@\n package net.engio.mbassy.subscription;\n \n import net.engio.mbassy.MessageBusException;\n+import net.engio.mbassy.bus.ISyncMessageBus;\n import net.engio.mbassy.common.StrongConcurrentSet;\n import net.engio.mbassy.common.WeakConcurrentSet;\n import net.engio.mbassy.dispatch.*;\n+import net.engio.mbassy.listener.MessageHandlerMetadata;\n \n import java.lang.reflect.Constructor;\n import java.lang.reflect.Modifier;\n \n /**\n- * Created with IntelliJ IDEA.\n- *\n- * @author bennidi\n- *         Date: 11/16/12\n- *         Time: 10:39 AM\n- *         To change this template use File | Settings | File Templates.\n+ * The subscription factory is used to create an empty subscription for specific message handler.\n+ * The message handler's configuration is evaluated and a corresponding subscription is built.\n  */\n public class SubscriptionFactory {\n \n-    public Subscription createSubscription(SubscriptionContext context) throws MessageBusException{\n+    private ISyncMessageBus bus;\n+\n+    public SubscriptionFactory setBus(ISyncMessageBus bus) {\n+        this.bus = bus;\n+        return this;\n+    }\n+\n+    public Subscription createSubscription(MessageHandlerMetadata handlerMetadata) throws MessageBusException{\n         try {\n+            SubscriptionContext context = new SubscriptionContext(bus, handlerMetadata);\n             IHandlerInvocation invocation = buildInvocationForHandler(context);\n             IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n             return new Subscription(context, dispatcher, context.getHandlerMetadata().useStrongReferences()\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java",
            "additions": 181,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,181 @@\n+package net.engio.mbassy.subscription;\n+\n+import net.engio.mbassy.common.ReflectionUtils;\n+import net.engio.mbassy.common.StrongConcurrentSet;\n+import net.engio.mbassy.listener.MessageHandlerMetadata;\n+import net.engio.mbassy.listener.MetadataReader;\n+\n+import java.util.*;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 5/11/13\n+ */\n+public class SubscriptionManager {\n+\n+    // the metadata reader that is used to inspect objects passed to the subscribe method\n+    private final MetadataReader metadataReader;\n+\n+    // all subscriptions per message type\n+    // this is the primary list for dispatching a specific message\n+    // write access is synchronized and happens only when a listener of a specific class is registered the first time\n+    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage\n+            = new HashMap<Class, Collection<Subscription>>(50);\n+\n+    // all subscriptions per messageHandler type\n+    // this map provides fast access for subscribing and unsubscribing\n+    // write access is synchronized and happens very infrequently\n+    // once a collection of subscriptions is stored it does not change\n+    private final Map<Class, Collection<Subscription>> subscriptionsPerListener\n+            = new HashMap<Class, Collection<Subscription>>(50);\n+\n+    // remember already processed classes that do not contain any message handlers\n+    private final StrongConcurrentSet<Class> nonListeners = new StrongConcurrentSet<Class>();\n+\n+    // this factory is used to create specialized subscriptions based on the given message handler configuration\n+    // it can be customized by implementing the getSubscriptionFactory() method\n+    private final SubscriptionFactory subscriptionFactory;\n+\n+    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n+\n+    public SubscriptionManager(MetadataReader metadataReader, SubscriptionFactory subscriptionFactory) {\n+        this.metadataReader = metadataReader;\n+        this.subscriptionFactory = subscriptionFactory;\n+    }\n+\n+\n+    public boolean unsubscribe(Object listener) {\n+        if (listener == null) {\n+            return false;\n+        }\n+        Collection<Subscription> subscriptions = getSubscriptionsByListener(listener);\n+        if (subscriptions == null) {\n+            return false;\n+        }\n+        boolean isRemoved = true;\n+        for (Subscription subscription : subscriptions) {\n+            isRemoved &= subscription.unsubscribe(listener);\n+        }\n+        return isRemoved;\n+    }\n+\n+\n+    private Collection<Subscription> getSubscriptionsByListener(Object listener) {\n+        Collection<Subscription> subscriptions;\n+        try {\n+            readWriteLock.readLock().lock();\n+            subscriptions = subscriptionsPerListener.get(listener.getClass());\n+        } finally {\n+            readWriteLock.readLock().unlock();\n+        }\n+        return subscriptions;\n+    }\n+\n+    public void subscribe(Object listener) {\n+        try {\n+            if (isKnownNonListener(listener)) {\n+                return; // early reject of known classes that do not define message handlers\n+            }\n+            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n+            // a listener is either subscribed for the first time\n+            if (subscriptionsByListener == null) {\n+                List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listener);\n+                if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n+                    nonListeners.add(listener.getClass());\n+                    return;\n+                }\n+                subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n+                // create subscriptions for all detected message handlers\n+                for (MessageHandlerMetadata messageHandler : messageHandlers) {\n+                    // create the subscription\n+                    subscriptionsByListener.add(subscriptionFactory.createSubscription(messageHandler));\n+                }\n+                // this will acquire a write lock and handle the case when another thread already subscribed\n+                // this particular listener in the mean-time\n+                subscribe(listener, subscriptionsByListener);\n+            } // or the subscriptions already exist and must only be updated\n+            else {\n+                for (Subscription sub : subscriptionsByListener) {\n+                    sub.subscribe(listener);\n+                }\n+            }\n+\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+\n+    private void subscribe(Object listener, Collection<Subscription> subscriptions) {\n+        try {\n+            readWriteLock.writeLock().lock();\n+            // basically this is a deferred double check\n+            // it's an ugly pattern but necessary because atomic upgrade from read to write lock\n+            // is not possible and using a write lock from the beginning with will dramatically decrease performance\n+            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n+\n+            if (subscriptionsByListener == null) {\n+                for (Subscription subscription : subscriptions) {\n+                    subscription.subscribe(listener);\n+                    for (Class<?> messageType : subscription.getHandledMessageTypes()) {\n+                        addMessageTypeSubscription(messageType, subscription);\n+                    }\n+                }\n+                subscriptionsPerListener.put(listener.getClass(), subscriptions);\n+            }\n+            // the rare case when multiple threads concurrently subscribed the same class for the first time\n+            // one will be first, all others will have to subscribe to the existing instead the generated subscriptions\n+            else {\n+                for (Subscription existingSubscription : subscriptionsByListener) {\n+                    existingSubscription.subscribe(listener);\n+                }\n+            }\n+        } finally {\n+            readWriteLock.writeLock().unlock();\n+        }\n+\n+\n+    }\n+\n+    private boolean isKnownNonListener(Object listener) {\n+        Class listeningClass = listener.getClass();\n+        return nonListeners.contains(listeningClass);\n+    }\n+\n+    // obtain the set of subscriptions for the given message type\n+    // Note: never returns null!\n+    public Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n+        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n+        readWriteLock.readLock().lock();\n+        if (subscriptionsPerMessage.get(messageType) != null) {\n+            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n+        }\n+        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n+            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n+            if (subs != null) {\n+                for (Subscription sub : subs) {\n+                    if (sub.handlesMessageType(messageType)) {\n+                        subscriptions.add(sub);\n+                    }\n+                }\n+            }\n+        }\n+        readWriteLock.readLock().unlock();\n+        return subscriptions;\n+    }\n+\n+\n+    // associate a suscription with a message type\n+    // NOTE: Not thread-safe! must be synchronized in outer scope\n+    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n+        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n+        if (subscriptions == null) {\n+            subscriptions = new LinkedList<Subscription>();\n+            subscriptionsPerMessage.put(messageType, subscriptions);\n+        }\n+        subscriptions.add(subscription);\n+    }\n+}\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConcurrentSetTest.java",
            "additions": 85,
            "deletions": 9
        },
        "diff content": "@@ -6,10 +6,8 @@ import net.engio.mbassy.common.IConcurrentSet;\n import net.engio.mbassy.common.UnitTest;\n import org.junit.Test;\n \n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.Random;\n+import java.util.*;\n+import java.util.concurrent.CopyOnWriteArraySet;\n \n /**\n  * This test ensures the correct behaviour of the set implementation that is the building\n@@ -218,13 +216,13 @@ public abstract class ConcurrentSetTest extends UnitTest {\n     @Test\n     public void testRemovalViaIterator() {\n         final HashSet<Object> source = new HashSet<Object>();\n-        final IConcurrentSet testSetWeak = createSet();\n+        final IConcurrentSet setUnderTest = createSet();\n \n         // build set of candidates and mark subset for removal\n         for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n             source.add(candidate);\n-            testSetWeak.add(candidate);\n+            setUnderTest.add(candidate);\n         }\n \n         // build test set by adding the candidates\n@@ -232,7 +230,7 @@ public abstract class ConcurrentSetTest extends UnitTest {\n         ConcurrentExecutor.runConcurrent(new Runnable() {\n             @Override\n             public void run() {\n-                Iterator<Object> iterator = testSetWeak.iterator();\n+                Iterator<Object> iterator = setUnderTest.iterator();\n                 while(iterator.hasNext()){\n                     iterator.remove();\n                 }\n@@ -242,11 +240,89 @@ public abstract class ConcurrentSetTest extends UnitTest {\n \n         // ensure that the test set still contains all objects from the source set that have not been marked\n         // for removal\n-        assertEquals(0, testSetWeak.size());\n+        assertEquals(0, setUnderTest.size());\n         for(Object src : source){\n-            assertFalse(testSetWeak.contains(src));\n+            assertFalse(setUnderTest.contains(src));\n         }\n     }\n \n \n+    /**\n+     * In this test HashMap will cross capacity threshold multiple times in\n+     * different directions which will trigger rehashing. Because rehashing\n+     * requires modification of Entry class for all hash map entries some keys\n+     * may temporarily disappear from the map.\n+     * <p>\n+     * For more information please take a look at transfer method in HashMap.\n+     *\n+     * Thanks to Ivan Koblik (http://koblik.blogspot.com) for contributing initial code and idea\n+     */\n+    @Test\n+    public void testConcurrentAddRemove() {\n+        final IConcurrentSet set = createSet();\n+        final List permanentObjects = createWithRandomIntegers(80, null);\n+        final List volatileObjects = createWithRandomIntegers(10000, permanentObjects);\n+        final CopyOnWriteArraySet missing = new CopyOnWriteArraySet();\n+        final int mutatorThreshold = 1000;\n+\n+        // Add elements that will not be touched by the constantly running mutating thread\n+        final int numItems = 8;\n+        for (Object permanent : permanentObjects) {\n+            set.add(permanent);\n+        }\n+\n+        // Adds and removes items >= numItems\n+        // thus forcing constant rehashing of the backing hashtable\n+        Runnable updatingThread = new Runnable() {\n+            public void run() {\n+                Random rand = new Random();\n+                for(int times = 0; times < 1000 ; times++){\n+                    System.out.println(\"New mutator cycle: \" + times);\n+                    HashSet elements = new HashSet(mutatorThreshold);\n+\n+                    for (int i = numItems; i < mutatorThreshold; i++) {\n+                        Object volatileObject = volatileObjects.get(Math.abs(rand.nextInt()) % volatileObjects.size());\n+                        set.add(volatileObject);\n+                        elements.add(volatileObject);\n+                    }\n+                    for (Object volObj : elements) {\n+                        set.remove(volObj);\n+                    }\n+                }\n+            };\n+        };\n+\n+        Runnable lookupThread = new Runnable() {\n+            @Override\n+            public void run() {\n+                for (int i = 0; i < 10000; i++) {\n+                    System.out.println(\"New lookup cycle: \" + i);\n+                    for (Object permanent : permanentObjects) {\n+                        // permanent items are never touched,\n+                        // --> set.contains(j) should always return true\n+                        if(!set.contains(permanent))\n+                            missing.add(permanent);\n+                    }\n+                }\n+            }\n+        };\n+\n+        ConcurrentExecutor.runConcurrent(updatingThread, lookupThread, lookupThread, lookupThread);\n+        assertTrue(\"There where items temporarily unavailable: \" + missing.size(), missing.size() == 0);\n+\n+    }\n+\n+\n+    public List createWithRandomIntegers(int size, List<Integer> exluding){\n+        if(exluding == null) exluding = new ArrayList<Integer>();\n+        List<Integer> result = new ArrayList<Integer>(size);\n+        Random rand = new Random();\n+        for(int i = 0; i < size;i++){\n+            result.add(rand.nextInt());\n+        }\n+        for(Integer excluded : exluding)\n+            result.remove(excluded);\n+        return result;\n+    }\n+\n }\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/FilterTest.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -6,8 +6,8 @@ import net.engio.mbassy.common.DeadMessage;\n import net.engio.mbassy.common.FilteredMessage;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.common.TestUtil;\n-import net.engio.mbassy.events.SubTestMessage;\n-import net.engio.mbassy.events.TestMessage;\n+import net.engio.mbassy.messages.SubTestMessage;\n+import net.engio.mbassy.messages.TestMessage;\n import net.engio.mbassy.listener.*;\n import net.engio.mbassy.listeners.ListenerFactory;\n import org.junit.Test;\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MessagePublicationTest.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -5,9 +5,9 @@ import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.common.ConcurrentExecutor;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.common.TestUtil;\n-import net.engio.mbassy.events.SubTestMessage;\n-import net.engio.mbassy.events.TestMessage;\n-import net.engio.mbassy.events.TestMessage2;\n+import net.engio.mbassy.messages.SubTestMessage;\n+import net.engio.mbassy.messages.TestMessage;\n+import net.engio.mbassy.messages.TestMessage2;\n import net.engio.mbassy.listeners.*;\n import org.junit.Test;\n \n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MetadataReaderTest.java",
            "additions": 8,
            "deletions": 8
        },
        "diff content": "@@ -27,7 +27,7 @@ public class MetadataReaderTest extends UnitTest {\n \n     @Test\n     public void testListenerWithoutInheritance() {\n-        MessageListenerMetadata<EventListener1> listener = reader.getMessageListener(EventListener1.class);\n+        MessageListenerMetadata<MessageListener1> listener = reader.getMessageListener(new MessageListener1());\n         ListenerValidator validator = new ListenerValidator()\n                 .expectHandlers(2, String.class)\n                 .expectHandlers(2, Object.class)\n@@ -38,7 +38,7 @@ public class MetadataReaderTest extends UnitTest {\n \n     @Test\n     public void testListenerWithInheritance() {\n-        MessageListenerMetadata<EventListener2> listener = reader.getMessageListener(EventListener2.class);\n+        MessageListenerMetadata<MessageListener2> listener = reader.getMessageListener(new MessageListener2());\n         ListenerValidator validator = new ListenerValidator()\n                 .expectHandlers(2, String.class)\n                 .expectHandlers(2, Object.class)\n@@ -48,7 +48,7 @@ public class MetadataReaderTest extends UnitTest {\n \n     @Test\n     public void testListenerWithInheritanceOverriding() {\n-        MessageListenerMetadata<EventListener3> listener = reader.getMessageListener(EventListener3.class);\n+        MessageListenerMetadata<MessageListener3> listener = reader.getMessageListener(new MessageListener3());\n \n         ListenerValidator validator = new ListenerValidator()\n                 .expectHandlers(0, String.class)\n@@ -59,7 +59,7 @@ public class MetadataReaderTest extends UnitTest {\n \n     @Test\n     public void testEnveloped() {\n-        MessageListenerMetadata<EnvelopedListener> listener = reader.getMessageListener(EnvelopedListener.class);\n+        MessageListenerMetadata<EnvelopedListener> listener = reader.getMessageListener(new EnvelopedListener());\n         ListenerValidator validator = new ListenerValidator()\n                 .expectHandlers(1, String.class)\n                 .expectHandlers(2, Integer.class)\n@@ -72,7 +72,7 @@ public class MetadataReaderTest extends UnitTest {\n \n     @Test\n     public void testEnvelopedSubclass() {\n-        MessageListenerMetadata<EnvelopedListenerSubclass> listener = reader.getMessageListener(EnvelopedListenerSubclass.class);\n+        MessageListenerMetadata<EnvelopedListenerSubclass> listener = reader.getMessageListener(new EnvelopedListenerSubclass());\n         ListenerValidator validator = new ListenerValidator()\n                 .expectHandlers(1, String.class)\n                 .expectHandlers(2, Integer.class)\n@@ -110,7 +110,7 @@ public class MetadataReaderTest extends UnitTest {\n \n \n     // a simple event listener\n-    public class EventListener1 {\n+    public class MessageListener1 {\n \n         @Handler(rejectSubtypes = true)\n         public void handleObject(Object o) {\n@@ -131,7 +131,7 @@ public class MetadataReaderTest extends UnitTest {\n     }\n \n     // the same handlers as its super class\n-    public class EventListener2 extends EventListener1 {\n+    public class MessageListener2 extends MessageListener1 {\n \n         // redefine handler implementation (not configuration)\n         public void handleString(String s) {\n@@ -140,7 +140,7 @@ public class MetadataReaderTest extends UnitTest {\n \n     }\n \n-    public class EventListener3 extends EventListener2 {\n+    public class MessageListener3 extends MessageListener2 {\n \n         // narrow the handler\n         @Handler(rejectSubtypes = true)\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SubscriptionManagerTest.java",
            "additions": 60,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,60 @@\n+package net.engio.mbassy;\n+\n+import net.engio.mbassy.common.UnitTest;\n+import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listener.MetadataReader;\n+import net.engio.mbassy.messages.ITestMessage;\n+import net.engio.mbassy.messages.TestMessage;\n+import net.engio.mbassy.subscription.Subscription;\n+import net.engio.mbassy.subscription.SubscriptionFactory;\n+import net.engio.mbassy.subscription.SubscriptionManager;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 5/12/13\n+ */\n+public class SubscriptionManagerTest extends UnitTest{\n+\n+    @Test\n+    public void testSimpleSynchronousHandler(){\n+        SubscriptionManager subMan = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n+        SimpleSynchronousMessageHandler\n+                listener1 = new SimpleSynchronousMessageHandler(),\n+                listener2 = new SimpleSynchronousMessageHandler();\n+        subMan.subscribe(listener1);\n+        subMan.subscribe(listener2);\n+\n+        Collection<Subscription> subscriptions = subMan.getSubscriptionsByMessageType(TestMessage.class);\n+        assertEquals(1, subscriptions.size());\n+        for(Subscription sub : subscriptions){\n+            assertEquals(2, sub.size());\n+            assertTrue(sub.contains(listener1));\n+            assertTrue(sub.contains(listener2));\n+        }\n+\n+        subscriptions = subMan.getSubscriptionsByMessageType(ITestMessage.class);\n+        assertEquals(1, subscriptions.size());\n+        for(Subscription sub : subscriptions){\n+            assertEquals(2, sub.size());\n+            assertTrue(sub.contains(listener1));\n+            assertTrue(sub.contains(listener2));\n+        }\n+    }\n+\n+\n+    static class SimpleSynchronousMessageHandler{\n+\n+        @Handler\n+        public void handle(TestMessage message) {\n+        }\n+\n+        @Handler\n+        public void handle(ITestMessage message) {\n+        }\n+    }\n+}\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/bus/ListenerSubscriptionTest.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -2,8 +2,8 @@ package net.engio.mbassy.bus;\n \n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.common.TestUtil;\n-import net.engio.mbassy.events.SubTestMessage;\n-import net.engio.mbassy.events.TestMessage;\n+import net.engio.mbassy.messages.SubTestMessage;\n+import net.engio.mbassy.messages.TestMessage;\n import net.engio.mbassy.listeners.EventingTestBean;\n import net.engio.mbassy.listeners.EventingTestBean2;\n import net.engio.mbassy.listeners.EventingTestBean3;\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,8 +1,8 @@\n package net.engio.mbassy.listeners;\n \n import net.engio.mbassy.dispatch.HandlerInvocation;\n-import net.engio.mbassy.events.SubTestMessage;\n-import net.engio.mbassy.events.TestMessage;\n+import net.engio.mbassy.messages.SubTestMessage;\n+import net.engio.mbassy.messages.TestMessage;\n import net.engio.mbassy.listener.*;\n import net.engio.mbassy.subscription.SubscriptionContext;\n \n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.listeners;\n \n-import net.engio.mbassy.events.SubTestMessage;\n+import net.engio.mbassy.messages.SubTestMessage;\n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Invoke;\n import net.engio.mbassy.listener.Listener;\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.listeners;\n \n-import net.engio.mbassy.events.SubTestMessage;\n+import net.engio.mbassy.messages.SubTestMessage;\n import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Invoke;\n import net.engio.mbassy.listener.Listener;\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.listeners;\n \n-import net.engio.mbassy.events.TestMessage;\n-import net.engio.mbassy.events.TestMessage2;\n+import net.engio.mbassy.messages.TestMessage;\n+import net.engio.mbassy.messages.TestMessage2;\n import net.engio.mbassy.listener.*;\n import net.engio.mbassy.listener.Invoke;\n import net.engio.mbassy.subscription.MessageEnvelope;\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/NonListeningBean.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.listeners;\n \n-import net.engio.mbassy.events.SubTestMessage;\n-import net.engio.mbassy.events.TestMessage;\n+import net.engio.mbassy.messages.SubTestMessage;\n+import net.engio.mbassy.messages.TestMessage;\n import net.engio.mbassy.listener.Handler;\n \n /**\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/ITestMessage.java",
            "additions": 10,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,10 @@\n+package net.engio.mbassy.messages;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 5/12/13\n+ */\n+public interface ITestMessage {\n+}\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/SubTestMessage.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package net.engio.mbassy.events;\n+package net.engio.mbassy.messages;\n \n /**\n  *\n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/TestMessage.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package net.engio.mbassy.events;\n+package net.engio.mbassy.messages;\n \n import java.util.concurrent.atomic.AtomicInteger;\n \n"
    },
    {
        "commit hash": "17b1fee1b6b44612588e711aa0279c511c9d8d3a",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/messages/TestMessage2.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package net.engio.mbassy.events;\n+package net.engio.mbassy.messages;\n \n import java.util.concurrent.atomic.AtomicInteger;\n \n"
    },
    {
        "commit hash": "bf0ce9535be084a1767095887351da9db358f680",
        "previous commit hash": "f5ecdefcd093e5aca4593e764d5378772b32509c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java",
            "additions": 4,
            "deletions": 3
        },
        "diff content": "@@ -11,7 +11,6 @@ import net.engio.mbassy.subscription.SubscriptionContext;\n import net.engio.mbassy.subscription.SubscriptionFactory;\n \n import java.util.*;\n-import java.util.concurrent.*;\n \n /**\n  * The base class for all message bus implementations.\n@@ -41,7 +40,7 @@ public abstract class AbstractSyncMessageBus<T, P extends ISyncMessageBus.ISyncP\n     private final Collection<Class> nonListeners = new HashSet<Class>();\n \n     // this handler will receive all errors that occur during message dispatch or message handling\n-    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n+    private final List<IPublicationErrorHandler> errorHandlers = new ArrayList<IPublicationErrorHandler>();\n \n     // this factory is used to create specialized subscriptions based on the given message handler configuration\n     // it can be customized by implementing the getSubscriptionFactory() method\n@@ -128,7 +127,9 @@ public abstract class AbstractSyncMessageBus<T, P extends ISyncMessageBus.ISyncP\n \n \n     public final void addErrorHandler(IPublicationErrorHandler handler) {\n-        errorHandlers.add(handler);\n+        synchronized (this){\n+            errorHandlers.add(handler);\n+        }\n     }\n \n     protected MessagePublication createMessagePublication(T message) {\n"
    },
    {
        "commit hash": "bf0ce9535be084a1767095887351da9db358f680",
        "previous commit hash": "f5ecdefcd093e5aca4593e764d5378772b32509c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MBassador.java",
            "additions": 0,
            "deletions": 3
        },
        "diff content": "@@ -1,10 +1,7 @@\n package net.engio.mbassy.bus;\n \n import net.engio.mbassy.PublicationError;\n-import net.engio.mbassy.common.DeadMessage;\n-import net.engio.mbassy.subscription.Subscription;\n \n-import java.util.Collection;\n import java.util.concurrent.TimeUnit;\n \n \n"
    },
    {
        "commit hash": "f5ecdefcd093e5aca4593e764d5378772b32509c",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/MessageBusException.java",
            "additions": 1,
            "deletions": 3
        },
        "diff content": "@@ -23,7 +23,5 @@ public class MessageBusException extends Exception{\n         super(cause);\n     }\n \n-    public MessageBusException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n-        super(message, cause, enableSuppression, writableStackTrace);\n-    }\n+\n }\n"
    },
    {
        "commit hash": "f5ecdefcd093e5aca4593e764d5378772b32509c",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -5,7 +5,7 @@ import java.util.List;\n import java.util.concurrent.*;\n \n /**\n- * The base class for all message bus implementations.\n+ * The base class for all async message bus implementations.\n  *\n  * @param <T>\n  * @param <P>\n"
    },
    {
        "commit hash": "f5ecdefcd093e5aca4593e764d5378772b32509c",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java",
            "additions": 11,
            "deletions": 1
        },
        "diff content": "@@ -2,6 +2,7 @@ package net.engio.mbassy.bus;\n \n import net.engio.mbassy.IPublicationErrorHandler;\n import net.engio.mbassy.PublicationError;\n+import net.engio.mbassy.common.DeadMessage;\n import net.engio.mbassy.common.ReflectionUtils;\n import net.engio.mbassy.listener.MessageHandlerMetadata;\n import net.engio.mbassy.listener.MetadataReader;\n@@ -130,7 +131,16 @@ public abstract class AbstractSyncMessageBus<T, P extends ISyncMessageBus.ISyncP\n         errorHandlers.add(handler);\n     }\n \n-\n+    protected MessagePublication createMessagePublication(T message) {\n+        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n+        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass().equals(DeadMessage.class)) {\n+            // Dead Event\n+            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n+            return getPublicationFactory().createPublication(this, subscriptions, new DeadMessage(message));\n+        } else {\n+            return getPublicationFactory().createPublication(this, subscriptions, message);\n+        }\n+    }\n \n     // obtain the set of subscriptions for the given message type\n     // Note: never returns null!\n"
    },
    {
        "commit hash": "f5ecdefcd093e5aca4593e764d5378772b32509c",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MBassador.java",
            "additions": 0,
            "deletions": 11
        },
        "diff content": "@@ -23,17 +23,6 @@ public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCo\n         return addAsynchronousDeliveryRequest(createMessagePublication(message), timeout, unit);\n     }\n \n-    private MessagePublication createMessagePublication(T message) {\n-        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n-        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass().equals(DeadMessage.class)) {\n-            // Dead Event\n-            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n-            return getPublicationFactory().createPublication(this, subscriptions, new DeadMessage(message));\n-        } else {\n-            return getPublicationFactory().createPublication(this, subscriptions, message);\n-        }\n-    }\n-\n \n     /**\n      * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n"
    },
    {
        "commit hash": "f5ecdefcd093e5aca4593e764d5378772b32509c",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MessagePublication.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -21,7 +21,7 @@ public class MessagePublication {\n \n     public static class Factory {\n \n-        public MessagePublication createPublication(IMessageBus owningBus, Collection<Subscription> subscriptions, Object message) {\n+        public MessagePublication createPublication(ISyncMessageBus owningBus, Collection<Subscription> subscriptions, Object message) {\n             return new MessagePublication(owningBus, subscriptions, message, State.Initial);\n         }\n \n@@ -35,9 +35,9 @@ public class MessagePublication {\n \n     private boolean delivered = false;\n \n-    private IMessageBus bus;\n+    private ISyncMessageBus bus;\n \n-    public MessagePublication(IMessageBus bus, Collection<Subscription> subscriptions, Object message, State initialState) {\n+    public MessagePublication(ISyncMessageBus bus, Collection<Subscription> subscriptions, Object message, State initialState) {\n         this.bus = bus;\n         this.subscriptions = subscriptions;\n         this.message = message;\n"
    },
    {
        "commit hash": "f5ecdefcd093e5aca4593e764d5378772b32509c",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/SyncMessageBus.java",
            "additions": 57,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,57 @@\n+package net.engio.mbassy.bus;\n+\n+import net.engio.mbassy.PublicationError;\n+\n+/**\n+ * Created with IntelliJ IDEA.\n+ * User: benjamin\n+ * Date: 4/3/13\n+ * Time: 9:02 AM\n+ * To change this template use File | Settings | File Templates.\n+ */\n+public class SyncMessageBus<T> extends AbstractSyncMessageBus<T, SyncMessageBus.SyncPostCommand>{\n+\n+\n+    public SyncMessageBus(SyncBusConfiguration configuration) {\n+        super(configuration);\n+    }\n+\n+    /**\n+     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n+     * The call blocks until every messageHandler has processed the message.\n+     *\n+     * @param message\n+     */\n+    public void publish(T message) {\n+        try {\n+            MessagePublication publication = createMessagePublication(message);\n+            publication.execute();\n+        } catch (Throwable e) {\n+            handlePublicationError(new PublicationError()\n+                    .setMessage(\"Error during publication of message\")\n+                    .setCause(e)\n+                    .setPublishedObject(message));\n+        }\n+\n+    }\n+\n+    @Override\n+    public SyncPostCommand post(T message) {\n+        return new SyncPostCommand(message);\n+    }\n+\n+    public class SyncPostCommand implements ISyncMessageBus.ISyncPostCommand{\n+\n+\n+        private T message;\n+\n+        public SyncPostCommand(T message) {\n+            this.message = message;\n+        }\n+\n+        @Override\n+        public void now() {\n+            publish(message);\n+        }\n+    }\n+}\n"
    },
    {
        "commit hash": "f5ecdefcd093e5aca4593e764d5378772b32509c",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AllTests.java",
            "additions": 3,
            "deletions": 1
        },
        "diff content": "@@ -14,7 +14,9 @@ import org.junit.runners.Suite;\n @Suite.SuiteClasses({\n         StrongConcurrentSetTest.class,\n         WeakConcurrentSetTest.class,\n-        MessagePublicationTest.class,\n+        AsynchronousMessageBusTest.class,\n+        SyncBusTest.MBassadorTest.class,\n+        SyncBusTest.SyncMessageBusTest.class,\n         FilterTest.class,\n         MetadataReaderTest.class,\n         ListenerSubscriptionTest.class,\n"
    },
    {
        "commit hash": "f5ecdefcd093e5aca4593e764d5378772b32509c",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AsynchronousMessageBusTest.java",
            "additions": 1,
            "deletions": 54
        },
        "diff content": "@@ -20,7 +20,7 @@ import java.util.concurrent.CopyOnWriteArrayList;\n  * @author bennidi\n  *         Date: 2/8/12\n  */\n-public class MessagePublicationTest extends MessageBusTest {\n+public class AsynchronousMessageBusTest extends MessageBusTest {\n \n     // this value probably needs to be adjusted depending on the performance of the underlying plattform\n     // otherwise the tests will fail since asynchronous processing might not have finished when\n@@ -61,59 +61,6 @@ public class MessagePublicationTest extends MessageBusTest {\n \n     }\n \n-    @Test\n-    public void testSynchronousMessagePublication() throws Exception {\n-\n-        MBassador bus = getBus(new BusConfiguration());\n-        ListenerFactory listenerFactory = new ListenerFactory()\n-                .create(10000, EventingTestBean.class)\n-                .create(10000, EventingTestBean2.class)\n-                .create(10000, EventingTestBean3.class)\n-                .create(10000, Object.class)\n-                .create(10000, NonListeningBean.class);\n-\n-        List<Object> listeners = listenerFactory.build();\n-\n-        // this will subscribe the listeners concurrently to the bus\n-        TestUtil.setup(bus, listeners, 10);\n-\n-        TestMessage message = new TestMessage();\n-        TestMessage subMessage = new SubTestMessage();\n-\n-        bus.publish(message);\n-        bus.publish(subMessage);\n-\n-        pause(processingTimeInMS);\n-\n-        assertEquals(30000, message.counter.get());\n-        assertEquals(70000, subMessage.counter.get());\n-\n-    }\n-\n-    @Test\n-    public void testStrongListenerSubscription() throws Exception {\n-\n-        MBassador bus = getBus(new BusConfiguration());\n-\n-\n-        for(int i = 0; i< 10000; i++){\n-            bus.subscribe(new EventingTestBean2());\n-        }\n-\n-        runGC();\n-\n-        TestMessage message = new TestMessage();\n-        TestMessage subMessage = new SubTestMessage();\n-\n-        bus.publish(message);\n-        bus.publish(subMessage);\n-\n-        pause(processingTimeInMS);\n-\n-        assertEquals(10000, message.counter.get());\n-        assertEquals(20000, subMessage.counter.get());\n-\n-    }\n \n     @Test\n     public void testConcurrentMixedMessagePublication() throws Exception {\n"
    },
    {
        "commit hash": "f5ecdefcd093e5aca4593e764d5378772b32509c",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SyncBusTest.java",
            "additions": 170,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,170 @@\n+package net.engio.mbassy;\n+\n+import net.engio.mbassy.bus.*;\n+import net.engio.mbassy.common.MessageBusTest;\n+import net.engio.mbassy.common.TestUtil;\n+import net.engio.mbassy.dispatch.HandlerInvocation;\n+import net.engio.mbassy.events.SubTestMessage;\n+import net.engio.mbassy.events.TestMessage;\n+import net.engio.mbassy.listener.*;\n+import net.engio.mbassy.listeners.*;\n+import net.engio.mbassy.subscription.SubscriptionContext;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+/**\n+ * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n+ *\n+ * @author bennidi\n+ *         Date: 2/8/12\n+ */\n+public abstract class SyncBusTest extends MessageBusTest {\n+\n+    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n+    // otherwise the tests will fail since asynchronous processing might not have finished when\n+    // evaluation is run\n+    private int processingTimeInMS = 4000;\n+\n+\n+    @Test\n+    public void testSynchronousMessagePublication() throws Exception {\n+\n+        ISyncMessageBus bus = getSyncMessageBus();\n+        ListenerFactory listenerFactory = new ListenerFactory()\n+                .create(10000, MessageListener1.class)\n+                .create(10000, MessageListener2.class)\n+                .create(10000, MessageListener3.class)\n+                .create(10000, Object.class)\n+                .create(10000, NonListeningBean.class);\n+\n+        List<Object> listeners = listenerFactory.build();\n+\n+        // this will subscribe the listeners concurrently to the bus\n+        TestUtil.setup(bus, listeners, 10);\n+\n+        TestMessage message = new TestMessage();\n+        TestMessage subMessage = new SubTestMessage();\n+\n+        bus.post(message).now();\n+        bus.post(subMessage).now();\n+\n+        pause(processingTimeInMS);\n+\n+        assertEquals(30000, message.counter.get());\n+        assertEquals(70000, subMessage.counter.get());\n+\n+    }\n+\n+    @Test\n+    public void testStrongListenerSubscription() throws Exception {\n+\n+        ISyncMessageBus bus = getSyncMessageBus();\n+\n+\n+        for(int i = 0; i< 10000; i++){\n+            bus.subscribe(new MessageListener2());\n+        }\n+\n+        runGC();\n+\n+        TestMessage message = new TestMessage();\n+        TestMessage subMessage = new SubTestMessage();\n+\n+        bus.post(message).now();\n+        bus.post(subMessage).now();\n+\n+        pause(processingTimeInMS);\n+\n+        assertEquals(10000, message.counter.get());\n+        assertEquals(20000, subMessage.counter.get());\n+\n+    }\n+\n+    protected abstract ISyncMessageBus getSyncMessageBus();\n+\n+\n+    public static class MessageListener1 {\n+\n+        // every event of type TestEvent or any subtype will be delivered\n+        // to this listener\n+        @Handler\n+        public void handleTestEvent(TestMessage message) {\n+            message.counter.incrementAndGet();\n+        }\n+\n+        // this handler will be invoked asynchronously\n+        @Handler(priority = 0, invocation = HandleSubTestEventInvocation.class)\n+        public void handleSubTestEvent(SubTestMessage message) {\n+            message.counter.incrementAndGet();\n+        }\n+\n+        // this handler will receive events of type SubTestEvent\n+        // or any subtabe and that passes the given filter\n+        @Handler(\n+                priority = 10,\n+                delivery = Invoke.Synchronously,\n+                filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n+        public void handleFiltered(SubTestMessage message) {\n+            message.counter.incrementAndGet();\n+        }\n+\n+\n+    }\n+\n+    public static class HandleSubTestEventInvocation extends HandlerInvocation<MessageListener1, SubTestMessage> {\n+\n+        public HandleSubTestEventInvocation(SubscriptionContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        public void invoke(MessageListener1 listener, SubTestMessage message) {\n+            listener.handleSubTestEvent(message);\n+        }\n+    }\n+\n+    @Listener(references = References.Strong)\n+    public static class MessageListener2 extends net.engio.mbassy.listeners.EventingTestBean {\n+\n+        // redefine the configuration for this handler\n+        @Handler(delivery = Invoke.Synchronously)\n+        public void handleSubTestEvent(SubTestMessage message) {\n+            super.handleSubTestEvent(message);\n+        }\n+\n+    }\n+\n+    @Listener(references = References.Strong)\n+    public static class MessageListener3 extends net.engio.mbassy.listeners.EventingTestBean2 {\n+\n+\n+        // this handler will be invoked asynchronously\n+        @Handler(priority = 0, delivery = Invoke.Synchronously)\n+        public void handleSubTestEventAgain(SubTestMessage message) {\n+            message.counter.incrementAndGet();\n+        }\n+\n+    }\n+\n+\n+    public static class MBassadorTest extends SyncBusTest {\n+\n+\n+        @Override\n+        protected ISyncMessageBus getSyncMessageBus() {\n+            return new MBassador(BusConfiguration.Default());\n+        }\n+\n+    }\n+\n+    public static class SyncMessageBusTest extends SyncBusTest {\n+\n+\n+        @Override\n+        protected ISyncMessageBus getSyncMessageBus() {\n+            return new SyncMessageBus(new SyncBusConfiguration());\n+        }\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "f5ecdefcd093e5aca4593e764d5378772b32509c",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 4,
            "deletions": 2
        },
        "diff content": "@@ -4,6 +4,7 @@ import junit.framework.Assert;\n import net.engio.mbassy.IPublicationErrorHandler;\n import net.engio.mbassy.PublicationError;\n import net.engio.mbassy.bus.BusConfiguration;\n+import net.engio.mbassy.bus.ISyncMessageBus;\n import net.engio.mbassy.bus.MBassador;\n \n /**\n@@ -13,9 +14,9 @@ import net.engio.mbassy.bus.MBassador;\n  * @author bennidi\n  *         Date: 3/2/13\n  */\n-public class MessageBusTest extends UnitTest {\n+public class MessageBusTest<Bus extends ISyncMessageBus> extends UnitTest {\n \n-    private static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n+    protected static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n         @Override\n         public void handleError(PublicationError error) {\n             Assert.fail();\n@@ -27,4 +28,5 @@ public class MessageBusTest extends UnitTest {\n         bus.addErrorHandler(TestFailingHandler);\n         return bus;\n     }\n+\n }\n"
    },
    {
        "commit hash": "f5ecdefcd093e5aca4593e764d5378772b32509c",
        "previous commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/TestUtil.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.common;\n \n import net.engio.mbassy.bus.IMessageBus;\n+import net.engio.mbassy.bus.ISyncMessageBus;\n \n import java.util.List;\n \n@@ -13,7 +14,7 @@ import java.util.List;\n public class TestUtil {\n \n \n-    public static void setup(final IMessageBus bus, final List<Object> listeners, int numberOfThreads) {\n+    public static void setup(final ISyncMessageBus bus, final List<Object> listeners, int numberOfThreads) {\n         Runnable[] setupUnits = new Runnable[numberOfThreads];\n         int partitionSize;\n         if(listeners.size() >= numberOfThreads){\n"
    },
    {
        "commit hash": "c7922f5e7e147828f679183fda03f6932373fc5c",
        "previous commit hash": "302d96f46b66b43fe49f8541747c1402fc944bf9",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.6</version>\n+    <version>1.1.7-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.6</tag>\n+        <tag>mbassador-1.1.4</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "302d96f46b66b43fe49f8541747c1402fc944bf9",
        "previous commit hash": "a9b25b65097a6405431ec045e58aae42e1585529",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.6-SNAPSHOT</version>\n+    <version>1.1.6</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.4</tag>\n+        <tag>mbassador-1.1.6</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "a9b25b65097a6405431ec045e58aae42e1585529",
        "previous commit hash": "a6995018adc51b1f251b2c07d1e0a7b22ba6eab1",
        "diff stats": {
            "file_path": "README.md",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -8,7 +8,7 @@ data structure to allow high throughput for concurrent access.\n Read this documentation to get an overview of its features. You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n which also contains a partial list of the features of the compared implementations.\n \n-The current version is 1.1.4 and it is available from the Maven Central Repository. See the release notes for more details.\n+The current version is 1.1.6 and it is available from the Maven Central Repository. See the release notes for more details.\n \n Table of contents:\n + [Features](#features)\n@@ -137,7 +137,7 @@ Beginning with version 1.1.0 MBassador is available from the Maven Central Repos\n     <dependency>\n         <groupId>net.engio</groupId>\n         <artifactId>mbassador</artifactId>\n-        <version>1.1.0</version>\n+        <version>1.1.6</version>\n     </dependency>\n ```\n \n@@ -151,7 +151,7 @@ to avoid confusion and misunderstanding.\n \n <h2>Release Notes</h2>\n \n-<h3>1.1.4</h3>\n+<h3>1.1.6</h3>\n \n  + Added support for choosing between strong and weak references using the new @Listener annotation. @Listener can be\n  added to any class that defines message handlers and allows to configure which reference type is used\n"
    },
    {
        "commit hash": "a9b25b65097a6405431ec045e58aae42e1585529",
        "previous commit hash": "a6995018adc51b1f251b2c07d1e0a7b22ba6eab1",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.4</version>\n+    <version>1.1.6-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n"
    },
    {
        "commit hash": "a6995018adc51b1f251b2c07d1e0a7b22ba6eab1",
        "previous commit hash": "f79647884fae3a320e399c46fa564816d0812ea9",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.4-SNAPSHOT</version>\n+    <version>1.1.4</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.2</tag>\n+        <tag>mbassador-1.1.4</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "f79647884fae3a320e399c46fa564816d0812ea9",
        "previous commit hash": "8da29f94cc2fcde87112139ee10af45ee387fb9d",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.2.0-SNAPSHOT</version>\n+    <version>1.1.4-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n"
    },
    {
        "commit hash": "8da29f94cc2fcde87112139ee10af45ee387fb9d",
        "previous commit hash": "a1a6324d4494c8652446d3f6d83f8db0d95e7080",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.4-SNAPSHOT</version>\n+    <version>1.2.0-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n"
    },
    {
        "commit hash": "a1a6324d4494c8652446d3f6d83f8db0d95e7080",
        "previous commit hash": "1230bc7691bda89d62544370ed98333bff7f64bc",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/ISyncMessageBus.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -10,7 +10,7 @@ import java.util.Collection;\n  * @author bennidi\n  *         Date: 3/29/13\n  */\n-public interface ISyncMessageBus<T, P extends IMessageBus.ISyncPostCommand> {\n+public interface ISyncMessageBus<T, P extends ISyncMessageBus.ISyncPostCommand> {\n \n \n     /**\n"
    },
    {
        "commit hash": "1230bc7691bda89d62544370ed98333bff7f64bc",
        "previous commit hash": "812eefae19074db5e660da7860b8fc2170b7adcf",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.6-SNAPSHOT</version>\n+    <version>1.1.4-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n"
    },
    {
        "commit hash": "812eefae19074db5e660da7860b8fc2170b7adcf",
        "previous commit hash": "e7c3dcfe568a3e2604622c7e95a9a131ea86c793",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.5</version>\n+    <version>1.1.6-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.5</tag>\n+        <tag>mbassador-1.1.2</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "e7c3dcfe568a3e2604622c7e95a9a131ea86c793",
        "previous commit hash": "07dc4ebd57befe9e3005119b78a40a2ff3ae701a",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.5-SNAPSHOT</version>\n+    <version>1.1.5</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.2</tag>\n+        <tag>mbassador-1.1.5</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "07dc4ebd57befe9e3005119b78a40a2ff3ae701a",
        "previous commit hash": "6470735f11e79165bc4646902d6a983118e36962",
        "diff stats": {
            "file_path": "README.md",
            "additions": 7,
            "deletions": 7
        },
        "diff content": "@@ -133,14 +133,14 @@ Message publication:\n \n <h2>Installation</h2>\n Beginning with version 1.1.0 MBassador is available from the Maven Central Repository using the following coordinates:\n+```xml\n+    <dependency>\n+        <groupId>net.engio</groupId>\n+        <artifactId>mbassador</artifactId>\n+        <version>1.1.0</version>\n+    </dependency>\n+```\n \n-    <pre><code class=\"xml\">\n-        &lt;dependency&gt;\n-            &lt;groupId&gt;net.engio&lt;/groupId&gt;\n-            &lt;artifactId&gt;mbassador&lt;/artifactId&gt;\n-            &lt;version&gt;1.1.0&lt;/version&gt;\n-        &lt;/dependency&gt;\n-    </code></pre>\n \n Of course you can always clone the repository and build from source.\n \n"
    },
    {
        "commit hash": "6470735f11e79165bc4646902d6a983118e36962",
        "previous commit hash": "41d298a4754651834958b9f8d1c0877085758bf3",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 7
        },
        "diff content": "@@ -133,13 +133,7 @@ Message publication:\n \n <h2>Installation</h2>\n Beginning with version 1.1.0 MBassador is available from the Maven Central Repository using the following coordinates:\n-         <pre><code class=\"xml\">\n-        <dependency>\n-            <groupId>net.engio</groupId>\n-            <artifactId>mbassador</artifactId>\n-            <version>1.1.0</version>\n-        </dependency>\n-        </code></pre>\n+\n     <pre><code class=\"xml\">\n         &lt;dependency&gt;\n             &lt;groupId&gt;net.engio&lt;/groupId&gt;\n"
    },
    {
        "commit hash": "41d298a4754651834958b9f8d1c0877085758bf3",
        "previous commit hash": "7928f0a121c9c726b426612c1a1d974e08f7d7a9",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -133,13 +133,13 @@ Message publication:\n \n <h2>Installation</h2>\n Beginning with version 1.1.0 MBassador is available from the Maven Central Repository using the following coordinates:\n-        <code class=\"xml\">\n+         <pre><code class=\"xml\">\n         <dependency>\n             <groupId>net.engio</groupId>\n             <artifactId>mbassador</artifactId>\n             <version>1.1.0</version>\n         </dependency>\n-        </code>\n+        </code></pre>\n     <pre><code class=\"xml\">\n         &lt;dependency&gt;\n             &lt;groupId&gt;net.engio&lt;/groupId&gt;\n"
    },
    {
        "commit hash": "7928f0a121c9c726b426612c1a1d974e08f7d7a9",
        "previous commit hash": "39839f6aa619811b8f48740103dcca7f724e86d5",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -133,12 +133,13 @@ Message publication:\n \n <h2>Installation</h2>\n Beginning with version 1.1.0 MBassador is available from the Maven Central Repository using the following coordinates:\n+        <code class=\"xml\">\n         <dependency>\n             <groupId>net.engio</groupId>\n             <artifactId>mbassador</artifactId>\n             <version>1.1.0</version>\n         </dependency>\n-\n+        </code>\n     <pre><code class=\"xml\">\n         &lt;dependency&gt;\n             &lt;groupId&gt;net.engio&lt;/groupId&gt;\n"
    },
    {
        "commit hash": "39839f6aa619811b8f48740103dcca7f724e86d5",
        "previous commit hash": "f65160d50295729cbdf0b89f69e8594468a5dcab",
        "diff stats": {
            "file_path": "README.md",
            "additions": 5,
            "deletions": 0
        },
        "diff content": "@@ -133,6 +133,11 @@ Message publication:\n \n <h2>Installation</h2>\n Beginning with version 1.1.0 MBassador is available from the Maven Central Repository using the following coordinates:\n+        <dependency>\n+            <groupId>net.engio</groupId>\n+            <artifactId>mbassador</artifactId>\n+            <version>1.1.0</version>\n+        </dependency>\n \n     <pre><code class=\"xml\">\n         &lt;dependency&gt;\n"
    },
    {
        "commit hash": "f65160d50295729cbdf0b89f69e8594468a5dcab",
        "previous commit hash": "e1c8db1a1d3055575c197abb2431eb08f9c33b82",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -140,7 +140,7 @@ Beginning with version 1.1.0 MBassador is available from the Maven Central Repos\n             &lt;artifactId&gt;mbassador&lt;/artifactId&gt;\n             &lt;version&gt;1.1.0&lt;/version&gt;\n         &lt;/dependency&gt;\n-    </pre></code>\n+    </code></pre>\n \n Of course you can always clone the repository and build from source.\n \n"
    },
    {
        "commit hash": "e1c8db1a1d3055575c197abb2431eb08f9c33b82",
        "previous commit hash": "d68cb63cadc3bbf22ac9901d8c5d02e421bda660",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -115,7 +115,7 @@ Creation of message bus and registration of listeners:\n         // bind it to any upper bound\n         MBassador<TestMessage> bus = new MBassador<TestMessage>(BusConfiguration.Default());\n         ListeningBean listener = new ListeningBean();\n-        // the listener will be registered using a weak-reference\n+        // the listener will be registered using a weak-reference if not configured otherwise with @Listener\n         bus.subscribe(listener);\n         // objects without handlers will be ignored\n         bus.subscribe(new ClassWithoutAnyDefinedHandlers());\n"
    },
    {
        "commit hash": "d68cb63cadc3bbf22ac9901d8c5d02e421bda660",
        "previous commit hash": "8d1379c6aad49df7e87234d62b52a1a97daa9c0e",
        "diff stats": {
            "file_path": "README.md",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -51,7 +51,7 @@ FilteredMessage events can be handled by registering listeners that handle Filte\n + <em><strong>Synchronization</em></strong>: It is possible to ensure that a handler is invoked non-concurrently,i.e. making it thread-safe by adding @Synchronized\n + <em><strong>Extensibility</em></strong>:MBassador is designed to be extensible with custom implementations of various components like message\n dispatchers and handler invocations (using the decorator pattern), metadata reader (you can add your own annotations) and factories for different\n- kinds of object.A configuration object can be passed to on instance creation to specify the different configurable parts\n+ kinds of objects. A configuration object is used to customize the different configurable parts\n + <em><strong>Ease of Use</em></strong>: Using MBassador in your project is very easy. Create as many instances of MBassador as you like (usually a singleton will do),\n mark and configure your message handlers with @Handler annotations and finally register the listeners at any MBassador instance. Start\n sending messages to your listeners using one of MBassador's publication methods (sync or async). Done!\n@@ -86,13 +86,13 @@ Handler definition (in any bean):\n \t\t// this handler will receive messages of type SubTestMessage\n         // or any of its sub types that passe the given filter(s)\n         @Handler(priority = 10,\n-                  delivery = Mode.Sequential,\n+                  delivery = Invoke.Synchronously,\n                   filters = {@Filter(Filters.SpecialMessage.class)})\n         public void handleFiltered(SubTestMessage message) {\n            //do something special here\n         }\n \n-        @Handler(delivery = Mode.Sequential, rejectSubtypes = true)\n+        @Handler(delivery = Invoke.Synchronously, rejectSubtypes = true)\n         @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n         public void handleUnrelatedMessageTypes(MessageEnvelope envelope) {\n             // the envelope will contain either an instance of TestMessage or TestMessage2\n"
    },
    {
        "commit hash": "8d1379c6aad49df7e87234d62b52a1a97daa9c0e",
        "previous commit hash": "aecb1593eb76d3715644b59a32f94db8a103403f",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -42,7 +42,7 @@ ignore objects without message handlers and automatically clean-up orphaned weak\n a single message handler\n + <em><strong>Message envelopes</em></strong>: Message handlers can declare to receive an enveloped message. The envelope can wrap different\n types of messages. This allows for a single handler to handle multiple, unrelated message types.\n-+ <em><strong>Handler priorities</em></strong>: A listener can be associated with a priority to influence the order in which messages are delivered when multiple handlers exist\n++ <em><strong>Handler priorities</em></strong>: A handler can be associated with a priority to influence the order in which messages are delivered when multiple matching handlers exist\n + <em><strong>Custom error handling</em></strong>: Errors during message delivery are sent to all registered error handlers which can be added to the bus as necessary.\n + <em><strong>DeadMessage event</em></strong>: Messages that do not match any handler result in the publication of a DeadMessage object which wraps the original message. DeadMessage events\n can be handled by registering listeners that handle DeadMessage.\n"
    },
    {
        "commit hash": "aecb1593eb76d3715644b59a32f94db8a103403f",
        "previous commit hash": "913c38edba518b6269b7645f04bb2f498040f870",
        "diff stats": {
            "file_path": "README.md",
            "additions": 5,
            "deletions": 3
        },
        "diff content": "@@ -29,7 +29,7 @@ At its core MBassador offers the following features:\n + <em><strong>Annotation driven</em></strong>: To define and customize a message handler simply mark it with @Handler annotation\n + <em><strong>Delivers everything</em></strong>: Messages must not implement any interface and can be of any type. It is\n possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery.\n-This means that listeners will also receivesubtypes of the message type they are listening for, e.g. a listener for Object.class receives everything.\n+This means that handlers will also receive subtypes of the message type they are listening for, e.g. a handler of Object.class receives everything.\n + <em><strong>Synchronous and asynchronous message delivery</em></strong>: A handler can be invoked to handle a message either synchronously or\n asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method\n blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch\n@@ -37,17 +37,18 @@ blocks until messages are delivered to all handlers) or asynchronous (fire and f\n listeners that are not used anymore (of course it is also possible to explicitly unregister a listener if needed). This is very comfortable\n in certain environments where listeners are managed by frameworks, i.e. spring, guice etc. Just stuff everything into the message bus, it will\n ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.\n-+ <em><strong>Strong references</em></strong>: Instead of using weak references, the bus can be configured to use strong references.\n++ <em><strong>Strong references</em></strong>: Instead of using weak references, a listener can be configured to be referenced using strong references using @Listener\n + <em><strong>Filtering</em></strong>: MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to\n a single message handler\n + <em><strong>Message envelopes</em></strong>: Message handlers can declare to receive an enveloped message. The envelope can wrap different\n-types of messages. This allows for a single handler to handle multiple (unrelated) message types.\n+types of messages. This allows for a single handler to handle multiple, unrelated message types.\n + <em><strong>Handler priorities</em></strong>: A listener can be associated with a priority to influence the order in which messages are delivered when multiple handlers exist\n + <em><strong>Custom error handling</em></strong>: Errors during message delivery are sent to all registered error handlers which can be added to the bus as necessary.\n + <em><strong>DeadMessage event</em></strong>: Messages that do not match any handler result in the publication of a DeadMessage object which wraps the original message. DeadMessage events\n can be handled by registering listeners that handle DeadMessage.\n + <em><strong>FilteredMessage event</em></strong>: Messages that have matching handlers but do not pass the configured filters result in the publication of a FilteredMessage object which wraps the original message.\n FilteredMessage events can be handled by registering listeners that handle FilteredMessage.\n++ <em><strong>Synchronization</em></strong>: It is possible to ensure that a handler is invoked non-concurrently,i.e. making it thread-safe by adding @Synchronized\n + <em><strong>Extensibility</em></strong>:MBassador is designed to be extensible with custom implementations of various components like message\n dispatchers and handler invocations (using the decorator pattern), metadata reader (you can add your own annotations) and factories for different\n  kinds of object.A configuration object can be passed to on instance creation to specify the different configurable parts\n@@ -57,6 +58,7 @@ sending messages to your listeners using one of MBassador's publication methods\n \n \n \n+\n <h2>Usage</h2>\n \n Handler definition (in any bean):\n"
    },
    {
        "commit hash": "913c38edba518b6269b7645f04bb2f498040f870",
        "previous commit hash": "7e818b584e5febe71a33c1158dff13a8e4383bd6",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.4</version>\n+    <version>1.1.5-SNAPSHOT</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.4</tag>\n+        <tag>mbassador-1.1.2</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "7e818b584e5febe71a33c1158dff13a8e4383bd6",
        "previous commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.4-SNAPSHOT</version>\n+    <version>1.1.4</version>\n     <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -35,7 +35,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.2</tag>\n+        <tag>mbassador-1.1.4</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "README.md",
            "additions": 36,
            "deletions": 22
        },
        "diff content": "@@ -8,7 +8,7 @@ data structure to allow high throughput for concurrent access.\n Read this documentation to get an overview of its features. You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n which also contains a partial list of the features of the compared implementations.\n \n-The current version is 1.1.3 and it is available from the Maven Central Repository. See the release notes for more details.\n+The current version is 1.1.4 and it is available from the Maven Central Repository. See the release notes for more details.\n \n Table of contents:\n + [Features](#features)\n@@ -33,10 +33,11 @@ This means that listeners will also receivesubtypes of the message type they are\n + <em><strong>Synchronous and asynchronous message delivery</em></strong>: A handler can be invoked to handle a message either synchronously or\n asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method\n blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch\n-+ <em><strong>Weak references</em></strong>: MBassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister\n++ <em><strong>Weak references</em></strong>: By default, MBassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister\n listeners that are not used anymore (of course it is also possible to explicitly unregister a listener if needed). This is very comfortable\n in certain environments where listeners are managed by frameworks, i.e. spring, guice etc. Just stuff everything into the message bus, it will\n ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.\n++ <em><strong>Strong references</em></strong>: Instead of using weak references, the bus can be configured to use strong references.\n + <em><strong>Filtering</em></strong>: MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to\n a single message handler\n + <em><strong>Message envelopes</em></strong>: Message handlers can declare to receive an enveloped message. The envelope can wrap different\n@@ -58,7 +59,7 @@ sending messages to your listeners using one of MBassador's publication methods\n \n <h2>Usage</h2>\n \n-Listener definition (in any bean):\n+Handler definition (in any bean):\n \n         // every message of type TestMessage or any subtype will be delivered\n         // to this handler\n@@ -67,8 +68,15 @@ Listener definition (in any bean):\n \t\t\t// do something\n \t\t}\n \n-        // this handler will be invoked concurrently\n-\t\t@Handler(delivery = Mode.Concurrent)\n+\t\t// every message of type TestMessage or any subtype will be delivered\n+        // to this handler\n+        @Handler\n+        public void handleTestMessageStrong(TestMessage message) {\n+            // do something\n+        }\n+\n+        // this handler will be invoked asynchronously (in a different thread)\n+\t\t@Handler(delivery = Invoke.Asynchronously)\n \t\tpublic void handleSubTestMessage(SubTestMessage message) {\n             // do something more expensive here\n \t\t}\n@@ -90,6 +98,15 @@ Listener definition (in any bean):\n         }\n \n \n+        // configure a listener to be stored using strong instead of weak references\n+        @Listener(references = References.Strong)\n+        public class MessageListener{\n+\n+            // any handler definitions\n+\n+        }\n+\n+\n Creation of message bus and registration of listeners:\n \n         // create as many instances as necessary\n@@ -113,22 +130,8 @@ Message publication:\n         bus.post(subMessage).now(); // same as above\n \n <h2>Installation</h2>\n-Beginning with version 1.1.0 MBassador is available from the Maven Central Repository (Hooray!). Older versions are\n-still available from the included maven repository in this github repo but will be deleted in the future.\n-The recommended way of using MBassador in your project is to add the dependency as shown in step two. Step one is only necessary\n-if you want to use an older version that is not available in the central repository.\n+Beginning with version 1.1.0 MBassador is available from the Maven Central Repository using the following coordinates:\n \n- 1. Add the repository location to your pom.xml\n-    <pre><code class=\"xml\">\n-    &lt;repositories&gt;\n-        &lt;repository&gt;\n-            &lt;id&gt;mbassador-github-repo&lt;/id&gt;\n-            &lt;url&gt;https://raw.github.com/bennidi/mbassador/master/maven &lt;/url&gt;\n-        &lt;/repository&gt;\n-    &lt;/repositories&gt;\n-    </pre></code>\n- 2. Add the MBassador dependency to your pom.xml. You can check which versions are available by browsing\n-    the git repository online.\n     <pre><code class=\"xml\">\n         &lt;dependency&gt;\n             &lt;groupId&gt;net.engio&lt;/groupId&gt;\n@@ -136,7 +139,6 @@ if you want to use an older version that is not available in the central reposit\n             &lt;version&gt;1.1.0&lt;/version&gt;\n         &lt;/dependency&gt;\n     </pre></code>\n- 3. Run mvn clean package to have maven download and install the required version into your local repository\n \n Of course you can always clone the repository and build from source.\n \n@@ -147,6 +149,18 @@ to avoid confusion and misunderstanding.\n \n <h2>Release Notes</h2>\n \n+<h3>1.1.4</h3>\n+\n+ + Added support for choosing between strong and weak references using the new @Listener annotation. @Listener can be\n+ added to any class that defines message handlers and allows to configure which reference type is used\n+ + Custom handler invocations: It is possible to provide a custom handler invocation for each message handler, see \"invocation\"\n+ property of @Handler\n+ + Changed packaging to \"bundle\" to support OSGI environments\n+ + Synchronization of message handlers via @Synchronized: Handlers that are not thread-safe can be synchronized to guarantee\n+  that only one thread at a time can invoke that handler\n+ + Created a message bus implementation that does not use threading to support use in non-multi-threaded environments like GWT,\n+ see ISyncMessageBus\n+\n <h3>1.1.3</h3>\n \n  + Added support for FilteredMessage event\n@@ -179,7 +193,7 @@ First stable release!\n  + Fixed behaviour with capacity bound blocking queue such that there now are two methods to schedule a message\n  asynchronously. One will block until capacity becomes available, the other will timeout after a specified amount of\n  time.\n- +  Added unit tests\n+ +  Additional unit tests\n \n <h3>1.0.5.RC</h3>\n \n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar and /dev/null differ\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-d53edd50a68307a4c209fd21fa0625d7\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-f2ed26a15178d83c80212ccce73584e97e7d6fb8\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.pom",
            "additions": 0,
            "deletions": 58
        },
        "diff content": "@@ -1,58 +0,0 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-\n-    <modelVersion>4.0.0</modelVersion>\n-    <groupId>org.mbassy</groupId>\n-    <artifactId>mbassador</artifactId>\n-    <version>1.0.0.RC</version>\n-    <packaging>jar</packaging>\n-    <name>mbassador</name>\n-    <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n-    </description>\n-\n-    <properties>\n-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-        <project.build.java.version>1.6</project.build.java.version>\n-        <github.url>file://${project.basedir}/maven</github.url>\n-    </properties>\n-\n-    <dependencies>\n-\n-        <dependency>\n-            <groupId>junit</groupId>\n-            <artifactId>junit</artifactId>\n-            <version>4.10</version>\n-            <scope>test</scope>\n-        </dependency>\n-\n-    </dependencies>\n-\n-    <distributionManagement>\n-        <repository>\n-            <id>mbassador-github-repo</id>\n-            <url>${github.url}</url>\n-        </repository>\n-    </distributionManagement>\n-\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>${project.build.java.version}</source>\n-                    <target>${project.build.java.version}</target>\n-                </configuration>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-surefire-plugin</artifactId>\n-                <configuration>\n-                    <skipTests>false</skipTests>\n-                </configuration>\n-            </plugin>\n-\n-        </plugins>\n-    </build>\n-</project>\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.pom.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-760688c8fb33fc90918146e68dab2646\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.pom.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-0abf762df11d85841f8f8b7f28361ff19549f019\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.1.RC/mbassador-1.0.1.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/maven/org/mbassy/mbassador/1.0.1.RC/mbassador-1.0.1.RC.jar and /dev/null differ\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.1.RC/mbassador-1.0.1.RC.jar.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-933328ff6220f5910770b9b5f13f2eeb\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.1.RC/mbassador-1.0.1.RC.jar.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-003aa85106cfbab5ce618ffd1a6fe36cd0e37b71\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.1.RC/mbassador-1.0.1.RC.pom",
            "additions": 0,
            "deletions": 58
        },
        "diff content": "@@ -1,58 +0,0 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-\n-    <modelVersion>4.0.0</modelVersion>\n-    <groupId>org.mbassy</groupId>\n-    <artifactId>mbassador</artifactId>\n-    <version>1.0.1.RC</version>\n-    <packaging>jar</packaging>\n-    <name>mbassador</name>\n-    <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n-    </description>\n-\n-    <properties>\n-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-        <project.build.java.version>1.6</project.build.java.version>\n-        <github.url>file://${project.basedir}/maven</github.url>\n-    </properties>\n-\n-    <dependencies>\n-\n-        <dependency>\n-            <groupId>junit</groupId>\n-            <artifactId>junit</artifactId>\n-            <version>4.10</version>\n-            <scope>test</scope>\n-        </dependency>\n-\n-    </dependencies>\n-\n-    <distributionManagement>\n-        <repository>\n-            <id>mbassador-github-repo</id>\n-            <url>${github.url}</url>\n-        </repository>\n-    </distributionManagement>\n-\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>${project.build.java.version}</source>\n-                    <target>${project.build.java.version}</target>\n-                </configuration>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-surefire-plugin</artifactId>\n-                <configuration>\n-                    <skipTests>false</skipTests>\n-                </configuration>\n-            </plugin>\n-\n-        </plugins>\n-    </build>\n-</project>\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.1.RC/mbassador-1.0.1.RC.pom.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-5959d236fd411d499f3b46ecedc28a84\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.1.RC/mbassador-1.0.1.RC.pom.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-5203632e409974a234ff8ce0ea88c5897a8cbffe\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.2.RC/mbassador-1.0.2.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/maven/org/mbassy/mbassador/1.0.2.RC/mbassador-1.0.2.RC.jar and /dev/null differ\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.2.RC/mbassador-1.0.2.RC.jar.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-5ad621adc6addc2292ee1fc7a2bd756d\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.2.RC/mbassador-1.0.2.RC.jar.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-258a17785e15390e868efe2a51d5370aeb602129\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.2.RC/mbassador-1.0.2.RC.pom",
            "additions": 0,
            "deletions": 58
        },
        "diff content": "@@ -1,58 +0,0 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-\n-    <modelVersion>4.0.0</modelVersion>\n-    <groupId>org.mbassy</groupId>\n-    <artifactId>mbassador</artifactId>\n-    <version>1.0.2.RC</version>\n-    <packaging>jar</packaging>\n-    <name>mbassador</name>\n-    <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n-    </description>\n-\n-    <properties>\n-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-        <project.build.java.version>1.6</project.build.java.version>\n-        <github.url>file://${project.basedir}/maven</github.url>\n-    </properties>\n-\n-    <dependencies>\n-\n-        <dependency>\n-            <groupId>junit</groupId>\n-            <artifactId>junit</artifactId>\n-            <version>4.10</version>\n-            <scope>test</scope>\n-        </dependency>\n-\n-    </dependencies>\n-\n-    <distributionManagement>\n-        <repository>\n-            <id>mbassador-github-repo</id>\n-            <url>${github.url}</url>\n-        </repository>\n-    </distributionManagement>\n-\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>${project.build.java.version}</source>\n-                    <target>${project.build.java.version}</target>\n-                </configuration>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-surefire-plugin</artifactId>\n-                <configuration>\n-                    <skipTests>false</skipTests>\n-                </configuration>\n-            </plugin>\n-\n-        </plugins>\n-    </build>\n-</project>\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.2.RC/mbassador-1.0.2.RC.pom.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-f7972cec0f8ebde2a2a17a678ef36eb6\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.2.RC/mbassador-1.0.2.RC.pom.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-f8c24fe42f192dbdd1f5d2b29bff0220d40039dd\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.3.RC/mbassador-1.0.3.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/maven/org/mbassy/mbassador/1.0.3.RC/mbassador-1.0.3.RC.jar and /dev/null differ\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.3.RC/mbassador-1.0.3.RC.jar.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-2bcfd233f83cb6fc4241c91a99f74030\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.3.RC/mbassador-1.0.3.RC.jar.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-20df67988104be77a9c3e2edbb8ba615a664671b\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.3.RC/mbassador-1.0.3.RC.pom",
            "additions": 0,
            "deletions": 58
        },
        "diff content": "@@ -1,58 +0,0 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-\n-    <modelVersion>4.0.0</modelVersion>\n-    <groupId>org.mbassy</groupId>\n-    <artifactId>mbassador</artifactId>\n-    <version>1.0.3.RC</version>\n-    <packaging>jar</packaging>\n-    <name>mbassador</name>\n-    <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n-    </description>\n-\n-    <properties>\n-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-        <project.build.java.version>1.6</project.build.java.version>\n-        <github.url>file://${project.basedir}/maven</github.url>\n-    </properties>\n-\n-    <dependencies>\n-\n-        <dependency>\n-            <groupId>junit</groupId>\n-            <artifactId>junit</artifactId>\n-            <version>4.10</version>\n-            <scope>test</scope>\n-        </dependency>\n-\n-    </dependencies>\n-\n-    <distributionManagement>\n-        <repository>\n-            <id>mbassador-github-repo</id>\n-            <url>${github.url}</url>\n-        </repository>\n-    </distributionManagement>\n-\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>${project.build.java.version}</source>\n-                    <target>${project.build.java.version}</target>\n-                </configuration>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-surefire-plugin</artifactId>\n-                <configuration>\n-                    <skipTests>false</skipTests>\n-                </configuration>\n-            </plugin>\n-\n-        </plugins>\n-    </build>\n-</project>\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.3.RC/mbassador-1.0.3.RC.pom.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-d766622aea3238ee52a60920313274d1\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.3.RC/mbassador-1.0.3.RC.pom.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-55c27ec10ee4067843f05fb735a2af95bc2c06cf\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.4.RC/mbassador-1.0.4.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/maven/org/mbassy/mbassador/1.0.4.RC/mbassador-1.0.4.RC.jar and /dev/null differ\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.4.RC/mbassador-1.0.4.RC.jar.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-2dcb34daf560ac4b9a87a95924aa7be6\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.4.RC/mbassador-1.0.4.RC.jar.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-275d892046554f6a86226d813202c5ab8a22cf92\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.4.RC/mbassador-1.0.4.RC.pom",
            "additions": 0,
            "deletions": 58
        },
        "diff content": "@@ -1,58 +0,0 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-\n-    <modelVersion>4.0.0</modelVersion>\n-    <groupId>org.mbassy</groupId>\n-    <artifactId>mbassador</artifactId>\n-    <version>1.0.4.RC</version>\n-    <packaging>jar</packaging>\n-    <name>mbassador</name>\n-    <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n-    </description>\n-\n-    <properties>\n-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-        <project.build.java.version>1.6</project.build.java.version>\n-        <github.url>file://${project.basedir}/maven</github.url>\n-    </properties>\n-\n-    <dependencies>\n-\n-        <dependency>\n-            <groupId>junit</groupId>\n-            <artifactId>junit</artifactId>\n-            <version>4.10</version>\n-            <scope>test</scope>\n-        </dependency>\n-\n-    </dependencies>\n-\n-    <distributionManagement>\n-        <repository>\n-            <id>mbassador-github-repo</id>\n-            <url>${github.url}</url>\n-        </repository>\n-    </distributionManagement>\n-\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>${project.build.java.version}</source>\n-                    <target>${project.build.java.version}</target>\n-                </configuration>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-surefire-plugin</artifactId>\n-                <configuration>\n-                    <skipTests>false</skipTests>\n-                </configuration>\n-            </plugin>\n-\n-        </plugins>\n-    </build>\n-</project>\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.4.RC/mbassador-1.0.4.RC.pom.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-75dda79a70a43a84877c3d62fdef401d\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.4.RC/mbassador-1.0.4.RC.pom.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-ed21bd9587e9ee76e63b31ede3cbb6eedb04fa70\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.5.RC/mbassador-1.0.5.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/maven/org/mbassy/mbassador/1.0.5.RC/mbassador-1.0.5.RC.jar and /dev/null differ\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.5.RC/mbassador-1.0.5.RC.jar.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-3ad14134e9752e3a073c75ab296427ef\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.5.RC/mbassador-1.0.5.RC.jar.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-bedef44bb92cbfafcba48624c91e185d692ea39d\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.5.RC/mbassador-1.0.5.RC.pom",
            "additions": 0,
            "deletions": 58
        },
        "diff content": "@@ -1,58 +0,0 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-\n-    <modelVersion>4.0.0</modelVersion>\n-    <groupId>org.mbassy</groupId>\n-    <artifactId>mbassador</artifactId>\n-    <version>1.0.5.RC</version>\n-    <packaging>jar</packaging>\n-    <name>mbassador</name>\n-    <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n-    </description>\n-\n-    <properties>\n-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-        <project.build.java.version>1.6</project.build.java.version>\n-        <github.url>file://${project.basedir}/maven</github.url>\n-    </properties>\n-\n-    <dependencies>\n-\n-        <dependency>\n-            <groupId>junit</groupId>\n-            <artifactId>junit</artifactId>\n-            <version>4.10</version>\n-            <scope>test</scope>\n-        </dependency>\n-\n-    </dependencies>\n-\n-    <distributionManagement>\n-        <repository>\n-            <id>mbassador-github-repo</id>\n-            <url>${github.url}</url>\n-        </repository>\n-    </distributionManagement>\n-\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>${project.build.java.version}</source>\n-                    <target>${project.build.java.version}</target>\n-                </configuration>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-surefire-plugin</artifactId>\n-                <configuration>\n-                    <skipTests>false</skipTests>\n-                </configuration>\n-            </plugin>\n-\n-        </plugins>\n-    </build>\n-</project>\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.5.RC/mbassador-1.0.5.RC.pom.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-0a781a5e9f22e5dafeb7f48fff65e46d\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.5.RC/mbassador-1.0.5.RC.pom.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-4378b82fa04f4c31f21321424d0c4c328905d3ad\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.jar and /dev/null differ\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.jar.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-dac16b8c129ee38d08e63d4cd487bdc9\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.jar.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-110fd15551d0a40fafd46cc4e66c590e4d1b2fc7\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.pom",
            "additions": 0,
            "deletions": 58
        },
        "diff content": "@@ -1,58 +0,0 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-\n-    <modelVersion>4.0.0</modelVersion>\n-    <groupId>org.mbassy</groupId>\n-    <artifactId>mbassador</artifactId>\n-    <version>1.0.6.RC</version>\n-    <packaging>jar</packaging>\n-    <name>mbassador</name>\n-    <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n-    </description>\n-\n-    <properties>\n-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-        <project.build.java.version>1.6</project.build.java.version>\n-        <github.url>file://${project.basedir}/maven</github.url>\n-    </properties>\n-\n-    <dependencies>\n-\n-        <dependency>\n-            <groupId>junit</groupId>\n-            <artifactId>junit</artifactId>\n-            <version>4.10</version>\n-            <scope>test</scope>\n-        </dependency>\n-\n-    </dependencies>\n-\n-    <distributionManagement>\n-        <repository>\n-            <id>mbassador-github-repo</id>\n-            <url>${github.url}</url>\n-        </repository>\n-    </distributionManagement>\n-\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>${project.build.java.version}</source>\n-                    <target>${project.build.java.version}</target>\n-                </configuration>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-surefire-plugin</artifactId>\n-                <configuration>\n-                    <skipTests>false</skipTests>\n-                </configuration>\n-            </plugin>\n-\n-        </plugins>\n-    </build>\n-</project>\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.pom.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-ebf2e22bfe53d858092befaa865d0bf4\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.pom.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-950ca7e831a9060060f943ca02d313f7c7f5ccbf\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/maven-metadata.xml",
            "additions": 0,
            "deletions": 13
        },
        "diff content": "@@ -1,13 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<metadata>\n-  <groupId>org.mbassy</groupId>\n-  <artifactId>mbassador</artifactId>\n-  <version>1.0.7.RC-SNAPSHOT</version>\n-  <versioning>\n-    <snapshot>\n-      <timestamp>20121229.133808</timestamp>\n-      <buildNumber>1</buildNumber>\n-    </snapshot>\n-    <lastUpdated>20121229133808</lastUpdated>\n-  </versioning>\n-</metadata>\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/maven-metadata.xml.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-732608242394f6b316a7cf631208b635\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/maven-metadata.xml.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-2cae8933661f8cf18afc2c923436c2457e0b3809\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1-javadoc.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1-javadoc.jar and /dev/null differ\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1-javadoc.jar.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-d20f34dc532b790786a74566598e5e68\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1-javadoc.jar.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-13de5221308cf546ff55aa6b5a35ec1f78ecf691\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1-sources.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1-sources.jar and /dev/null differ\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1-sources.jar.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-ec63e6aa1e908e4036cca782675742df\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1-sources.jar.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-79eb0716f839f2b63cf5d3d9796800967d54fdb5\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1.jar and /dev/null differ\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1.jar.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-21ac5231ee676ba2461e31392e210b54\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1.jar.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-9cfcc0fe9534d2a530b48445331d451b97ca3342\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1.pom",
            "additions": 0,
            "deletions": 152
        },
        "diff content": "@@ -1,152 +0,0 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-\n-    <modelVersion>4.0.0</modelVersion>\n-    <groupId>org.mbassy</groupId>\n-    <artifactId>mbassador</artifactId>\n-    <version>1.0.7.RC-SNAPSHOT</version>\n-    <packaging>jar</packaging>\n-    <name>mbassador</name>\n-    <description>\n-        Mbassador is a fast and flexible message bus system following the publish subscribe pattern.\n-        It is designed for ease of use and aims to be feature rich and extensible\n-        while preserving resource efficiency and performance.\n-\n-        It features:\n-        declarative listener definition via annotations,\n-        sync and/or async message delivery,\n-        weak-references,\n-        message filtering,\n-        ordering of message handlers etc.\n-\n-    </description>\n-\n-    <url>https://github.com/bennidi/mbassador</url>\n-    <licenses>\n-        <license>\n-            <name>MIT license</name>\n-            <url>http://www.opensource.org/licenses/mit-license.php</url>\n-        </license>\n-    </licenses>\n-    <scm>\n-        <url>scm:git:git@github.com:bennidi/mbassador.git</url>\n-        <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-    </scm>\n-    <developers>\n-\n-        <developer>\n-            <id>bennidi</id>\n-            <name>Benjamin Diedrichsen</name>\n-            <timezone>+1</timezone>\n-        </developer>\n-    </developers>\n-\n-    <properties>\n-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-        <project.build.java.version>1.6</project.build.java.version>\n-        <github.url>file://${project.basedir}/maven</github.url>\n-    </properties>\n-\n-    <dependencies>\n-\n-        <dependency>\n-            <groupId>junit</groupId>\n-            <artifactId>junit</artifactId>\n-            <version>4.10</version>\n-            <scope>test</scope>\n-        </dependency>\n-\n-    </dependencies>\n-\n-    <distributionManagement>\n-        <repository>\n-            <id>mbassador-github-repo</id>\n-            <url>${github.url}</url>\n-        </repository>\n-    </distributionManagement>\n-\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>${project.build.java.version}</source>\n-                    <target>${project.build.java.version}</target>\n-                </configuration>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-release-plugin</artifactId>\n-                <version>2.4</version>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-surefire-plugin</artifactId>\n-                <configuration>\n-                    <skipTests>false</skipTests>\n-                </configuration>\n-            </plugin>\n-\n-            <!-- bind the source attaching to package phase -->\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-source-plugin</artifactId>\n-                <executions>\n-                    <execution>\n-                        <id>attach-sources</id>\n-                        <goals>\n-                            <goal>jar</goal>\n-                        </goals>\n-                    </execution>\n-                </executions>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-javadoc-plugin</artifactId>\n-                <executions>\n-                    <execution>\n-                        <id>attach-javadocs</id>\n-                        <goals>\n-                            <goal>jar</goal>\n-                        </goals>\n-                    </execution>\n-                </executions>\n-            </plugin>\n-\n-        </plugins>\n-    </build>\n-\n-    <profiles>\n-        <profile>\n-            <id>release-sign-artifacts</id>\n-            <activation>\n-                <property>\n-                    <name>performRelease</name>\n-                    <value>true</value>\n-                </property>\n-            </activation>\n-            <build>\n-                <plugins>\n-                    <plugin>\n-                        <groupId>org.apache.maven.plugins</groupId>\n-                        <artifactId>maven-gpg-plugin</artifactId>\n-                        <version>1.4</version>\n-                        <executions>\n-                            <execution>\n-                                <id>sign-artifacts</id>\n-                                <phase>verify</phase>\n-                                <goals>\n-                                    <goal>sign</goal>\n-                                </goals>\n-                            </execution>\n-                        </executions>\n-                    </plugin>\n-                </plugins>\n-            </build>\n-        </profile>\n-    </profiles>\n-</project>\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1.pom.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-05e16f4d46db6bc39529ebe889ff552d\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1.pom.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-5e078c7f168816392ca34e41cbc8f58c81b8c5d9\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml",
            "additions": 0,
            "deletions": 19
        },
        "diff content": "@@ -1,19 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<metadata>\n-  <groupId>org.mbassy</groupId>\n-  <artifactId>mbassador</artifactId>\n-  <version>1.0.0.RC</version>\n-  <versioning>\n-    <versions>\n-      <version>1.0.0.RC</version>\n-      <version>1.0.1.RC</version>\n-      <version>1.0.2.RC</version>\n-      <version>1.0.3.RC</version>\n-      <version>1.0.4.RC</version>\n-      <version>1.0.5.RC</version>\n-      <version>1.0.6.RC</version>\n-      <version>1.0.7.RC-SNAPSHOT</version>\n-    </versions>\n-    <lastUpdated>20121229133808</lastUpdated>\n-  </versioning>\n-</metadata>\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-46231d9bfb55280deeea69a9e18ed52b\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-3608eef0e3183c20460c8b1839c6a3d5740dd63e\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/docs/wiki-bus-overview.md",
            "additions": 3,
            "deletions": 2
        },
        "diff content": "@@ -18,9 +18,10 @@ The basic contract of the bus is that it will deliver a specific message exactly\n Currently, message handlers will be invoked in inverse sequence of subscription but any\n client using this bus should not rely on this assumption.\n \n-The bus uses weak references to all listeners such that registered listeners do not need to\n+By default, the bus uses weak references to all listeners such that registered listeners do not need to\n be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n-removed on-the-fly as messages get published.\n+removed on-the-fly as messages get published. It is possible to enable the use of strong references on the message handler\n+level.\n \n Unsubscribing a listener means removing all subscribed message handlers of that listener. This remove operation\n immediately effects all running publications processes -> A removed listener will under no circumstances receive any message publications.\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/docs/wiki-listener-def.md",
            "additions": 33,
            "deletions": 11
        },
        "diff content": "@@ -10,10 +10,17 @@ filters, delivery modes etc.\n \n   <tr>\n         <td>delivery</td>\n-        <td>Message delivery can either run sequentially(i.e. one listener at a time) or concurrently\n-            (i.e. multiple threads are used to deliver the same message to different listeners).\n-            Note:The number of parallel threads is configurable per instance using the BusConfiguration</td>\n-        <td>Sequential</td>\n+        <td>Message handler invocation can be configured to run\n+            <ul>\n+                <li>Synchronously: One handler at a time within a given message publication. Each invocation occurs from the same thread</li>\n+                <li>Asynchronously: Multiple threads are used within a given message publication. Each handler invocation\n+                runs in a separate thread.Note:The number of parallel threads is configurable per instance using the BusConfiguration</li>\n+            </ul>\n+            Note: Use @Synchronized if your handler does not allow multiple, concurrent message publications, i.e.\n+            handlers that are not thread-safe but are used in a multi-threaded environment where asynchronous message publication\n+            is possible.\n+        </td>\n+        <td>Synchronously</td>\n   </tr>\n \n   <tr>\n@@ -42,6 +49,21 @@ filters, delivery modes etc.\n             <td>true</td>\n     </tr>\n \n+    <tr>\n+                <td>strongReferencess</td>\n+                <td>Whether the bus should use storng references to the listeners instead of weak references\n+                </td>\n+                <td>false</td>\n+        </tr>\n+    <tr>\n+                    <td>invocation</td>\n+                    <td>Specify a custom implementation for the handler invocation. By default, a generic implementation\n+                    that uses reflection will be used. Note: A custom implementation will not be faster than the generic one\n+                    since there are heavy optimizations by the JVM using JIT-Compiler and more.\n+                    </td>\n+                    <td>false</td>\n+            </tr>\n+\n \n </table>\n \n@@ -59,22 +81,22 @@ receive all messages of type TestEvent or any subtype sequentially.\n \n \n \n-This handler will receive all messages of type SubTestEvent or any subtype concurrently\n+This handler will receive all messages of type SubTestEvent or any subtype\n \n-        // this handler will be invoked concurrently\n-\t\t@Handler(delivery = Mode.Concurrent)\n+        // handler invocation will occur in a different thread\n+\t\t@Handler(delivery = Invoke.Asynchronously)\n \t\tpublic void handleSubTestEvent(SubTestEvent event) {\n             // do something more expensive here\n \t\t}\n \n-This handler will receive all messages of type SubTestEvent or any subtype sequentially,\n+This handler will receive all messages of type SubTestEvent or any subtype,\n given that they pass the specified filters. This handler will be invoked before the formerly\n defined one, since it specifies a higher priority\n \n \t\t// this handler will receive messages of type SubTestEvent\n         // or any of its sub types that passe the given filter(s)\n         @Handler(priority = 10,\n-                  dispatch = Mode.Synchronous,\n+                  dispatch = Invoke.Synchronously,\n                   filters = {@Filter(Filters.SpecialEvent.class)})\n         public void handleFiltered(SubTestEvent event) {\n            //do something special here\n@@ -112,8 +134,8 @@ Message handler inheritance corresponds to inheritance of methods as defined in\n A subclass of any class that defines message handlers will inherit these handler and their configuration.\n It is possible to change (override) the configuration simply by overriding the super class' method and\n specifying a different configuration. This way, it is also possible to deactivate a message handler of\n-a super class by using the \"enabled\" property on the overridden method.\n-If a class overrides a method that is configured as a message handler in one of its super classes\n+a super class by setting the \"enabled\" property to \"false\" on the overridden method.\n+If a class overrides a method that is already configured as a message handler\n it is still considered a message handler but of course the implementation of the overriding class\n will be used.\n \n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/MessageBusException.java",
            "additions": 29,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,29 @@\n+package net.engio.mbassy;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 3/29/13\n+ */\n+public class MessageBusException extends Exception{\n+\n+    public MessageBusException() {\n+    }\n+\n+    public MessageBusException(String message) {\n+        super(message);\n+    }\n+\n+    public MessageBusException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+    public MessageBusException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    public MessageBusException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n+        super(message, cause, enableSuppression, writableStackTrace);\n+    }\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java",
            "additions": 100,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,100 @@\n+package net.engio.mbassy.bus;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The base class for all message bus implementations.\n+ *\n+ * @param <T>\n+ * @param <P>\n+ */\n+public abstract class AbstractSyncAsyncMessageBus<T, P extends IMessageBus.IPostCommand> extends AbstractSyncMessageBus<T, P> implements IMessageBus<T, P> {\n+\n+    // executor for asynchronous message handlers\n+    private final ExecutorService executor;\n+\n+    // all threads that are available for asynchronous message dispatching\n+    private final List<Thread> dispatchers;\n+\n+    // all pending messages scheduled for asynchronous dispatch are queued here\n+    private final BlockingQueue<MessagePublication> pendingMessages;\n+\n+    public AbstractSyncAsyncMessageBus(BusConfiguration configuration) {\n+        super(configuration);\n+        this.executor = configuration.getExecutor();\n+        pendingMessages = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n+         dispatchers = new ArrayList<Thread>(configuration.getNumberOfMessageDispatchers());\n+        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n+    }\n+\n+\n+    // initialize the dispatch workers\n+    private void initDispatcherThreads(int numberOfThreads) {\n+        for (int i = 0; i < numberOfThreads; i++) {\n+            // each thread will run forever and process incoming\n+            //dispatch requests\n+            Thread dispatcher = new Thread(new Runnable() {\n+                public void run() {\n+                    while (true) {\n+                        try {\n+                            pendingMessages.take().execute();\n+                        } catch (InterruptedException e) {\n+                            Thread.currentThread().interrupt();\n+                            return;\n+                        }\n+                    }\n+                }\n+            });\n+            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n+            dispatchers.add(dispatcher);\n+            dispatcher.start();\n+        }\n+    }\n+\n+\n+    // this method enqueues a message delivery request\n+    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request) {\n+        try {\n+            pendingMessages.put(request);\n+            return request.markScheduled();\n+        } catch (InterruptedException e) {\n+            return request.setError();\n+        }\n+    }\n+\n+    // this method enqueues a message delivery request\n+    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit) {\n+        try {\n+            return pendingMessages.offer(request, timeout, unit)\n+                    ? request.markScheduled()\n+                    : request.setError();\n+        } catch (InterruptedException e) {\n+            return request.setError();\n+        }\n+    }\n+\n+    @Override\n+    protected void finalize() throws Throwable {\n+        shutdown();\n+        super.finalize();\n+    }\n+\n+    public void shutdown() {\n+        for (Thread dispatcher : dispatchers) {\n+            dispatcher.interrupt();\n+        }\n+        executor.shutdown();\n+    }\n+\n+    public boolean hasPendingMessages() {\n+        return pendingMessages.size() > 0;\n+    }\n+\n+    @Override\n+    public Executor getExecutor() {\n+        return executor;\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java",
            "additions": 4,
            "deletions": 94
        },
        "diff content": "@@ -9,22 +9,8 @@ import net.engio.mbassy.subscription.Subscription;\n import net.engio.mbassy.subscription.SubscriptionContext;\n import net.engio.mbassy.subscription.SubscriptionFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.TreeSet;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.TimeUnit;\n+import java.util.*;\n+import java.util.concurrent.*;\n \n /**\n  * The base class for all message bus implementations.\n@@ -32,10 +18,8 @@ import java.util.concurrent.TimeUnit;\n  * @param <T>\n  * @param <P>\n  */\n-public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n+public abstract class AbstractSyncMessageBus<T, P extends ISyncMessageBus.ISyncPostCommand> implements ISyncMessageBus<T, P> {\n \n-    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n-    private final ExecutorService executor;\n \n     // the metadata reader that is used to parse objects passed to the subscribe method\n     private final MetadataReader metadataReader;\n@@ -58,12 +42,6 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     // this handler will receive all errors that occur during message dispatch or message handling\n     private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n \n-    // all threads that are available for asynchronous message dispatching\n-    private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n-\n-    // all pending messages scheduled for asynchronous dispatch are queued here\n-    private final BlockingQueue<MessagePublication> pendingMessages;\n-\n     // this factory is used to create specialized subscriptions based on the given message handler configuration\n     // it can be customized by implementing the getSubscriptionFactory() method\n     private final SubscriptionFactory subscriptionFactory;\n@@ -71,40 +49,13 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     private final MessagePublication.Factory publicationFactory;\n \n \n-    public AbstractMessageBus(BusConfiguration configuration) {\n-        this.executor = configuration.getExecutor();\n+    public AbstractSyncMessageBus(SyncBusConfiguration configuration) {\n         subscriptionFactory = configuration.getSubscriptionFactory();\n         this.metadataReader = configuration.getMetadataReader();\n         this.publicationFactory = configuration.getMessagePublicationFactory();\n-        pendingMessages = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n-        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n         addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n     }\n \n-\n-    // initialize the dispatch workers\n-    private void initDispatcherThreads(int numberOfThreads) {\n-        for (int i = 0; i < numberOfThreads; i++) {\n-            // each thread will run forever and process incoming\n-            //dispatch requests\n-            Thread dispatcher = new Thread(new Runnable() {\n-                public void run() {\n-                    while (true) {\n-                        try {\n-                            pendingMessages.take().execute();\n-                        } catch (InterruptedException e) {\n-                            Thread.currentThread().interrupt();\n-                            return;\n-                        }\n-                    }\n-                }\n-            });\n-            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n-            dispatchers.add(dispatcher);\n-            dispatcher.start();\n-        }\n-    }\n-\n     protected MessagePublication.Factory getPublicationFactory() {\n         return publicationFactory;\n     }\n@@ -179,26 +130,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         errorHandlers.add(handler);\n     }\n \n-    // this method enqueues a message delivery request\n-    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request) {\n-        try {\n-            pendingMessages.put(request);\n-            return request.markScheduled();\n-        } catch (InterruptedException e) {\n-            return request.setError();\n-        }\n-    }\n \n-    // this method enqueues a message delivery request\n-    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit) {\n-        try {\n-            return pendingMessages.offer(request, timeout, unit)\n-                    ? request.markScheduled()\n-                    : request.setError();\n-        } catch (InterruptedException e) {\n-            return request.setError();\n-        }\n-    }\n \n     // obtain the set of subscriptions for the given message type\n     // Note: never returns null!\n@@ -241,26 +173,4 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         }\n     }\n \n-    @Override\n-    protected void finalize() throws Throwable {\n-        shutdown();\n-        super.finalize();\n-    }\n-\n-    private void shutdown() {\n-        for (Thread dispatcher : dispatchers) {\n-            dispatcher.interrupt();\n-        }\n-        executor.shutdown();\n-    }\n-\n-    public boolean hasPendingMessages() {\n-        return pendingMessages.size() > 0;\n-    }\n-\n-    @Override\n-    public Executor getExecutor() {\n-        return executor;\n-    }\n-\n }\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/BusConfiguration.java",
            "additions": 7,
            "deletions": 44
        },
        "diff content": "@@ -1,14 +1,6 @@\n package net.engio.mbassy.bus;\n \n-import net.engio.mbassy.listener.MetadataReader;\n-import net.engio.mbassy.subscription.SubscriptionFactory;\n-\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.ThreadPoolExecutor;\n-import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.*;\n \n /**\n  * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n@@ -16,7 +8,7 @@ import java.util.concurrent.TimeUnit;\n  * @author bennidi\n  *         Date: 12/8/12\n  */\n-public class BusConfiguration {\n+public class BusConfiguration extends SyncBusConfiguration<BusConfiguration> {\n \n     private static final ThreadFactory DaemonThreadFactory = new ThreadFactory() {\n         @Override\n@@ -37,36 +29,11 @@ public class BusConfiguration {\n \n     private int maximumNumberOfPendingMessages;\n \n-    private SubscriptionFactory subscriptionFactory;\n-\n-    private MetadataReader metadataReader;\n-\n-    private MessagePublication.Factory messagePublicationFactory;\n-\n     public BusConfiguration() {\n+        super();\n         this.numberOfMessageDispatchers = 2;\n         this.maximumNumberOfPendingMessages = Integer.MAX_VALUE;\n-        this.subscriptionFactory = new SubscriptionFactory();\n         this.executor = new ThreadPoolExecutor(10, 10, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), DaemonThreadFactory);\n-        this.metadataReader = new MetadataReader();\n-        this.messagePublicationFactory = new MessagePublication.Factory();\n-    }\n-\n-    public MessagePublication.Factory getMessagePublicationFactory() {\n-        return messagePublicationFactory;\n-    }\n-\n-    public void setMessagePublicationFactory(MessagePublication.Factory messagePublicationFactory) {\n-        this.messagePublicationFactory = messagePublicationFactory;\n-    }\n-\n-    public MetadataReader getMetadataReader() {\n-        return metadataReader;\n-    }\n-\n-    public BusConfiguration setMetadataReader(MetadataReader metadataReader) {\n-        this.metadataReader = metadataReader;\n-        return this;\n     }\n \n     public int getNumberOfMessageDispatchers() {\n@@ -78,6 +45,10 @@ public class BusConfiguration {\n         return this;\n     }\n \n+    /**\n+     * By default an unbound queuing strategy is used to ensure that no events get lost\n+     * @return\n+     */\n     public ExecutorService getExecutor() {\n         return executor;\n     }\n@@ -98,12 +69,4 @@ public class BusConfiguration {\n         return this;\n     }\n \n-    public SubscriptionFactory getSubscriptionFactory() {\n-        return subscriptionFactory;\n-    }\n-\n-    public BusConfiguration setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n-        this.subscriptionFactory = subscriptionFactory;\n-        return this;\n-    }\n }\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/IMessageBus.java",
            "additions": 14,
            "deletions": 59
        },
        "diff content": "@@ -1,8 +1,5 @@\n package net.engio.mbassy.bus;\n \n-import net.engio.mbassy.IPublicationErrorHandler;\n-\n-import java.util.Collection;\n import java.util.concurrent.Executor;\n import java.util.concurrent.TimeUnit;\n \n@@ -47,81 +44,38 @@ import java.util.concurrent.TimeUnit;\n  * @Author bennidi\n  * Date: 2/8/12\n  */\n-public interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n-\n-    /**\n-     * Subscribe all listeners of the given message to receive message publications.\n-     * Any message may only be subscribed once (subsequent subscriptions of an already subscribed\n-     * message will be silently ignored)\n-     *\n-     * @param listener\n-     */\n-    void subscribe(Object listener);\n+public interface IMessageBus<T, P extends IMessageBus.IPostCommand> extends ISyncMessageBus<T,P> {\n \n     /**\n-     * Immediately remove all registered message handlers (if any) of the given listener. When this call returns all handlers\n-     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n-     * publications that have been published when the message listener was still subscribed).\n-     * <p/>\n-     * A call to this method passing null, an already unsubscribed listener or any object that does not define any message\n-     * handlers will not have any effect and is silently ignored.\n+     * Get the executor service that is used for asynchronous message publications.\n+     * The executor is passed to the message bus at creation time.\n      *\n-     * @param listener\n-     * @return true, if the listener was found and successfully removed\n-     *         false otherwise\n-     */\n-    boolean unsubscribe(Object listener);\n-\n-    /**\n-     * @param message\n      * @return\n      */\n-    P post(T message);\n-\n-    /**\n-     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n-     * may not be accessible due to security constraints or is not annotated properly.\n-     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n-     * A call to this method will add the given error handler to the chain\n-     *\n-     * @param errorHandler\n-     */\n-    void addErrorHandler(IPublicationErrorHandler errorHandler);\n+    Executor getExecutor();\n \n     /**\n-     * Returns an immutable collection containing all the registered error handlers\n+     * Check whether any asynchronous message publications are pending for being processed\n      *\n      * @return\n      */\n-    Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n+    boolean hasPendingMessages();\n \n     /**\n-     * Get the executor service that is used to asynchronous message publication.\n-     * The executor is passed to the message bus at creation time.\n-     *\n-     * @return\n+     * Shutdown the bus such that it will stop delivering asynchronous messages. Executor service and\n+     * other internally used threads will be shutdown gracefully. After calling shutdown it is not safe\n+     * to further use the message bus.\n      */\n-    Executor getExecutor();\n+    void shutdown();\n \n     /**\n-     * Check whether any asynchronous message publications are pending for being processed\n-     *\n+     * @param message\n      * @return\n      */\n-    boolean hasPendingMessages();\n+    P post(T message);\n \n-    /**\n-     * A post command is used as an intermediate object created by a call to the message bus' post method.\n-     * It encapsulates the functionality provided by the message bus that created the command.\n-     * Subclasses may extend this interface and add functionality, e.g. different dispatch schemes.\n-     */\n-    interface IPostCommand<T> {\n \n-        /**\n-         * Execute the message publication immediately. This call blocks until every matching message handler\n-         * has been invoked.\n-         */\n-        void now();\n+    interface IPostCommand extends ISyncPostCommand {\n \n         /**\n          * Execute the message publication asynchronously. The behaviour of this method depends on the\n@@ -146,4 +100,5 @@ public interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n          */\n         MessagePublication asynchronously(long timeout, TimeUnit unit);\n     }\n+\n }\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/ISyncMessageBus.java",
            "additions": 77,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,77 @@\n+package net.engio.mbassy.bus;\n+\n+import net.engio.mbassy.IPublicationErrorHandler;\n+\n+import java.util.Collection;\n+\n+/**\n+ *\n+ *\n+ * @author bennidi\n+ *         Date: 3/29/13\n+ */\n+public interface ISyncMessageBus<T, P extends IMessageBus.ISyncPostCommand> {\n+\n+\n+    /**\n+     * Subscribe all listeners of the given message to receive message publications.\n+     * Any message may only be subscribed once (subsequent subscriptions of an already subscribed\n+     * message will be silently ignored)\n+     *\n+     * @param listener\n+     */\n+    void subscribe(Object listener);\n+\n+    /**\n+     * Immediately remove all registered message handlers (if any) of the given listener. When this call returns all handlers\n+     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n+     * publications that have been published when the message listener was still subscribed).\n+     * <p/>\n+     * A call to this method passing null, an already unsubscribed listener or any object that does not define any message\n+     * handlers will not have any effect and is silently ignored.\n+     *\n+     * @param listener\n+     * @return true, if the listener was found and successfully removed\n+     *         false otherwise\n+     */\n+    boolean unsubscribe(Object listener);\n+\n+    /**\n+     * @param message\n+     * @return\n+     */\n+    P post(T message);\n+\n+    /**\n+     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n+     * may not be accessible due to security constraints or is not annotated properly.\n+     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n+     * A call to this method will add the given error handler to the chain\n+     *\n+     * @param errorHandler\n+     */\n+    void addErrorHandler(IPublicationErrorHandler errorHandler);\n+\n+    /**\n+     * Returns an immutable collection containing all the registered error handlers\n+     *\n+     * @return\n+     */\n+    Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n+\n+\n+\n+    /**\n+     * A post command is used as an intermediate object created by a call to the message bus' post method.\n+     * It encapsulates the functionality provided by the message bus that created the command.\n+     * Subclasses may extend this interface and add functionality, e.g. different dispatch schemes.\n+     */\n+    interface ISyncPostCommand {\n+\n+        /**\n+         * Execute the message publication immediately. This call blocks until every matching message handler\n+         * has been invoked.\n+         */\n+        void now();\n+    }\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MBassador.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -8,7 +8,7 @@ import java.util.Collection;\n import java.util.concurrent.TimeUnit;\n \n \n-public class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>> {\n+public class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> {\n \n     public MBassador(BusConfiguration configuration) {\n         super(configuration);\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/SyncBusConfiguration.java",
            "additions": 49,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,49 @@\n+package net.engio.mbassy.bus;\n+\n+import net.engio.mbassy.listener.MetadataReader;\n+import net.engio.mbassy.subscription.SubscriptionFactory;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 3/29/13\n+ */\n+public class SyncBusConfiguration<Config extends SyncBusConfiguration<Config>> {\n+\n+    protected SubscriptionFactory subscriptionFactory;\n+    protected MetadataReader metadataReader;\n+    protected MessagePublication.Factory messagePublicationFactory;\n+\n+    public SyncBusConfiguration() {\n+        this.metadataReader = new MetadataReader();\n+        this.subscriptionFactory = new SubscriptionFactory();\n+        this.messagePublicationFactory = new MessagePublication.Factory();\n+    }\n+\n+    public MessagePublication.Factory getMessagePublicationFactory() {\n+        return messagePublicationFactory;\n+    }\n+\n+    public void setMessagePublicationFactory(MessagePublication.Factory messagePublicationFactory) {\n+        this.messagePublicationFactory = messagePublicationFactory;\n+    }\n+\n+    public MetadataReader getMetadataReader() {\n+        return metadataReader;\n+    }\n+\n+    public Config setMetadataReader(MetadataReader metadataReader) {\n+        this.metadataReader = metadataReader;\n+        return (Config)this;\n+    }\n+\n+    public SubscriptionFactory getSubscriptionFactory() {\n+        return subscriptionFactory;\n+    }\n+\n+    public Config setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n+        this.subscriptionFactory = subscriptionFactory;\n+        return (Config)this;\n+    }\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java",
            "additions": 134,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,134 @@\n+package net.engio.mbassy.common;\n+\n+\n+import java.util.Map;\n+\n+/**\n+ * This data structure is optimized for non-blocking reads even when write operations occur.\n+ * Running read iterators will not be affected by add operations since writes always insert at the head of the\n+ * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n+ * been reached by the iterator will not appear in that iterator anymore.\n+ *\n+ * @author bennidi\n+ *         Date: 2/12/12\n+ */\n+public abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n+\n+    // Internal state\n+    private final Object lock = new Object();\n+    private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(log n) lookup\n+    protected Entry<T> head; // reference to the first element\n+\n+    protected AbstractConcurrentSet(Map<T, ISetEntry<T>> entries) {\n+        this.entries = entries;\n+    }\n+\n+    protected abstract Entry<T> createEntry(T value, Entry<T> next);\n+\n+    @Override\n+    public IConcurrentSet<T> add(T element) {\n+        if (element == null || entries.containsKey(element)) {\n+            return this;\n+        }\n+        synchronized (lock) {\n+            insert(element);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public boolean contains(T element) {\n+        ISetEntry<T> entry = entries.get(element);\n+        return entry != null && entry.getValue() != null;\n+    }\n+\n+    private void insert(T element) {\n+        if (entries.containsKey(element)) {\n+            return;\n+        }\n+        head = createEntry(element, head);\n+        entries.put(element, head);\n+    }\n+\n+    @Override\n+    public int size() {\n+        return entries.size();\n+    }\n+\n+    @Override\n+    public IConcurrentSet<T> addAll(Iterable<T> elements) {\n+        synchronized (lock) {\n+            for (T element : elements) {\n+                if (element == null || entries.containsKey(element)) {\n+                    return this;\n+                }\n+\n+                insert(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public boolean remove(T element) {\n+        if (!entries.containsKey(element)) {\n+            return false;\n+        }\n+        synchronized (lock) {\n+            ISetEntry<T> listelement = entries.get(element);\n+            if (listelement == null) {\n+                return false; //removed by other thread\n+            }\n+            if (listelement != head) {\n+                listelement.remove();\n+            } else {\n+                ISetEntry<T> oldHead = head;\n+                head = head.next();\n+                oldHead.clear(); // optimize for GC\n+            }\n+            entries.remove(element);\n+        }\n+        return true;\n+    }\n+\n+\n+    public abstract static class Entry<T> implements ISetEntry<T> {\n+\n+        private Entry<T> next;\n+\n+        private Entry<T> predecessor;\n+\n+        protected Entry(Entry<T> next) {\n+            this.next = next;\n+            next.predecessor = this;\n+        }\n+\n+        protected Entry() {\n+        }\n+\n+        // not thread-safe! must be synchronized in enclosing context\n+        @Override\n+        public void remove() {\n+            if (predecessor != null) {\n+                predecessor.next = next;\n+                if (next != null) {\n+                    next.predecessor = predecessor;\n+                }\n+            } else if (next != null) {\n+                next.predecessor = null;\n+            }\n+            next = null;\n+            predecessor = null;\n+        }\n+\n+        @Override\n+        public Entry<T> next() {\n+            return next;\n+        }\n+\n+        @Override\n+        public void clear() {\n+            next = null;\n+        }\n+    }\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ConcurrentSet.java",
            "additions": 0,
            "deletions": 183
        },
        "diff content": "@@ -1,183 +0,0 @@\n-package net.engio.mbassy.common;\n-\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Iterator;\n-import java.util.WeakHashMap;\n-\n-/**\n- * This data structure is optimized for non-blocking reads even when write operations occur.\n- * Running read iterators will not be affected by add operations since writes always insert at the head of the\n- * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n- * been reached by the iterator will not appear in that iterator anymore.\n- * <p/>\n- * The structure uses weak references to the elements. Iterators automatically perform cleanups of\n- * garbage collected objects during iteration -> no dedicated maintenance operations need to be called or run in background.\n- * <p/>\n- * <p/>\n- * <p/>\n- *\n- * @author bennidi\n- *         Date: 2/12/12\n- */\n-public class ConcurrentSet<T> implements Iterable<T> {\n-\n-    // Internal state\n-    private final Object lock = new Object();\n-    private WeakHashMap<T, Entry<T>> entries = new WeakHashMap<T, Entry<T>>(); // maintain a map of entries for O(log n) lookup\n-    private Entry<T> head; // reference to the first element\n-\n-    public ConcurrentSet<T> add(T element) {\n-        if (element == null || entries.containsKey(element)) {\n-            return this;\n-        }\n-        synchronized (lock) {\n-            insert(element);\n-        }\n-        return this;\n-    }\n-\n-    public boolean contains(T element) {\n-        Entry<T> entry = entries.get(element);\n-        return entry != null && entry.getValue() != null;\n-    }\n-\n-    private void insert(T element) {\n-        if (entries.containsKey(element)) {\n-            return;\n-        }\n-        if (head == null) {\n-            head = new Entry<T>(element);\n-        } else {\n-            head = new Entry<T>(element, head);\n-        }\n-        entries.put(element, head);\n-    }\n-\n-    public int size() {\n-        return entries.size();\n-    }\n-\n-    public ConcurrentSet<T> addAll(Iterable<T> elements) {\n-        synchronized (lock) {\n-            for (T element : elements) {\n-                if (element == null || entries.containsKey(element)) {\n-                    return this;\n-                }\n-\n-                insert(element);\n-            }\n-        }\n-        return this;\n-    }\n-\n-    public boolean remove(T element) {\n-        if (!entries.containsKey(element)) {\n-            return false;\n-        }\n-        synchronized (lock) {\n-            Entry<T> listelement = entries.get(element);\n-            if (listelement == null) {\n-                return false; //removed by other thread\n-            }\n-            if (listelement != head) {\n-                listelement.remove();\n-            } else {\n-                Entry<T> oldHead = head;\n-                head = head.next();\n-                oldHead.next = null; // optimize for GC\n-            }\n-            entries.remove(element);\n-        }\n-        return true;\n-    }\n-\n-    public Iterator<T> iterator() {\n-        return new Iterator<T>() {\n-\n-            private Entry<T> current = head;\n-\n-            public boolean hasNext() {\n-                if (current == null) return false;\n-                if (current.getValue() == null) {    // auto-removal of orphan references\n-                    do {\n-                        remove();\n-                    } while(current != null && current.getValue() == null);\n-                    return hasNext();\n-                } else {\n-                    return true;\n-                }\n-            }\n-\n-            public T next() {\n-                if (current == null) {\n-                    return null;\n-                }\n-                T value = current.getValue();\n-                if (value == null) {    // auto-removal of orphan references\n-                    do {\n-                        remove();\n-                    } while(current != null && current.getValue() == null);\n-                    return next();\n-                } else {\n-                    current = current.next();\n-                    return value;\n-                }\n-            }\n-\n-            public void remove() {\n-                if (current == null) {\n-                    return;\n-                }\n-                Entry<T> newCurrent = current.next();\n-                ConcurrentSet.this.remove(current.getValue());\n-                current = newCurrent;\n-            }\n-        };\n-    }\n-\n-\n-    public class Entry<T> {\n-\n-        private WeakReference<T> value;\n-\n-        private Entry<T> next;\n-\n-        private Entry<T> predecessor;\n-\n-\n-        private Entry(T value) {\n-            this.value = new WeakReference<T>(value);\n-        }\n-\n-        private Entry(T value, Entry<T> next) {\n-            this(value);\n-            this.next = next;\n-            next.predecessor = this;\n-        }\n-\n-        public T getValue() {\n-            return value.get();\n-        }\n-\n-        // not thread-safe! must be synchronized in enclosing context\n-        public void remove() {\n-            if (predecessor != null) {\n-                predecessor.next = next;\n-                if (next != null) {\n-                    next.predecessor = predecessor;\n-                }\n-            } else if (next != null) {\n-                next.predecessor = null;\n-            }\n-            next = null;\n-            predecessor = null;\n-        }\n-\n-        public Entry<T> next() {\n-            return next;\n-        }\n-\n-\n-    }\n-}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/IConcurrentSet.java",
            "additions": 20,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,20 @@\n+package net.engio.mbassy.common;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 3/29/13\n+ */\n+public interface IConcurrentSet<T> extends Iterable<T> {\n+\n+    IConcurrentSet<T> add(T element);\n+\n+    boolean contains(T element);\n+\n+    int size();\n+\n+    IConcurrentSet<T> addAll(Iterable<T> elements);\n+\n+    boolean remove(T element);\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ISetEntry.java",
            "additions": 19,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,19 @@\n+package net.engio.mbassy.common;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 3/29/13\n+ */\n+public interface ISetEntry<T> {\n+\n+    T getValue();\n+\n+    // not thread-safe! must be synchronized in enclosing context\n+    void remove();\n+\n+    ISetEntry<T> next();\n+\n+    void clear();\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/StrongConcurrentSet.java",
            "additions": 84,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,84 @@\n+package net.engio.mbassy.common;\n+\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+\n+/**\n+ * This implementation uses weak references to the elements. Iterators automatically perform cleanups of\n+ * garbage collected objects during iteration -> no dedicated maintenance operations need to be called or run in background.\n+ * <p/>\n+ * <p/>\n+ * <p/>\n+ *\n+ * @author bennidi\n+ *         Date: 2/12/12\n+ */\n+public class StrongConcurrentSet<T> extends AbstractConcurrentSet<T>{\n+\n+\n+    public StrongConcurrentSet() {\n+        super(new HashMap<T, ISetEntry<T>>());\n+    }\n+\n+    public Iterator<T> iterator() {\n+        return new Iterator<T>() {\n+\n+            private ISetEntry<T> current = head;\n+\n+            public boolean hasNext() {\n+                return current != null;\n+            }\n+\n+            public T next() {\n+                if (current == null) {\n+                    return null;\n+                }\n+               else {\n+                    T value = current.getValue();\n+                    current = current.next();\n+                    return value;\n+                }\n+            }\n+\n+            public void remove() {\n+                if (current == null) {\n+                    return;\n+                }\n+                ISetEntry<T> newCurrent = current.next();\n+                StrongConcurrentSet.this.remove(current.getValue());\n+                current = newCurrent;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    protected Entry<T> createEntry(T value, Entry<T> next) {\n+        return next != null ? new StrongEntry<T>(value, next) : new StrongEntry<T>(value);\n+    }\n+\n+\n+    public static class StrongEntry<T> extends Entry<T> {\n+\n+        private T value;\n+\n+        private StrongEntry(T value, Entry<T> next) {\n+            super(next);\n+            this.value = value;\n+        }\n+\n+        private StrongEntry(T value) {\n+            super();\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public T getValue() {\n+            return value;\n+        }\n+\n+\n+\n+\n+    }\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/WeakConcurrentSet.java",
            "additions": 98,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,98 @@\n+package net.engio.mbassy.common;\n+\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Iterator;\n+import java.util.WeakHashMap;\n+\n+/**\n+ * This implementation uses weak references to the elements. Iterators automatically perform cleanups of\n+ * garbage collected objects during iteration -> no dedicated maintenance operations need to be called or run in background.\n+ * <p/>\n+ * <p/>\n+ * <p/>\n+ *\n+ * @author bennidi\n+ *         Date: 2/12/12\n+ */\n+public class WeakConcurrentSet<T> extends AbstractConcurrentSet<T>{\n+\n+\n+    public WeakConcurrentSet() {\n+        super(new WeakHashMap<T, ISetEntry<T>>());\n+    }\n+\n+    public Iterator<T> iterator() {\n+        return new Iterator<T>() {\n+\n+            private ISetEntry<T> current = head;\n+\n+            public boolean hasNext() {\n+                if (current == null) return false;\n+                if (current.getValue() == null) {    // auto-removal of orphan references\n+                    do {\n+                        remove();\n+                    } while(current != null && current.getValue() == null);\n+                    return hasNext();\n+                } else {\n+                    return true;\n+                }\n+            }\n+\n+            public T next() {\n+                if (current == null) {\n+                    return null;\n+                }\n+                T value = current.getValue();\n+                if (value == null) {    // auto-removal of orphan references\n+                    do {\n+                        remove();\n+                    } while(current != null && current.getValue() == null);\n+                    return next();\n+                } else {\n+                    current = current.next();\n+                    return value;\n+                }\n+            }\n+\n+            public void remove() {\n+                if (current == null) {\n+                    return;\n+                }\n+                ISetEntry<T> newCurrent = current.next();\n+                WeakConcurrentSet.this.remove(current.getValue());\n+                current = newCurrent;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    protected Entry<T> createEntry(T value, Entry<T> next) {\n+        return next != null ? new WeakEntry<T>(value, next) : new WeakEntry<T>(value);\n+    }\n+\n+\n+    public static class WeakEntry<T> extends Entry<T> {\n+\n+        private WeakReference<T> value;\n+\n+        private WeakEntry(T value, Entry<T> next) {\n+            super(next);\n+            this.value = new WeakReference<T>(value);\n+        }\n+\n+        private WeakEntry(T value) {\n+            super();\n+            this.value = new WeakReference<T>(value);\n+        }\n+\n+        @Override\n+        public T getValue() {\n+            return value.get();\n+        }\n+\n+\n+\n+\n+    }\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n+import net.engio.mbassy.bus.IMessageBus;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n \n /**\n@@ -8,7 +9,7 @@ import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n  * @author bennidi\n  *         Date: 11/23/12\n  */\n-public class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n+public class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware<IMessageBus> implements IHandlerInvocation<Object,Object,IMessageBus> {\n \n     private IHandlerInvocation delegate;\n \n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/DelegatingMessageDispatcher.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -11,7 +11,7 @@ import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n  */\n public abstract class DelegatingMessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher {\n \n-    private IMessageDispatcher delegate;\n+    private final IMessageDispatcher delegate;\n \n \n     public DelegatingMessageDispatcher(IMessageDispatcher delegate) {\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.dispatch;\n \n import net.engio.mbassy.bus.MessagePublication;\n-import net.engio.mbassy.common.ConcurrentSet;\n+import net.engio.mbassy.common.IConcurrentSet;\n import net.engio.mbassy.subscription.MessageEnvelope;\n \n /**\n@@ -21,7 +21,7 @@ public class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher {\n     }\n \n     @Override\n-    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n+    public void dispatch(MessagePublication publication, Object message, IConcurrentSet listeners) {\n         getDelegate().dispatch(publication, new MessageEnvelope(message), listeners);\n     }\n }\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.dispatch;\n \n import net.engio.mbassy.bus.MessagePublication;\n-import net.engio.mbassy.common.ConcurrentSet;\n+import net.engio.mbassy.common.IConcurrentSet;\n import net.engio.mbassy.listener.IMessageFilter;\n \n /**\n@@ -37,7 +37,7 @@ public class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n \n \n     @Override\n-    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n+    public void dispatch(MessagePublication publication, Object message, IConcurrentSet listeners) {\n         if (passesFilter(message)) {\n             getDelegate().dispatch(publication, message, listeners);\n         }\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/HandlerInvocation.java",
            "additions": 19,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,19 @@\n+package net.engio.mbassy.dispatch;\n+\n+import net.engio.mbassy.bus.ISyncMessageBus;\n+import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n+import net.engio.mbassy.subscription.SubscriptionContext;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 3/29/13\n+ */\n+public abstract class HandlerInvocation<Listener, Message> extends AbstractSubscriptionContextAware<ISyncMessageBus> implements IHandlerInvocation<Listener, Message,ISyncMessageBus>{\n+\n+\n+    public HandlerInvocation(SubscriptionContext context) {\n+        super(context);\n+    }\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java",
            "additions": 4,
            "deletions": 2
        },
        "diff content": "@@ -1,5 +1,7 @@\n package net.engio.mbassy.dispatch;\n \n+import net.engio.mbassy.bus.ISyncMessageBus;\n+\n /**\n  * A handler invocation encapsulates the logic that is used to invoke a single\n  * message handler to process a given message.\n@@ -9,7 +11,7 @@ package net.engio.mbassy.dispatch;\n  * @author bennidi\n  *         Date: 11/23/12\n  */\n-public interface IHandlerInvocation extends ISubscriptionContextAware {\n+public interface IHandlerInvocation<Listener, Message, Bus extends ISyncMessageBus> extends ISubscriptionContextAware<Bus> {\n \n     /**\n      * Invoke the message delivery logic of this handler\n@@ -17,5 +19,5 @@ public interface IHandlerInvocation extends ISubscriptionContextAware {\n      * @param listener The listener that will receive the message\n      * @param message  The message to be delivered to the listener\n      */\n-    void invoke(Object listener, Object message);\n+    void invoke(Listener listener, Message message);\n }\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IMessageBusAware.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.bus.IMessageBus;\n+import net.engio.mbassy.bus.ISyncMessageBus;\n \n /**\n  * This interface marks components that have access to the message bus that they belong to.\n@@ -8,7 +8,7 @@ import net.engio.mbassy.bus.IMessageBus;\n  * @author bennidi\n  *         Date: 3/1/13\n  */\n-public interface IMessageBusAware {\n+public interface IMessageBusAware<Bus extends ISyncMessageBus> {\n \n-    IMessageBus getBus();\n+    Bus getBus();\n }\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.dispatch;\n \n import net.engio.mbassy.bus.MessagePublication;\n-import net.engio.mbassy.common.ConcurrentSet;\n+import net.engio.mbassy.common.IConcurrentSet;\n \n /**\n  * A message dispatcher provides the functionality to deliver a single message\n@@ -29,7 +29,7 @@ public interface IMessageDispatcher extends ISubscriptionContextAware {\n      * @param message     The message that should be delivered to the listeners\n      * @param listeners   The listeners that should receive the message\n      */\n-    void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners);\n+    void dispatch(MessagePublication publication, Object message, IConcurrentSet listeners);\n \n     /**\n      * Get the handler invocation that will be used to deliver the\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/ISubscriptionContextAware.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n+import net.engio.mbassy.bus.ISyncMessageBus;\n import net.engio.mbassy.subscription.SubscriptionContext;\n \n /**\n@@ -8,7 +9,7 @@ import net.engio.mbassy.subscription.SubscriptionContext;\n  * @author bennidi\n  *         Date: 3/1/13\n  */\n-public interface ISubscriptionContextAware extends IMessageBusAware {\n+public interface ISubscriptionContextAware<Bus extends ISyncMessageBus> extends IMessageBusAware<Bus> {\n \n     /**\n      * Get the subscription context associated with this object\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.dispatch;\n \n import net.engio.mbassy.bus.MessagePublication;\n-import net.engio.mbassy.common.ConcurrentSet;\n+import net.engio.mbassy.common.IConcurrentSet;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n import net.engio.mbassy.subscription.SubscriptionContext;\n \n@@ -17,7 +17,7 @@ import net.engio.mbassy.subscription.SubscriptionContext;\n  */\n public class MessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher {\n \n-    private IHandlerInvocation invocation;\n+    private final IHandlerInvocation invocation;\n \n     public MessageDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n         super(context);\n@@ -25,7 +25,7 @@ public class MessageDispatcher extends AbstractSubscriptionContextAware implemen\n     }\n \n     @Override\n-    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n+    public void dispatch(final MessagePublication publication, final Object message, final IConcurrentSet listeners) {\n         publication.markDelivered();\n         for (Object listener : listeners) {\n             getInvocation().invoke(listener, message);\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -2,7 +2,6 @@ package net.engio.mbassy.dispatch;\n \n import net.engio.mbassy.IPublicationErrorHandler;\n import net.engio.mbassy.PublicationError;\n-import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n import net.engio.mbassy.subscription.SubscriptionContext;\n \n import java.lang.reflect.InvocationTargetException;\n@@ -15,7 +14,7 @@ import java.util.Collection;\n  * @author bennidi\n  *         Date: 11/23/12\n  */\n-public class ReflectiveHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n+public class ReflectiveHandlerInvocation extends HandlerInvocation{\n \n     public ReflectiveHandlerInvocation(SubscriptionContext context) {\n         super(context);\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/SynchronizedHandlerInvocation.java",
            "additions": 31,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,31 @@\n+package net.engio.mbassy.dispatch;\n+\n+import net.engio.mbassy.bus.IMessageBus;\n+import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n+\n+/**\n+ * Synchronizes message handler invocations for all handlers that specify @Synchronized\n+ *\n+ * @author bennidi\n+ *         Date: 3/31/13\n+ */\n+public class SynchronizedHandlerInvocation extends AbstractSubscriptionContextAware<IMessageBus> implements IHandlerInvocation<Object,Object,IMessageBus>  {\n+\n+    private IHandlerInvocation delegate;\n+\n+    public SynchronizedHandlerInvocation(IHandlerInvocation delegate) {\n+        super(delegate.getContext());\n+        this.delegate = delegate;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void invoke(final Object listener, final Object message) {\n+        synchronized (listener){\n+            delegate.invoke(listener, message);\n+        }\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Handler.java",
            "additions": 18,
            "deletions": 6
        },
        "diff content": "@@ -1,10 +1,9 @@\n package net.engio.mbassy.listener;\n \n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Inherited;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n+import net.engio.mbassy.dispatch.HandlerInvocation;\n+import net.engio.mbassy.dispatch.ReflectiveHandlerInvocation;\n+\n+import java.lang.annotation.*;\n \n /**\n  * Mark any method of any object(=listener) as a message handler and configure the handler\n@@ -28,7 +27,7 @@ public @interface Handler {\n      * Define the mode in which a message is delivered to each listener. Listeners can be notified\n      * sequentially or concurrently.\n      */\n-    Mode delivery() default Mode.Sequential;\n+    Invoke delivery() default Invoke.Synchronously;\n \n     /**\n      * Handlers are ordered by priority and handlers with higher priority are processed before\n@@ -51,4 +50,17 @@ public @interface Handler {\n      */\n     boolean enabled() default true;\n \n+\n+    /**\n+     * Each handler call is implemented as an invocation object that implements the invocation mechanism.\n+     * The basic implementation uses reflection and is the default. It is possible though to provide a custom\n+     * invocation to add additional logic.\n+     *\n+     * Note: Providing a custom invocation will most likely reduce performance, since the JIT-Compiler\n+     * can not do some of its sophisticated byte code optimizations.\n+     *\n+     */\n+    Class<? extends HandlerInvocation> invocation() default ReflectiveHandlerInvocation.class;\n+\n+\n }\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Invoke.java",
            "additions": 11,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,11 @@\n+package net.engio.mbassy.listener;\n+\n+/**\n+ * Created with IntelliJ IDEA.\n+ *\n+ * @author bennidi\n+ *         Date: 11/16/12\n+ */\n+public enum Invoke {\n+    Synchronously, Asynchronously\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Listener.java",
            "additions": 24,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,24 @@\n+package net.engio.mbassy.listener;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * @author bennidi\n+ *         Date: 3/29/13\n+ */\n+@Retention(value = RetentionPolicy.RUNTIME)\n+@Target(value = {ElementType.TYPE})\n+public @interface Listener {\n+\n+    /**\n+     * By default, references to message listeners are weak to eliminate risks of memory leaks.\n+     * It is possible to use strong references instead.\n+     *\n+     * @return\n+     */\n+    References references() default References.Weak;\n+\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java",
            "additions": 34,
            "deletions": 11
        },
        "diff content": "@@ -1,7 +1,8 @@\n package net.engio.mbassy.listener;\n \n+import net.engio.mbassy.dispatch.HandlerInvocation;\n+\n import java.lang.reflect.Method;\n-import java.util.Collections;\n import java.util.LinkedList;\n import java.util.List;\n \n@@ -11,36 +12,54 @@ import java.util.List;\n  */\n public class MessageHandlerMetadata {\n \n-    private Method handler;\n+    private final Method handler;\n+\n+    private final IMessageFilter[] filter;\n+\n+    private final Handler handlerConfig;\n \n-    private IMessageFilter[] filter;\n+    private final boolean isAsynchronous;\n \n-    private Handler handlerConfig;\n+    private final Enveloped envelope;\n \n-    private boolean isAsynchronous = false;\n+    private final List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n \n-    private Enveloped envelope = null;\n+    private final boolean acceptsSubtypes;\n \n-    private List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n+    private final Listener listenerConfig;\n \n-    private boolean acceptsSubtypes = true;\n+    private final boolean isSynchronized;\n \n \n-    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Handler handlerConfig) {\n+    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Handler handlerConfig, Listener listenerConfig) {\n+        if(handler == null || handlerConfig == null){\n+            throw new IllegalArgumentException(\"The message handler configuration may not be null\");\n+        }\n         this.handler = handler;\n         this.filter = filter;\n         this.handlerConfig = handlerConfig;\n-        this.isAsynchronous = handlerConfig.delivery().equals(Mode.Concurrent);\n+        this.isAsynchronous = handlerConfig.delivery().equals(Invoke.Asynchronously);\n         this.envelope = handler.getAnnotation(Enveloped.class);\n         this.acceptsSubtypes = !handlerConfig.rejectSubtypes();\n+        this.listenerConfig = listenerConfig;\n+        this.isSynchronized = handler.getAnnotation(Synchronized.class) != null;\n         if (this.envelope != null) {\n-            Collections.addAll(handledMessages, envelope.messages());\n+            for(Class messageType : envelope.messages()){\n+                handledMessages.add(messageType);\n+            }\n         } else {\n             handledMessages.add(handler.getParameterTypes()[0]);\n         }\n         this.handler.setAccessible(true);\n     }\n \n+    public boolean isSynchronized(){\n+        return isSynchronized;\n+    }\n+\n+    public boolean useStrongReferences(){\n+        return listenerConfig != null && listenerConfig.references().equals(References.Strong);\n+    }\n \n     public boolean isAsynchronous() {\n         return isAsynchronous;\n@@ -70,6 +89,10 @@ public class MessageHandlerMetadata {\n         return envelope != null;\n     }\n \n+    public Class<? extends HandlerInvocation> getHandlerInvocation(){\n+        return handlerConfig.invocation();\n+    }\n+\n     public boolean handlesMessage(Class<?> messageType) {\n         for (Class<?> handledMessage : handledMessages) {\n             if (handledMessage.equals(messageType)) {\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MetadataReader.java",
            "additions": 5,
            "deletions": 8
        },
        "diff content": "@@ -54,14 +54,12 @@ public class MetadataReader {\n     }\n \n \n-    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler) {\n-        Handler config = messageHandler.getAnnotation(Handler.class);\n-        return new MessageHandlerMetadata(messageHandler, getFilter(config), config);\n-    }\n+\n \n     // get all listeners defined by the given class (includes\n     // listeners defined in super classes)\n     public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n+        Listener listenerConfig = target.getAnnotation(Listener.class);\n         // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n         List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n         // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n@@ -72,19 +70,18 @@ public class MetadataReader {\n             }\n         }\n \n-\n         List<MessageHandlerMetadata> filteredHandlers = new LinkedList<MessageHandlerMetadata>();\n         // for each handler there will be no overriding method that specifies @Handler annotation\n         // but an overriding method does inherit the listener configuration of the overwritten method\n         for (Method handler : bottomMostHandlers) {\n-            Handler handle = handler.getAnnotation(Handler.class);\n-            if (!handle.enabled() || !isValidMessageHandler(handler)) {\n+            Handler handlerConfig = handler.getAnnotation(Handler.class);\n+            if (!handlerConfig.enabled() || !isValidMessageHandler(handler)) {\n                 continue; // disabled or invalid listeners are ignored\n             }\n             Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n             // if a handler is overwritten it inherits the configuration of its parent method\n             MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n-                    getFilter(handle), handle);\n+                    getFilter(handlerConfig), handlerConfig, listenerConfig);\n             filteredHandlers.add(handlerMetadata);\n \n         }\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Mode.java",
            "additions": 0,
            "deletions": 13
        },
        "diff content": "@@ -1,13 +0,0 @@\n-package net.engio.mbassy.listener;\n-\n-/**\n- * Created with IntelliJ IDEA.\n- *\n- * @author bennidi\n- *         Date: 11/16/12\n- *         Time: 10:01 AM\n- *         To change this template use File | Settings | File Templates.\n- */\n-public enum Mode {\n-    Sequential, Concurrent\n-}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/References.java",
            "additions": 10,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,10 @@\n+package net.engio.mbassy.listener;\n+\n+/**\n+*\n+* @author bennidi\n+*         Date: 3/29/13\n+*/\n+public enum References {\n+    Strong,Weak\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Synchronized.java",
            "additions": 16,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,16 @@\n+package net.engio.mbassy.listener;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * A handler marked with this annotation is guaranteed to be invoked in a thread-safe manner, that is, no\n+ * other running message publication will be able to invoke this handler as long as it has not done its work.\n+ *\n+ * @author bennidi\n+ *         Date: 3/31/13\n+ */\n+@Retention(value = RetentionPolicy.RUNTIME)\n+@Inherited\n+@Target(value = {ElementType.METHOD})\n+public @interface Synchronized {\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java",
            "additions": 6,
            "deletions": 6
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.subscription;\n \n-import net.engio.mbassy.bus.IMessageBus;\n+import net.engio.mbassy.bus.ISyncMessageBus;\n import net.engio.mbassy.dispatch.ISubscriptionContextAware;\n \n /**\n@@ -9,20 +9,20 @@ import net.engio.mbassy.dispatch.ISubscriptionContextAware;\n  * @author bennidi\n  *         Date: 3/1/13\n  */\n-public class AbstractSubscriptionContextAware implements ISubscriptionContextAware {\n+public class AbstractSubscriptionContextAware<Bus extends ISyncMessageBus> implements ISubscriptionContextAware<Bus> {\n \n-    private SubscriptionContext context;\n+    private final SubscriptionContext<Bus> context;\n \n-    public AbstractSubscriptionContextAware(SubscriptionContext context) {\n+    public AbstractSubscriptionContextAware(SubscriptionContext<Bus> context) {\n         this.context = context;\n     }\n \n-    public SubscriptionContext getContext() {\n+    public SubscriptionContext<Bus> getContext() {\n         return context;\n     }\n \n     @Override\n-    public IMessageBus getBus() {\n+    public Bus getBus() {\n         return context.getOwningBus();\n     }\n }\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 7,
            "deletions": 6
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.subscription;\n \n import net.engio.mbassy.bus.MessagePublication;\n-import net.engio.mbassy.common.ConcurrentSet;\n+import net.engio.mbassy.common.IConcurrentSet;\n import net.engio.mbassy.dispatch.IMessageDispatcher;\n \n import java.util.Comparator;\n@@ -12,17 +12,18 @@ import java.util.UUID;\n  */\n public class Subscription {\n \n-    private UUID id = UUID.randomUUID();\n+    private final UUID id = UUID.randomUUID();\n \n-    protected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n+    protected final IConcurrentSet<Object> listeners;\n \n-    private IMessageDispatcher dispatcher;\n+    private final IMessageDispatcher dispatcher;\n \n-    private SubscriptionContext context;\n+    private final SubscriptionContext context;\n \n-    public Subscription(SubscriptionContext context, IMessageDispatcher dispatcher) {\n+    Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, IConcurrentSet<Object> listeners) {\n         this.context = context;\n         this.dispatcher = dispatcher;\n+        this.listeners = listeners;\n     }\n \n \n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java",
            "additions": 5,
            "deletions": 5
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.subscription;\n \n-import net.engio.mbassy.bus.IMessageBus;\n+import net.engio.mbassy.bus.ISyncMessageBus;\n import net.engio.mbassy.listener.MessageHandlerMetadata;\n \n /**\n@@ -12,13 +12,13 @@ import net.engio.mbassy.listener.MessageHandlerMetadata;\n  * @author bennidi\n  *         Date: 11/23/12\n  */\n-public class SubscriptionContext {\n+public class SubscriptionContext<Bus extends ISyncMessageBus> {\n \n-    private IMessageBus owningBus;\n+    private Bus owningBus;\n \n     private MessageHandlerMetadata handlerMetadata;\n \n-    public SubscriptionContext(IMessageBus owningBus, MessageHandlerMetadata handlerMetadata) {\n+    public SubscriptionContext(Bus owningBus, MessageHandlerMetadata handlerMetadata) {\n         this.owningBus = owningBus;\n         this.handlerMetadata = handlerMetadata;\n     }\n@@ -28,7 +28,7 @@ public class SubscriptionContext {\n      *\n      * @return\n      */\n-    public IMessageBus getOwningBus() {\n+    public Bus getOwningBus() {\n         return owningBus;\n     }\n \n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java",
            "additions": 31,
            "deletions": 13
        },
        "diff content": "@@ -1,12 +1,12 @@\n package net.engio.mbassy.subscription;\n \n-import net.engio.mbassy.dispatch.AsynchronousHandlerInvocation;\n-import net.engio.mbassy.dispatch.EnvelopedMessageDispatcher;\n-import net.engio.mbassy.dispatch.FilteredMessageDispatcher;\n-import net.engio.mbassy.dispatch.IHandlerInvocation;\n-import net.engio.mbassy.dispatch.IMessageDispatcher;\n-import net.engio.mbassy.dispatch.MessageDispatcher;\n-import net.engio.mbassy.dispatch.ReflectiveHandlerInvocation;\n+import net.engio.mbassy.MessageBusException;\n+import net.engio.mbassy.common.StrongConcurrentSet;\n+import net.engio.mbassy.common.WeakConcurrentSet;\n+import net.engio.mbassy.dispatch.*;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n \n /**\n  * Created with IntelliJ IDEA.\n@@ -18,14 +18,23 @@ import net.engio.mbassy.dispatch.ReflectiveHandlerInvocation;\n  */\n public class SubscriptionFactory {\n \n-    public Subscription createSubscription(SubscriptionContext context) {\n-        IHandlerInvocation invocation = buildInvocationForHandler(context);\n-        IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n-        return new Subscription(context, dispatcher);\n+    public Subscription createSubscription(SubscriptionContext context) throws MessageBusException{\n+        try {\n+            IHandlerInvocation invocation = buildInvocationForHandler(context);\n+            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n+            return new Subscription(context, dispatcher, context.getHandlerMetadata().useStrongReferences()\n+                ? new StrongConcurrentSet<Object>()\n+                : new WeakConcurrentSet<Object>());\n+        } catch (Exception e) {\n+            throw new MessageBusException(e);\n+        }\n     }\n \n-    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) {\n-        IHandlerInvocation invocation = new ReflectiveHandlerInvocation(context);\n+    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {\n+        IHandlerInvocation invocation = createBaseHandlerInvocation(context);\n+        if(context.getHandlerMetadata().isSynchronized()){\n+            invocation = new SynchronizedHandlerInvocation(invocation);\n+        }\n         if (context.getHandlerMetadata().isAsynchronous()) {\n             invocation = new AsynchronousHandlerInvocation(invocation);\n         }\n@@ -42,4 +51,13 @@ public class SubscriptionFactory {\n         }\n         return dispatcher;\n     }\n+\n+    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws Exception {\n+        Class<? extends HandlerInvocation> invocation = context.getHandlerMetadata().getHandlerInvocation();\n+        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){\n+            throw new MessageBusException(\"The handler invocation must be top level class or nested STATIC inner class\");\n+        }\n+        Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);\n+        return constructor.newInstance(context);\n+    }\n }\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AllTests.java",
            "additions": 4,
            "deletions": 2
        },
        "diff content": "@@ -12,13 +12,15 @@ import org.junit.runners.Suite;\n  */\n @RunWith(Suite.class)\n @Suite.SuiteClasses({\n-        ConcurrentSetTest.class,\n+        StrongConcurrentSetTest.class,\n+        WeakConcurrentSetTest.class,\n         MessagePublicationTest.class,\n         FilterTest.class,\n         MetadataReaderTest.class,\n         ListenerSubscriptionTest.class,\n         MethodDispatchTest.class,\n-        DeadEventTest.class\n+        DeadEventTest.class,\n+        SynchronizedHandlerTest.class\n })\n public class AllTests {\n }\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConcurrentSetTest.java",
            "additions": 36,
            "deletions": 73
        },
        "diff content": "@@ -1,11 +1,10 @@\n package net.engio.mbassy;\n \n import junit.framework.Assert;\n-import org.junit.Ignore;\n-import org.junit.Test;\n import net.engio.mbassy.common.ConcurrentExecutor;\n-import net.engio.mbassy.common.ConcurrentSet;\n+import net.engio.mbassy.common.IConcurrentSet;\n import net.engio.mbassy.common.UnitTest;\n+import org.junit.Test;\n \n import java.util.HashSet;\n import java.util.Iterator;\n@@ -23,50 +22,14 @@ import java.util.Random;\n  * @author bennidi\n  *         Date: 11/12/12\n  */\n-public class ConcurrentSetTest extends UnitTest {\n+public abstract class ConcurrentSetTest extends UnitTest {\n \n     // Shared state\n-    private int numberOfElements = 100000;\n-    private int numberOfThreads = 50;\n-\n-    @Ignore(\"Currently fails when building as a suite with JDK 1.7.0_15 and Maven 3.0.5 on a Mac\")\n-    @Test\n-    public void testIteratorCleanup() {\n-\n-        // Assemble\n-        final HashSet<Object> persistingCandidates = new HashSet<Object>();\n-        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n-        final Random rand = new Random();\n-\n-        for (int i = 0; i < numberOfElements; i++) {\n-            Object candidate = new Object();\n-\n-            if (rand.nextInt() % 3 == 0) {\n-                persistingCandidates.add(candidate);\n-            }\n-            testSet.add(candidate);\n-        }\n-\n-        // Remove/Garbage collect all objects that have not\n-        // been inserted into the set of persisting candidates.\n-        runGC();\n-\n-        ConcurrentExecutor.runConcurrent(new Runnable() {\n-            @Override\n-            public void run() {\n-                for (Object testObject : testSet) {\n-                    // do nothing\n-                    // just iterate to trigger automatic clean up\n-                    System.currentTimeMillis();\n-                }\n-            }\n-        }, numberOfThreads);\n-\n-        assertEquals(persistingCandidates.size(), testSet.size());\n-        for (Object test : testSet) {\n-            assertTrue(persistingCandidates.contains(test));\n-        }\n-    }\n+    protected final int numberOfElements = 100000;\n+    protected final int numberOfThreads = 50;\n+    \n+    \n+    protected abstract IConcurrentSet createSet();\n \n \n     @Test\n@@ -74,7 +37,7 @@ public class ConcurrentSetTest extends UnitTest {\n         final LinkedList<Object> duplicates = new LinkedList<Object>();\n         final HashSet<Object> distinct = new HashSet<Object>();\n \n-        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n+        final IConcurrentSet testSetWeak = createSet();\n         Random rand = new Random();\n \n         // build set of distinct objects and list of duplicates\n@@ -92,15 +55,15 @@ public class ConcurrentSetTest extends UnitTest {\n             @Override\n             public void run() {\n                 for (Object src : duplicates) {\n-                    testSet.add(src);\n+                    testSetWeak.add(src);\n                 }\n             }\n         }, numberOfThreads);\n \n         // check that the control set and the test set contain the exact same elements\n-        assertEquals(distinct.size(), testSet.size());\n+        assertEquals(distinct.size(), testSetWeak.size());\n         for (Object uniqueObject : distinct) {\n-            assertTrue(testSet.contains(uniqueObject));\n+            assertTrue(testSetWeak.contains(uniqueObject));\n         }\n     }\n \n@@ -110,7 +73,7 @@ public class ConcurrentSetTest extends UnitTest {\n \n         final HashSet<Object> hashSet = new HashSet<Object>();\n \n-        final ConcurrentSet<Object> concurrentSet = new ConcurrentSet<Object>();\n+        final IConcurrentSet weakConcurrentSet = createSet();\n \n         for (int i = 0; i < 1000000; i++) {\n             source.add(new Object());\n@@ -126,7 +89,7 @@ public class ConcurrentSetTest extends UnitTest {\n \n         start = System.currentTimeMillis();\n         for (Object o : source) {\n-            concurrentSet.add(o);\n+            weakConcurrentSet.add(o);\n         }\n         duration = System.currentTimeMillis() - start;\n         System.out.println(\"Performance of ConcurrentSet for 1.000.000 object insertions \" + duration);\n@@ -138,7 +101,7 @@ public class ConcurrentSetTest extends UnitTest {\n         final HashSet<Object> source = new HashSet<Object>();\n         final HashSet<Object> toRemove = new HashSet<Object>();\n \n-        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n+        final IConcurrentSet testSetWeak = createSet();\n         // build set of distinct objects and mark a subset of those for removal\n         for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n@@ -153,7 +116,7 @@ public class ConcurrentSetTest extends UnitTest {\n             @Override\n             public void run() {\n                 for (Object src : source) {\n-                    testSet.add(src);\n+                    testSetWeak.add(src);\n                 }\n             }\n         }, numberOfThreads);\n@@ -163,20 +126,20 @@ public class ConcurrentSetTest extends UnitTest {\n             @Override\n             public void run() {\n                 for (Object src : toRemove) {\n-                    testSet.remove(src);\n+                    testSetWeak.remove(src);\n                 }\n             }\n         }, numberOfThreads);\n \n         // ensure that the test set does not contain any of the elements that have been removed from it\n-        for (Object tar : testSet) {\n+        for (Object tar : testSetWeak) {\n             Assert.assertTrue(!toRemove.contains(tar));\n         }\n         // ensure that the test set still contains all objects from the source set that have not been marked\n         // for removal\n-        assertEquals(source.size() - toRemove.size(), testSet.size());\n+        assertEquals(source.size() - toRemove.size(), testSetWeak.size());\n         for (Object src : source) {\n-            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n+            if (!toRemove.contains(src)) assertTrue(testSetWeak.contains(src));\n         }\n     }\n \n@@ -185,7 +148,7 @@ public class ConcurrentSetTest extends UnitTest {\n         final HashSet<Object> source = new HashSet<Object>();\n         final HashSet<Object> toRemove = new HashSet<Object>();\n \n-        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n+        final IConcurrentSet testSetWeak = createSet();\n         // build set of candidates and mark subset for removal\n         for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n@@ -201,35 +164,35 @@ public class ConcurrentSetTest extends UnitTest {\n             @Override\n             public void run() {\n                 for (Object src : source) {\n-                    testSet.add(src);\n+                    testSetWeak.add(src);\n                     if (toRemove.contains(src))\n-                        testSet.remove(src);\n+                        testSetWeak.remove(src);\n                 }\n             }\n         }, numberOfThreads);\n \n         // ensure that the test set does not contain any of the elements that have been removed from it\n-        for (Object tar : testSet) {\n+        for (Object tar : testSetWeak) {\n             Assert.assertTrue(!toRemove.contains(tar));\n         }\n         // ensure that the test set still contains all objects from the source set that have not been marked\n         // for removal\n-        assertEquals(source.size() - toRemove.size(), testSet.size());\n+        assertEquals(source.size() - toRemove.size(), testSetWeak.size());\n         for (Object src : source) {\n-            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n+            if (!toRemove.contains(src)) assertTrue(testSetWeak.contains(src));\n         }\n     }\n \n     @Test\n     public void testCompleteRemoval() {\n         final HashSet<Object> source = new HashSet<Object>();\n-        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n+        final IConcurrentSet testSetWeak = createSet();\n \n         // build set of candidates and mark subset for removal\n         for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n             source.add(candidate);\n-            testSet.add(candidate);\n+            testSetWeak.add(candidate);\n         }\n \n         // build test set by adding the candidates\n@@ -238,7 +201,7 @@ public class ConcurrentSetTest extends UnitTest {\n             @Override\n             public void run() {\n                 for (Object src : source) {\n-                    testSet.remove(src);\n+                    testSetWeak.remove(src);\n                 }\n             }\n         }, numberOfThreads);\n@@ -246,22 +209,22 @@ public class ConcurrentSetTest extends UnitTest {\n \n         // ensure that the test set still contains all objects from the source set that have not been marked\n         // for removal\n-        assertEquals(0, testSet.size());\n+        assertEquals(0, testSetWeak.size());\n         for(Object src : source){\n-            assertFalse(testSet.contains(src));\n+            assertFalse(testSetWeak.contains(src));\n         }\n     }\n \n     @Test\n     public void testRemovalViaIterator() {\n         final HashSet<Object> source = new HashSet<Object>();\n-        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n+        final IConcurrentSet testSetWeak = createSet();\n \n         // build set of candidates and mark subset for removal\n         for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n             source.add(candidate);\n-            testSet.add(candidate);\n+            testSetWeak.add(candidate);\n         }\n \n         // build test set by adding the candidates\n@@ -269,7 +232,7 @@ public class ConcurrentSetTest extends UnitTest {\n         ConcurrentExecutor.runConcurrent(new Runnable() {\n             @Override\n             public void run() {\n-                Iterator<Object> iterator = testSet.iterator();\n+                Iterator<Object> iterator = testSetWeak.iterator();\n                 while(iterator.hasNext()){\n                     iterator.remove();\n                 }\n@@ -279,9 +242,9 @@ public class ConcurrentSetTest extends UnitTest {\n \n         // ensure that the test set still contains all objects from the source set that have not been marked\n         // for removal\n-        assertEquals(0, testSet.size());\n+        assertEquals(0, testSetWeak.size());\n         for(Object src : source){\n-            assertFalse(testSet.contains(src));\n+            assertFalse(testSetWeak.contains(src));\n         }\n     }\n \n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/DeadEventTest.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -2,7 +2,7 @@ package net.engio.mbassy;\n \n import net.engio.mbassy.bus.BusConfiguration;\n import net.engio.mbassy.bus.MBassador;\n-import net.engio.mbassy.common.ConcurrentSet;\n+import net.engio.mbassy.common.WeakConcurrentSet;\n import net.engio.mbassy.common.DeadMessage;\n import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.listener.Handler;\n@@ -33,7 +33,7 @@ public class DeadEventTest extends MessageBusTest{\n \n     public class DeadEventHandler{\n \n-         private ConcurrentSet deadEvents = new ConcurrentSet();\n+         private WeakConcurrentSet deadEvents = new WeakConcurrentSet();\n \n         @Handler\n          public void handle(DeadMessage message){\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/FilterTest.java",
            "additions": 8,
            "deletions": 6
        },
        "diff content": "@@ -1,19 +1,19 @@\n package net.engio.mbassy;\n \n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n import net.engio.mbassy.bus.BusConfiguration;\n import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.common.DeadMessage;\n import net.engio.mbassy.common.FilteredMessage;\n import net.engio.mbassy.common.MessageBusTest;\n-import net.engio.mbassy.events.SubTestMessage;\n-import net.engio.mbassy.listener.*;\n-import org.junit.Test;\n import net.engio.mbassy.common.TestUtil;\n+import net.engio.mbassy.events.SubTestMessage;\n import net.engio.mbassy.events.TestMessage;\n+import net.engio.mbassy.listener.*;\n import net.engio.mbassy.listeners.ListenerFactory;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n  * Testing of filter functionality\n@@ -28,6 +28,8 @@ public class FilterTest extends MessageBusTest {\n \n     @Test\n     public void testSubclassFilter() throws Exception {\n+        FilteredEventCounter.set(0);\n+        DeadEventCounter.set(0);\n \n         MBassador bus = getBus(new BusConfiguration());\n         ListenerFactory listenerFactory = new ListenerFactory()\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MessagePublicationTest.java",
            "additions": 32,
            "deletions": 12
        },
        "diff content": "@@ -1,23 +1,18 @@\n package net.engio.mbassy;\n \n-import java.util.List;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-\n import net.engio.mbassy.bus.BusConfiguration;\n import net.engio.mbassy.bus.MBassador;\n-import net.engio.mbassy.common.MessageBusTest;\n-import net.engio.mbassy.events.SubTestMessage;\n-import org.junit.Test;\n import net.engio.mbassy.common.ConcurrentExecutor;\n+import net.engio.mbassy.common.MessageBusTest;\n import net.engio.mbassy.common.TestUtil;\n+import net.engio.mbassy.events.SubTestMessage;\n import net.engio.mbassy.events.TestMessage;\n import net.engio.mbassy.events.TestMessage2;\n-import net.engio.mbassy.listeners.EventingTestBean;\n-import net.engio.mbassy.listeners.EventingTestBean2;\n-import net.engio.mbassy.listeners.EventingTestBean3;\n-import net.engio.mbassy.listeners.ListenerFactory;\n-import net.engio.mbassy.listeners.MultiEventHandler;\n-import net.engio.mbassy.listeners.NonListeningBean;\n+import net.engio.mbassy.listeners.*;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n \n /**\n  * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n@@ -95,6 +90,31 @@ public class MessagePublicationTest extends MessageBusTest {\n \n     }\n \n+    @Test\n+    public void testStrongListenerSubscription() throws Exception {\n+\n+        MBassador bus = getBus(new BusConfiguration());\n+\n+\n+        for(int i = 0; i< 10000; i++){\n+            bus.subscribe(new EventingTestBean2());\n+        }\n+\n+        runGC();\n+\n+        TestMessage message = new TestMessage();\n+        TestMessage subMessage = new SubTestMessage();\n+\n+        bus.publish(message);\n+        bus.publish(subMessage);\n+\n+        pause(processingTimeInMS);\n+\n+        assertEquals(10000, message.counter.get());\n+        assertEquals(20000, subMessage.counter.get());\n+\n+    }\n+\n     @Test\n     public void testConcurrentMixedMessagePublication() throws Exception {\n         final CopyOnWriteArrayList<TestMessage> testMessages = new CopyOnWriteArrayList<TestMessage>();\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/StrongConcurrentSetTest.java",
            "additions": 18,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,18 @@\n+package net.engio.mbassy;\n+\n+import net.engio.mbassy.common.IConcurrentSet;\n+import net.engio.mbassy.common.StrongConcurrentSet;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 3/29/13\n+ */\n+public class StrongConcurrentSetTest extends ConcurrentSetTest{\n+\n+    @Override\n+    protected IConcurrentSet createSet() {\n+        return new StrongConcurrentSet();\n+    }\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java",
            "additions": 103,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,103 @@\n+package net.engio.mbassy;\n+\n+import net.engio.mbassy.bus.BusConfiguration;\n+import net.engio.mbassy.bus.IMessageBus;\n+import net.engio.mbassy.bus.MessagePublication;\n+import net.engio.mbassy.common.MessageBusTest;\n+import net.engio.mbassy.listener.Handler;\n+import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.listener.Synchronized;\n+import org.junit.Test;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 3/31/13\n+ */\n+public class SynchronizedHandlerTest extends MessageBusTest {\n+\n+\n+    private static int incrementsPerHandler = 10000;\n+    private static int numberOfMessages = 1000;\n+    private static int numberOfHandlers = 1000;\n+\n+    @Test\n+    public void testSynchronizedWithSynchronousInvocation(){\n+        List<SynchronizedMessageHandlerSync> handlers = new LinkedList<SynchronizedMessageHandlerSync>();\n+        IMessageBus bus = getBus(BusConfiguration.Default()\n+                .setNumberOfMessageDispatchers(6));\n+        for(int i = 0; i < numberOfHandlers; i++){\n+            SynchronizedMessageHandlerSync handler = new SynchronizedMessageHandlerSync();\n+            handlers.add(handler);\n+            bus.subscribe(handler);\n+        }\n+\n+        MessagePublication publication = null;\n+        for(int i = 0; i < numberOfMessages; i++){\n+           publication =  bus.post(new Object()).asynchronously();\n+        }\n+        while (!publication.isFinished()){\n+            pause(2000);\n+        }\n+\n+        for(SynchronizedMessageHandlerSync handler : handlers){\n+            assertEquals(incrementsPerHandler * numberOfMessages, handler.Counter);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSynchronizedWithAsSynchronousInvocation(){\n+        List<SynchronizedMessageHandlerAsyn> handlers = new LinkedList<SynchronizedMessageHandlerAsyn>();\n+        IMessageBus bus = getBus(BusConfiguration.Default()\n+                .setNumberOfMessageDispatchers(6));\n+        for(int i = 0; i < numberOfHandlers; i++){\n+            SynchronizedMessageHandlerAsyn handler = new SynchronizedMessageHandlerAsyn();\n+            handlers.add(handler);\n+            bus.subscribe(handler);\n+        }\n+\n+        for(int i = 0; i < numberOfMessages; i++){\n+            bus.post(new Object()).asynchronously();\n+        }\n+\n+        pause(10000);\n+\n+        for(SynchronizedMessageHandlerAsyn handler : handlers){\n+            assertEquals(incrementsPerHandler * numberOfMessages, handler.Counter);\n+        }\n+\n+    }\n+\n+    public static class SynchronizedMessageHandlerSync{\n+\n+        private int Counter = 0;\n+\n+        @Handler\n+        @Synchronized\n+        public void handleMessage(Object o){\n+           for(int i = 0; i < incrementsPerHandler; i++){\n+               Counter++;\n+           }\n+        }\n+\n+    }\n+\n+    public static class SynchronizedMessageHandlerAsyn{\n+\n+        private int Counter = 0;\n+\n+        @Handler(delivery = Invoke.Asynchronously)\n+        @Synchronized\n+        public void handleMessage(Object o){\n+            for(int i = 0; i < incrementsPerHandler; i++){\n+                Counter++;\n+            }\n+        }\n+\n+    }\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/WeakConcurrentSetTest.java",
            "additions": 64,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,64 @@\n+package net.engio.mbassy;\n+\n+import net.engio.mbassy.common.ConcurrentExecutor;\n+import net.engio.mbassy.common.IConcurrentSet;\n+import net.engio.mbassy.common.WeakConcurrentSet;\n+import org.junit.Test;\n+\n+import java.util.HashSet;\n+import java.util.Random;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 3/29/13\n+ */\n+public class WeakConcurrentSetTest extends ConcurrentSetTest{\n+\n+    @Override\n+    protected IConcurrentSet createSet() {\n+        return new WeakConcurrentSet();\n+    }\n+\n+    //@Ignore(\"Currently fails when building as a suite with JDK 1.7.0_15 and Maven 3.0.5 on a Mac\")\n+    @Test\n+    public void testIteratorCleanup() {\n+\n+        // Assemble\n+        final HashSet<Object> persistingCandidates = new HashSet<Object>();\n+        final IConcurrentSet testSetWeak = createSet();\n+        final Random rand = new Random();\n+\n+        for (int i = 0; i < numberOfElements; i++) {\n+            Object candidate = new Object();\n+\n+            if (rand.nextInt() % 3 == 0) {\n+                persistingCandidates.add(candidate);\n+            }\n+            testSetWeak.add(candidate);\n+        }\n+\n+        // Remove/Garbage collect all objects that have not\n+        // been inserted into the set of persisting candidates.\n+        runGC();\n+\n+        ConcurrentExecutor.runConcurrent(new Runnable() {\n+            @Override\n+            public void run() {\n+                for (Object testObject : testSetWeak) {\n+                    // do nothing\n+                    // just iterate to trigger automatic clean up\n+                    System.currentTimeMillis();\n+                }\n+            }\n+        }, numberOfThreads);\n+\n+        assertEquals(persistingCandidates.size(), testSetWeak.size());\n+        for (Object test : testSetWeak) {\n+            assertTrue(persistingCandidates.contains(test));\n+        }\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean.java",
            "additions": 14,
            "deletions": 2
        },
        "diff content": "@@ -1,8 +1,10 @@\n package net.engio.mbassy.listeners;\n \n+import net.engio.mbassy.dispatch.HandlerInvocation;\n import net.engio.mbassy.events.SubTestMessage;\n import net.engio.mbassy.events.TestMessage;\n import net.engio.mbassy.listener.*;\n+import net.engio.mbassy.subscription.SubscriptionContext;\n \n /**\n  * Basic bean that defines some event handlers to be used for different unit testting scenarios\n@@ -20,7 +22,7 @@ public class EventingTestBean {\n     }\n \n     // this handler will be invoked asynchronously\n-    @Handler(priority = 0, delivery = Mode.Concurrent)\n+    @Handler(priority = 0, delivery = Invoke.Asynchronously, invocation = HandleSubTestEventInvocation.class)\n     public void handleSubTestEvent(SubTestMessage message) {\n         message.counter.incrementAndGet();\n     }\n@@ -29,11 +31,21 @@ public class EventingTestBean {\n     // or any subtabe and that passes the given filter\n     @Handler(\n             priority = 10,\n-            delivery = Mode.Sequential,\n+            delivery = Invoke.Synchronously,\n             filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n     public void handleFiltered(SubTestMessage message) {\n         message.counter.incrementAndGet();\n     }\n \n+    public static class HandleSubTestEventInvocation extends HandlerInvocation<EventingTestBean, SubTestMessage> {\n \n+        public HandleSubTestEventInvocation(SubscriptionContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        public void invoke(EventingTestBean listener, SubTestMessage message) {\n+            listener.handleSubTestEvent(message);\n+        }\n+    }\n }\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java",
            "additions": 6,
            "deletions": 2
        },
        "diff content": "@@ -2,17 +2,21 @@ package net.engio.mbassy.listeners;\n \n import net.engio.mbassy.events.SubTestMessage;\n import net.engio.mbassy.listener.Handler;\n-import net.engio.mbassy.listener.Mode;\n+import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.References;\n \n /**\n  * @author bennidi\n  * Date: 11/22/12\n  */\n+@Listener(references = References.Strong)\n public class EventingTestBean2 extends EventingTestBean{\n \n     // redefine the configuration for this handler\n-    @Handler(delivery = Mode.Sequential)\n+    @Handler(delivery = Invoke.Synchronously)\n     public void handleSubTestEvent(SubTestMessage message) {\n         super.handleSubTestEvent(message);\n     }\n+\n }\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java",
            "additions": 5,
            "deletions": 2
        },
        "diff content": "@@ -2,17 +2,20 @@ package net.engio.mbassy.listeners;\n \n import net.engio.mbassy.events.SubTestMessage;\n import net.engio.mbassy.listener.Handler;\n-import net.engio.mbassy.listener.Mode;\n+import net.engio.mbassy.listener.Invoke;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.References;\n \n /**\n  * @author bennidi\n  * Date: 11/22/12\n  */\n+@Listener(references = References.Strong)\n public class EventingTestBean3 extends EventingTestBean2{\n \n \n     // this handler will be invoked asynchronously\n-    @Handler(priority = 0, delivery = Mode.Sequential)\n+    @Handler(priority = 0, delivery = Invoke.Synchronously)\n     public void handleSubTestEventAgain(SubTestMessage message) {\n         message.counter.incrementAndGet();\n     }\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java",
            "additions": 4,
            "deletions": 7
        },
        "diff content": "@@ -2,11 +2,8 @@ package net.engio.mbassy.listeners;\n \n import net.engio.mbassy.events.TestMessage;\n import net.engio.mbassy.events.TestMessage2;\n-import net.engio.mbassy.listener.Enveloped;\n-import net.engio.mbassy.listener.Filter;\n-import net.engio.mbassy.listener.Filters;\n-import net.engio.mbassy.listener.Handler;\n-import net.engio.mbassy.listener.Mode;\n+import net.engio.mbassy.listener.*;\n+import net.engio.mbassy.listener.Invoke;\n import net.engio.mbassy.subscription.MessageEnvelope;\n \n /**\n@@ -18,7 +15,7 @@ import net.engio.mbassy.subscription.MessageEnvelope;\n public class MultiEventHandler {\n \n \n-    @Handler(delivery = Mode.Sequential)\n+    @Handler(delivery = Invoke.Synchronously)\n     @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n     public void handleEvents(MessageEnvelope envelope) {\n         if(TestMessage.class.isAssignableFrom(envelope.getMessage().getClass())){\n@@ -31,7 +28,7 @@ public class MultiEventHandler {\n         }\n     }\n \n-    @Handler(delivery = Mode.Sequential, filters = @Filter(Filters.RejectSubtypes.class))\n+    @Handler(delivery = Invoke.Synchronously, filters = @Filter(Filters.RejectSubtypes.class))\n     @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n     public void handleSuperTypeEvents(MessageEnvelope envelope) {\n         if(TestMessage.class.isAssignableFrom(envelope.getMessage().getClass())){\n"
    },
    {
        "commit hash": "12a3e778e99564b1c7031516a26786a9a96362db",
        "previous commit hash": "f52fc0e681a58959eab8a10b0964716290e982b4",
        "diff stats": {
            "file_path": "testNTimes.sh",
            "additions": 12,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,12 @@\n+#!/bin/bash\n+for (( i = 1; i < $1 ; i++ ))\n+do\n+  echo \"Attempt $i\"\n+  mvn test -o -Dtest=$2\n+  exitcode=$?\n+  if [ $exitcode -ne 0 ]\n+  then\n+    echo \"Error at attempt $i\"\n+    exit\n+  fi\n+done\n"
    },
    {
        "commit hash": "8349aef7c8cd33f944c87c2bde961ea7663b0f10",
        "previous commit hash": "fb2bdd4c1a72de2222c8a31cbe8c0b6c71b53c24",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractMessageBus.java",
            "additions": 5,
            "deletions": 3
        },
        "diff content": "@@ -43,15 +43,17 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     // all subscriptions per message type\n     // this is the primary list for dispatching a specific message\n     // write access is synchronized and happens very infrequently\n-    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n+    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage\n+            = new HashMap<Class, Collection<Subscription>>(50);\n \n     // all subscriptions per messageHandler type\n     // this list provides fast access for subscribing and unsubscribing\n     // write access is synchronized and happens very infrequently\n-    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n+    private final Map<Class, Collection<Subscription>> subscriptionsPerListener\n+            = new HashMap<Class, Collection<Subscription>>(50);\n \n     // remember already processed classes that do not contain any listeners\n-    private final Collection<Class> nonListeners = new HashSet();\n+    private final Collection<Class> nonListeners = new HashSet<Class>();\n \n     // this handler will receive all errors that occur during message dispatch or message handling\n     private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n"
    },
    {
        "commit hash": "8349aef7c8cd33f944c87c2bde961ea7663b0f10",
        "previous commit hash": "fb2bdd4c1a72de2222c8a31cbe8c0b6c71b53c24",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MessagePublication.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -103,7 +103,7 @@ public class MessagePublication {\n     }\n \n     private enum State {\n-        Initial, Scheduled, Running, Finished, Error;\n+        Initial, Scheduled, Running, Finished, Error\n     }\n \n }\n"
    },
    {
        "commit hash": "8349aef7c8cd33f944c87c2bde961ea7663b0f10",
        "previous commit hash": "fb2bdd4c1a72de2222c8a31cbe8c0b6c71b53c24",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ConcurrentSet.java",
            "additions": 5,
            "deletions": 4
        },
        "diff content": "@@ -22,15 +22,16 @@ import java.util.WeakHashMap;\n  */\n public class ConcurrentSet<T> implements Iterable<T> {\n \n+    // Internal state\n+    private final Object lock = new Object();\n     private WeakHashMap<T, Entry<T>> entries = new WeakHashMap<T, Entry<T>>(); // maintain a map of entries for O(log n) lookup\n-\n     private Entry<T> head; // reference to the first element\n \n     public ConcurrentSet<T> add(T element) {\n         if (element == null || entries.containsKey(element)) {\n             return this;\n         }\n-        synchronized (this) {\n+        synchronized (lock) {\n             insert(element);\n         }\n         return this;\n@@ -58,7 +59,7 @@ public class ConcurrentSet<T> implements Iterable<T> {\n     }\n \n     public ConcurrentSet<T> addAll(Iterable<T> elements) {\n-        synchronized (this) {\n+        synchronized (lock) {\n             for (T element : elements) {\n                 if (element == null || entries.containsKey(element)) {\n                     return this;\n@@ -74,7 +75,7 @@ public class ConcurrentSet<T> implements Iterable<T> {\n         if (!entries.containsKey(element)) {\n             return false;\n         }\n-        synchronized (this) {\n+        synchronized (lock) {\n             Entry<T> listelement = entries.get(element);\n             if (listelement == null) {\n                 return false; //removed by other thread\n"
    },
    {
        "commit hash": "8349aef7c8cd33f944c87c2bde961ea7663b0f10",
        "previous commit hash": "fb2bdd4c1a72de2222c8a31cbe8c0b6c71b53c24",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ReflectionUtils.java",
            "additions": 0,
            "deletions": 3
        },
        "diff content": "@@ -91,9 +91,6 @@ public class ReflectionUtils {\n         Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n         Class[] subClassMethodParameters = superclassMethod.getParameterTypes();\n         // method must specify the same number of parameters\n-        if (subClassMethodParameters.length != subClassMethodParameters.length) {\n-            return false;\n-        }\n         //the parameters must occur in the exact same order\n         for (int i = 0; i < subClassMethodParameters.length; i++) {\n             if (!superClassMethodParameters[i].equals(subClassMethodParameters[i])) {\n"
    },
    {
        "commit hash": "8349aef7c8cd33f944c87c2bde961ea7663b0f10",
        "previous commit hash": "fb2bdd4c1a72de2222c8a31cbe8c0b6c71b53c24",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -26,8 +26,8 @@ public class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n         if (filter == null) {\n             return true;\n         } else {\n-            for (int i = 0; i < filter.length; i++) {\n-                if (!filter[i].accepts(message, getContext().getHandlerMetadata())) {\n+            for (IMessageFilter aFilter : filter) {\n+                if (!aFilter.accepts(message, getContext().getHandlerMetadata())) {\n                     return false;\n                 }\n             }\n"
    },
    {
        "commit hash": "8349aef7c8cd33f944c87c2bde961ea7663b0f10",
        "previous commit hash": "fb2bdd4c1a72de2222c8a31cbe8c0b6c71b53c24",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.listener;\n \n import java.lang.reflect.Method;\n+import java.util.Collections;\n import java.util.LinkedList;\n import java.util.List;\n \n@@ -33,8 +34,7 @@ public class MessageHandlerMetadata {\n         this.envelope = handler.getAnnotation(Enveloped.class);\n         this.acceptsSubtypes = !handlerConfig.rejectSubtypes();\n         if (this.envelope != null) {\n-            for (Class messageType : envelope.messages())\n-                handledMessages.add(messageType);\n+            Collections.addAll(handledMessages, envelope.messages());\n         } else {\n             handledMessages.add(handler.getParameterTypes()[0]);\n         }\n"
    },
    {
        "commit hash": "8349aef7c8cd33f944c87c2bde961ea7663b0f10",
        "previous commit hash": "fb2bdd4c1a72de2222c8a31cbe8c0b6c71b53c24",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -15,7 +15,7 @@ import java.util.List;\n public class MessageListenerMetadata<T> {\n \n \n-    public static final IPredicate<MessageHandlerMetadata> ForMessage(final Class<?> messageType) {\n+    public static IPredicate<MessageHandlerMetadata> ForMessage(final Class<?> messageType) {\n         return new IPredicate<MessageHandlerMetadata>() {\n             @Override\n             public boolean apply(MessageHandlerMetadata target) {\n"
    },
    {
        "commit hash": "8349aef7c8cd33f944c87c2bde961ea7663b0f10",
        "previous commit hash": "fb2bdd4c1a72de2222c8a31cbe8c0b6c71b53c24",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/MessageEnvelope.java",
            "additions": 0,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,5 @@\n package net.engio.mbassy.subscription;\n \n-import java.sql.Timestamp;\n-\n /**\n  * A message envelope is used to wrap messages of arbitrary type such that a handler\n  * my receive messages of different types.\n"
    },
    {
        "commit hash": "8349aef7c8cd33f944c87c2bde961ea7663b0f10",
        "previous commit hash": "fb2bdd4c1a72de2222c8a31cbe8c0b6c71b53c24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConcurrentSetTest.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -32,9 +32,11 @@ public class ConcurrentSetTest extends UnitTest {\n     @Ignore(\"Currently fails when building as a suite with JDK 1.7.0_15 and Maven 3.0.5 on a Mac\")\n     @Test\n     public void testIteratorCleanup() {\n+\n+        // Assemble\n         final HashSet<Object> persistingCandidates = new HashSet<Object>();\n         final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n-        Random rand = new Random();\n+        final Random rand = new Random();\n \n         for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n@@ -100,8 +102,6 @@ public class ConcurrentSetTest extends UnitTest {\n         for (Object uniqueObject : distinct) {\n             assertTrue(testSet.contains(uniqueObject));\n         }\n-\n-\n     }\n \n     @Test\n"
    },
    {
        "commit hash": "8349aef7c8cd33f944c87c2bde961ea7663b0f10",
        "previous commit hash": "fb2bdd4c1a72de2222c8a31cbe8c0b6c71b53c24",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/bus/ListenerSubscriptionTest.java",
            "additions": 7,
            "deletions": 5
        },
        "diff content": "@@ -1,14 +1,16 @@\n package net.engio.mbassy.bus;\n \n-import net.engio.mbassy.bus.BusConfiguration;\n-import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.common.MessageBusTest;\n-import net.engio.mbassy.events.SubTestMessage;\n-import org.junit.Test;\n import net.engio.mbassy.common.TestUtil;\n+import net.engio.mbassy.events.SubTestMessage;\n import net.engio.mbassy.events.TestMessage;\n-import net.engio.mbassy.listeners.*;\n+import net.engio.mbassy.listeners.EventingTestBean;\n+import net.engio.mbassy.listeners.EventingTestBean2;\n+import net.engio.mbassy.listeners.EventingTestBean3;\n+import net.engio.mbassy.listeners.ListenerFactory;\n+import net.engio.mbassy.listeners.NonListeningBean;\n import net.engio.mbassy.subscription.Subscription;\n+import org.junit.Test;\n \n import java.util.Collection;\n import java.util.LinkedList;\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": ".gitignore",
            "additions": 4,
            "deletions": 0
        },
        "diff content": "@@ -1,5 +1,9 @@\n # idea project settings #\n *.iml\n+*.ipr\n+*.iws\n+.idea/*\n+.idea\n \n # Package Files #\n *.war\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 36,
            "deletions": 1
        },
        "diff content": "@@ -23,7 +23,6 @@\n         weak-references,\n         message filtering,\n         ordering of message handlers etc.\n-\n     </description>\n \n     <url>https://github.com/bennidi/mbassador</url>\n@@ -50,6 +49,10 @@\n     </developers>\n \n     <properties>\n+        <nazgul-codestyle.version>2.0.1</nazgul-codestyle.version>\n+        <jdk.version>1.6</jdk.version>\n+        <pmd.plugin.version>3.0.1</pmd.plugin.version>\n+\n         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n         <project.build.java.version>1.6</project.build.java.version>\n         <github.url>file://${project.basedir}/mvn-local-repo</github.url>\n@@ -77,6 +80,38 @@\n \n     <build>\n         <plugins>\n+            <!-- plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-pmd-plugin</artifactId>\n+                <version>${pmd.plugin.version}</version>\n+                <configuration>\n+                    <excludeRoots>\n+                        <excludeRoot>src/main/generated</excludeRoot>\n+                        <excludeRoot>src/test</excludeRoot>\n+                    </excludeRoots>\n+                    <rulesets>\n+                        <ruleset>/codestyle/pmd-rules.xml</ruleset>\n+                    </rulesets>\n+                    <targetJdk>${jdk.version}</targetJdk>\n+                    <sourceEncoding>${project.build.sourceEncoding}</sourceEncoding>\n+                </configuration>\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>check</goal>\n+                            <goal>cpd-check</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+                <dependencies>\n+                    <dependency>\n+                        <groupId>se.jguru.nazgul.tools.codestyle</groupId>\n+                        <artifactId>nazgul-codestyle</artifactId>\n+                        <version>${nazgul-codestyle.version}</version>\n+                    </dependency>\n+                </dependencies>\n+            </plugin -->\n+\n             <plugin>\n                 <groupId>org.apache.felix</groupId>\n                 <artifactId>maven-bundle-plugin</artifactId>\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/IPublicationErrorHandler.java",
            "additions": 25,
            "deletions": 13
        },
        "diff content": "@@ -1,32 +1,44 @@\n package net.engio.mbassy;\n \n /**\n- * Publication error handlers are provided with a publication error every time an error occurs during message publication.\n- * A handler might fail with an exception, not be accessible because of the presence of a security manager\n- * or other reasons might lead to failures during the message publication process.\n- *\n+ * Publication error handlers are provided with a publication error every time an\n+ * error occurs during message publication.\n+ * A handler might fail with an exception, not be accessible because of the presence\n+ * of a security manager or other reasons might lead to failures during the message publication process.\n  * <p/>\n+ *\n  * @author bennidi\n- * Date: 2/22/12\n+ *         Date: 2/22/12\n  */\n+@SuppressWarnings(\"PMD.UnusedModifier\")\n public interface IPublicationErrorHandler {\n \n     /**\n      * Handle the given publication error.\n      *\n-     * @param error\n+     * @param error The PublicationError to handle.\n      */\n-\tpublic void handleError(PublicationError error);\n+    void handleError(PublicationError error);\n \n-    // This is the default error handler it will simply log to standard out and\n-    // print stack trace if available\n+    /**\n+     * The default error handler will simply log to standard out and\n+     * print the stack trace if available.\n+     */\n     static final class ConsoleLogger implements IPublicationErrorHandler {\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n         @Override\n-        public void handleError(PublicationError error) {\n+        public void handleError(final PublicationError error) {\n+\n+            // Printout the error itself\n             System.out.println(error);\n-            if (error.getCause() != null) error.getCause().printStackTrace();\n+\n+            // Printout the stacktrace from the cause.\n+            if (error.getCause() != null) {\n+                error.getCause().printStackTrace();\n+            }\n         }\n     }\n-\n-    ;\n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/PublicationError.java",
            "additions": 87,
            "deletions": 60
        },
        "diff content": "@@ -3,83 +3,110 @@ package net.engio.mbassy;\n import java.lang.reflect.Method;\n \n /**\n- * Publication errors are created when object publication fails for some reason and contain details\n- * as to the cause and location where they occured.\n+ * Publication errors are created when object publication fails\n+ * for some reason and contain details as to the cause and location\n+ * where they occurred.\n  * <p/>\n+ *\n  * @author bennidi\n- * Date: 2/22/12\n- * Time: 4:59 PM\n+ *         Date: 2/22/12\n+ *         Time: 4:59 PM\n  */\n public class PublicationError {\n \n-\tprivate Throwable cause;\n-\n-\tprivate String message;\n-\n-\tprivate Method listener;\n-\n-\tprivate Object listeningObject;\n-\n-\tprivate Object publishedObject;\n-\n-\n-\tpublic PublicationError(Throwable cause, String message, Method listener, Object listeningObject, Object publishedObject) {\n-\t\tthis.cause = cause;\n-\t\tthis.message = message;\n-\t\tthis.listener = listener;\n-\t\tthis.listeningObject = listeningObject;\n-\t\tthis.publishedObject = publishedObject;\n-\t}\n+    // Internal state\n+    private Throwable cause;\n+    private String message;\n+    private Method listener;\n+    private Object listeningObject;\n+    private Object publishedObject;\n+\n+    /**\n+     * Compound constructor, creating a PublicationError from the supplied objects.\n+     *\n+     * @param cause           The Throwable giving rise to this PublicationError.\n+     * @param message         The message to send.\n+     * @param listener        The method where the error was created.\n+     * @param listeningObject The object in which the PublicationError was generated.\n+     * @param publishedObject The published object which gave rise to the error.\n+     */\n+    public PublicationError(final Throwable cause,\n+                            final String message,\n+                            final Method listener,\n+                            final Object listeningObject,\n+                            final Object publishedObject) {\n+\n+        this.cause = cause;\n+        this.message = message;\n+        this.listener = listener;\n+        this.listeningObject = listeningObject;\n+        this.publishedObject = publishedObject;\n+    }\n \n-\tpublic PublicationError(){\n-\t\tsuper();\n-\t}\n+    /**\n+     * Default constructor.\n+     */\n+    public PublicationError() {\n+        super();\n+    }\n \n-\tpublic Throwable getCause() {\n-\t\treturn cause;\n-\t}\n+    /**\n+     * @return The Throwable giving rise to this PublicationError.\n+     */\n+    public Throwable getCause() {\n+        return cause;\n+    }\n \n-\tpublic PublicationError setCause(Throwable cause) {\n-\t\tthis.cause = cause;\n-\t\treturn this;\n-\t}\n+    /**\n+     * Assigns the cause of this PublicationError.\n+     *\n+     * @param cause A Throwable which gave rise to this PublicationError.\n+     * @return This PublicationError.\n+     */\n+    public PublicationError setCause(Throwable cause) {\n+        this.cause = cause;\n+        return this;\n+    }\n \n-\tpublic String getMessage() {\n-\t\treturn message;\n-\t}\n+    public String getMessage() {\n+        return message;\n+    }\n \n-\tpublic PublicationError setMessage(String message) {\n-\t\tthis.message = message;\n-\t\treturn this;\n-\t}\n+    public PublicationError setMessage(String message) {\n+        this.message = message;\n+        return this;\n+    }\n \n-\tpublic Method getListener() {\n-\t\treturn listener;\n-\t}\n+    public Method getListener() {\n+        return listener;\n+    }\n \n-\tpublic PublicationError setListener(Method listener) {\n-\t\tthis.listener = listener;\n-\t\treturn this;\n-\t}\n+    public PublicationError setListener(Method listener) {\n+        this.listener = listener;\n+        return this;\n+    }\n \n-\tpublic Object getListeningObject() {\n-\t\treturn listeningObject;\n-\t}\n+    public Object getListeningObject() {\n+        return listeningObject;\n+    }\n \n-\tpublic PublicationError setListeningObject(Object listeningObject) {\n-\t\tthis.listeningObject = listeningObject;\n-\t\treturn this;\n-\t}\n+    public PublicationError setListeningObject(Object listeningObject) {\n+        this.listeningObject = listeningObject;\n+        return this;\n+    }\n \n-\tpublic Object getPublishedObject() {\n-\t\treturn publishedObject;\n-\t}\n+    public Object getPublishedObject() {\n+        return publishedObject;\n+    }\n \n-\tpublic PublicationError setPublishedObject(Object publishedObject) {\n-\t\tthis.publishedObject = publishedObject;\n-\t\treturn this;\n-\t}\n+    public PublicationError setPublishedObject(Object publishedObject) {\n+        this.publishedObject = publishedObject;\n+        return this;\n+    }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     @Override\n     public String toString() {\n         return \"PublicationError{\" +\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractMessageBus.java",
            "additions": 39,
            "deletions": 21
        },
        "diff content": "@@ -3,14 +3,28 @@ package net.engio.mbassy.bus;\n import net.engio.mbassy.IPublicationErrorHandler;\n import net.engio.mbassy.PublicationError;\n import net.engio.mbassy.common.ReflectionUtils;\n-import net.engio.mbassy.subscription.SubscriptionContext;\n import net.engio.mbassy.listener.MessageHandlerMetadata;\n import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.subscription.Subscription;\n+import net.engio.mbassy.subscription.SubscriptionContext;\n import net.engio.mbassy.subscription.SubscriptionFactory;\n \n-import java.util.*;\n-import java.util.concurrent.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  * The base class for all message bus implementations.\n@@ -60,7 +74,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         subscriptionFactory = configuration.getSubscriptionFactory();\n         this.metadataReader = configuration.getMetadataReader();\n         this.publicationFactory = configuration.getMessagePublicationFactory();\n-        pendingMessages  = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n+        pendingMessages = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n         initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n         addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n     }\n@@ -89,7 +103,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         }\n     }\n \n-    protected MessagePublication.Factory getPublicationFactory(){\n+    protected MessagePublication.Factory getPublicationFactory() {\n         return publicationFactory;\n     }\n \n@@ -99,9 +113,13 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     }\n \n     public boolean unsubscribe(Object listener) {\n-        if (listener == null) return false;\n+        if (listener == null) {\n+            return false;\n+        }\n         Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n-        if (subscriptions == null) return false;\n+        if (subscriptions == null) {\n+            return false;\n+        }\n         boolean isRemoved = true;\n         for (Subscription subscription : subscriptions) {\n             isRemoved = isRemoved && subscription.unsubscribe(listener);\n@@ -113,8 +131,9 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     public void subscribe(Object listener) {\n         try {\n             Class listeningClass = listener.getClass();\n-            if (nonListeners.contains(listeningClass))\n+            if (nonListeners.contains(listeningClass)) {\n                 return; // early reject of known classes that do not participate in eventing\n+            }\n             Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n             if (subscriptionsByListener == null) { // if the type is registered for the first time\n                 synchronized (this) { // new subscriptions must be processed sequentially\n@@ -135,7 +154,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n                             subscriptionsByListener.add(subscription);// add it for the listener type (for future subscriptions)\n \n                             List<Class<?>> messageTypes = messageHandler.getHandledMessages();\n-                            for(Class<?> messageType : messageTypes){\n+                            for (Class<?> messageType : messageTypes) {\n                                 addMessageTypeSubscription(messageType, subscription);\n                             }\n                             //updateMessageTypeHierarchy(eventType);\n@@ -145,7 +164,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n                 }\n             }\n             // register the listener to the existing subscriptions\n-            for (Subscription sub : subscriptionsByListener){\n+            for (Subscription sub : subscriptionsByListener) {\n                 sub.subscribe(listener);\n             }\n         } catch (Exception e) {\n@@ -154,12 +173,12 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     }\n \n \n-    public void addErrorHandler(IPublicationErrorHandler handler) {\n+    public final void addErrorHandler(IPublicationErrorHandler handler) {\n         errorHandlers.add(handler);\n     }\n \n     // this method enqueues a message delivery request\n-    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request){\n+    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request) {\n         try {\n             pendingMessages.put(request);\n             return request.markScheduled();\n@@ -169,7 +188,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     }\n \n     // this method enqueues a message delivery request\n-    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit){\n+    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit) {\n         try {\n             return pendingMessages.offer(request, timeout, unit)\n                     ? request.markScheduled()\n@@ -191,8 +210,10 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n             Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n             if (subs != null) {\n-                for(Subscription sub : subs){\n-                    if(sub.handlesMessageType(messageType))subscriptions.add(sub);\n+                for (Subscription sub : subs) {\n+                    if (sub.handlesMessageType(messageType)) {\n+                        subscriptions.add(sub);\n+                    }\n                 }\n             }\n         }\n@@ -200,7 +221,6 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     }\n \n \n-\n     // associate a suscription with a message type\n     // NOTE: Not thread-safe! must be synchronized in outer scope\n     private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n@@ -213,10 +233,8 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     }\n \n \n-\n-\n     public void handlePublicationError(PublicationError error) {\n-        for (IPublicationErrorHandler errorHandler : errorHandlers){\n+        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n             errorHandler.handleError(error);\n         }\n     }\n@@ -227,14 +245,14 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         super.finalize();\n     }\n \n-    private void shutdown(){\n+    private void shutdown() {\n         for (Thread dispatcher : dispatchers) {\n             dispatcher.interrupt();\n         }\n         executor.shutdown();\n     }\n \n-    public boolean hasPendingMessages(){\n+    public boolean hasPendingMessages() {\n         return pendingMessages.size() > 0;\n     }\n \n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/BusConfiguration.java",
            "additions": 7,
            "deletions": 2
        },
        "diff content": "@@ -3,7 +3,12 @@ package net.engio.mbassy.bus;\n import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.subscription.SubscriptionFactory;\n \n-import java.util.concurrent.*;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n@@ -22,7 +27,7 @@ public class BusConfiguration {\n         }\n     };\n \n-    public static final BusConfiguration Default(){\n+    public static BusConfiguration Default() {\n         return new BusConfiguration();\n     }\n \n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/IMessageBus.java",
            "additions": 17,
            "deletions": 26
        },
        "diff content": "@@ -7,7 +7,6 @@ import java.util.concurrent.Executor;\n import java.util.concurrent.TimeUnit;\n \n /**\n- *\n  * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n  * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n  * The dispatch mechanism can by controlled for per message handler and message publication.\n@@ -41,7 +40,7 @@ import java.util.concurrent.TimeUnit;\n  * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n  * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n  * after the remove operation completed.\n- *\n+ * <p/>\n  * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n  * get dispatched to all message handlers that take an instance of List as their parameter\n  *\n@@ -57,29 +56,27 @@ public interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n      *\n      * @param listener\n      */\n-    public void subscribe(Object listener);\n-\n+    void subscribe(Object listener);\n \n     /**\n      * Immediately remove all registered message handlers (if any) of the given listener. When this call returns all handlers\n      * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n      * publications that have been published when the message listener was still subscribed).\n-     *\n+     * <p/>\n      * A call to this method passing null, an already unsubscribed listener or any object that does not define any message\n      * handlers will not have any effect and is silently ignored.\n      *\n      * @param listener\n-     * @return  true, if the listener was found and successfully removed\n-     *          false otherwise\n+     * @return true, if the listener was found and successfully removed\n+     *         false otherwise\n      */\n-    public boolean unsubscribe(Object listener);\n+    boolean unsubscribe(Object listener);\n \n     /**\n-     *\n      * @param message\n      * @return\n      */\n-    public P post(T message);\n+    P post(T message);\n \n     /**\n      * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n@@ -89,15 +86,14 @@ public interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n      *\n      * @param errorHandler\n      */\n-    public void addErrorHandler(IPublicationErrorHandler errorHandler);\n+    void addErrorHandler(IPublicationErrorHandler errorHandler);\n \n     /**\n      * Returns an immutable collection containing all the registered error handlers\n      *\n      * @return\n      */\n-    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n-\n+    Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n \n     /**\n      * Get the executor service that is used to asynchronous message publication.\n@@ -105,54 +101,49 @@ public interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n      *\n      * @return\n      */\n-    public Executor getExecutor();\n+    Executor getExecutor();\n \n     /**\n      * Check whether any asynchronous message publications are pending for being processed\n      *\n      * @return\n      */\n-    public boolean hasPendingMessages();\n-\n+    boolean hasPendingMessages();\n \n     /**\n      * A post command is used as an intermediate object created by a call to the message bus' post method.\n      * It encapsulates the functionality provided by the message bus that created the command.\n      * Subclasses may extend this interface and add functionality, e.g. different dispatch schemes.\n-     *\n      */\n-    public static interface IPostCommand<T>{\n+    interface IPostCommand<T> {\n \n         /**\n          * Execute the message publication immediately. This call blocks until every matching message handler\n          * has been invoked.\n          */\n-        public void now();\n+        void now();\n \n         /**\n          * Execute the message publication asynchronously. The behaviour of this method depends on the\n          * configured queuing strategy:\n-         *\n+         * <p/>\n          * If an unbound queuing strategy is used the call returns immediately.\n          * If a bounded queue is used the call might block until the message can be placed in the queue.\n          *\n          * @return A message publication that can be used to access information about the state of\n          */\n-        public MessagePublication asynchronously();\n-\n+        MessagePublication asynchronously();\n \n         /**\n          * Execute the message publication asynchronously. The behaviour of this method depends on the\n          * configured queuing strategy:\n-         *\n+         * <p/>\n          * If an unbound queuing strategy is used the call returns immediately.\n          * If a bounded queue is used the call will block until the message can be placed in the queue\n          * or the timeout is reached.\n          *\n          * @return A message publication that wraps up the publication request\n          */\n-        public MessagePublication asynchronously(long timeout, TimeUnit unit);\n-\n+        MessagePublication asynchronously(long timeout, TimeUnit unit);\n     }\n-\n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MBassador.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -29,12 +29,12 @@ public class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>>\n             // Dead Event\n             subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n             return getPublicationFactory().createPublication(this, subscriptions, new DeadMessage(message));\n+        } else {\n+            return getPublicationFactory().createPublication(this, subscriptions, message);\n         }\n-        else return getPublicationFactory().createPublication(this, subscriptions, message);\n     }\n \n \n-\n     /**\n      * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n      * The call blocks until every messageHandler has processed the message.\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MessagePublication.java",
            "additions": 18,
            "deletions": 17
        },
        "diff content": "@@ -10,18 +10,18 @@ import java.util.Collection;\n  * A message publication is created for each asynchronous message dispatch. It reflects the state\n  * of the corresponding message publication process, i.e. provides information whether the\n  * publication was successfully scheduled, is currently running etc.\n- *\n+ * <p/>\n  * A message publication lives within a single thread. It is not designed in a thread-safe manner -> not eligible to\n  * be used in multiple threads simultaneously .\n  *\n  * @author bennidi\n- * Date: 11/16/12\n+ *         Date: 11/16/12\n  */\n public class MessagePublication {\n \n-    public static class Factory{\n+    public static class Factory {\n \n-        public MessagePublication createPublication(IMessageBus owningBus, Collection<Subscription> subscriptions, Object message){\n+        public MessagePublication createPublication(IMessageBus owningBus, Collection<Subscription> subscriptions, Object message) {\n             return new MessagePublication(owningBus, subscriptions, message, State.Initial);\n         }\n \n@@ -48,17 +48,17 @@ public class MessagePublication {\n         return subscriptions.add(subscription);\n     }\n \n-    protected void execute(){\n+    protected void execute() {\n         state = State.Running;\n-        for(Subscription sub : subscriptions){\n+        for (Subscription sub : subscriptions) {\n             sub.publish(this, message);\n         }\n         state = State.Finished;\n         // if the message has not been marked delivered by the dispatcher\n-        if(!delivered){\n-            if(!isFilteredEvent() && !isDeadEvent()){\n+        if (!delivered) {\n+            if (!isFilteredEvent() && !isDeadEvent()) {\n                 bus.post(new FilteredMessage(message)).now();\n-            }else if(!isDeadEvent()){\n+            } else if (!isDeadEvent()) {\n                 bus.post(new DeadMessage(message)).now();\n             }\n \n@@ -77,32 +77,33 @@ public class MessagePublication {\n         return state.equals(State.Scheduled);\n     }\n \n-    public void markDelivered(){\n+    public void markDelivered() {\n         delivered = true;\n     }\n \n-    public MessagePublication markScheduled(){\n-        if(!state.equals(State.Initial))\n+    public MessagePublication markScheduled() {\n+        if (!state.equals(State.Initial)) {\n             return this;\n+        }\n         state = State.Scheduled;\n         return this;\n     }\n \n-    public MessagePublication setError(){\n+    public MessagePublication setError() {\n         state = State.Error;\n         return this;\n     }\n \n-    public boolean isDeadEvent(){\n+    public boolean isDeadEvent() {\n         return DeadMessage.class.isAssignableFrom(message.getClass());\n     }\n \n-    public boolean isFilteredEvent(){\n+    public boolean isFilteredEvent() {\n         return FilteredMessage.class.isAssignableFrom(message.getClass());\n     }\n \n-    private enum State{\n-        Initial,Scheduled,Running,Finished,Error;\n+    private enum State {\n+        Initial, Scheduled, Running, Finished, Error;\n     }\n \n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ConcurrentSet.java",
            "additions": 30,
            "deletions": 12
        },
        "diff content": "@@ -20,27 +20,31 @@ import java.util.WeakHashMap;\n  * @author bennidi\n  *         Date: 2/12/12\n  */\n-public class ConcurrentSet<T> implements Iterable<T>{\n+public class ConcurrentSet<T> implements Iterable<T> {\n \n     private WeakHashMap<T, Entry<T>> entries = new WeakHashMap<T, Entry<T>>(); // maintain a map of entries for O(log n) lookup\n \n     private Entry<T> head; // reference to the first element\n \n     public ConcurrentSet<T> add(T element) {\n-        if (element == null || entries.containsKey(element)) return this;\n+        if (element == null || entries.containsKey(element)) {\n+            return this;\n+        }\n         synchronized (this) {\n             insert(element);\n         }\n         return this;\n     }\n \n-    public boolean contains(T element){\n+    public boolean contains(T element) {\n         Entry<T> entry = entries.get(element);\n         return entry != null && entry.getValue() != null;\n     }\n \n     private void insert(T element) {\n-        if (entries.containsKey(element)) return;\n+        if (entries.containsKey(element)) {\n+            return;\n+        }\n         if (head == null) {\n             head = new Entry<T>(element);\n         } else {\n@@ -49,14 +53,16 @@ public class ConcurrentSet<T> implements Iterable<T>{\n         entries.put(element, head);\n     }\n \n-    public int size(){\n+    public int size() {\n         return entries.size();\n     }\n \n     public ConcurrentSet<T> addAll(Iterable<T> elements) {\n         synchronized (this) {\n             for (T element : elements) {\n-                if (element == null || entries.containsKey(element)) return this;\n+                if (element == null || entries.containsKey(element)) {\n+                    return this;\n+                }\n \n                 insert(element);\n             }\n@@ -65,10 +71,14 @@ public class ConcurrentSet<T> implements Iterable<T>{\n     }\n \n     public boolean remove(T element) {\n-        if (!entries.containsKey(element)) return false;\n+        if (!entries.containsKey(element)) {\n+            return false;\n+        }\n         synchronized (this) {\n             Entry<T> listelement = entries.get(element);\n-            if(listelement == null)return false; //removed by other thread\n+            if (listelement == null) {\n+                return false; //removed by other thread\n+            }\n             if (listelement != head) {\n                 listelement.remove();\n             } else {\n@@ -87,7 +97,9 @@ public class ConcurrentSet<T> implements Iterable<T>{\n             private Entry<T> current = head;\n \n             public boolean hasNext() {\n-                if (current == null) return false;\n+                if (current == null) {\n+                    return false;\n+                }\n                 T value = current.getValue();\n                 if (value == null) {    // auto-removal of orphan references\n                     remove();\n@@ -98,7 +110,9 @@ public class ConcurrentSet<T> implements Iterable<T>{\n             }\n \n             public T next() {\n-                if (current == null) return null;\n+                if (current == null) {\n+                    return null;\n+                }\n                 T value = current.getValue();\n                 if (value == null) {    // auto-removal of orphan references\n                     remove();\n@@ -110,7 +124,9 @@ public class ConcurrentSet<T> implements Iterable<T>{\n             }\n \n             public void remove() {\n-                if (current == null) return;\n+                if (current == null) {\n+                    return;\n+                }\n                 Entry<T> newCurrent = current.next();\n                 ConcurrentSet.this.remove(current.getValue());\n                 current = newCurrent;\n@@ -146,7 +162,9 @@ public class ConcurrentSet<T> implements Iterable<T>{\n         public void remove() {\n             if (predecessor != null) {\n                 predecessor.next = next;\n-                if(next != null)next.predecessor = predecessor;\n+                if (next != null) {\n+                    next.predecessor = predecessor;\n+                }\n             } else if (next != null) {\n                 next.predecessor = null;\n             }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/IPredicate.java",
            "additions": 5,
            "deletions": 5
        },
        "diff content": "@@ -2,13 +2,13 @@ package net.engio.mbassy.common;\n \n /**\n  * Created with IntelliJ IDEA.\n+ *\n  * @author bennidi\n- * Date: 10/22/12\n- * Time: 9:33 AM\n- * To change this template use File | Settings | File Templates.\n+ *         Date: 10/22/12\n+ *         Time: 9:33 AM\n+ *         To change this template use File | Settings | File Templates.\n  */\n public interface IPredicate<T> {\n \n-    public boolean apply(T target);\n-\n+    boolean apply(T target);\n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ReflectionUtils.java",
            "additions": 16,
            "deletions": 13
        },
        "diff content": "@@ -38,12 +38,11 @@ public class ReflectionUtils {\n      * @param subclass\n      * @return\n      */\n-    public static Method getOverridingMethod(Method overridingMethod, Class subclass) {\n+    public static Method getOverridingMethod(final Method overridingMethod, final Class subclass) {\n         Class current = subclass;\n-        while(!current.equals(overridingMethod.getDeclaringClass())){\n+        while (!current.equals(overridingMethod.getDeclaringClass())) {\n             try {\n-                Method overridden = current.getDeclaredMethod(overridingMethod.getName(), overridingMethod.getParameterTypes());\n-                return overridden;\n+                return current.getDeclaredMethod(overridingMethod.getName(), overridingMethod.getParameterTypes());\n             } catch (NoSuchMethodException e) {\n                 current = current.getSuperclass();\n             }\n@@ -51,10 +50,12 @@ public class ReflectionUtils {\n         return null;\n     }\n \n-    public static List<Method> withoutOverridenSuperclassMethods(List<Method> allMethods) {\n+    public static List<Method> withoutOverridenSuperclassMethods(final List<Method> allMethods) {\n         List<Method> filtered = new LinkedList<Method>();\n         for (Method method : allMethods) {\n-            if (!containsOverridingMethod(allMethods, method)) filtered.add(method);\n+            if (!containsOverridingMethod(allMethods, method)) {\n+                filtered.add(method);\n+            }\n         }\n         return filtered;\n     }\n@@ -68,9 +69,11 @@ public class ReflectionUtils {\n         return superclasses;\n     }\n \n-    public static boolean containsOverridingMethod(List<Method> allMethods, Method methodToCheck) {\n+    public static boolean containsOverridingMethod(final List<Method> allMethods, final Method methodToCheck) {\n         for (Method method : allMethods) {\n-            if (isOverriddenBy(methodToCheck, method)) return true;\n+            if (isOverriddenBy(methodToCheck, method)) {\n+                return true;\n+            }\n         }\n         return false;\n     }\n@@ -88,14 +91,14 @@ public class ReflectionUtils {\n         Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n         Class[] subClassMethodParameters = superclassMethod.getParameterTypes();\n         // method must specify the same number of parameters\n-        if(subClassMethodParameters.length != subClassMethodParameters.length){\n+        if (subClassMethodParameters.length != subClassMethodParameters.length) {\n             return false;\n         }\n         //the parameters must occur in the exact same order\n-        for(int i = 0 ; i< subClassMethodParameters.length; i++){\n-           if(!superClassMethodParameters[i].equals(subClassMethodParameters[i])){\n-               return false;\n-           }\n+        for (int i = 0; i < subClassMethodParameters.length; i++) {\n+            if (!superClassMethodParameters[i].equals(subClassMethodParameters[i])) {\n+                return false;\n+            }\n         }\n         return true;\n     }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java",
            "additions": 3,
            "deletions": 0
        },
        "diff content": "@@ -17,6 +17,9 @@ public class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAw\n         this.delegate = delegate;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     @Override\n     public void invoke(final Object listener, final Object message) {\n         getContext().getOwningBus().getExecutor().execute(new Runnable() {\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/DelegatingMessageDispatcher.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@ import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n  * @author bennidi\n  *         Date: 3/1/13\n  */\n-public abstract class DelegatingMessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher{\n+public abstract class DelegatingMessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher {\n \n     private IMessageDispatcher delegate;\n \n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -7,13 +7,13 @@ import net.engio.mbassy.subscription.MessageEnvelope;\n /**\n  * The enveloped dispatcher will wrap published messages in an envelope before\n  * passing them to their configured dispatcher.\n- *\n+ * <p/>\n  * All enveloped message handlers will have this dispatcher in their chain\n  *\n  * @author bennidi\n  *         Date: 12/12/12\n  */\n-public class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher{\n+public class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher {\n \n \n     public EnvelopedMessageDispatcher(IMessageDispatcher dispatcher) {\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java",
            "additions": 7,
            "deletions": 6
        },
        "diff content": "@@ -25,10 +25,11 @@ public class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n \n         if (filter == null) {\n             return true;\n-        }\n-        else {\n+        } else {\n             for (int i = 0; i < filter.length; i++) {\n-                if (!filter[i].accepts(message, getContext().getHandlerMetadata())) return false;\n+                if (!filter[i].accepts(message, getContext().getHandlerMetadata())) {\n+                    return false;\n+                }\n             }\n             return true;\n         }\n@@ -37,9 +38,9 @@ public class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n \n     @Override\n     public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n-         if(passesFilter(message)){\n-             getDelegate().dispatch(publication, message, listeners);\n-         }\n+        if (passesFilter(message)) {\n+            getDelegate().dispatch(publication, message, listeners);\n+        }\n     }\n \n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java",
            "additions": 1,
            "deletions": 3
        },
        "diff content": "@@ -17,7 +17,5 @@ public interface IHandlerInvocation extends ISubscriptionContextAware {\n      * @param listener The listener that will receive the message\n      * @param message  The message to be delivered to the listener\n      */\n-    public void invoke(final Object listener, final Object message);\n-\n-\n+    void invoke(Object listener, Object message);\n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IMessageBusAware.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -10,5 +10,5 @@ import net.engio.mbassy.bus.IMessageBus;\n  */\n public interface IMessageBusAware {\n \n-    public IMessageBus getBus();\n+    IMessageBus getBus();\n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java",
            "additions": 11,
            "deletions": 9
        },
        "diff content": "@@ -7,10 +7,10 @@ import net.engio.mbassy.common.ConcurrentSet;\n  * A message dispatcher provides the functionality to deliver a single message\n  * to a set of listeners. A message dispatcher uses a message context to access\n  * all information necessary for the message delivery.\n- *\n+ * <p/>\n  * The delivery of a single message to a single listener is responsibility of the\n  * handler invocation object associated with the dispatcher.\n- *\n+ * <p/>\n  * Implementations if IMessageDispatcher are partially designed using decorator pattern\n  * such that it is possible to compose different message dispatchers into dispatcher chains\n  * to achieve more complex dispatch logic.\n@@ -26,15 +26,17 @@ public interface IMessageDispatcher extends ISubscriptionContextAware {\n      * on the configuration of the dispatcher\n      *\n      * @param publication The message publication that initiated the dispatch\n-     * @param message The message that should be delivered to the listeners\n-     * @param listeners The listeners that should receive the message\n+     * @param message     The message that should be delivered to the listeners\n+     * @param listeners   The listeners that should receive the message\n      */\n-    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners);\n+    void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners);\n \n     /**\n-     * Get the handler invocation that will be used to deliver the message to each\n-     * listener\n-     * @return\n+     * Get the handler invocation that will be used to deliver the\n+     * message to each listener.\n+     *\n+     * @return the handler invocation that will be used to deliver the\n+     *         message to each listener\n      */\n-    public IHandlerInvocation getInvocation();\n+    IHandlerInvocation getInvocation();\n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/ISubscriptionContextAware.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -13,7 +13,7 @@ public interface ISubscriptionContextAware extends IMessageBusAware {\n     /**\n      * Get the subscription context associated with this object\n      *\n-     * @return\n+     * @return the subscription context associated with this object\n      */\n-    public SubscriptionContext getContext();\n+    SubscriptionContext getContext();\n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java",
            "additions": 2,
            "deletions": 3
        },
        "diff content": "@@ -7,7 +7,7 @@ import net.engio.mbassy.subscription.SubscriptionContext;\n \n /**\n  * Standard implementation for direct, unfiltered message delivery.\n- *\n+ * <p/>\n  * For each message delivery, this dispatcher iterates over the listeners\n  * and uses the previously provided handler invocation to deliver the message\n  * to each listener\n@@ -27,7 +27,7 @@ public class MessageDispatcher extends AbstractSubscriptionContextAware implemen\n     @Override\n     public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n         publication.markDelivered();\n-        for(Object listener: listeners){\n+        for (Object listener : listeners) {\n             getInvocation().invoke(listener, message);\n         }\n     }\n@@ -36,5 +36,4 @@ public class MessageDispatcher extends AbstractSubscriptionContextAware implemen\n     public IHandlerInvocation getInvocation() {\n         return invocation;\n     }\n-\n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java",
            "additions": 11,
            "deletions": 11
        },
        "diff content": "@@ -15,42 +15,39 @@ import java.util.Collection;\n  * @author bennidi\n  *         Date: 11/23/12\n  */\n-public class ReflectiveHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation{\n+public class ReflectiveHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n \n     public ReflectiveHandlerInvocation(SubscriptionContext context) {\n         super(context);\n     }\n \n-    protected void handlePublicationError(PublicationError error){\n+    protected void handlePublicationError(PublicationError error) {\n         Collection<IPublicationErrorHandler> handlers = getContext().getOwningBus().getRegisteredErrorHandlers();\n-        for(IPublicationErrorHandler handler : handlers){\n+        for (IPublicationErrorHandler handler : handlers) {\n             handler.handleError(error);\n         }\n     }\n \n-    protected void invokeHandler(final Object message, final Object listener, Method handler){\n+    protected void invokeHandler(final Object message, final Object listener, Method handler) {\n         try {\n             handler.invoke(listener, message);\n-        }catch(IllegalAccessException e){\n+        } catch (IllegalAccessException e) {\n             handlePublicationError(\n                     new PublicationError(e, \"Error during messageHandler notification. \" +\n                             \"The class or method is not accessible\",\n                             handler, listener, message));\n-        }\n-        catch(IllegalArgumentException e){\n+        } catch (IllegalArgumentException e) {\n             handlePublicationError(\n                     new PublicationError(e, \"Error during messageHandler notification. \" +\n                             \"Wrong arguments passed to method. Was: \" + message.getClass()\n                             + \"Expected: \" + handler.getParameterTypes()[0],\n                             handler, listener, message));\n-        }\n-        catch (InvocationTargetException e) {\n+        } catch (InvocationTargetException e) {\n             handlePublicationError(\n                     new PublicationError(e, \"Error during messageHandler notification. \" +\n                             \"Message handler threw exception\",\n                             handler, listener, message));\n-        }\n-        catch (Throwable e) {\n+        } catch (Throwable e) {\n             handlePublicationError(\n                     new PublicationError(e, \"Error during messageHandler notification. \" +\n                             \"Unexpected exception\",\n@@ -58,6 +55,9 @@ public class ReflectiveHandlerInvocation extends AbstractSubscriptionContextAwar\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     @Override\n     public void invoke(final Object listener, final Object message) {\n         invokeHandler(message, listener, getContext().getHandlerMetadata().getHandler());\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Enveloped.java",
            "additions": 7,
            "deletions": 3
        },
        "diff content": "@@ -1,13 +1,17 @@\n package net.engio.mbassy.listener;\n \n-import java.lang.annotation.*;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n \n /**\n  * Configure a handler to receive an enveloped message as a wrapper around the source\n  * message. An enveloped message can contain any type of message\n  *\n  * @author bennidi\n- * Date: 2/8/12\n+ *         Date: 2/8/12\n  */\n @Retention(value = RetentionPolicy.RUNTIME)\n @Inherited\n@@ -17,7 +21,7 @@ public @interface Enveloped {\n     /**\n      * The set of messages that should be dispatched to the message handler\n      */\n-\tClass[] messages();\n+    Class[] messages();\n \n \n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Filter.java",
            "additions": 6,
            "deletions": 4
        },
        "diff content": "@@ -10,10 +10,11 @@ import java.lang.annotation.Target;\n  * It references a class that implements the IMessageFilter interface.\n  * The filter will be used to check whether a message should be delivered\n  * to the listener or not.\n- *\n  * <p/>\n- * @author  bennidi\n- * Date: 2/14/12\n+ * <p/>\n+ *\n+ * @author bennidi\n+ *         Date: 2/14/12\n  */\n @Retention(value = RetentionPolicy.RUNTIME)\n @Target(value = {ElementType.ANNOTATION_TYPE})\n@@ -22,7 +23,8 @@ public @interface Filter {\n     /**\n      * The class that implements the filter.\n      * Note: A filter always needs to provide a non-arg constructor\n+     *\n      * @return\n      */\n-\tClass<? extends IMessageFilter> value();\n+    Class<? extends IMessageFilter> value();\n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Filters.java",
            "additions": 4,
            "deletions": 2
        },
        "diff content": "@@ -30,8 +30,10 @@ public class Filters {\n \n         @Override\n         public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n-            for(Class handledMessage : metadata.getHandledMessages()){\n-                if(handledMessage.equals(event.getClass()))return true;\n+            for (Class handledMessage : metadata.getHandledMessages()) {\n+                if (handledMessage.equals(event.getClass())) {\n+                    return true;\n+                }\n             }\n             return false;\n         }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Handler.java",
            "additions": 7,
            "deletions": 4
        },
        "diff content": "@@ -1,13 +1,17 @@\n package net.engio.mbassy.listener;\n \n-import java.lang.annotation.*;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n \n /**\n  * Mark any method of any object(=listener) as a message handler and configure the handler\n  * using different properties.\n  *\n  * @author bennidi\n- * Date: 2/8/12\n+ *         Date: 2/8/12\n  */\n @Retention(value = RetentionPolicy.RUNTIME)\n @Inherited\n@@ -18,12 +22,11 @@ public @interface Handler {\n      * Add any numbers of filters to the handler. All filters are evaluated before the handler\n      * is actually invoked, which is only if all the filters accept the message.\n      */\n-\tFilter[] filters() default {};\n+    Filter[] filters() default {};\n \n     /**\n      * Define the mode in which a message is delivered to each listener. Listeners can be notified\n      * sequentially or concurrently.\n-     *\n      */\n     Mode delivery() default Mode.Sequential;\n \n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/IMessageFilter.java",
            "additions": 3,
            "deletions": 5
        },
        "diff content": "@@ -3,21 +3,19 @@ package net.engio.mbassy.listener;\n /**\n  * Message filters can be used to prevent certain messages to be delivered to a specific listener.\n  * If a filter is used the message will only be delivered if it passes the filter(s)\n- *\n+ * <p/>\n  * NOTE: A message filter must provide either a no-arg constructor.\n  *\n  * @author bennidi\n- * Date: 2/8/12\n+ *         Date: 2/8/12\n  */\n public interface IMessageFilter {\n \n     /**\n      * Evaluate the message to ensure that it matches the handler configuration\n      *\n-     *\n      * @param message the message to be delivered\n      * @return\n      */\n-\tpublic boolean accepts(Object message, MessageHandlerMetadata metadata);\n-\n+    boolean accepts(Object message, MessageHandlerMetadata metadata);\n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java",
            "additions": 17,
            "deletions": 16
        },
        "diff content": "@@ -5,10 +5,8 @@ import java.util.LinkedList;\n import java.util.List;\n \n /**\n- *\n- *\n  * @author bennidi\n- * Date: 11/14/12\n+ *         Date: 11/14/12\n  */\n public class MessageHandlerMetadata {\n \n@@ -34,26 +32,25 @@ public class MessageHandlerMetadata {\n         this.isAsynchronous = handlerConfig.delivery().equals(Mode.Concurrent);\n         this.envelope = handler.getAnnotation(Enveloped.class);\n         this.acceptsSubtypes = !handlerConfig.rejectSubtypes();\n-        if(this.envelope != null){\n-            for(Class messageType : envelope.messages())\n+        if (this.envelope != null) {\n+            for (Class messageType : envelope.messages())\n                 handledMessages.add(messageType);\n-        }\n-        else{\n+        } else {\n             handledMessages.add(handler.getParameterTypes()[0]);\n         }\n         this.handler.setAccessible(true);\n     }\n \n \n-    public boolean isAsynchronous(){\n+    public boolean isAsynchronous() {\n         return isAsynchronous;\n     }\n \n-    public boolean isFiltered(){\n+    public boolean isFiltered() {\n         return filter != null && filter.length > 0;\n     }\n \n-    public int getPriority(){\n+    public int getPriority() {\n         return handlerConfig.priority();\n     }\n \n@@ -65,7 +62,7 @@ public class MessageHandlerMetadata {\n         return filter;\n     }\n \n-    public List<Class<?>> getHandledMessages(){\n+    public List<Class<?>> getHandledMessages() {\n         return handledMessages;\n     }\n \n@@ -73,15 +70,19 @@ public class MessageHandlerMetadata {\n         return envelope != null;\n     }\n \n-    public boolean handlesMessage(Class<?> messageType){\n-        for(Class<?> handledMessage : handledMessages){\n-            if(handledMessage.equals(messageType))return true;\n-            if(handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) return true;\n+    public boolean handlesMessage(Class<?> messageType) {\n+        for (Class<?> handledMessage : handledMessages) {\n+            if (handledMessage.equals(messageType)) {\n+                return true;\n+            }\n+            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\n+                return true;\n+            }\n         }\n         return false;\n     }\n \n-    public boolean acceptsSubtypes(){\n+    public boolean acceptsSubtypes() {\n         return acceptsSubtypes;\n     }\n \n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java",
            "additions": 8,
            "deletions": 7
        },
        "diff content": "@@ -9,14 +9,13 @@ import java.util.List;\n  * Provides information about the message listeners of a specific class. Each message handler\n  * defined by the target class is represented as a single entity.\n  *\n- *\n  * @author bennidi\n  *         Date: 12/16/12\n  */\n public class MessageListenerMetadata<T> {\n \n \n-    public static final IPredicate<MessageHandlerMetadata> ForMessage(final Class<?> messageType){\n+    public static final IPredicate<MessageHandlerMetadata> ForMessage(final Class<?> messageType) {\n         return new IPredicate<MessageHandlerMetadata>() {\n             @Override\n             public boolean apply(MessageHandlerMetadata target) {\n@@ -35,19 +34,21 @@ public class MessageListenerMetadata<T> {\n     }\n \n \n-    public List<MessageHandlerMetadata> getHandlers(IPredicate<MessageHandlerMetadata> filter){\n+    public List<MessageHandlerMetadata> getHandlers(IPredicate<MessageHandlerMetadata> filter) {\n         List<MessageHandlerMetadata> matching = new LinkedList<MessageHandlerMetadata>();\n-        for(MessageHandlerMetadata handler : handlers){\n-            if(filter.apply(handler))matching.add(handler);\n+        for (MessageHandlerMetadata handler : handlers) {\n+            if (filter.apply(handler)) {\n+                matching.add(handler);\n+            }\n         }\n         return matching;\n     }\n \n-    public boolean handles(Class<?> messageType){\n+    public boolean handles(Class<?> messageType) {\n         return !getHandlers(ForMessage(messageType)).isEmpty();\n     }\n \n-    public Class<T> getListerDefinition(){\n+    public Class<T> getListerDefinition() {\n         return listenerDefinition;\n     }\n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MetadataReader.java",
            "additions": 22,
            "deletions": 18
        },
        "diff content": "@@ -5,14 +5,16 @@ import net.engio.mbassy.common.ReflectionUtils;\n import net.engio.mbassy.subscription.MessageEnvelope;\n \n import java.lang.reflect.Method;\n-import java.util.*;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n- *\n  * The meta data reader is responsible for parsing and validating message handler configurations.\n  *\n  * @author bennidi\n- * Date: 11/16/12\n+ *         Date: 11/16/12\n  */\n public class MetadataReader {\n \n@@ -28,18 +30,19 @@ public class MetadataReader {\n     private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n \n     // retrieve all instances of filters associated with the given subscription\n-    private IMessageFilter[] getFilter(Handler subscription){\n-        if (subscription.filters().length == 0) return null;\n+    private IMessageFilter[] getFilter(Handler subscription) {\n+        if (subscription.filters().length == 0) {\n+            return null;\n+        }\n         IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n         int i = 0;\n         for (Filter filterDef : subscription.filters()) {\n             IMessageFilter filter = filterCache.get(filterDef.value());\n             if (filter == null) {\n-                try{\n+                try {\n                     filter = filterDef.value().newInstance();\n                     filterCache.put(filterDef.value(), filter);\n-                }\n-                catch (Exception e){\n+                } catch (Exception e) {\n                     throw new RuntimeException(e);// propagate as runtime exception\n                 }\n \n@@ -51,7 +54,7 @@ public class MetadataReader {\n     }\n \n \n-    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler){\n+    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler) {\n         Handler config = messageHandler.getAnnotation(Handler.class);\n         return new MessageHandlerMetadata(messageHandler, getFilter(config), config);\n     }\n@@ -63,19 +66,21 @@ public class MetadataReader {\n         List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n         // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n         List<Method> bottomMostHandlers = new LinkedList<Method>();\n-        for(Method handler : allHandlers){\n-            if(!ReflectionUtils.containsOverridingMethod(allHandlers, handler)){\n+        for (Method handler : allHandlers) {\n+            if (!ReflectionUtils.containsOverridingMethod(allHandlers, handler)) {\n                 bottomMostHandlers.add(handler);\n             }\n         }\n \n \n-        List<MessageHandlerMetadata>  filteredHandlers = new LinkedList<MessageHandlerMetadata>();\n+        List<MessageHandlerMetadata> filteredHandlers = new LinkedList<MessageHandlerMetadata>();\n         // for each handler there will be no overriding method that specifies @Handler annotation\n         // but an overriding method does inherit the listener configuration of the overwritten method\n-        for(Method handler : bottomMostHandlers){\n+        for (Method handler : bottomMostHandlers) {\n             Handler handle = handler.getAnnotation(Handler.class);\n-            if(!handle.enabled() || !isValidMessageHandler(handler)) continue; // disabled or invalid listeners are ignored\n+            if (!handle.enabled() || !isValidMessageHandler(handler)) {\n+                continue; // disabled or invalid listeners are ignored\n+            }\n             Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n             // if a handler is overwritten it inherits the configuration of its parent method\n             MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n@@ -92,9 +97,8 @@ public class MetadataReader {\n     }\n \n \n-\n     private boolean isValidMessageHandler(Method handler) {\n-        if(handler == null || handler.getAnnotation(Handler.class) == null){\n+        if (handler == null || handler.getAnnotation(Handler.class) == null) {\n             return false;\n         }\n         if (handler.getParameterTypes().length != 1) {\n@@ -104,11 +108,11 @@ public class MetadataReader {\n             return false;\n         }\n         Enveloped envelope = handler.getAnnotation(Enveloped.class);\n-        if(envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])){\n+        if (envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])) {\n             System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n             return false;\n         }\n-        if(envelope != null && envelope.messages().length == 0){\n+        if (envelope != null && envelope.messages().length == 0) {\n             System.out.println(\"Message envelope configured but message types defined for handler\");\n             return false;\n         }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Mode.java",
            "additions": 7,
            "deletions": 6
        },
        "diff content": "@@ -1,12 +1,13 @@\n package net.engio.mbassy.listener;\n \n /**\n-* Created with IntelliJ IDEA.\n-* @author bennidi\n-* Date: 11/16/12\n-* Time: 10:01 AM\n-* To change this template use File | Settings | File Templates.\n-*/\n+ * Created with IntelliJ IDEA.\n+ *\n+ * @author bennidi\n+ *         Date: 11/16/12\n+ *         Time: 10:01 AM\n+ *         To change this template use File | Settings | File Templates.\n+ */\n public enum Mode {\n     Sequential, Concurrent\n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@ import net.engio.mbassy.dispatch.ISubscriptionContextAware;\n  * @author bennidi\n  *         Date: 3/1/13\n  */\n-public class AbstractSubscriptionContextAware implements ISubscriptionContextAware{\n+public class AbstractSubscriptionContextAware implements ISubscriptionContextAware {\n \n     private SubscriptionContext context;\n \n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/MessageEnvelope.java",
            "additions": 3,
            "deletions": 6
        },
        "diff content": "@@ -11,17 +11,14 @@ import java.sql.Timestamp;\n  */\n public class MessageEnvelope {\n \n-    private Timestamp tsCreated = new Timestamp(System.currentTimeMillis());\n-\n+    // Internal state\n     private Object message;\n \n-\n     public MessageEnvelope(Object message) {\n         this.message = message;\n     }\n \n-\n-    public <T> T getMessage(){\n-        return (T)message;\n+    public <T> T getMessage() {\n+        return (T) message;\n     }\n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 10,
            "deletions": 10
        },
        "diff content": "@@ -1,12 +1,12 @@\n package net.engio.mbassy.subscription;\n \n-import java.util.Comparator;\n-import java.util.UUID;\n-\n import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.common.ConcurrentSet;\n import net.engio.mbassy.dispatch.IMessageDispatcher;\n \n+import java.util.Comparator;\n+import java.util.UUID;\n+\n /**\n  * A subscription is a thread safe container for objects that contain message handlers\n  */\n@@ -26,16 +26,16 @@ public class Subscription {\n     }\n \n \n-    public boolean handlesMessageType(Class<?> messageType){\n+    public boolean handlesMessageType(Class<?> messageType) {\n         return context.getHandlerMetadata().handlesMessage(messageType);\n     }\n \n \n-    public void publish(MessagePublication publication, Object message){\n-          dispatcher.dispatch(publication, message, listeners);\n+    public void publish(MessagePublication publication, Object message) {\n+        dispatcher.dispatch(publication, message, listeners);\n     }\n \n-    public int getPriority(){\n+    public int getPriority() {\n         return context.getHandlerMetadata().getPriority();\n     }\n \n@@ -49,7 +49,7 @@ public class Subscription {\n         return listeners.remove(existingListener);\n     }\n \n-    public int size(){\n+    public int size() {\n         return listeners.size();\n     }\n \n@@ -57,8 +57,8 @@ public class Subscription {\n     public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n         @Override\n         public int compare(Subscription o1, Subscription o2) {\n-            int result =  o1.getPriority() - o2.getPriority();\n-            return result == 0 ? o1.id.compareTo(o2.id): result;\n+            int result = o1.getPriority() - o2.getPriority();\n+            return result == 0 ? o1.id.compareTo(o2.id) : result;\n         }\n     };\n \n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java",
            "additions": 2,
            "deletions": 0
        },
        "diff content": "@@ -25,6 +25,7 @@ public class SubscriptionContext {\n \n     /**\n      * Get a reference to the message bus this context belongs to\n+     *\n      * @return\n      */\n     public IMessageBus getOwningBus() {\n@@ -35,6 +36,7 @@ public class SubscriptionContext {\n     /**\n      * Get the meta data that specifies the characteristics of the message handler\n      * that is associated with this context\n+     *\n      * @return\n      */\n     public MessageHandlerMetadata getHandlerMetadata() {\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java",
            "additions": 23,
            "deletions": 16
        },
        "diff content": "@@ -1,38 +1,45 @@\n package net.engio.mbassy.subscription;\n \n-import net.engio.mbassy.dispatch.*;\n+import net.engio.mbassy.dispatch.AsynchronousHandlerInvocation;\n+import net.engio.mbassy.dispatch.EnvelopedMessageDispatcher;\n+import net.engio.mbassy.dispatch.FilteredMessageDispatcher;\n+import net.engio.mbassy.dispatch.IHandlerInvocation;\n+import net.engio.mbassy.dispatch.IMessageDispatcher;\n+import net.engio.mbassy.dispatch.MessageDispatcher;\n+import net.engio.mbassy.dispatch.ReflectiveHandlerInvocation;\n \n /**\n  * Created with IntelliJ IDEA.\n+ *\n  * @author bennidi\n- * Date: 11/16/12\n- * Time: 10:39 AM\n- * To change this template use File | Settings | File Templates.\n+ *         Date: 11/16/12\n+ *         Time: 10:39 AM\n+ *         To change this template use File | Settings | File Templates.\n  */\n public class SubscriptionFactory {\n \n-    public Subscription createSubscription(SubscriptionContext context){\n+    public Subscription createSubscription(SubscriptionContext context) {\n         IHandlerInvocation invocation = buildInvocationForHandler(context);\n         IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n         return new Subscription(context, dispatcher);\n     }\n \n-    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context){\n+    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) {\n         IHandlerInvocation invocation = new ReflectiveHandlerInvocation(context);\n-        if(context.getHandlerMetadata().isAsynchronous()){\n+        if (context.getHandlerMetadata().isAsynchronous()) {\n             invocation = new AsynchronousHandlerInvocation(invocation);\n         }\n         return invocation;\n     }\n \n-    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation){\n-       IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n-       if(context.getHandlerMetadata().isEnveloped()){\n-          dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n-       }\n-       if(context.getHandlerMetadata().isFiltered()){\n-          dispatcher = new FilteredMessageDispatcher(dispatcher);\n-       }\n-       return dispatcher;\n+    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n+        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n+        if (context.getHandlerMetadata().isEnveloped()) {\n+            dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n+        }\n+        if (context.getHandlerMetadata().isFiltered()) {\n+            dispatcher = new FilteredMessageDispatcher(dispatcher);\n+        }\n+        return dispatcher;\n     }\n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConcurrentSetTest.java",
            "additions": 5,
            "deletions": 5
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy;\n \n import junit.framework.Assert;\n+import org.junit.Ignore;\n import org.junit.Test;\n import net.engio.mbassy.common.ConcurrentExecutor;\n import net.engio.mbassy.common.ConcurrentSet;\n@@ -24,11 +25,11 @@ import java.util.Random;\n  */\n public class ConcurrentSetTest extends UnitTest {\n \n+    // Shared state\n     private int numberOfElements = 100000;\n-\n     private int numberOfThreads = 50;\n \n-\n+    @Ignore(\"Currently fails when building as a suite with JDK 1.7.0_15 and Maven 3.0.5 on a Mac\")\n     @Test\n     public void testIteratorCleanup() {\n         final HashSet<Object> persistingCandidates = new HashSet<Object>();\n@@ -44,7 +45,8 @@ public class ConcurrentSetTest extends UnitTest {\n             testSet.add(candidate);\n         }\n \n-        // this will remove all objects that have not been inserted into the set of persisting candidates\n+        // Remove/Garbage collect all objects that have not\n+        // been inserted into the set of persisting candidates.\n         runGC();\n \n         ConcurrentExecutor.runConcurrent(new Runnable() {\n@@ -62,8 +64,6 @@ public class ConcurrentSetTest extends UnitTest {\n         for (Object test : testSet) {\n             assertTrue(persistingCandidates.contains(test));\n         }\n-\n-\n     }\n \n \n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 4,
            "deletions": 5
        },
        "diff content": "@@ -1,7 +1,8 @@\n package net.engio.mbassy.common;\n \n import junit.framework.Assert;\n-import net.engio.mbassy.*;\n+import net.engio.mbassy.IPublicationErrorHandler;\n+import net.engio.mbassy.PublicationError;\n import net.engio.mbassy.bus.BusConfiguration;\n import net.engio.mbassy.bus.MBassador;\n \n@@ -12,7 +13,7 @@ import net.engio.mbassy.bus.MBassador;\n  * @author bennidi\n  *         Date: 3/2/13\n  */\n-public class MessageBusTest extends UnitTest{\n+public class MessageBusTest extends UnitTest {\n \n     private static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n         @Override\n@@ -21,11 +22,9 @@ public class MessageBusTest extends UnitTest{\n         }\n     };\n \n-    public MBassador getBus(BusConfiguration configuration){\n+    public MBassador getBus(BusConfiguration configuration) {\n         MBassador bus = new MBassador(configuration);\n         bus.addErrorHandler(TestFailingHandler);\n         return bus;\n     }\n-\n-\n }\n"
    },
    {
        "commit hash": "cb949a219ee69600d85639ee5bee1c70e6a22628",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/UnitTest.java",
            "additions": 4,
            "deletions": 2
        },
        "diff content": "@@ -13,12 +13,14 @@ import java.lang.ref.WeakReference;\n  */\n public class UnitTest {\n \n+    // Internal state\n+    private Runtime runtime = Runtime.getRuntime();\n \n     public void pause(long ms) {\n         try {\n             Thread.sleep(ms);\n         } catch (InterruptedException e) {\n-            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n+            e.printStackTrace();\n         }\n     }\n \n@@ -30,7 +32,7 @@ public class UnitTest {\n     public void runGC() {\n         WeakReference ref = new WeakReference<Object>(new Object());\n         while(ref.get() != null) {\n-            System.gc();\n+            runtime.gc();\n         }\n     }\n \n"
    },
    {
        "commit hash": "acc59eb8c324b94acad6251e026abd37b01b94b5",
        "previous commit hash": "54b3154ddc53e1511ec1bfc829f4bcccd35368f6",
        "diff stats": {
            "file_path": ".gitignore",
            "additions": 5,
            "deletions": 0
        },
        "diff content": "@@ -13,3 +13,8 @@ target/**\n # the local maven repository #\n mvn-local-repo/**/*\n release.properties\n+/.classpath\n+/.project\n+/.settings/org.eclipse.core.resources.prefs\n+/.settings/org.eclipse.jdt.core.prefs\n+/.settings/org.eclipse.m2e.core.prefs\n"
    },
    {
        "commit hash": "54b3154ddc53e1511ec1bfc829f4bcccd35368f6",
        "previous commit hash": "c74e3da2dd11d56da8fb84661d419d84197fcb9d",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ConcurrentSet.java",
            "additions": 7,
            "deletions": 4
        },
        "diff content": "@@ -88,9 +88,10 @@ public class ConcurrentSet<T> implements Iterable<T>{\n \n             public boolean hasNext() {\n                 if (current == null) return false;\n-                T value = current.getValue();\n-                if (value == null) {    // auto-removal of orphan references\n-                    remove();\n+                if (current.getValue() == null) {    // auto-removal of orphan references\n+                    do {\n+                        remove();\n+                    } while(current != null && current.getValue() == null);\n                     return hasNext();\n                 } else {\n                     return true;\n@@ -101,7 +102,9 @@ public class ConcurrentSet<T> implements Iterable<T>{\n                 if (current == null) return null;\n                 T value = current.getValue();\n                 if (value == null) {    // auto-removal of orphan references\n-                    remove();\n+                    do {\n+                        remove();\n+                    } while(current != null && current.getValue() == null);\n                     return next();\n                 } else {\n                     current = current.next();\n"
    },
    {
        "commit hash": "03d21a096f778f3f215722f843bbca690220dfaf",
        "previous commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "diff stats": {
            "file_path": ".gitignore",
            "additions": 3,
            "deletions": 1
        },
        "diff content": "@@ -1,11 +1,13 @@\n # idea project settings #\n+.idea/**\n *.iml\n+*.ipr\n+*.iws\n \n # Package Files #\n *.war\n *.ear\n \n-\n # root of compiled classes #\n target/**/*\n target/**\n"
    },
    {
        "commit hash": "295dfd3ec6ec552e9cf1e3559e1762e32d961023",
        "previous commit hash": "c74e3da2dd11d56da8fb84661d419d84197fcb9d",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 14,
            "deletions": 1
        },
        "diff content": "@@ -10,7 +10,7 @@\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n     <version>1.1.4-SNAPSHOT</version>\n-    <packaging>jar</packaging>\n+    <packaging>bundle</packaging>\n     <name>mbassador</name>\n     <description>\n         Mbassador is a fast and flexible message bus system following the publish subscribe pattern.\n@@ -77,6 +77,19 @@\n \n     <build>\n         <plugins>\n+            <plugin>\n+                <groupId>org.apache.felix</groupId>\n+                <artifactId>maven-bundle-plugin</artifactId>\n+                <version>2.3.7</version>\n+                <extensions>true</extensions>\n+                <configuration>\n+                    <instructions>\n+                        <Bundle-SymbolicName>${project.groupId}.${project.artifactId}</Bundle-SymbolicName>\n+                        <Export-Package>{local-packages}</Export-Package>\n+                    </instructions>\n+                </configuration>\n+            </plugin>\n+\n             <plugin>\n                 <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-compiler-plugin</artifactId>\n"
    },
    {
        "commit hash": "c74e3da2dd11d56da8fb84661d419d84197fcb9d",
        "previous commit hash": "0b2de1cf304f99b72e47545d924402ec6cf99f3b",
        "diff stats": {
            "file_path": "README.md",
            "additions": 8,
            "deletions": 9
        },
        "diff content": "@@ -43,10 +43,10 @@ a single message handler\n types of messages. This allows for a single handler to handle multiple (unrelated) message types.\n + <em><strong>Handler priorities</em></strong>: A listener can be associated with a priority to influence the order in which messages are delivered when multiple handlers exist\n + <em><strong>Custom error handling</em></strong>: Errors during message delivery are sent to all registered error handlers which can be added to the bus as necessary.\n-+ <em><strong>DeadMessage event</em></strong>: Messages that do not match any handler result in the publication of a DeadMessage object which wraps the original message. Dead events\n-can be handled by registering listeners that handle DeadEvent.\n++ <em><strong>DeadMessage event</em></strong>: Messages that do not match any handler result in the publication of a DeadMessage object which wraps the original message. DeadMessage events\n+can be handled by registering listeners that handle DeadMessage.\n + <em><strong>FilteredMessage event</em></strong>: Messages that have matching handlers but do not pass the configured filters result in the publication of a FilteredMessage object which wraps the original message.\n-Filtered events can be handled by registering listeners that handle FilteredEvent.\n+FilteredMessage events can be handled by registering listeners that handle FilteredMessage.\n + <em><strong>Extensibility</em></strong>:MBassador is designed to be extensible with custom implementations of various components like message\n dispatchers and handler invocations (using the decorator pattern), metadata reader (you can add your own annotations) and factories for different\n  kinds of object.A configuration object can be passed to on instance creation to specify the different configurable parts\n@@ -60,16 +60,16 @@ sending messages to your listeners using one of MBassador's publication methods\n \n Listener definition (in any bean):\n \n-        // every event of type TestMessage or any subtype will be delivered\n+        // every message of type TestMessage or any subtype will be delivered\n         // to this handler\n         @Handler\n-\t\tpublic void handleTestMessage(TestMessage event) {\n+\t\tpublic void handleTestMessage(TestMessage message) {\n \t\t\t// do something\n \t\t}\n \n         // this handler will be invoked concurrently\n \t\t@Handler(delivery = Mode.Concurrent)\n-\t\tpublic void handleSubTestMessage(SubTestMessage event) {\n+\t\tpublic void handleSubTestMessage(SubTestMessage message) {\n             // do something more expensive here\n \t\t}\n \n@@ -78,7 +78,7 @@ Listener definition (in any bean):\n         @Handler(priority = 10,\n                   delivery = Mode.Sequential,\n                   filters = {@Filter(Filters.SpecialMessage.class)})\n-        public void handleFiltered(SubTestMessage event) {\n+        public void handleFiltered(SubTestMessage message) {\n            //do something special here\n         }\n \n@@ -202,8 +202,7 @@ The initial inspiration for creating this component came from trying out Google\n I liked the simplicity of its design and I do trust the developers at Google a lot, so I was happy to find that they also\n provided an event bus system. The main reason it proved to be unusable for our scenario was that it uses strong references\n to the listeners such that every object has to be explicitly deregistered. This was difficult in our Spring managed environment.\n-Finally, I decided to create a custom implementation, which then matured to be stable, extensibel and yet very efficient\n-and well performing.\n+Finally, I decided to create a custom implementation, which then matured to be stable, extensible and yet very efficient.\n \n I want to thank the development team from friendsurance (www.friendsurance.de) for their support and feedback on the bus\n implementation and the management of friendsurance for allowing me to publish the component as an open source project.\n"
    },
    {
        "commit hash": "0b2de1cf304f99b72e47545d924402ec6cf99f3b",
        "previous commit hash": "b419dd240bdada8f10d21d9eea45056a79920dbc",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -84,7 +84,7 @@ Listener definition (in any bean):\n \n         @Handler(delivery = Mode.Sequential, rejectSubtypes = true)\n         @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n-        public void handleVariousEvents(MessageEnvelope envelope) {\n+        public void handleUnrelatedMessageTypes(MessageEnvelope envelope) {\n             // the envelope will contain either an instance of TestMessage or TestMessage2\n             // if rejectSubtypes were set to 'false' (default) also subtypes of TestMessage or TestMessage2 would be allowed\n         }\n"
    },
    {
        "commit hash": "b419dd240bdada8f10d21d9eea45056a79920dbc",
        "previous commit hash": "b4d401a970f79c2a1450dfd8846437d4daf594b5",
        "diff stats": {
            "file_path": "README.md",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -8,7 +8,7 @@ data structure to allow high throughput for concurrent access.\n Read this documentation to get an overview of its features. You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n which also contains a partial list of the features of the compared implementations.\n \n-The current version is 1.1.1 and it is available from the Maven Central Repository. See the release notes for more details.\n+The current version is 1.1.3 and it is available from the Maven Central Repository. See the release notes for more details.\n \n Table of contents:\n + [Features](#features)\n@@ -43,9 +43,9 @@ a single message handler\n types of messages. This allows for a single handler to handle multiple (unrelated) message types.\n + <em><strong>Handler priorities</em></strong>: A listener can be associated with a priority to influence the order in which messages are delivered when multiple handlers exist\n + <em><strong>Custom error handling</em></strong>: Errors during message delivery are sent to all registered error handlers which can be added to the bus as necessary.\n-+ <em><strong>Dead Event</em></strong>: Messages that do not match any handler result in the publication of a DeadEvent object which wraps the original message. Dead events\n++ <em><strong>DeadMessage event</em></strong>: Messages that do not match any handler result in the publication of a DeadMessage object which wraps the original message. Dead events\n can be handled by registering listeners that handle DeadEvent.\n-+ <em><strong>Dead Event</em></strong>: Messages that have matching handlers but do not pass the configured filters result in the publication of a FilteredEvent object which wraps the original message.\n++ <em><strong>FilteredMessage event</em></strong>: Messages that have matching handlers but do not pass the configured filters result in the publication of a FilteredMessage object which wraps the original message.\n Filtered events can be handled by registering listeners that handle FilteredEvent.\n + <em><strong>Extensibility</em></strong>:MBassador is designed to be extensible with custom implementations of various components like message\n dispatchers and handler invocations (using the decorator pattern), metadata reader (you can add your own annotations) and factories for different\n"
    },
    {
        "commit hash": "b4d401a970f79c2a1450dfd8846437d4daf594b5",
        "previous commit hash": "f29ec01eb734c299806af307bb733ed0d80b42c5",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.3</version>\n+    <version>1.1.4-SNAPSHOT</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -36,7 +36,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.3</tag>\n+        <tag>mbassador-1.1.2</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "f29ec01eb734c299806af307bb733ed0d80b42c5",
        "previous commit hash": "818d3bcf19e054d68f1f1b20b0ab427d37032252",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.3-SNAPSHOT</version>\n+    <version>1.1.3</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -36,7 +36,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.2</tag>\n+        <tag>mbassador-1.1.3</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "818d3bcf19e054d68f1f1b20b0ab427d37032252",
        "previous commit hash": "2425b34ab3327d8a82749fa5628bd565b1fbe8f6",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -147,7 +147,7 @@ to avoid confusion and misunderstanding.\n \n <h2>Release Notes</h2>\n \n-<h3>1.1.2</h3>\n+<h3>1.1.3</h3>\n \n  + Added support for FilteredMessage event\n  + Renamed @Listener to @Handler and DeadEvent to DeadMessage to increase alignment with the established terminology.\n"
    },
    {
        "commit hash": "818d3bcf19e054d68f1f1b20b0ab427d37032252",
        "previous commit hash": "2425b34ab3327d8a82749fa5628bd565b1fbe8f6",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.2-SNAPSHOT</version>\n+    <version>1.1.3-SNAPSHOT</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>\n"
    },
    {
        "commit hash": "2425b34ab3327d8a82749fa5628bd565b1fbe8f6",
        "previous commit hash": "62af3c7b22cbb9aeaabb53f058e2c42c21868297",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.2</version>\n+    <version>1.1.2-SNAPSHOT</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>\n"
    },
    {
        "commit hash": "62af3c7b22cbb9aeaabb53f058e2c42c21868297",
        "previous commit hash": "b82632490bfb057ea06a36efca911f4f0ebde368",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.2-SNAPSHOT</version>\n+    <version>1.1.2</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -36,7 +36,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>HEAD</tag>\n+        <tag>mbassador-1.1.2</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "b82632490bfb057ea06a36efca911f4f0ebde368",
        "previous commit hash": "8fcce2f0eb005d7434735ea60303699a13b94cd1",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.3-SNAPSHOT</version>\n+    <version>1.1.2-SNAPSHOT</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>\n"
    },
    {
        "commit hash": "8fcce2f0eb005d7434735ea60303699a13b94cd1",
        "previous commit hash": "0f62f53ebda03a1ccdea71b5a0de8ff3a30e8e14",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.2</version>\n+    <version>1.1.3-SNAPSHOT</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -36,7 +36,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.2</tag>\n+        <tag>HEAD</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "0f62f53ebda03a1ccdea71b5a0de8ff3a30e8e14",
        "previous commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.2-SNAPSHOT</version>\n+    <version>1.1.2</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -36,7 +36,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>HEAD</tag>\n+        <tag>mbassador-1.1.2</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "README.md",
            "additions": 72,
            "deletions": 45
        },
        "diff content": "@@ -5,8 +5,7 @@ MBassador is a very light-weight message (event) bus implementation following th\n for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. It uses a specialized\n data structure to allow high throughput for concurrent access.\n \n-Read this documentation to get an overview of its features and how cool this message (event) bus actually is.\n-You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n+Read this documentation to get an overview of its features. You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n which also contains a partial list of the features of the compared implementations.\n \n The current version is 1.1.1 and it is available from the Maven Central Repository. See the release notes for more details.\n@@ -15,6 +14,7 @@ Table of contents:\n + [Features](#features)\n + [Usage](#usage)\n + [Installation](#installation)\n++ [Wiki](#wiki)\n + [Release Notes](#releasenotes)\n + [Roadmap](#roadmap)\n + [Credits](#credits)\n@@ -26,26 +26,33 @@ Table of contents:\n \n At its core MBassador offers the following features:\n \n-+ <em><strong>Annotation driven</em></strong>: To define and customize a message handler simply mark it with @Listener annotation\n-+ <em><strong>Delivers everything</em></strong>: Messages must not implement any interface and can be of any type (-> message bus is typed using generics with upper\n-bound being Object.class). The class hierarchy of a message is considered during message delivery. This means that listeners will also receive\n-subtypes of the message type they are listening for, e.g. a listener for Object.class receives everything.\n++ <em><strong>Annotation driven</em></strong>: To define and customize a message handler simply mark it with @Handler annotation\n++ <em><strong>Delivers everything</em></strong>: Messages must not implement any interface and can be of any type. It is\n+possible though to define an upper bound of the message type using generics. The class hierarchy of a message is considered during message delivery.\n+This means that listeners will also receivesubtypes of the message type they are listening for, e.g. a listener for Object.class receives everything.\n + <em><strong>Synchronous and asynchronous message delivery</em></strong>: A handler can be invoked to handle a message either synchronously or\n asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method\n blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch\n-+ <em><strong>Weak references</em></strong>: Mbassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister\n++ <em><strong>Weak references</em></strong>: MBassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister\n listeners that are not used anymore (of course it is also possible to explicitly unregister a listener if needed). This is very comfortable\n-in certain environments where objects are created by frameworks, i.e. spring, guice etc. Just stuff everything into the message bus, it will\n+in certain environments where listeners are managed by frameworks, i.e. spring, guice etc. Just stuff everything into the message bus, it will\n ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.\n-+ <em><strong>Filtering</em></strong>: Mbassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to\n++ <em><strong>Filtering</em></strong>: MBassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to\n a single message handler\n-+ <em><strong>Message envelopes</em></strong>: Message handlers can declare to receive an enveloped message. The envelope can wrap around different\n-types of messages. This allows for a single handler to handle multiple message types\n-+ <em><strong>Handler priorities</em></strong>: A listener can be associated with a priority to influence the order of the message delivery\n-+ <em><strong>Error handling</em></strong>: Errors during message delivery are sent to an error handler of which a custom implementation can easily be plugged-in.\n-+ <em><strong>Ease of Use</em></strong>: Using Mbassador in your project is very easy. Create as many instances of Mbassador as you like (usually a singleton will do),\n-mark and configure your message handlers with @Listener annotations and finally register the listeners at any Mbassador instance. Start\n-sending messages to your listeners using one of Mbassador's publication methods (sync or async). Done!\n++ <em><strong>Message envelopes</em></strong>: Message handlers can declare to receive an enveloped message. The envelope can wrap different\n+types of messages. This allows for a single handler to handle multiple (unrelated) message types.\n++ <em><strong>Handler priorities</em></strong>: A listener can be associated with a priority to influence the order in which messages are delivered when multiple handlers exist\n++ <em><strong>Custom error handling</em></strong>: Errors during message delivery are sent to all registered error handlers which can be added to the bus as necessary.\n++ <em><strong>Dead Event</em></strong>: Messages that do not match any handler result in the publication of a DeadEvent object which wraps the original message. Dead events\n+can be handled by registering listeners that handle DeadEvent.\n++ <em><strong>Dead Event</em></strong>: Messages that have matching handlers but do not pass the configured filters result in the publication of a FilteredEvent object which wraps the original message.\n+Filtered events can be handled by registering listeners that handle FilteredEvent.\n++ <em><strong>Extensibility</em></strong>:MBassador is designed to be extensible with custom implementations of various components like message\n+dispatchers and handler invocations (using the decorator pattern), metadata reader (you can add your own annotations) and factories for different\n+ kinds of object.A configuration object can be passed to on instance creation to specify the different configurable parts\n++ <em><strong>Ease of Use</em></strong>: Using MBassador in your project is very easy. Create as many instances of MBassador as you like (usually a singleton will do),\n+mark and configure your message handlers with @Handler annotations and finally register the listeners at any MBassador instance. Start\n+sending messages to your listeners using one of MBassador's publication methods (sync or async). Done!\n \n \n \n@@ -53,33 +60,33 @@ sending messages to your listeners using one of Mbassador's publication methods\n \n Listener definition (in any bean):\n \n-        // every event of type TestEvent or any subtype will be delivered\n+        // every event of type TestMessage or any subtype will be delivered\n         // to this handler\n-        @Listener\n-\t\tpublic void handleTestEvent(TestEvent event) {\n+        @Handler\n+\t\tpublic void handleTestMessage(TestMessage event) {\n \t\t\t// do something\n \t\t}\n \n         // this handler will be invoked concurrently\n-\t\t@Listener(delivery = Mode.Concurrent)\n-\t\tpublic void handleSubTestEvent(SubTestEvent event) {\n+\t\t@Handler(delivery = Mode.Concurrent)\n+\t\tpublic void handleSubTestMessage(SubTestMessage event) {\n             // do something more expensive here\n \t\t}\n \n-\t\t// this handler will receive messages of type SubTestEvent\n+\t\t// this handler will receive messages of type SubTestMessage\n         // or any of its sub types that passe the given filter(s)\n-        @Listener(priority = 10,\n+        @Handler(priority = 10,\n                   delivery = Mode.Sequential,\n-                  filters = {@Filter(Filters.SpecialEvent.class)})\n-        public void handleFiltered(SubTestEvent event) {\n+                  filters = {@Filter(Filters.SpecialMessage.class)})\n+        public void handleFiltered(SubTestMessage event) {\n            //do something special here\n         }\n \n-        @Listener(delivery = Mode.Sequential, rejectSubtypes = true)\n-        @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n+        @Handler(delivery = Mode.Sequential, rejectSubtypes = true)\n+        @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n         public void handleVariousEvents(MessageEnvelope envelope) {\n-            // the envelope will contain either an instance of TestEvent or TestEvent2\n-            // if rejectSubtypes were set to 'false' (default) also subtypes of TestEvent or TestEvent2 would be allowed\n+            // the envelope will contain either an instance of TestMessage or TestMessage2\n+            // if rejectSubtypes were set to 'false' (default) also subtypes of TestMessage or TestMessage2 would be allowed\n         }\n \n \n@@ -87,7 +94,7 @@ Creation of message bus and registration of listeners:\n \n         // create as many instances as necessary\n         // bind it to any upper bound\n-        MBassador<TestEvent> bus = new MBassador<TestEvent>(BusConfiguration.Default());\n+        MBassador<TestMessage> bus = new MBassador<TestMessage>(BusConfiguration.Default());\n         ListeningBean listener = new ListeningBean();\n         // the listener will be registered using a weak-reference\n         bus.subscribe(listener);\n@@ -97,18 +104,18 @@ Creation of message bus and registration of listeners:\n \n Message publication:\n \n-        TestEvent event = new TestEvent();\n-        TestEvent subEvent = new SubTestEvent();\n+        TestMessage message = new TestMessage();\n+        TestMessage subMessage = new SubTestMessage();\n \n-        bus.publishAsync(event); //returns immediately, publication will continue asynchronously\n-        bus.post(event).asynchronously(); // same as above\n-        bus.publish(subEvent);   // will return after each handler has been invoked\n-        bus.post(subEvent).now(); // same as above\n+        bus.publishAsync(message); //returns immediately, publication will continue asynchronously\n+        bus.post(message).asynchronously(); // same as above\n+        bus.publish(subMessage);   // will return after each handler has been invoked\n+        bus.post(subMessage).now(); // same as above\n \n <h2>Installation</h2>\n Beginning with version 1.1.0 MBassador is available from the Maven Central Repository (Hooray!). Older versions are\n still available from the included maven repository in this github repo but will be deleted in the future.\n-The preferred way of using MBassador is to simply add the dependency as shown in step two. Step one is only necessary\n+The recommended way of using MBassador in your project is to add the dependency as shown in step two. Step one is only necessary\n if you want to use an older version that is not available in the central repository.\n \n  1. Add the repository location to your pom.xml\n@@ -131,17 +138,31 @@ if you want to use an older version that is not available in the central reposit\n     </pre></code>\n  3. Run mvn clean package to have maven download and install the required version into your local repository\n \n-Of course you can always clone the repository and build from source\n+Of course you can always clone the repository and build from source.\n+\n+<h2>Wiki</h2>\n+There is ongoing afford to extend documentation and provide code samples and detailed explanations of how the message bus\n+works. Code samples can also be found in the various test cases. Please read about the terminology used in this project\n+to avoid confusion and misunderstanding.\n \n <h2>Release Notes</h2>\n \n+<h3>1.1.2</h3>\n+\n+ + Added support for FilteredMessage event\n+ + Renamed @Listener to @Handler and DeadEvent to DeadMessage to increase alignment with the established terminology.\n+ Sorry for the inconvenience since this will lead to compile errors but good old find&replace will do\n+ + Repackaging and refactoring of some parts\n+ + Introduced message publication factories as configurable components to make MBassador more extensible/customizable\n+ + Added more documentation and unit tests\n+\n <h3>1.1.1</h3>\n \n- + Added support for DeadEvent\n- + Introduced new property to @Listener annotation that allows to activate/deactivate any message handler\n+ + Added support for DeadMessage event\n+ + Introduced new property to @Handler annotation that allows to activate/deactivate any message handler\n  + Full support of proxies created by cglib\n  + Message handler inheritance changed! See wiki page about handler definition for more details.\n- + Changed @Listener property \"dispatch\" to \"delivery\" and renamed the associated enumeration values to\n+ + Changed @Handler property \"dispatch\" to \"delivery\" and renamed the associated enumeration values to\n    more precisely indicate their meaning\n  + Added more unit tests\n \n@@ -163,7 +184,7 @@ First stable release!\n <h3>1.0.5.RC</h3>\n \n  + Added MessageEnvelope and @Enveloped annotation to configure handlers that might receive arbitrary message type\n- + Added handler configuration property to @Listener annotation to move from message filtering to more specific implementation\n+ + Added handler configuration property to @Handler annotation to move from message filtering to more specific implementation\n  of this feature\n \n <h3>1.0.4.RC</h3>\n@@ -177,9 +198,12 @@ successful commit etc.). Currently in beta, see <a href=\"https://github.com/benn\n \n \n <h2>Credits</h2>\n-The initial inspiration for creating this component came from looking at Google Guava's event bus implementation. Since\n-it did not provide all the features we needed in our project, I decided to create my own implementation. It matured to be\n-quite a feature rich and yet very efficient and performant implementation.\n+The initial inspiration for creating this component came from trying out Google Guava's event bus implementation.\n+I liked the simplicity of its design and I do trust the developers at Google a lot, so I was happy to find that they also\n+provided an event bus system. The main reason it proved to be unusable for our scenario was that it uses strong references\n+to the listeners such that every object has to be explicitly deregistered. This was difficult in our Spring managed environment.\n+Finally, I decided to create a custom implementation, which then matured to be stable, extensibel and yet very efficient\n+and well performing.\n \n I want to thank the development team from friendsurance (www.friendsurance.de) for their support and feedback on the bus\n implementation and the management of friendsurance for allowing me to publish the component as an open source project.\n@@ -189,6 +213,9 @@ implementation and the management of friendsurance for allowing me to publish th\n Any feature requests and feedback are more than welcome. You may suggest improvements either by submitting an\n issue or by forking the repo and creating a pull request. I will try to respond as quickly as possible.\n \n+Sample code and documentation are both very appreciated contributions. Especially integration with different frameworks\n+such as Spring, Guice or other is of great value. Feel free and welcome to create Wiki pages to share your code and ideas.\n+\n <h2>License</h2>\n \n This project is distributed under the terms of the MIT License. See file \"LICENSE\" for further reference.\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "build.gradle",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,7 +1,7 @@\n usePlugin('java')\n \n group=\"org.mbassy\"\n-version=\"1.10.0-SNAPSHOT\"\n+version=\"1.1.2\"\n \n dependencies {\n     addMavenRepo()\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/docs/wiki-bus-overview.md",
            "additions": 28,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,28 @@\n+Note: Please refer to the terminology wiki page before reading the following explanations..\n+\n+A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n+synchronously or asynchronously and the dispatch mechanism can by controlled for each message handler and per message publication.\n+\n+Each message publication is isolated from all other running publications such that it does not interfere with them.\n+Hence, the bus expects message handlers to be stateless as they may be invoked concurrently if multiple\n+messages of the same type get published asynchronously.\n+\n+Messages are published to all listeners that accept the type or super type of the published message. Additionally\n+a message handler may define filters to narrow the set of messages that it accepts.\n+\n+Subscribed listeners are available to all pending message publications that have not yet started processing.\n+Any message listener may only be subscribed once - subsequent subscriptions of an already subscribed message listener\n+will be silently ignored.\n+\n+The basic contract of the bus is that it will deliver a specific message exactly once to each of the subscribed message handlers.\n+Currently, message handlers will be invoked in inverse sequence of subscription but any\n+client using this bus should not rely on this assumption.\n+\n+The bus uses weak references to all listeners such that registered listeners do not need to\n+be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n+removed on-the-fly as messages get published.\n+\n+Unsubscribing a listener means removing all subscribed message handlers of that listener. This remove operation\n+immediately effects all running publications processes -> A removed listener will under no circumstances receive any message publications.\n+A listener is considered removed after the unsubscribe(Object) call returned.Any running message publication that has not yet delivered\n+the message to the recently removed listener will not see the listener after the remove operation completed.\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/docs/wiki-listener-def.md",
            "additions": 6,
            "deletions": 6
        },
        "diff content": "@@ -52,7 +52,7 @@ receive all messages of type TestEvent or any subtype sequentially.\n \n         // every message of type TestEvent or any subtype will be delivered\n         // to this handler\n-        @Listener\n+        @Handler\n \t\tpublic void handleTestEvent(TestEvent event) {\n \t\t\t// do something\n \t\t}\n@@ -62,7 +62,7 @@ receive all messages of type TestEvent or any subtype sequentially.\n This handler will receive all messages of type SubTestEvent or any subtype concurrently\n \n         // this handler will be invoked concurrently\n-\t\t@Listener(delivery = Mode.Concurrent)\n+\t\t@Handler(delivery = Mode.Concurrent)\n \t\tpublic void handleSubTestEvent(SubTestEvent event) {\n             // do something more expensive here\n \t\t}\n@@ -73,7 +73,7 @@ defined one, since it specifies a higher priority\n \n \t\t// this handler will receive messages of type SubTestEvent\n         // or any of its sub types that passe the given filter(s)\n-        @Listener(priority = 10,\n+        @Handler(priority = 10,\n                   dispatch = Mode.Synchronous,\n                   filters = {@Filter(Filters.SpecialEvent.class)})\n         public void handleFiltered(SubTestEvent event) {\n@@ -81,7 +81,7 @@ defined one, since it specifies a higher priority\n         }\n \n \n-        @Listener(dispatch = Mode.Synchronous, rejectSubtypes = true)\n+        @Handler(dispatch = Mode.Synchronous, rejectSubtypes = true)\n         @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n         public void handleVariousEvents(MessageEnvelope envelope) {\n             // the envelope will contain either an instance of TestEvent or TestEvent2\n@@ -95,10 +95,10 @@ defined one, since it specifies a higher priority\n Since one parameter (the message) does not offer a great deal of flexibility if different types\n of messages should be consumed, there exists the possibility to wrap a message inside an envelope.\n An enveloped message handler specifies the message type it consumes by using the @Enveloped annotation\n-in addition to the @Listener annotation. All configurations of @Listener apply to each of the specified\n+in addition to the @Handler annotation. All configurations of @Handler apply to each of the specified\n message types.\n \n-        @Listener(dispatch = Mode.Synchronous, rejectSubtypes = true)\n+        @Handler(dispatch = Mode.Synchronous, rejectSubtypes = true)\n         @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n         public void handleVariousEvents(MessageEnvelope envelope) {\n             // the envelope will contain either an instance of TestEvent or TestEvent2\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/docs/wiki-terminology.md",
            "additions": 39,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,39 @@\n+<h2>Terminology</h2>\n+To avoid confusion and increase precision of the available documentation a common vocabulary of the most relevant concepts is necessary.\n+Specifically, the terms \"event\" and \"message\" have their own definition within the context of the message bus system and as such require\n+some clarification.\n+\n+<h3>Message</h3>\n+A message is an object used for communication between multiple other objects.Other libraries established the term \"event\" which essentially\n+refers to the same idea (an event occurs at some point in the system and is published to other components such that they might react to it).\n+MBassador uses the term message instead of event since the object sent through it does not necessarily represent an event. It might merely represent\n+data to be processed, e.g. stored or transformed.\n+\n+A message can be any object, no restrictions or assumptions are made. A message can be sent by any object that has access to the bus\n+and is delivered to all registered listeners that consume the type of message.\n+\n+<h3>Message handler</h3>\n+A message handler is a method that defines exactly one parameter (the message) and is marked with @Handler. A handler has a message type\n+that is implicitly defined in the method signature (the parameter type). A message handler will be invoked for each message that has a compatible\n+type.\n+\n+<h3>Message listener</h3>\n+An object that defines one or more message handlers and that has been subscribed at the message bus is referred to as (message) listener.\n+\n+<h3>Subscription</h3>\n+Subscription is the process of adding a listener to the message bus, such that it might receive messages. It is used interchangeably with the\n+term \"registration\"\n+\n+<h3>Message publication|Message dispatch</h3>\n+The process of delivering a message from the sender to all registered listeners is called message publication.\n+The initial phase of this process, that lasts until the message is actually delivered to the handlers is called message dispatch.\n+The distinction is necessarily drawn as all method publications share a common scheme but may vary in the way how the dispatching works.\n+\n+<h3>Event</h3>\n+The term \"event\" refers to events that can occur during message publication. Currently there are two types of events:\n+\n+ + DeadMessage: Whenever a message is published and no listeners exist that defined matching handlers, a DeadMessage event will be created and published\n+ using the common message publication mechanism. Listeners with handlers for DeadEvent can be subscribed to listen for and react to dead\n+ + FilteredMessage: Since handlers can define filters to narrow the set of messages it consumes, it is possible that a message is not delivered\n+ to any handler. In such a case the FilteredMessage event is published,\n+\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/AbstractMessageBus.java",
            "additions": 10,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,9 @@\n-package net.engio.mbassy;\n+package net.engio.mbassy.bus;\n \n+import net.engio.mbassy.IPublicationErrorHandler;\n+import net.engio.mbassy.PublicationError;\n import net.engio.mbassy.common.ReflectionUtils;\n-import net.engio.mbassy.dispatch.SubscriptionContext;\n+import net.engio.mbassy.subscription.SubscriptionContext;\n import net.engio.mbassy.listener.MessageHandlerMetadata;\n import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.subscription.Subscription;\n@@ -50,12 +52,14 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     // it can be customized by implementing the getSubscriptionFactory() method\n     private final SubscriptionFactory subscriptionFactory;\n \n+    private final MessagePublication.Factory publicationFactory;\n \n \n     public AbstractMessageBus(BusConfiguration configuration) {\n         this.executor = configuration.getExecutor();\n         subscriptionFactory = configuration.getSubscriptionFactory();\n         this.metadataReader = configuration.getMetadataReader();\n+        this.publicationFactory = configuration.getMessagePublicationFactory();\n         pendingMessages  = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n         initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n         addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n@@ -85,6 +89,10 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         }\n     }\n \n+    protected MessagePublication.Factory getPublicationFactory(){\n+        return publicationFactory;\n+    }\n+\n     @Override\n     public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n         return Collections.unmodifiableCollection(errorHandlers);\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/BusConfiguration.java",
            "additions": 12,
            "deletions": 2
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package net.engio.mbassy;\n+package net.engio.mbassy.bus;\n \n import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.subscription.SubscriptionFactory;\n@@ -6,7 +6,7 @@ import net.engio.mbassy.subscription.SubscriptionFactory;\n import java.util.concurrent.*;\n \n /**\n- * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour. *\n+ * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n  *\n  * @author bennidi\n  *         Date: 12/8/12\n@@ -36,13 +36,23 @@ public class BusConfiguration {\n \n     private MetadataReader metadataReader;\n \n+    private MessagePublication.Factory messagePublicationFactory;\n+\n     public BusConfiguration() {\n         this.numberOfMessageDispatchers = 2;\n         this.maximumNumberOfPendingMessages = Integer.MAX_VALUE;\n         this.subscriptionFactory = new SubscriptionFactory();\n         this.executor = new ThreadPoolExecutor(10, 10, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), DaemonThreadFactory);\n         this.metadataReader = new MetadataReader();\n+        this.messagePublicationFactory = new MessagePublication.Factory();\n+    }\n+\n+    public MessagePublication.Factory getMessagePublicationFactory() {\n+        return messagePublicationFactory;\n+    }\n \n+    public void setMessagePublicationFactory(MessagePublication.Factory messagePublicationFactory) {\n+        this.messagePublicationFactory = messagePublicationFactory;\n     }\n \n     public MetadataReader getMetadataReader() {\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/IMessageBus.java",
            "additions": 5,
            "deletions": 3
        },
        "diff content": "@@ -1,4 +1,6 @@\n-package net.engio.mbassy;\n+package net.engio.mbassy.bus;\n+\n+import net.engio.mbassy.IPublicationErrorHandler;\n \n import java.util.Collection;\n import java.util.concurrent.Executor;\n@@ -17,7 +19,7 @@ import java.util.concurrent.TimeUnit;\n  * <p/>\n  * A listener is any object that defines at least one message handler and that has been subscribed to at least\n  * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n- * as a message handler using the @Listener annotation.\n+ * as a message handler using the @Handler annotation.\n  * <p/>\n  * The bus uses weak references to all listeners such that registered listeners do not need to\n  * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n@@ -145,7 +147,7 @@ public interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n          *\n          * If an unbound queuing strategy is used the call returns immediately.\n          * If a bounded queue is used the call will block until the message can be placed in the queue\n-         * or the timeout r\n+         * or the timeout is reached.\n          *\n          * @return A message publication that wraps up the publication request\n          */\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MBassador.java",
            "additions": 7,
            "deletions": 6
        },
        "diff content": "@@ -1,6 +1,7 @@\n-package net.engio.mbassy;\n+package net.engio.mbassy.bus;\n \n-import net.engio.mbassy.common.DeadEvent;\n+import net.engio.mbassy.PublicationError;\n+import net.engio.mbassy.common.DeadMessage;\n import net.engio.mbassy.subscription.Subscription;\n \n import java.util.Collection;\n@@ -24,12 +25,12 @@ public class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>>\n \n     private MessagePublication createMessagePublication(T message) {\n         Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n-        if (subscriptions == null || subscriptions.isEmpty()) {\n+        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass().equals(DeadMessage.class)) {\n             // Dead Event\n-            subscriptions = getSubscriptionsByMessageType(DeadEvent.class);\n-            return MessagePublication.Create(this, subscriptions, new DeadEvent(message));\n+            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n+            return getPublicationFactory().createPublication(this, subscriptions, new DeadMessage(message));\n         }\n-        else return MessagePublication.Create(this, subscriptions, message);\n+        else return getPublicationFactory().createPublication(this, subscriptions, message);\n     }\n \n \n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/MessagePublication.java",
            "additions": 20,
            "deletions": 10
        },
        "diff content": "@@ -1,7 +1,7 @@\n-package net.engio.mbassy;\n+package net.engio.mbassy.bus;\n \n-import net.engio.mbassy.common.DeadEvent;\n-import net.engio.mbassy.common.FilteredEvent;\n+import net.engio.mbassy.common.DeadMessage;\n+import net.engio.mbassy.common.FilteredMessage;\n import net.engio.mbassy.subscription.Subscription;\n \n import java.util.Collection;\n@@ -19,8 +19,12 @@ import java.util.Collection;\n  */\n public class MessagePublication {\n \n-    public static  MessagePublication Create(IMessageBus bus, Collection<Subscription> subscriptions, Object message){\n-        return new MessagePublication(bus,subscriptions, message, State.Initial);\n+    public static class Factory{\n+\n+        public MessagePublication createPublication(IMessageBus owningBus, Collection<Subscription> subscriptions, Object message){\n+            return new MessagePublication(owningBus, subscriptions, message, State.Initial);\n+        }\n+\n     }\n \n     private Collection<Subscription> subscriptions;\n@@ -33,7 +37,7 @@ public class MessagePublication {\n \n     private IMessageBus bus;\n \n-    private MessagePublication(IMessageBus bus, Collection<Subscription> subscriptions, Object message, State initialState) {\n+    public MessagePublication(IMessageBus bus, Collection<Subscription> subscriptions, Object message, State initialState) {\n         this.bus = bus;\n         this.subscriptions = subscriptions;\n         this.message = message;\n@@ -50,8 +54,14 @@ public class MessagePublication {\n             sub.publish(this, message);\n         }\n         state = State.Finished;\n-        if(!delivered && !isFilteredEvent() && !isDeadEvent()){\n-            bus.post(new FilteredEvent(message)).now();\n+        // if the message has not been marked delivered by the dispatcher\n+        if(!delivered){\n+            if(!isFilteredEvent() && !isDeadEvent()){\n+                bus.post(new FilteredMessage(message)).now();\n+            }else if(!isDeadEvent()){\n+                bus.post(new DeadMessage(message)).now();\n+            }\n+\n         }\n     }\n \n@@ -84,11 +94,11 @@ public class MessagePublication {\n     }\n \n     public boolean isDeadEvent(){\n-        return DeadEvent.class.isAssignableFrom(message.getClass());\n+        return DeadMessage.class.isAssignableFrom(message.getClass());\n     }\n \n     public boolean isFilteredEvent(){\n-        return FilteredEvent.class.isAssignableFrom(message.getClass());\n+        return FilteredMessage.class.isAssignableFrom(message.getClass());\n     }\n \n     private enum State{\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/bus/SyncAsyncPostCommand.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package net.engio.mbassy;\n+package net.engio.mbassy.bus;\n \n import java.util.concurrent.TimeUnit;\n \n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/DeadMessage.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -7,9 +7,9 @@ package net.engio.mbassy.common;\n  * @author bennidi\n  *         Date: 1/18/13\n  */\n-public class DeadEvent extends PublicationEvent {\n+public final class DeadMessage extends PublicationEvent {\n \n-    public DeadEvent(Object message) {\n+    public DeadMessage(Object message) {\n         super(message);\n     }\n \n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/FilteredMessage.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -8,10 +8,10 @@ package net.engio.mbassy.common;\n  * @author bennidi\n  *         Date: 3/1/13\n  */\n-public class FilteredEvent extends PublicationEvent {\n+public class FilteredMessage extends PublicationEvent {\n \n \n-    public FilteredEvent(Object event) {\n+    public FilteredMessage(Object event) {\n         super(event);\n     }\n }\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/PublicationEvent.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -15,7 +15,7 @@ public abstract class PublicationEvent {\n         this.event = message;\n     }\n \n-    public Object getEvent() {\n+    public Object getMessage() {\n         return event;\n     }\n }\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,5 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.MessagePublication;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n \n /**\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.MessagePublication;\n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.common.ConcurrentSet;\n import net.engio.mbassy.subscription.MessageEnvelope;\n \n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.MessagePublication;\n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.common.ConcurrentSet;\n import net.engio.mbassy.listener.IMessageFilter;\n \n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java",
            "additions": 0,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,5 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.MessagePublication;\n-\n /**\n  * A handler invocation encapsulates the logic that is used to invoke a single\n  * message handler to process a given message.\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IMessageBusAware.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.IMessageBus;\n+import net.engio.mbassy.bus.IMessageBus;\n \n /**\n  * This interface marks components that have access to the message bus that they belong to.\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n-import net.engio.mbassy.MessagePublication;\n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.common.ConcurrentSet;\n \n /**\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/ISubscriptionContextAware.java",
            "additions": 2,
            "deletions": 0
        },
        "diff content": "@@ -1,5 +1,7 @@\n package net.engio.mbassy.dispatch;\n \n+import net.engio.mbassy.subscription.SubscriptionContext;\n+\n /**\n  * This interface marks components that have access to the subscription context.\n  *\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java",
            "additions": 2,
            "deletions": 4
        },
        "diff content": "@@ -1,11 +1,9 @@\n package net.engio.mbassy.dispatch;\n \n-import java.lang.reflect.Method;\n-\n-import net.engio.mbassy.IMessageBus;\n-import net.engio.mbassy.MessagePublication;\n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.common.ConcurrentSet;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n+import net.engio.mbassy.subscription.SubscriptionContext;\n \n /**\n  * Standard implementation for direct, unfiltered message delivery.\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,9 +1,9 @@\n package net.engio.mbassy.dispatch;\n \n import net.engio.mbassy.IPublicationErrorHandler;\n-import net.engio.mbassy.MessagePublication;\n import net.engio.mbassy.PublicationError;\n import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n+import net.engio.mbassy.subscription.SubscriptionContext;\n \n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Enveloped.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -4,7 +4,7 @@ import java.lang.annotation.*;\n \n /**\n  * Configure a handler to receive an enveloped message as a wrapper around the source\n- * message. An enveloped message can be\n+ * message. An enveloped message can contain any type of message\n  *\n  * @author bennidi\n  * Date: 2/8/12\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Filter.java",
            "additions": 9,
            "deletions": 4
        },
        "diff content": "@@ -6,10 +6,10 @@ import java.lang.annotation.RetentionPolicy;\n import java.lang.annotation.Target;\n \n /**\n- * THe filter annotation is used to add filters to message listeners.\n- * It references a class that implements the MessageFilter interface.\n- * The object filter will be used to check whether a message should be delivered\n- * to the message listener or not.\n+ * The filter annotation is used to add filters to message listeners.\n+ * It references a class that implements the IMessageFilter interface.\n+ * The filter will be used to check whether a message should be delivered\n+ * to the listener or not.\n  *\n  * <p/>\n  * @author  bennidi\n@@ -19,5 +19,10 @@ import java.lang.annotation.Target;\n @Target(value = {ElementType.ANNOTATION_TYPE})\n public @interface Filter {\n \n+    /**\n+     * The class that implements the filter.\n+     * Note: A filter always needs to provide a non-arg constructor\n+     * @return\n+     */\n \tClass<? extends IMessageFilter> value();\n }\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Filters.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -1,7 +1,8 @@\n package net.engio.mbassy.listener;\n \n /**\n- * Todo: Add javadoc\n+ * Some sample filters that are not particularly useful in production environment\n+ * but illustrate how filters are meant to be used.\n  *\n  * @author bennidi\n  *         Date: 12/12/12\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Handler.java",
            "additions": 51,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,51 @@\n+package net.engio.mbassy.listener;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * Mark any method of any object(=listener) as a message handler and configure the handler\n+ * using different properties.\n+ *\n+ * @author bennidi\n+ * Date: 2/8/12\n+ */\n+@Retention(value = RetentionPolicy.RUNTIME)\n+@Inherited\n+@Target(value = {ElementType.METHOD})\n+public @interface Handler {\n+\n+    /**\n+     * Add any numbers of filters to the handler. All filters are evaluated before the handler\n+     * is actually invoked, which is only if all the filters accept the message.\n+     */\n+\tFilter[] filters() default {};\n+\n+    /**\n+     * Define the mode in which a message is delivered to each listener. Listeners can be notified\n+     * sequentially or concurrently.\n+     *\n+     */\n+    Mode delivery() default Mode.Sequential;\n+\n+    /**\n+     * Handlers are ordered by priority and handlers with higher priority are processed before\n+     * those with lower priority, i.e. Influence the order in which different handlers that consume\n+     * the same message type are invoked.\n+     */\n+    int priority() default 0;\n+\n+    /**\n+     * Define whether or not the handler accepts sub types of the message type it declares in its\n+     * signature.\n+     */\n+    boolean rejectSubtypes() default false;\n+\n+\n+    /**\n+     * Enable or disable the handler. Disabled handlers do not receive any messages.\n+     * This property is useful for quick changes in configuration and necessary to disable\n+     * handlers that have been declared by a superclass but do not apply to the subclass\n+     */\n+    boolean enabled() default true;\n+\n+}\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Listener.java",
            "additions": 0,
            "deletions": 28
        },
        "diff content": "@@ -1,28 +0,0 @@\n-package net.engio.mbassy.listener;\n-\n-import java.lang.annotation.*;\n-\n-/**\n- * Mark any method of any object as a message handler and configure the handler\n- * using different properties.\n- *\n- * @author bennidi\n- * Date: 2/8/12\n- */\n-@Retention(value = RetentionPolicy.RUNTIME)\n-@Inherited\n-@Target(value = {ElementType.METHOD})\n-public @interface Listener {\n-\n-\n-\tFilter[] filters() default {}; // no filters by default\n-\n-    Mode delivery() default Mode.Sequential;\n-\n-    int priority() default 0;\n-\n-    boolean rejectSubtypes() default false;\n-\n-    boolean enabled() default true;\n-\n-}\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java",
            "additions": 7,
            "deletions": 7
        },
        "diff content": "@@ -16,7 +16,7 @@ public class MessageHandlerMetadata {\n \n     private IMessageFilter[] filter;\n \n-    private Listener listenerConfig;\n+    private Handler handlerConfig;\n \n     private boolean isAsynchronous = false;\n \n@@ -27,13 +27,13 @@ public class MessageHandlerMetadata {\n     private boolean acceptsSubtypes = true;\n \n \n-    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Listener listenerConfig) {\n+    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Handler handlerConfig) {\n         this.handler = handler;\n         this.filter = filter;\n-        this.listenerConfig = listenerConfig;\n-        this.isAsynchronous = listenerConfig.delivery().equals(Mode.Concurrent);\n+        this.handlerConfig = handlerConfig;\n+        this.isAsynchronous = handlerConfig.delivery().equals(Mode.Concurrent);\n         this.envelope = handler.getAnnotation(Enveloped.class);\n-        this.acceptsSubtypes = !listenerConfig.rejectSubtypes();\n+        this.acceptsSubtypes = !handlerConfig.rejectSubtypes();\n         if(this.envelope != null){\n             for(Class messageType : envelope.messages())\n                 handledMessages.add(messageType);\n@@ -54,7 +54,7 @@ public class MessageHandlerMetadata {\n     }\n \n     public int getPriority(){\n-        return listenerConfig.priority();\n+        return handlerConfig.priority();\n     }\n \n     public Method getHandler() {\n@@ -87,6 +87,6 @@ public class MessageHandlerMetadata {\n \n \n     public boolean isEnabled() {\n-        return listenerConfig.enabled();\n+        return handlerConfig.enabled();\n     }\n }\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MetadataReader.java",
            "additions": 10,
            "deletions": 10
        },
        "diff content": "@@ -16,11 +16,11 @@ import java.util.*;\n  */\n public class MetadataReader {\n \n-    //  This predicate is used to find all message listeners (methods annotated with @Listener)\n+    //  This predicate is used to find all message listeners (methods annotated with @Handler)\n     private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n         @Override\n         public boolean apply(Method target) {\n-            return target.getAnnotation(Listener.class) != null;\n+            return target.getAnnotation(Handler.class) != null;\n         }\n     };\n \n@@ -28,7 +28,7 @@ public class MetadataReader {\n     private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n \n     // retrieve all instances of filters associated with the given subscription\n-    private IMessageFilter[] getFilter(Listener subscription){\n+    private IMessageFilter[] getFilter(Handler subscription){\n         if (subscription.filters().length == 0) return null;\n         IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n         int i = 0;\n@@ -52,14 +52,14 @@ public class MetadataReader {\n \n \n     public MessageHandlerMetadata getHandlerMetadata(Method messageHandler){\n-        Listener config = messageHandler.getAnnotation(Listener.class);\n+        Handler config = messageHandler.getAnnotation(Handler.class);\n         return new MessageHandlerMetadata(messageHandler, getFilter(config), config);\n     }\n \n     // get all listeners defined by the given class (includes\n     // listeners defined in super classes)\n     public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n-        // get all handlers (this will include all (inherited) methods directly annotated using @Listener)\n+        // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n         List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n         // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n         List<Method> bottomMostHandlers = new LinkedList<Method>();\n@@ -71,15 +71,15 @@ public class MetadataReader {\n \n \n         List<MessageHandlerMetadata>  filteredHandlers = new LinkedList<MessageHandlerMetadata>();\n-        // for each handler there will be no overriding method that specifies @Listener annotation\n+        // for each handler there will be no overriding method that specifies @Handler annotation\n         // but an overriding method does inherit the listener configuration of the overwritten method\n         for(Method handler : bottomMostHandlers){\n-            Listener listener = handler.getAnnotation(Listener.class);\n-            if(!listener.enabled() || !isValidMessageHandler(handler)) continue; // disabled or invalid listeners are ignored\n+            Handler handle = handler.getAnnotation(Handler.class);\n+            if(!handle.enabled() || !isValidMessageHandler(handler)) continue; // disabled or invalid listeners are ignored\n             Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n             // if a handler is overwritten it inherits the configuration of its parent method\n             MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n-                    getFilter(listener), listener);\n+                    getFilter(handle), handle);\n             filteredHandlers.add(handlerMetadata);\n \n         }\n@@ -94,7 +94,7 @@ public class MetadataReader {\n \n \n     private boolean isValidMessageHandler(Method handler) {\n-        if(handler == null || handler.getAnnotation(Listener.class) == null){\n+        if(handler == null || handler.getAnnotation(Handler.class) == null){\n             return false;\n         }\n         if (handler.getParameterTypes().length != 1) {\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -1,8 +1,7 @@\n package net.engio.mbassy.subscription;\n \n-import net.engio.mbassy.IMessageBus;\n+import net.engio.mbassy.bus.IMessageBus;\n import net.engio.mbassy.dispatch.ISubscriptionContextAware;\n-import net.engio.mbassy.dispatch.SubscriptionContext;\n \n /**\n  * The base implementation for subscription context aware objects (mightily obvious :)\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -3,10 +3,9 @@ package net.engio.mbassy.subscription;\n import java.util.Comparator;\n import java.util.UUID;\n \n-import net.engio.mbassy.MessagePublication;\n+import net.engio.mbassy.bus.MessagePublication;\n import net.engio.mbassy.common.ConcurrentSet;\n import net.engio.mbassy.dispatch.IMessageDispatcher;\n-import net.engio.mbassy.dispatch.SubscriptionContext;\n \n /**\n  * A subscription is a thread safe container for objects that contain message handlers\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,6 @@\n-package net.engio.mbassy.dispatch;\n+package net.engio.mbassy.subscription;\n \n-import net.engio.mbassy.IMessageBus;\n+import net.engio.mbassy.bus.IMessageBus;\n import net.engio.mbassy.listener.MessageHandlerMetadata;\n \n /**\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1,7 +1,6 @@\n package net.engio.mbassy.subscription;\n \n import net.engio.mbassy.dispatch.*;\n-import net.engio.mbassy.dispatch.SubscriptionContext;\n \n /**\n  * Created with IntelliJ IDEA.\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AllTests.java",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy;\n \n+import net.engio.mbassy.bus.ListenerSubscriptionTest;\n import org.junit.runner.RunWith;\n import org.junit.runners.Suite;\n \n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/DeadEventTest.java",
            "additions": 10,
            "deletions": 8
        },
        "diff content": "@@ -1,9 +1,11 @@\n package net.engio.mbassy;\n \n+import net.engio.mbassy.bus.BusConfiguration;\n+import net.engio.mbassy.bus.MBassador;\n import net.engio.mbassy.common.ConcurrentSet;\n-import net.engio.mbassy.common.DeadEvent;\n-import net.engio.mbassy.common.UnitTest;\n-import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.common.DeadMessage;\n+import net.engio.mbassy.common.MessageBusTest;\n+import net.engio.mbassy.listener.Handler;\n import org.junit.Test;\n \n /**\n@@ -12,12 +14,12 @@ import org.junit.Test;\n  * @author bennidi\n  *         Date: 1/18/13\n  */\n-public class DeadEventTest extends UnitTest{\n+public class DeadEventTest extends MessageBusTest{\n \n \n     @Test\n     public void testDeadEvent(){\n-        MBassador bus = new MBassador(BusConfiguration.Default());\n+        MBassador bus = getBus(BusConfiguration.Default());\n         DeadEventHandler deadEventHandler = new DeadEventHandler();\n         bus.subscribe(deadEventHandler);\n         assertEquals(0, deadEventHandler.getDeadEventCount());\n@@ -33,9 +35,9 @@ public class DeadEventTest extends UnitTest{\n \n          private ConcurrentSet deadEvents = new ConcurrentSet();\n \n-        @Listener\n-         public void handle(DeadEvent event){\n-             deadEvents.add(event);\n+        @Handler\n+         public void handle(DeadMessage message){\n+             deadEvents.add(message);\n          }\n \n \n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/FilterTest.java",
            "additions": 77,
            "deletions": 23
        },
        "diff content": "@@ -1,17 +1,19 @@\n package net.engio.mbassy;\n \n import java.util.List;\n-\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import net.engio.mbassy.bus.BusConfiguration;\n+import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.common.DeadMessage;\n+import net.engio.mbassy.common.FilteredMessage;\n+import net.engio.mbassy.common.MessageBusTest;\n+import net.engio.mbassy.events.SubTestMessage;\n+import net.engio.mbassy.listener.*;\n import org.junit.Test;\n import net.engio.mbassy.common.TestUtil;\n-import net.engio.mbassy.common.UnitTest;\n-import net.engio.mbassy.events.SubTestEvent;\n-import net.engio.mbassy.events.TestEvent;\n-import net.engio.mbassy.listener.Filter;\n-import net.engio.mbassy.listener.Filters;\n-import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.events.TestMessage;\n import net.engio.mbassy.listeners.ListenerFactory;\n-import net.engio.mbassy.listeners.NonListeningBean;\n \n /**\n  * Testing of filter functionality\n@@ -19,42 +21,94 @@ import net.engio.mbassy.listeners.NonListeningBean;\n  * @author bennidi\n  *         Date: 11/26/12\n  */\n-public class FilterTest extends UnitTest {\n+public class FilterTest extends MessageBusTest {\n+\n+    private static final AtomicInteger FilteredEventCounter = new AtomicInteger(0);\n+    private static final AtomicInteger DeadEventCounter = new AtomicInteger(0);\n \n     @Test\n     public void testSubclassFilter() throws Exception {\n \n-        MBassador bus = new MBassador(new BusConfiguration());\n+        MBassador bus = getBus(new BusConfiguration());\n         ListenerFactory listenerFactory = new ListenerFactory()\n-                .create(100, FilteredMessageListener.class)\n-                .create(100, Object.class)\n-                .create(100, NonListeningBean.class);\n+                .create(100, FilteredMessageListener.class);\n \n         List<Object> listeners = listenerFactory.build();\n \n         // this will subscribe the listeners concurrently to the bus\n         TestUtil.setup(bus, listeners, 10);\n \n-        TestEvent event = new TestEvent();\n-        TestEvent subTestEvent = new SubTestEvent();\n-\n-        bus.post(event).now();\n-        bus.post(subTestEvent).now();\n+        TestMessage message = new TestMessage();\n+        TestMessage subTestMessage = new SubTestMessage();\n \n-        assertEquals(100, event.counter.get());\n-        assertEquals(0, subTestEvent.counter.get());\n+        bus.post(message).now();\n+        bus.post(subTestMessage).now();\n \n+        assertEquals(100, message.counter.get());\n+        assertEquals(0, subTestMessage.counter.get());\n+        assertEquals(100, FilteredEventCounter.get());\n     }\n \n+    @Test\n+    public void testFilteredFilteredEvent() throws Exception {\n+        FilteredEventCounter.set(0);\n+        DeadEventCounter.set(0);\n+\n+        MBassador bus = getBus(new BusConfiguration());\n+        ListenerFactory listenerFactory = new ListenerFactory()\n+                .create(100, FilteredMessageListener.class);\n+\n+        List<Object> listeners = listenerFactory.build();\n+\n+        // this will subscribe the listeners concurrently to the bus\n+        TestUtil.setup(bus, listeners, 10);\n+\n+        bus.post(new Object()).now();\n+        bus.post(new SubTestMessage()).now();\n+\n+        assertEquals(100, FilteredEventCounter.get()); // the SubTestMessage should have been republished as a filtered event\n+        assertEquals(100, DeadEventCounter.get()); // Object.class was filtered and the fil\n+    }\n \n     public static class FilteredMessageListener{\n \n-        @Listener(filters = {@Filter(Filters.RejectSubtypes.class)})\n-        public void handleTestEvent(TestEvent event){\n-            event.counter.incrementAndGet();\n+        // NOTE: Use rejectSubtypes property of @Handler to achieve the same functionality but with better performance\n+        // and more concise syntax\n+        @Handler(filters = {@Filter(Filters.RejectSubtypes.class)})\n+        public void handleTestMessage(TestMessage message){\n+            message.counter.incrementAndGet();\n+        }\n+\n+        // FilteredEvents that contain messages of class Object will be filtered (again) and should cause a DeadEvent to be thrown\n+        @Handler(filters = {@Filter(RejectFilteredObjects.class)})\n+        public void handleFilteredEvent(FilteredMessage filtered){\n+            FilteredEventCounter.incrementAndGet();\n+        }\n+\n+        // will cause republication of a FilteredEvent\n+        @Handler(filters = {@Filter(Filters.RejectAll.class)})\n+        public void handleNone(Object any){\n+            FilteredEventCounter.incrementAndGet();\n         }\n \n+        // will cause republication of a FilteredEvent\n+        @Handler\n+        public void handleDead(DeadMessage dead){\n+            DeadEventCounter.incrementAndGet();\n+        }\n+\n+\n+    }\n+\n+    public static class RejectFilteredObjects implements IMessageFilter{\n \n+        @Override\n+        public boolean accepts(Object message, MessageHandlerMetadata metadata) {\n+            if(message.getClass().equals(FilteredMessage.class) && ((FilteredMessage)message).getMessage().getClass().equals(Object.class)){\n+                return false;\n+            }\n+            return true;\n+        }\n     }\n \n }\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MessagePublicationTest.java",
            "additions": 37,
            "deletions": 35
        },
        "diff content": "@@ -3,13 +3,15 @@ package net.engio.mbassy;\n import java.util.List;\n import java.util.concurrent.CopyOnWriteArrayList;\n \n+import net.engio.mbassy.bus.BusConfiguration;\n+import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.common.MessageBusTest;\n+import net.engio.mbassy.events.SubTestMessage;\n import org.junit.Test;\n import net.engio.mbassy.common.ConcurrentExecutor;\n import net.engio.mbassy.common.TestUtil;\n-import net.engio.mbassy.common.UnitTest;\n-import net.engio.mbassy.events.SubTestEvent;\n-import net.engio.mbassy.events.TestEvent;\n-import net.engio.mbassy.events.TestEvent2;\n+import net.engio.mbassy.events.TestMessage;\n+import net.engio.mbassy.events.TestMessage2;\n import net.engio.mbassy.listeners.EventingTestBean;\n import net.engio.mbassy.listeners.EventingTestBean2;\n import net.engio.mbassy.listeners.EventingTestBean3;\n@@ -23,7 +25,7 @@ import net.engio.mbassy.listeners.NonListeningBean;\n  * @author bennidi\n  *         Date: 2/8/12\n  */\n-public class MessagePublicationTest extends UnitTest {\n+public class MessagePublicationTest extends MessageBusTest {\n \n     // this value probably needs to be adjusted depending on the performance of the underlying plattform\n     // otherwise the tests will fail since asynchronous processing might not have finished when\n@@ -34,7 +36,7 @@ public class MessagePublicationTest extends UnitTest {\n     @Test\n     public void testAsynchronousMessagePublication() throws Exception {\n \n-        MBassador bus = new MBassador(new BusConfiguration());\n+        MBassador bus = getBus(new BusConfiguration());\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(10000, EventingTestBean.class)\n                 .create(10000, EventingTestBean2.class)\n@@ -48,26 +50,26 @@ public class MessagePublicationTest extends UnitTest {\n         // this will subscribe the listeners concurrently to the bus\n         TestUtil.setup(bus, listeners, 10);\n \n-        TestEvent event = new TestEvent();\n-        TestEvent subEvent = new SubTestEvent();\n-        TestEvent2 event2 = new TestEvent2();\n+        TestMessage message = new TestMessage();\n+        TestMessage subMessage = new SubTestMessage();\n+        TestMessage2 message2 = new TestMessage2();\n \n-        bus.publishAsync(event);\n-        bus.publishAsync(subEvent);\n-        bus.publishAsync(event2);\n+        bus.publishAsync(message);\n+        bus.publishAsync(subMessage);\n+        bus.publishAsync(message2);\n \n         pause(processingTimeInMS);\n \n-        assertEquals(50000, event.counter.get());\n-        assertEquals(80000, subEvent.counter.get());\n-        assertEquals(20000, event2.counter.get());\n+        assertEquals(50000, message.counter.get());\n+        assertEquals(80000, subMessage.counter.get());\n+        assertEquals(20000, message2.counter.get());\n \n     }\n \n     @Test\n     public void testSynchronousMessagePublication() throws Exception {\n \n-        MBassador bus = new MBassador(new BusConfiguration());\n+        MBassador bus = getBus(new BusConfiguration());\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(10000, EventingTestBean.class)\n                 .create(10000, EventingTestBean2.class)\n@@ -80,27 +82,27 @@ public class MessagePublicationTest extends UnitTest {\n         // this will subscribe the listeners concurrently to the bus\n         TestUtil.setup(bus, listeners, 10);\n \n-        TestEvent event = new TestEvent();\n-        TestEvent subEvent = new SubTestEvent();\n+        TestMessage message = new TestMessage();\n+        TestMessage subMessage = new SubTestMessage();\n \n-        bus.publish(event);\n-        bus.publish(subEvent);\n+        bus.publish(message);\n+        bus.publish(subMessage);\n \n         pause(processingTimeInMS);\n \n-        assertEquals(30000, event.counter.get());\n-        assertEquals(70000, subEvent.counter.get());\n+        assertEquals(30000, message.counter.get());\n+        assertEquals(70000, subMessage.counter.get());\n \n     }\n \n     @Test\n     public void testConcurrentMixedMessagePublication() throws Exception {\n-        final CopyOnWriteArrayList<TestEvent> testEvents = new CopyOnWriteArrayList<TestEvent>();\n-        final CopyOnWriteArrayList<SubTestEvent> subtestEvents = new CopyOnWriteArrayList<SubTestEvent>();\n+        final CopyOnWriteArrayList<TestMessage> testMessages = new CopyOnWriteArrayList<TestMessage>();\n+        final CopyOnWriteArrayList<SubTestMessage> subtestMessages = new CopyOnWriteArrayList<SubTestMessage>();\n         final int eventLoopsPerTHread = 100;\n \n \n-        final MBassador bus = new MBassador(new BusConfiguration());\n+        final MBassador bus = getBus(new BusConfiguration());\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(10000, EventingTestBean.class)\n                 .create(10000, EventingTestBean2.class)\n@@ -117,25 +119,25 @@ public class MessagePublicationTest extends UnitTest {\n             @Override\n             public void run() {\n                 for (int i = 0; i < eventLoopsPerTHread; i++) {\n-                    TestEvent event = new TestEvent();\n-                    SubTestEvent subEvent = new SubTestEvent();\n-                    testEvents.add(event);\n-                    subtestEvents.add(subEvent);\n+                    TestMessage message = new TestMessage();\n+                    SubTestMessage subMessage = new SubTestMessage();\n+                    testMessages.add(message);\n+                    subtestMessages.add(subMessage);\n \n-                    bus.publishAsync(event);\n-                    bus.publish(subEvent);\n+                    bus.publishAsync(message);\n+                    bus.publish(subMessage);\n                 }\n             }\n         }, 10);\n \n         pause(processingTimeInMS);\n \n-        for (TestEvent event : testEvents) {\n-            assertEquals(30000, event.counter.get());\n+        for (TestMessage message : testMessages) {\n+            assertEquals(30000, message.counter.get());\n         }\n \n-        for (SubTestEvent event : subtestEvents) {\n-            assertEquals(70000, event.counter.get());\n+        for (SubTestMessage message : subtestMessages) {\n+            assertEquals(70000, message.counter.get());\n         }\n \n     }\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MetadataReaderTest.java",
            "additions": 9,
            "deletions": 9
        },
        "diff content": "@@ -3,7 +3,7 @@ package net.engio.mbassy;\n import org.junit.Test;\n import net.engio.mbassy.common.UnitTest;\n import net.engio.mbassy.listener.Enveloped;\n-import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.MessageListenerMetadata;\n import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.subscription.MessageEnvelope;\n@@ -112,18 +112,18 @@ public class MetadataReaderTest extends UnitTest {\n     // a simple event listener\n     public class EventListener1 {\n \n-        @Listener(rejectSubtypes = true)\n+        @Handler(rejectSubtypes = true)\n         public void handleObject(Object o) {\n \n         }\n \n-        @Listener\n+        @Handler\n         public void handleAny(Object o) {\n \n         }\n \n \n-        @Listener\n+        @Handler\n         public void handleString(String s) {\n \n         }\n@@ -143,12 +143,12 @@ public class MetadataReaderTest extends UnitTest {\n     public class EventListener3 extends EventListener2 {\n \n         // narrow the handler\n-        @Listener(rejectSubtypes = true)\n+        @Handler(rejectSubtypes = true)\n         public void handleAny(Object o) {\n \n         }\n \n-        @Listener(enabled = false)\n+        @Handler(enabled = false)\n         public void handleString(String s) {\n \n         }\n@@ -158,13 +158,13 @@ public class MetadataReaderTest extends UnitTest {\n     public class EnvelopedListener{\n \n \n-        @Listener(rejectSubtypes = true)\n+        @Handler(rejectSubtypes = true)\n         @Enveloped(messages = {String.class, Integer.class, Long.class})\n         public void handleEnveloped(MessageEnvelope o) {\n \n         }\n \n-        @Listener\n+        @Handler\n         @Enveloped(messages = {Number.class})\n         public void handleEnveloped2(MessageEnvelope o) {\n \n@@ -175,7 +175,7 @@ public class MetadataReaderTest extends UnitTest {\n     public class EnvelopedListenerSubclass extends EnvelopedListener{\n \n         // narrow to integer\n-        @Listener\n+        @Handler\n         @Enveloped(messages = {Integer.class})\n         public void handleEnveloped2(MessageEnvelope o) {\n \n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MethodDispatchTest.java",
            "additions": 7,
            "deletions": 5
        },
        "diff content": "@@ -1,7 +1,9 @@\n package net.engio.mbassy;\n \n-import net.engio.mbassy.common.UnitTest;\n-import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.bus.BusConfiguration;\n+import net.engio.mbassy.bus.IMessageBus;\n+import net.engio.mbassy.common.MessageBusTest;\n+import net.engio.mbassy.listener.Handler;\n import org.junit.Test;\n \n /**\n@@ -10,7 +12,7 @@ import org.junit.Test;\n  * @author bennidi\n  *         Date: 1/17/13\n  */\n-public class MethodDispatchTest extends UnitTest{\n+public class MethodDispatchTest extends MessageBusTest{\n \n    private boolean listener1Called = false;\n    private boolean listener2Called = false;\n@@ -20,7 +22,7 @@ public class MethodDispatchTest extends UnitTest{\n     // a simple event listener\n     public class EventListener1 {\n \n-        @Listener\n+        @Handler\n         public void handleString(String s) {\n              listener1Called = true;\n         }\n@@ -39,7 +41,7 @@ public class MethodDispatchTest extends UnitTest{\n \n     @Test\n     public void testDispatch1(){\n-        MBassador bus = new MBassador(BusConfiguration.Default());\n+        IMessageBus bus = getBus(BusConfiguration.Default());\n         EventListener2 listener2 = new EventListener2();\n         bus.subscribe(listener2);\n         bus.post(\"jfndf\").now();\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/bus/ListenerSubscriptionTest.java",
            "additions": 15,
            "deletions": 13
        },
        "diff content": "@@ -1,10 +1,12 @@\n-package net.engio.mbassy;\n+package net.engio.mbassy.bus;\n \n+import net.engio.mbassy.bus.BusConfiguration;\n+import net.engio.mbassy.bus.MBassador;\n+import net.engio.mbassy.common.MessageBusTest;\n+import net.engio.mbassy.events.SubTestMessage;\n import org.junit.Test;\n import net.engio.mbassy.common.TestUtil;\n-import net.engio.mbassy.common.UnitTest;\n-import net.engio.mbassy.events.SubTestEvent;\n-import net.engio.mbassy.events.TestEvent;\n+import net.engio.mbassy.events.TestMessage;\n import net.engio.mbassy.listeners.*;\n import net.engio.mbassy.subscription.Subscription;\n \n@@ -18,13 +20,13 @@ import java.util.List;\n  * @author bennidi\n  *         Date: 1/9/13\n  */\n-public class ListenerSubscriptionTest extends UnitTest{\n+public class ListenerSubscriptionTest extends MessageBusTest{\n \n \n     // this is a single threaded test for subscribing and unsubscribing of a single listener\n     @Test\n     public void testSubscribeSimple() throws InterruptedException {\n-        MBassador bus = new MBassador(new BusConfiguration());\n+        MBassador bus = getBus(new BusConfiguration());\n         List<Object> listeners = new LinkedList<Object>();\n         int listenerCount = 200000;\n \n@@ -43,11 +45,11 @@ public class ListenerSubscriptionTest extends UnitTest{\n         }\n \n         // check the generated subscriptions for existence of all previously subscribed valid listeners\n-        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n+        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n         assertEquals(1, testEventsubscriptions.size());\n         assertEquals(listenerCount, getNumberOfSubscribedListeners(testEventsubscriptions));\n \n-        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n+        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n         assertEquals(3, subTestEventsubscriptions.size());\n         assertEquals(3 * listenerCount, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n \n@@ -57,11 +59,11 @@ public class ListenerSubscriptionTest extends UnitTest{\n         }\n \n         // no listener should be left\n-        testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n+        testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n         assertEquals(1, testEventsubscriptions.size());\n         assertEquals(0, getNumberOfSubscribedListeners(testEventsubscriptions));\n \n-        subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n+        subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n         assertEquals(3, subTestEventsubscriptions.size());\n         assertEquals(0, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n \n@@ -78,7 +80,7 @@ public class ListenerSubscriptionTest extends UnitTest{\n     @Test\n     public void testConcurrentSubscription() throws Exception {\n \n-        MBassador bus = new MBassador(new BusConfiguration());\n+        MBassador bus = getBus(new BusConfiguration());\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(10000, EventingTestBean.class)\n                 .create(10000, EventingTestBean2.class)\n@@ -92,11 +94,11 @@ public class ListenerSubscriptionTest extends UnitTest{\n         TestUtil.setup(bus, listeners, 10);\n \n         // check the generated subscriptions for existence of all previously subscribed valid listeners\n-        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n+        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n         assertEquals(3, testEventsubscriptions.size());\n         assertEquals(30000, getNumberOfSubscribedListeners(testEventsubscriptions));\n \n-        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n+        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n         assertEquals(10, subTestEventsubscriptions.size());\n         assertEquals(100000, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n \n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/MessageBusTest.java",
            "additions": 31,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,31 @@\n+package net.engio.mbassy.common;\n+\n+import junit.framework.Assert;\n+import net.engio.mbassy.*;\n+import net.engio.mbassy.bus.BusConfiguration;\n+import net.engio.mbassy.bus.MBassador;\n+\n+/**\n+ * A base test that provides a factory for message bus that makes tests fail if any\n+ * publication error occurs\n+ *\n+ * @author bennidi\n+ *         Date: 3/2/13\n+ */\n+public class MessageBusTest extends UnitTest{\n+\n+    private static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n+        @Override\n+        public void handleError(PublicationError error) {\n+            Assert.fail();\n+        }\n+    };\n+\n+    public MBassador getBus(BusConfiguration configuration){\n+        MBassador bus = new MBassador(configuration);\n+        bus.addErrorHandler(TestFailingHandler);\n+        return bus;\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/TestUtil.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.common;\n \n-import net.engio.mbassy.IMessageBus;\n+import net.engio.mbassy.bus.IMessageBus;\n \n import java.util.List;\n \n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/events/SubTestMessage.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -5,6 +5,6 @@ package net.engio.mbassy.events;\n  * @author bennidi\n  *         Date: 11/22/12\n  */\n-public class SubTestEvent extends TestEvent {\n+public class SubTestMessage extends TestMessage {\n \n }\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/events/TestMessage.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -8,7 +8,7 @@ import java.util.concurrent.atomic.AtomicInteger;\n * @author bennidi\n * Date: 11/22/12\n */\n-public class TestEvent2 {\n+public class TestMessage {\n \n     public AtomicInteger counter = new AtomicInteger();\n \n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/events/TestMessage2.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -8,7 +8,7 @@ import java.util.concurrent.atomic.AtomicInteger;\n * @author bennidi\n * Date: 11/22/12\n */\n-public class TestEvent {\n+public class TestMessage2 {\n \n     public AtomicInteger counter = new AtomicInteger();\n \n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean.java",
            "additions": 11,
            "deletions": 11
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.listeners;\n \n-import net.engio.mbassy.events.SubTestEvent;\n-import net.engio.mbassy.events.TestEvent;\n+import net.engio.mbassy.events.SubTestMessage;\n+import net.engio.mbassy.events.TestMessage;\n import net.engio.mbassy.listener.*;\n \n /**\n@@ -14,25 +14,25 @@ public class EventingTestBean {\n \n     // every event of type TestEvent or any subtype will be delivered\n     // to this listener\n-    @Listener\n-    public void handleTestEvent(TestEvent event) {\n-        event.counter.incrementAndGet();\n+    @Handler\n+    public void handleTestEvent(TestMessage message) {\n+        message.counter.incrementAndGet();\n     }\n \n     // this handler will be invoked asynchronously\n-    @Listener(priority = 0, delivery = Mode.Concurrent)\n-    public void handleSubTestEvent(SubTestEvent event) {\n-        event.counter.incrementAndGet();\n+    @Handler(priority = 0, delivery = Mode.Concurrent)\n+    public void handleSubTestEvent(SubTestMessage message) {\n+        message.counter.incrementAndGet();\n     }\n \n     // this handler will receive events of type SubTestEvent\n     // or any subtabe and that passes the given filter\n-    @Listener(\n+    @Handler(\n             priority = 10,\n             delivery = Mode.Sequential,\n             filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n-    public void handleFiltered(SubTestEvent event) {\n-        event.counter.incrementAndGet();\n+    public void handleFiltered(SubTestMessage message) {\n+        message.counter.incrementAndGet();\n     }\n \n \n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java",
            "additions": 5,
            "deletions": 5
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.listeners;\n \n-import net.engio.mbassy.events.SubTestEvent;\n-import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.events.SubTestMessage;\n+import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Mode;\n \n /**\n@@ -11,8 +11,8 @@ import net.engio.mbassy.listener.Mode;\n public class EventingTestBean2 extends EventingTestBean{\n \n     // redefine the configuration for this handler\n-    @Listener(delivery = Mode.Sequential)\n-    public void handleSubTestEvent(SubTestEvent event) {\n-        super.handleSubTestEvent(event);\n+    @Handler(delivery = Mode.Sequential)\n+    public void handleSubTestEvent(SubTestMessage message) {\n+        super.handleSubTestEvent(message);\n     }\n }\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java",
            "additions": 5,
            "deletions": 5
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy.listeners;\n \n-import net.engio.mbassy.events.SubTestEvent;\n-import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.events.SubTestMessage;\n+import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Mode;\n \n /**\n@@ -12,9 +12,9 @@ public class EventingTestBean3 extends EventingTestBean2{\n \n \n     // this handler will be invoked asynchronously\n-    @Listener(priority = 0, delivery = Mode.Sequential)\n-    public void handleSubTestEventAgain(SubTestEvent event) {\n-        event.counter.incrementAndGet();\n+    @Handler(priority = 0, delivery = Mode.Sequential)\n+    public void handleSubTestEventAgain(SubTestMessage message) {\n+        message.counter.incrementAndGet();\n     }\n \n }\n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java",
            "additions": 19,
            "deletions": 19
        },
        "diff content": "@@ -1,11 +1,11 @@\n package net.engio.mbassy.listeners;\n \n-import net.engio.mbassy.events.TestEvent;\n-import net.engio.mbassy.events.TestEvent2;\n+import net.engio.mbassy.events.TestMessage;\n+import net.engio.mbassy.events.TestMessage2;\n import net.engio.mbassy.listener.Enveloped;\n import net.engio.mbassy.listener.Filter;\n import net.engio.mbassy.listener.Filters;\n-import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.Handler;\n import net.engio.mbassy.listener.Mode;\n import net.engio.mbassy.subscription.MessageEnvelope;\n \n@@ -18,29 +18,29 @@ import net.engio.mbassy.subscription.MessageEnvelope;\n public class MultiEventHandler {\n \n \n-    @Listener(delivery = Mode.Sequential)\n-    @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n+    @Handler(delivery = Mode.Sequential)\n+    @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n     public void handleEvents(MessageEnvelope envelope) {\n-        if(TestEvent.class.isAssignableFrom(envelope.getMessage().getClass())){\n-            TestEvent event = envelope.getMessage();\n-            event.counter.incrementAndGet();\n+        if(TestMessage.class.isAssignableFrom(envelope.getMessage().getClass())){\n+            TestMessage message = envelope.getMessage();\n+            message.counter.incrementAndGet();\n         }\n-        if(envelope.getMessage().getClass().equals(TestEvent2.class)){\n-            TestEvent2 event = envelope.getMessage();\n-            event.counter.incrementAndGet();\n+        if(envelope.getMessage().getClass().equals(TestMessage2.class)){\n+            TestMessage2 message = envelope.getMessage();\n+            message.counter.incrementAndGet();\n         }\n     }\n \n-    @Listener(delivery = Mode.Sequential, filters = @Filter(Filters.RejectSubtypes.class))\n-    @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n+    @Handler(delivery = Mode.Sequential, filters = @Filter(Filters.RejectSubtypes.class))\n+    @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n     public void handleSuperTypeEvents(MessageEnvelope envelope) {\n-        if(TestEvent.class.isAssignableFrom(envelope.getMessage().getClass())){\n-            TestEvent event = envelope.getMessage();\n-            event.counter.incrementAndGet();\n+        if(TestMessage.class.isAssignableFrom(envelope.getMessage().getClass())){\n+            TestMessage message = envelope.getMessage();\n+            message.counter.incrementAndGet();\n         }\n-        if(envelope.getMessage().getClass().equals(TestEvent2.class)){\n-            TestEvent2 event = envelope.getMessage();\n-            event.counter.incrementAndGet();\n+        if(envelope.getMessage().getClass().equals(TestMessage2.class)){\n+            TestMessage2 message = envelope.getMessage();\n+            message.counter.incrementAndGet();\n         }\n     }\n \n"
    },
    {
        "commit hash": "e7a76287cb4e9019a2f977240b6d7aa16fea8fe9",
        "previous commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/NonListeningBean.java",
            "additions": 12,
            "deletions": 12
        },
        "diff content": "@@ -1,8 +1,8 @@\n package net.engio.mbassy.listeners;\n \n-import net.engio.mbassy.events.SubTestEvent;\n-import net.engio.mbassy.events.TestEvent;\n-import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.events.SubTestMessage;\n+import net.engio.mbassy.events.TestMessage;\n+import net.engio.mbassy.listener.Handler;\n \n /**\n  * This bean overrides all the handlers defined in its superclass. Since it does not specify any annotations\n@@ -15,20 +15,20 @@ public class NonListeningBean extends EventingTestBean{\n \n \n     @Override\n-    @Listener(enabled = false)\n-    public void handleTestEvent(TestEvent event) {\n-        event.counter.incrementAndGet();   // should never be called\n+    @Handler(enabled = false)\n+    public void handleTestEvent(TestMessage message) {\n+        message.counter.incrementAndGet();   // should never be called\n     }\n \n     @Override\n-    @Listener(enabled = false)\n-    public void handleSubTestEvent(SubTestEvent event) {\n-        event.counter.incrementAndGet();   // should never be called\n+    @Handler(enabled = false)\n+    public void handleSubTestEvent(SubTestMessage message) {\n+        message.counter.incrementAndGet();   // should never be called\n     }\n \n     @Override\n-    @Listener(enabled = false)\n-    public void handleFiltered(SubTestEvent event) {\n-        event.counter.incrementAndGet();   // should never be called\n+    @Handler(enabled = false)\n+    public void handleFiltered(SubTestMessage message) {\n+        message.counter.incrementAndGet();   // should never be called\n     }\n }\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/AbstractMessageBus.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,7 +1,7 @@\n package net.engio.mbassy;\n \n import net.engio.mbassy.common.ReflectionUtils;\n-import net.engio.mbassy.dispatch.MessagingContext;\n+import net.engio.mbassy.dispatch.SubscriptionContext;\n import net.engio.mbassy.listener.MessageHandlerMetadata;\n import net.engio.mbassy.listener.MetadataReader;\n import net.engio.mbassy.subscription.Subscription;\n@@ -122,7 +122,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n                         for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                             // create the subscription\n                             Subscription subscription = subscriptionFactory\n-                                    .createSubscription(new MessagingContext(this, messageHandler));\n+                                    .createSubscription(new SubscriptionContext(this, messageHandler));\n                             subscription.subscribe(listener);\n                             subscriptionsByListener.add(subscription);// add it for the listener type (for future subscriptions)\n \n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/MBassador.java",
            "additions": 2,
            "deletions": 19
        },
        "diff content": "@@ -27,9 +27,9 @@ public class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>>\n         if (subscriptions == null || subscriptions.isEmpty()) {\n             // Dead Event\n             subscriptions = getSubscriptionsByMessageType(DeadEvent.class);\n-            return MessagePublication.Create(subscriptions, new DeadEvent(message));\n+            return MessagePublication.Create(this, subscriptions, new DeadEvent(message));\n         }\n-        else return MessagePublication.Create(subscriptions, message);\n+        else return MessagePublication.Create(this, subscriptions, message);\n     }\n \n \n@@ -44,23 +44,6 @@ public class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>>\n         try {\n             MessagePublication publication = createMessagePublication(message);\n             publication.execute();\n-\n-            /*\n-            final Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n-            if (subscriptions == null || subscriptions.isEmpty()) {\n-                // publish a DeadEvent since no subscriptions could be found\n-                final Collection<Subscription> deadEventSubscriptions = getSubscriptionsByMessageType(DeadEvent.class);\n-                if (deadEventSubscriptions != null && !deadEventSubscriptions.isEmpty()) {\n-                    for (Subscription subscription : deadEventSubscriptions) {\n-                        subscription.publish(new DeadEvent(message));\n-                    }\n-                }\n-            }\n-            else{\n-                for (Subscription subscription : subscriptions) {\n-                    subscription.publish(message);\n-                }\n-            }*/\n         } catch (Throwable e) {\n             handlePublicationError(new PublicationError()\n                     .setMessage(\"Error during publication of message\")\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/MessagePublication.java",
            "additions": 24,
            "deletions": 4
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy;\n \n import net.engio.mbassy.common.DeadEvent;\n+import net.engio.mbassy.common.FilteredEvent;\n import net.engio.mbassy.subscription.Subscription;\n \n import java.util.Collection;\n@@ -10,13 +11,16 @@ import java.util.Collection;\n  * of the corresponding message publication process, i.e. provides information whether the\n  * publication was successfully scheduled, is currently running etc.\n  *\n+ * A message publication lives within a single thread. It is not designed in a thread-safe manner -> not eligible to\n+ * be used in multiple threads simultaneously .\n+ *\n  * @author bennidi\n  * Date: 11/16/12\n  */\n public class MessagePublication {\n \n-    public static  MessagePublication Create(Collection<Subscription> subscriptions, Object message){\n-        return new MessagePublication(subscriptions, message, State.Initial);\n+    public static  MessagePublication Create(IMessageBus bus, Collection<Subscription> subscriptions, Object message){\n+        return new MessagePublication(bus,subscriptions, message, State.Initial);\n     }\n \n     private Collection<Subscription> subscriptions;\n@@ -25,7 +29,12 @@ public class MessagePublication {\n \n     private State state = State.Scheduled;\n \n-    private MessagePublication(Collection<Subscription> subscriptions, Object message, State initialState) {\n+    private boolean delivered = false;\n+\n+    private IMessageBus bus;\n+\n+    private MessagePublication(IMessageBus bus, Collection<Subscription> subscriptions, Object message, State initialState) {\n+        this.bus = bus;\n         this.subscriptions = subscriptions;\n         this.message = message;\n         this.state = initialState;\n@@ -38,9 +47,12 @@ public class MessagePublication {\n     protected void execute(){\n         state = State.Running;\n         for(Subscription sub : subscriptions){\n-            sub.publish(message);\n+            sub.publish(this, message);\n         }\n         state = State.Finished;\n+        if(!delivered && !isFilteredEvent() && !isDeadEvent()){\n+            bus.post(new FilteredEvent(message)).now();\n+        }\n     }\n \n     public boolean isFinished() {\n@@ -55,6 +67,10 @@ public class MessagePublication {\n         return state.equals(State.Scheduled);\n     }\n \n+    public void markDelivered(){\n+        delivered = true;\n+    }\n+\n     public MessagePublication markScheduled(){\n         if(!state.equals(State.Initial))\n             return this;\n@@ -71,6 +87,10 @@ public class MessagePublication {\n         return DeadEvent.class.isAssignableFrom(message.getClass());\n     }\n \n+    public boolean isFilteredEvent(){\n+        return FilteredEvent.class.isAssignableFrom(message.getClass());\n+    }\n+\n     private enum State{\n         Initial,Scheduled,Running,Finished,Error;\n     }\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/DeadEvent.java",
            "additions": 3,
            "deletions": 8
        },
        "diff content": "@@ -7,15 +7,10 @@ package net.engio.mbassy.common;\n  * @author bennidi\n  *         Date: 1/18/13\n  */\n-public class DeadEvent {\n+public class DeadEvent extends PublicationEvent {\n \n-    private Object event;\n-\n-    public DeadEvent(Object event) {\n-        this.event = event;\n+    public DeadEvent(Object message) {\n+        super(message);\n     }\n \n-    public Object getEvent() {\n-        return event;\n-    }\n }\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/FilteredEvent.java",
            "additions": 17,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,17 @@\n+package net.engio.mbassy.common;\n+\n+/**\n+ * A filtered event is published when there have been matching subscriptions for a given\n+ * message publication but configured filters prevented the message from being delivered to\n+ * any of the handlers.\n+ *\n+ * @author bennidi\n+ *         Date: 3/1/13\n+ */\n+public class FilteredEvent extends PublicationEvent {\n+\n+\n+    public FilteredEvent(Object event) {\n+        super(event);\n+    }\n+}\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/PublicationEvent.java",
            "additions": 21,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,21 @@\n+package net.engio.mbassy.common;\n+\n+/**\n+ * A wrapped event is created when various conditions are matched (these depend on the concrete\n+ * (sub)type of wrapped event).\n+ *\n+ * @author bennidi\n+ *         Date: 3/1/13\n+ */\n+public abstract class PublicationEvent {\n+\n+    private Object event;\n+\n+    public PublicationEvent(Object message) {\n+        this.event = message;\n+    }\n+\n+    public Object getEvent() {\n+        return event;\n+    }\n+}\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/AbstractHandlerInvocation.java",
            "additions": 0,
            "deletions": 65
        },
        "diff content": "@@ -1,65 +0,0 @@\n-package net.engio.mbassy.dispatch;\n-\n-import net.engio.mbassy.IPublicationErrorHandler;\n-import net.engio.mbassy.PublicationError;\n-\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.util.Collection;\n-\n-/**\n- * Todo: Add javadoc\n- *\n- * @author bennidi\n- *         Date: 11/23/12\n- */\n-public class AbstractHandlerInvocation {\n-\n-    private MessagingContext context;\n-\n-    protected void handlePublicationError(PublicationError error){\n-        Collection<IPublicationErrorHandler> handlers = getContext().getOwningBus().getRegisteredErrorHandlers();\n-        for(IPublicationErrorHandler handler : handlers){\n-            handler.handleError(error);\n-        }\n-    }\n-\n-    protected void invokeHandler(final Object message, final Object listener, Method handler){\n-        try {\n-            handler.invoke(listener, message);\n-        }catch(IllegalAccessException e){\n-            handlePublicationError(\n-                    new PublicationError(e, \"Error during messageHandler notification. \" +\n-                            \"The class or method is not accessible\",\n-                            handler, listener, message));\n-        }\n-        catch(IllegalArgumentException e){\n-            handlePublicationError(\n-                    new PublicationError(e, \"Error during messageHandler notification. \" +\n-                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n-                            + \"Expected: \" + handler.getParameterTypes()[0],\n-                            handler, listener, message));\n-        }\n-        catch (InvocationTargetException e) {\n-            handlePublicationError(\n-                    new PublicationError(e, \"Error during messageHandler notification. \" +\n-                            \"Message handler threw exception\",\n-                            handler, listener, message));\n-        }\n-        catch (Throwable e) {\n-            handlePublicationError(\n-                    new PublicationError(e, \"Error during messageHandler notification. \" +\n-                            \"Unexpected exception\",\n-                            handler, listener, message));\n-        }\n-    }\n-\n-\n-    public AbstractHandlerInvocation(MessagingContext context) {\n-        this.context = context;\n-    }\n-\n-    public MessagingContext getContext() {\n-        return context;\n-    }\n-}\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java",
            "additions": 6,
            "deletions": 10
        },
        "diff content": "@@ -1,6 +1,7 @@\n package net.engio.mbassy.dispatch;\n \n-import java.lang.reflect.Method;\n+import net.engio.mbassy.MessagePublication;\n+import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n \n /**\n  * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n@@ -8,27 +9,22 @@ import java.lang.reflect.Method;\n  * @author bennidi\n  *         Date: 11/23/12\n  */\n-public class AsynchronousHandlerInvocation implements IHandlerInvocation {\n+public class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n \n     private IHandlerInvocation delegate;\n \n     public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n-        super();\n+        super(delegate.getContext());\n         this.delegate = delegate;\n     }\n \n     @Override\n-    public void invoke(final Method handler, final Object listener, final Object message) {\n+    public void invoke(final Object listener, final Object message) {\n         getContext().getOwningBus().getExecutor().execute(new Runnable() {\n             @Override\n             public void run() {\n-                delegate.invoke(handler, listener, message);\n+                delegate.invoke(listener, message);\n             }\n         });\n     }\n-\n-    @Override\n-    public MessagingContext getContext() {\n-        return delegate.getContext();\n-    }\n }\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/DelegatingMessageDispatcher.java",
            "additions": 30,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,30 @@\n+package net.engio.mbassy.dispatch;\n+\n+import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n+\n+/**\n+ * A delegating dispatcher wraps additional logic around a given delegate. Essentially its\n+ * an implementation of the decorator pattern.\n+ *\n+ * @author bennidi\n+ *         Date: 3/1/13\n+ */\n+public abstract class DelegatingMessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher{\n+\n+    private IMessageDispatcher delegate;\n+\n+\n+    public DelegatingMessageDispatcher(IMessageDispatcher delegate) {\n+        super(delegate.getContext());\n+        this.delegate = delegate;\n+    }\n+\n+    protected IMessageDispatcher getDelegate() {\n+        return delegate;\n+    }\n+\n+    @Override\n+    public IHandlerInvocation getInvocation() {\n+        return delegate.getInvocation();\n+    }\n+}\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java",
            "additions": 9,
            "deletions": 16
        },
        "diff content": "@@ -1,34 +1,27 @@\n package net.engio.mbassy.dispatch;\n \n+import net.engio.mbassy.MessagePublication;\n import net.engio.mbassy.common.ConcurrentSet;\n import net.engio.mbassy.subscription.MessageEnvelope;\n \n /**\n- * Todo: Add javadoc\n+ * The enveloped dispatcher will wrap published messages in an envelope before\n+ * passing them to their configured dispatcher.\n+ *\n+ * All enveloped message handlers will have this dispatcher in their chain\n  *\n  * @author bennidi\n  *         Date: 12/12/12\n  */\n-public class EnvelopedMessageDispatcher implements IMessageDispatcher {\n+public class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher{\n \n-    private IMessageDispatcher del;\n \n     public EnvelopedMessageDispatcher(IMessageDispatcher dispatcher) {\n-        this.del = dispatcher;\n-    }\n-\n-    @Override\n-    public void dispatch(Object message, ConcurrentSet listeners) {\n-        del.dispatch(new MessageEnvelope(message), listeners);\n-    }\n-\n-    @Override\n-    public MessagingContext getContext() {\n-        return del.getContext();\n+        super(dispatcher);\n     }\n \n     @Override\n-    public IHandlerInvocation getInvocation() {\n-        return del.getInvocation();\n+    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n+        getDelegate().dispatch(publication, new MessageEnvelope(message), listeners);\n     }\n }\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java",
            "additions": 5,
            "deletions": 17
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n+import net.engio.mbassy.MessagePublication;\n import net.engio.mbassy.common.ConcurrentSet;\n import net.engio.mbassy.listener.IMessageFilter;\n \n@@ -11,14 +12,12 @@ import net.engio.mbassy.listener.IMessageFilter;\n  * @author bennidi\n  *         Date: 11/23/12\n  */\n-public class FilteredMessageDispatcher implements IMessageDispatcher {\n+public class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n \n     private final IMessageFilter[] filter;\n \n-    private IMessageDispatcher del;\n-\n     public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\n-        this.del = dispatcher;\n+        super(dispatcher);\n         this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\n     }\n \n@@ -37,21 +36,10 @@ public class FilteredMessageDispatcher implements IMessageDispatcher {\n \n \n     @Override\n-    public void dispatch(Object message, ConcurrentSet listeners) {\n+    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n          if(passesFilter(message)){\n-             del.dispatch(message, listeners);\n+             getDelegate().dispatch(publication, message, listeners);\n          }\n     }\n \n-    @Override\n-    public MessagingContext getContext() {\n-        return del.getContext();\n-    }\n-\n-    @Override\n-    public IHandlerInvocation getInvocation() {\n-        return del.getInvocation();\n-    }\n-\n-\n }\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java",
            "additions": 4,
            "deletions": 10
        },
        "diff content": "@@ -1,6 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n-import java.lang.reflect.Method;\n+import net.engio.mbassy.MessagePublication;\n \n /**\n  * A handler invocation encapsulates the logic that is used to invoke a single\n@@ -11,21 +11,15 @@ import java.lang.reflect.Method;\n  * @author bennidi\n  *         Date: 11/23/12\n  */\n-public interface IHandlerInvocation {\n+public interface IHandlerInvocation extends ISubscriptionContextAware {\n \n     /**\n-     * Invoke the message delivery logic of this handler invocation\n+     * Invoke the message delivery logic of this handler\n      *\n-     * @param handler The method that represents the actual message handler logic of the listener\n      * @param listener The listener that will receive the message\n      * @param message  The message to be delivered to the listener\n      */\n-    public void invoke(final Method handler, final Object listener, final Object message);\n+    public void invoke(final Object listener, final Object message);\n \n-    /**\n-     * Get the messaging context associated with this invocation\n-     * @return\n-     */\n-    public MessagingContext getContext();\n \n }\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IMessageBusAware.java",
            "additions": 14,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,14 @@\n+package net.engio.mbassy.dispatch;\n+\n+import net.engio.mbassy.IMessageBus;\n+\n+/**\n+ * This interface marks components that have access to the message bus that they belong to.\n+ *\n+ * @author bennidi\n+ *         Date: 3/1/13\n+ */\n+public interface IMessageBusAware {\n+\n+    public IMessageBus getBus();\n+}\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java",
            "additions": 6,
            "deletions": 11
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy.dispatch;\n \n+import net.engio.mbassy.MessagePublication;\n import net.engio.mbassy.common.ConcurrentSet;\n \n /**\n@@ -11,30 +12,24 @@ import net.engio.mbassy.common.ConcurrentSet;\n  * handler invocation object associated with the dispatcher.\n  *\n  * Implementations if IMessageDispatcher are partially designed using decorator pattern\n- * such that it is possible to compose different message dispatchers to achieve more complex\n- * dispatch logic.\n+ * such that it is possible to compose different message dispatchers into dispatcher chains\n+ * to achieve more complex dispatch logic.\n  *\n  * @author bennidi\n  *         Date: 11/23/12\n  */\n-public interface IMessageDispatcher {\n+public interface IMessageDispatcher extends ISubscriptionContextAware {\n \n     /**\n      * Delivers the given message to the given set of listeners.\n      * Delivery may be delayed, aborted or restricted in various ways, depending\n      * on the configuration of the dispatcher\n      *\n+     * @param publication The message publication that initiated the dispatch\n      * @param message The message that should be delivered to the listeners\n      * @param listeners The listeners that should receive the message\n      */\n-    public void dispatch(Object message, ConcurrentSet listeners);\n-\n-    /**\n-     * Get the messaging context associated with this dispatcher\n-     *\n-     * @return\n-     */\n-    public MessagingContext getContext();\n+    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners);\n \n     /**\n      * Get the handler invocation that will be used to deliver the message to each\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/ISubscriptionContextAware.java",
            "additions": 17,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,17 @@\n+package net.engio.mbassy.dispatch;\n+\n+/**\n+ * This interface marks components that have access to the subscription context.\n+ *\n+ * @author bennidi\n+ *         Date: 3/1/13\n+ */\n+public interface ISubscriptionContextAware extends IMessageBusAware {\n+\n+    /**\n+     * Get the subscription context associated with this object\n+     *\n+     * @return\n+     */\n+    public SubscriptionContext getContext();\n+}\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java",
            "additions": 10,
            "deletions": 12
        },
        "diff content": "@@ -2,7 +2,10 @@ package net.engio.mbassy.dispatch;\n \n import java.lang.reflect.Method;\n \n+import net.engio.mbassy.IMessageBus;\n+import net.engio.mbassy.MessagePublication;\n import net.engio.mbassy.common.ConcurrentSet;\n+import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n \n /**\n  * Standard implementation for direct, unfiltered message delivery.\n@@ -14,31 +17,26 @@ import net.engio.mbassy.common.ConcurrentSet;\n  * @author bennidi\n  *         Date: 11/23/12\n  */\n-public class MessageDispatcher implements IMessageDispatcher {\n-\n-    private MessagingContext context;\n+public class MessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher {\n \n     private IHandlerInvocation invocation;\n \n-    public MessageDispatcher(MessagingContext context, IHandlerInvocation invocation) {\n-        this.context = context;\n+    public MessageDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n+        super(context);\n         this.invocation = invocation;\n     }\n \n     @Override\n-    public void dispatch(Object message, ConcurrentSet listeners) {\n-        Method handler = getContext().getHandlerMetadata().getHandler();\n+    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n+        publication.markDelivered();\n         for(Object listener: listeners){\n-            getInvocation().invoke(handler, listener, message);\n+            getInvocation().invoke(listener, message);\n         }\n     }\n \n-    public MessagingContext getContext() {\n-        return context;\n-    }\n-\n     @Override\n     public IHandlerInvocation getInvocation() {\n         return invocation;\n     }\n+\n }\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java",
            "additions": 48,
            "deletions": 4
        },
        "diff content": "@@ -1,6 +1,13 @@\n package net.engio.mbassy.dispatch;\n \n+import net.engio.mbassy.IPublicationErrorHandler;\n+import net.engio.mbassy.MessagePublication;\n+import net.engio.mbassy.PublicationError;\n+import net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n+\n+import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n+import java.util.Collection;\n \n /**\n  * Uses reflection to invoke a message handler for a given message.\n@@ -8,14 +15,51 @@ import java.lang.reflect.Method;\n  * @author bennidi\n  *         Date: 11/23/12\n  */\n-public class ReflectiveHandlerInvocation extends AbstractHandlerInvocation implements IHandlerInvocation {\n+public class ReflectiveHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation{\n \n-    public ReflectiveHandlerInvocation(MessagingContext context) {\n+    public ReflectiveHandlerInvocation(SubscriptionContext context) {\n         super(context);\n     }\n \n+    protected void handlePublicationError(PublicationError error){\n+        Collection<IPublicationErrorHandler> handlers = getContext().getOwningBus().getRegisteredErrorHandlers();\n+        for(IPublicationErrorHandler handler : handlers){\n+            handler.handleError(error);\n+        }\n+    }\n+\n+    protected void invokeHandler(final Object message, final Object listener, Method handler){\n+        try {\n+            handler.invoke(listener, message);\n+        }catch(IllegalAccessException e){\n+            handlePublicationError(\n+                    new PublicationError(e, \"Error during messageHandler notification. \" +\n+                            \"The class or method is not accessible\",\n+                            handler, listener, message));\n+        }\n+        catch(IllegalArgumentException e){\n+            handlePublicationError(\n+                    new PublicationError(e, \"Error during messageHandler notification. \" +\n+                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n+                            + \"Expected: \" + handler.getParameterTypes()[0],\n+                            handler, listener, message));\n+        }\n+        catch (InvocationTargetException e) {\n+            handlePublicationError(\n+                    new PublicationError(e, \"Error during messageHandler notification. \" +\n+                            \"Message handler threw exception\",\n+                            handler, listener, message));\n+        }\n+        catch (Throwable e) {\n+            handlePublicationError(\n+                    new PublicationError(e, \"Error during messageHandler notification. \" +\n+                            \"Unexpected exception\",\n+                            handler, listener, message));\n+        }\n+    }\n+\n     @Override\n-    public void invoke(final Method handler, final Object listener, final Object message) {\n-        invokeHandler(message, listener, handler);\n+    public void invoke(final Object listener, final Object message) {\n+        invokeHandler(message, listener, getContext().getHandlerMetadata().getHandler());\n     }\n }\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/SubscriptionContext.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -4,21 +4,21 @@ import net.engio.mbassy.IMessageBus;\n import net.engio.mbassy.listener.MessageHandlerMetadata;\n \n /**\n- * The messaging context holds all data/objects that is relevant to successfully publish\n+ * The subscription context holds all (meta)data/objects that are relevant to successfully publish\n  * a message within a subscription. A one-to-one relation between a subscription and\n- * MessagingContext holds -> a messaging context is created for each distinct subscription\n+ * subscription context holds -> a subscription context is created for each distinct subscription\n  * that lives inside a message bus.\n  *\n  * @author bennidi\n  *         Date: 11/23/12\n  */\n-public class MessagingContext {\n+public class SubscriptionContext {\n \n     private IMessageBus owningBus;\n \n     private MessageHandlerMetadata handlerMetadata;\n \n-    public MessagingContext(IMessageBus owningBus, MessageHandlerMetadata handlerMetadata) {\n+    public SubscriptionContext(IMessageBus owningBus, MessageHandlerMetadata handlerMetadata) {\n         this.owningBus = owningBus;\n         this.handlerMetadata = handlerMetadata;\n     }\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java",
            "additions": 29,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,29 @@\n+package net.engio.mbassy.subscription;\n+\n+import net.engio.mbassy.IMessageBus;\n+import net.engio.mbassy.dispatch.ISubscriptionContextAware;\n+import net.engio.mbassy.dispatch.SubscriptionContext;\n+\n+/**\n+ * The base implementation for subscription context aware objects (mightily obvious :)\n+ *\n+ * @author bennidi\n+ *         Date: 3/1/13\n+ */\n+public class AbstractSubscriptionContextAware implements ISubscriptionContextAware{\n+\n+    private SubscriptionContext context;\n+\n+    public AbstractSubscriptionContextAware(SubscriptionContext context) {\n+        this.context = context;\n+    }\n+\n+    public SubscriptionContext getContext() {\n+        return context;\n+    }\n+\n+    @Override\n+    public IMessageBus getBus() {\n+        return context.getOwningBus();\n+    }\n+}\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 6,
            "deletions": 9
        },
        "diff content": "@@ -3,9 +3,10 @@ package net.engio.mbassy.subscription;\n import java.util.Comparator;\n import java.util.UUID;\n \n+import net.engio.mbassy.MessagePublication;\n import net.engio.mbassy.common.ConcurrentSet;\n import net.engio.mbassy.dispatch.IMessageDispatcher;\n-import net.engio.mbassy.dispatch.MessagingContext;\n+import net.engio.mbassy.dispatch.SubscriptionContext;\n \n /**\n  * A subscription is a thread safe container for objects that contain message handlers\n@@ -18,9 +19,9 @@ public class Subscription {\n \n     private IMessageDispatcher dispatcher;\n \n-    private MessagingContext context;\n+    private SubscriptionContext context;\n \n-    public Subscription(MessagingContext context, IMessageDispatcher dispatcher) {\n+    public Subscription(SubscriptionContext context, IMessageDispatcher dispatcher) {\n         this.context = context;\n         this.dispatcher = dispatcher;\n     }\n@@ -31,12 +32,8 @@ public class Subscription {\n     }\n \n \n-    public void publish(Object message){\n-          dispatcher.dispatch(message, listeners);\n-    }\n-\n-    public MessagingContext getContext(){\n-        return context;\n+    public void publish(MessagePublication publication, Object message){\n+          dispatcher.dispatch(publication, message, listeners);\n     }\n \n     public int getPriority(){\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java",
            "additions": 5,
            "deletions": 11
        },
        "diff content": "@@ -1,13 +1,7 @@\n package net.engio.mbassy.subscription;\n \n-import net.engio.mbassy.dispatch.AsynchronousHandlerInvocation;\n-import net.engio.mbassy.dispatch.EnvelopedMessageDispatcher;\n-import net.engio.mbassy.dispatch.FilteredMessageDispatcher;\n-import net.engio.mbassy.dispatch.IHandlerInvocation;\n-import net.engio.mbassy.dispatch.IMessageDispatcher;\n-import net.engio.mbassy.dispatch.MessageDispatcher;\n-import net.engio.mbassy.dispatch.MessagingContext;\n-import net.engio.mbassy.dispatch.ReflectiveHandlerInvocation;\n+import net.engio.mbassy.dispatch.*;\n+import net.engio.mbassy.dispatch.SubscriptionContext;\n \n /**\n  * Created with IntelliJ IDEA.\n@@ -18,13 +12,13 @@ import net.engio.mbassy.dispatch.ReflectiveHandlerInvocation;\n  */\n public class SubscriptionFactory {\n \n-    public Subscription createSubscription(MessagingContext context){\n+    public Subscription createSubscription(SubscriptionContext context){\n         IHandlerInvocation invocation = buildInvocationForHandler(context);\n         IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n         return new Subscription(context, dispatcher);\n     }\n \n-    protected IHandlerInvocation buildInvocationForHandler(MessagingContext context){\n+    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context){\n         IHandlerInvocation invocation = new ReflectiveHandlerInvocation(context);\n         if(context.getHandlerMetadata().isAsynchronous()){\n             invocation = new AsynchronousHandlerInvocation(invocation);\n@@ -32,7 +26,7 @@ public class SubscriptionFactory {\n         return invocation;\n     }\n \n-    protected IMessageDispatcher buildDispatcher(MessagingContext context, IHandlerInvocation invocation){\n+    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation){\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n        if(context.getHandlerMetadata().isEnveloped()){\n           dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n"
    },
    {
        "commit hash": "eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53",
        "previous commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/DeadEventTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -7,7 +7,7 @@ import net.engio.mbassy.listener.Listener;\n import org.junit.Test;\n \n /**\n- * Verify correct behaviour in case of empty message publications\n+ * Verify correct behaviour in case of message publications that do not have any matching subscriptions\n  *\n  * @author bennidi\n  *         Date: 1/18/13\n"
    },
    {
        "commit hash": "676f729e08e67774aa7c9ab10b4264c5070e5403",
        "previous commit hash": "49ee3cb84b0e0c62b4fdef450e98e92a3b077f75",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.1</version>\n+    <version>1.1.2-SNAPSHOT</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -36,7 +36,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.1</tag>\n+        <tag>HEAD</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "49ee3cb84b0e0c62b4fdef450e98e92a3b077f75",
        "previous commit hash": "08a88a3c617c901dd679a545eaa4c110d0bee2e8",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.1-SNAPSHOT</version>\n+    <version>1.1.1</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -36,7 +36,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>HEAD</tag>\n+        <tag>mbassador-1.1.1</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "08a88a3c617c901dd679a545eaa4c110d0bee2e8",
        "previous commit hash": "fca9c6017cb8210a7dd216388bf66e7af3bfd45e",
        "diff stats": {
            "file_path": "wiki-listener-def.md",
            "additions": 2,
            "deletions": 5
        },
        "diff content": "@@ -1,15 +1,12 @@\n-Listener Definition\n-===================\n-\n MBassador allows a variety of message handler configurations that will affect how a message\n is delivered to a specific listener. There are properties to control the handling of subclasses\n-of the specified message (the method parameter), the execution order of handlers for the same message,\n+of the specified message (the method parameter), the execution order of handlers for the same message type,\n filters, delivery modes etc.\n \n <h2>Message handler properties</h2>\n \n <table>\n-  <tr> <td>Property</td> <td>Meaning</td> <td>Default</td> </tr>\n+  <tr> <td>Property</td> <td>Description</td> <td>Default</td> </tr>\n \n   <tr>\n         <td>delivery</td>\n"
    },
    {
        "commit hash": "fca9c6017cb8210a7dd216388bf66e7af3bfd45e",
        "previous commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -137,6 +137,7 @@ Of course you can always clone the repository and build from source\n \n <h3>1.1.1</h3>\n \n+ + Added support for DeadEvent\n  + Introduced new property to @Listener annotation that allows to activate/deactivate any message handler\n  + Full support of proxies created by cglib\n  + Message handler inheritance changed! See wiki page about handler definition for more details.\n"
    },
    {
        "commit hash": "fca9c6017cb8210a7dd216388bf66e7af3bfd45e",
        "previous commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/AbstractMessageBus.java",
            "additions": 5,
            "deletions": 4
        },
        "diff content": "@@ -44,7 +44,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n \n     // all pending messages scheduled for asynchronous dispatch are queued here\n-    private final BlockingQueue<MessagePublication<T>> pendingMessages;\n+    private final BlockingQueue<MessagePublication> pendingMessages;\n \n     // this factory is used to create specialized subscriptions based on the given message handler configuration\n     // it can be customized by implementing the getSubscriptionFactory() method\n@@ -56,7 +56,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         this.executor = configuration.getExecutor();\n         subscriptionFactory = configuration.getSubscriptionFactory();\n         this.metadataReader = configuration.getMetadataReader();\n-        pendingMessages  = new LinkedBlockingQueue<MessagePublication<T>>(configuration.getMaximumNumberOfPendingMessages());\n+        pendingMessages  = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n         initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n         addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n     }\n@@ -151,7 +151,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     }\n \n     // this method enqueues a message delivery request\n-    protected MessagePublication<T> addAsynchronousDeliveryRequest(MessagePublication<T> request){\n+    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request){\n         try {\n             pendingMessages.put(request);\n             return request.markScheduled();\n@@ -161,7 +161,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     }\n \n     // this method enqueues a message delivery request\n-    protected MessagePublication<T> addAsynchronousDeliveryRequest(MessagePublication<T> request, long timeout, TimeUnit unit){\n+    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit){\n         try {\n             return pendingMessages.offer(request, timeout, unit)\n                     ? request.markScheduled()\n@@ -172,6 +172,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     }\n \n     // obtain the set of subscriptions for the given message type\n+    // Note: never returns null!\n     protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n         Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n \n"
    },
    {
        "commit hash": "fca9c6017cb8210a7dd216388bf66e7af3bfd45e",
        "previous commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/IMessageBus.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -136,7 +136,7 @@ public interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n          *\n          * @return A message publication that can be used to access information about the state of\n          */\n-        public MessagePublication<T> asynchronously();\n+        public MessagePublication asynchronously();\n \n \n         /**\n@@ -149,7 +149,7 @@ public interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n          *\n          * @return A message publication that wraps up the publication request\n          */\n-        public MessagePublication<T> asynchronously(long timeout, TimeUnit unit);\n+        public MessagePublication asynchronously(long timeout, TimeUnit unit);\n \n     }\n \n"
    },
    {
        "commit hash": "fca9c6017cb8210a7dd216388bf66e7af3bfd45e",
        "previous commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/MBassador.java",
            "additions": 33,
            "deletions": 11
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy;\n \n+import net.engio.mbassy.common.DeadEvent;\n import net.engio.mbassy.subscription.Subscription;\n \n import java.util.Collection;\n@@ -13,17 +14,26 @@ public class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>>\n     }\n \n \n-    public MessagePublication<T> publishAsync(T message) {\n-        return addAsynchronousDeliveryRequest(MessagePublication.Create(\n-                getSubscriptionsByMessageType(message.getClass()), message));\n+    public MessagePublication publishAsync(T message) {\n+        return addAsynchronousDeliveryRequest(createMessagePublication(message));\n     }\n \n-    public MessagePublication<T> publishAsync(T message, long timeout, TimeUnit unit) {\n-        return addAsynchronousDeliveryRequest(MessagePublication.Create(\n-                getSubscriptionsByMessageType(message.getClass()), message), timeout, unit);\n+    public MessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n+        return addAsynchronousDeliveryRequest(createMessagePublication(message), timeout, unit);\n+    }\n+\n+    private MessagePublication createMessagePublication(T message) {\n+        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n+        if (subscriptions == null || subscriptions.isEmpty()) {\n+            // Dead Event\n+            subscriptions = getSubscriptionsByMessageType(DeadEvent.class);\n+            return MessagePublication.Create(subscriptions, new DeadEvent(message));\n+        }\n+        else return MessagePublication.Create(subscriptions, message);\n     }\n \n \n+\n     /**\n      * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n      * The call blocks until every messageHandler has processed the message.\n@@ -32,13 +42,25 @@ public class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>>\n      */\n     public void publish(T message) {\n         try {\n+            MessagePublication publication = createMessagePublication(message);\n+            publication.execute();\n+\n+            /*\n             final Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n-            if (subscriptions == null) {\n-                return; // TODO: Dead Event?\n-            }\n-            for (Subscription subscription : subscriptions) {\n-                subscription.publish(message);\n+            if (subscriptions == null || subscriptions.isEmpty()) {\n+                // publish a DeadEvent since no subscriptions could be found\n+                final Collection<Subscription> deadEventSubscriptions = getSubscriptionsByMessageType(DeadEvent.class);\n+                if (deadEventSubscriptions != null && !deadEventSubscriptions.isEmpty()) {\n+                    for (Subscription subscription : deadEventSubscriptions) {\n+                        subscription.publish(new DeadEvent(message));\n+                    }\n+                }\n             }\n+            else{\n+                for (Subscription subscription : subscriptions) {\n+                    subscription.publish(message);\n+                }\n+            }*/\n         } catch (Throwable e) {\n             handlePublicationError(new PublicationError()\n                     .setMessage(\"Error during publication of message\")\n"
    },
    {
        "commit hash": "fca9c6017cb8210a7dd216388bf66e7af3bfd45e",
        "previous commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/MessagePublication.java",
            "additions": 12,
            "deletions": 7
        },
        "diff content": "@@ -1,5 +1,6 @@\n package net.engio.mbassy;\n \n+import net.engio.mbassy.common.DeadEvent;\n import net.engio.mbassy.subscription.Subscription;\n \n import java.util.Collection;\n@@ -12,19 +13,19 @@ import java.util.Collection;\n  * @author bennidi\n  * Date: 11/16/12\n  */\n-public class MessagePublication<T> {\n+public class MessagePublication {\n \n-    public static <T> MessagePublication<T> Create(Collection<Subscription> subscriptions, T message){\n-        return new MessagePublication<T>(subscriptions, message, State.Initial);\n+    public static  MessagePublication Create(Collection<Subscription> subscriptions, Object message){\n+        return new MessagePublication(subscriptions, message, State.Initial);\n     }\n \n     private Collection<Subscription> subscriptions;\n \n-    private T message;\n+    private Object message;\n \n     private State state = State.Scheduled;\n \n-    private MessagePublication(Collection<Subscription> subscriptions, T message, State initialState) {\n+    private MessagePublication(Collection<Subscription> subscriptions, Object message, State initialState) {\n         this.subscriptions = subscriptions;\n         this.message = message;\n         this.state = initialState;\n@@ -54,18 +55,22 @@ public class MessagePublication<T> {\n         return state.equals(State.Scheduled);\n     }\n \n-    public MessagePublication<T> markScheduled(){\n+    public MessagePublication markScheduled(){\n         if(!state.equals(State.Initial))\n             return this;\n         state = State.Scheduled;\n         return this;\n     }\n \n-    public MessagePublication<T> setError(){\n+    public MessagePublication setError(){\n         state = State.Error;\n         return this;\n     }\n \n+    public boolean isDeadEvent(){\n+        return DeadEvent.class.isAssignableFrom(message.getClass());\n+    }\n+\n     private enum State{\n         Initial,Scheduled,Running,Finished,Error;\n     }\n"
    },
    {
        "commit hash": "fca9c6017cb8210a7dd216388bf66e7af3bfd45e",
        "previous commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/SyncAsyncPostCommand.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -24,7 +24,7 @@ public class SyncAsyncPostCommand<T> implements IMessageBus.IPostCommand {\n     }\n \n     @Override\n-    public MessagePublication<T> asynchronously() {\n+    public MessagePublication asynchronously() {\n         return mBassador.publishAsync(message);\n     }\n \n"
    },
    {
        "commit hash": "fca9c6017cb8210a7dd216388bf66e7af3bfd45e",
        "previous commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/DeadEvent.java",
            "additions": 21,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,21 @@\n+package net.engio.mbassy.common;\n+\n+/**\n+ * The DeadEvent is delivered to all subscribed handlers (if any) whenever no message\n+ * handlers could be found for a given message publication.\n+ *\n+ * @author bennidi\n+ *         Date: 1/18/13\n+ */\n+public class DeadEvent {\n+\n+    private Object event;\n+\n+    public DeadEvent(Object event) {\n+        this.event = event;\n+    }\n+\n+    public Object getEvent() {\n+        return event;\n+    }\n+}\n"
    },
    {
        "commit hash": "fca9c6017cb8210a7dd216388bf66e7af3bfd45e",
        "previous commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AllTests.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -16,7 +16,8 @@ import org.junit.runners.Suite;\n         FilterTest.class,\n         MetadataReaderTest.class,\n         ListenerSubscriptionTest.class,\n-        MethodDispatchTest.class\n+        MethodDispatchTest.class,\n+        DeadEventTest.class\n })\n public class AllTests {\n }\n"
    },
    {
        "commit hash": "fca9c6017cb8210a7dd216388bf66e7af3bfd45e",
        "previous commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/DeadEventTest.java",
            "additions": 48,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,48 @@\n+package net.engio.mbassy;\n+\n+import net.engio.mbassy.common.ConcurrentSet;\n+import net.engio.mbassy.common.DeadEvent;\n+import net.engio.mbassy.common.UnitTest;\n+import net.engio.mbassy.listener.Listener;\n+import org.junit.Test;\n+\n+/**\n+ * Verify correct behaviour in case of empty message publications\n+ *\n+ * @author bennidi\n+ *         Date: 1/18/13\n+ */\n+public class DeadEventTest extends UnitTest{\n+\n+\n+    @Test\n+    public void testDeadEvent(){\n+        MBassador bus = new MBassador(BusConfiguration.Default());\n+        DeadEventHandler deadEventHandler = new DeadEventHandler();\n+        bus.subscribe(deadEventHandler);\n+        assertEquals(0, deadEventHandler.getDeadEventCount());\n+        bus.post(new Object()).now();\n+        assertEquals(1, deadEventHandler.getDeadEventCount());\n+        bus.post(323).now();\n+        assertEquals(2, deadEventHandler.getDeadEventCount());\n+        bus.publish(\"fkdfdk\");\n+        assertEquals(3, deadEventHandler.getDeadEventCount());\n+    }\n+\n+    public class DeadEventHandler{\n+\n+         private ConcurrentSet deadEvents = new ConcurrentSet();\n+\n+        @Listener\n+         public void handle(DeadEvent event){\n+             deadEvents.add(event);\n+         }\n+\n+\n+        public int getDeadEventCount(){\n+            return deadEvents.size();\n+        }\n+\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "previous commit hash": "1ed1bb29a87d8faadbc919b64a585bc9cf3ee3c8",
        "diff stats": {
            "file_path": "README.md",
            "additions": 14,
            "deletions": 5
        },
        "diff content": "@@ -9,7 +9,7 @@ Read this documentation to get an overview of its features and how cool this mes\n You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n which also contains a partial list of the features of the compared implementations.\n \n-The current version is 1.1.0 and it is available from the Maven Central Repository. See the release notes for more details.\n+The current version is 1.1.1 and it is available from the Maven Central Repository. See the release notes for more details.\n \n Table of contents:\n + [Features](#features)\n@@ -60,8 +60,8 @@ Listener definition (in any bean):\n \t\t\t// do something\n \t\t}\n \n-        // this handler will be invoked asynchronously\n-\t\t@Listener(dispatch = Mode.Asynchronous)\n+        // this handler will be invoked concurrently\n+\t\t@Listener(delivery = Mode.Concurrent)\n \t\tpublic void handleSubTestEvent(SubTestEvent event) {\n             // do something more expensive here\n \t\t}\n@@ -69,13 +69,13 @@ Listener definition (in any bean):\n \t\t// this handler will receive messages of type SubTestEvent\n         // or any of its sub types that passe the given filter(s)\n         @Listener(priority = 10,\n-                  dispatch = Mode.Synchronous,\n+                  delivery = Mode.Sequential,\n                   filters = {@Filter(Filters.SpecialEvent.class)})\n         public void handleFiltered(SubTestEvent event) {\n            //do something special here\n         }\n \n-        @Listener(dispatch = Mode.Synchronous, rejectSubtypes = true)\n+        @Listener(delivery = Mode.Sequential, rejectSubtypes = true)\n         @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n         public void handleVariousEvents(MessageEnvelope envelope) {\n             // the envelope will contain either an instance of TestEvent or TestEvent2\n@@ -135,6 +135,15 @@ Of course you can always clone the repository and build from source\n \n <h2>Release Notes</h2>\n \n+<h3>1.1.1</h3>\n+\n+ + Introduced new property to @Listener annotation that allows to activate/deactivate any message handler\n+ + Full support of proxies created by cglib\n+ + Message handler inheritance changed! See wiki page about handler definition for more details.\n+ + Changed @Listener property \"dispatch\" to \"delivery\" and renamed the associated enumeration values to\n+   more precisely indicate their meaning\n+ + Added more unit tests\n+\n <h3>1.1.0</h3>\n \n First stable release!\n"
    },
    {
        "commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "previous commit hash": "1ed1bb29a87d8faadbc919b64a585bc9cf3ee3c8",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ReflectionUtils.java",
            "additions": 10,
            "deletions": 1
        },
        "diff content": "@@ -29,6 +29,15 @@ public class ReflectionUtils {\n         return methods;\n     }\n \n+    /**\n+     * Traverses the class hierarchy upwards, starting at the given subclass, looking\n+     * for an override of the given methods -> finds the bottom most override of the given\n+     * method if any exists\n+     *\n+     * @param overridingMethod\n+     * @param subclass\n+     * @return\n+     */\n     public static Method getOverridingMethod(Method overridingMethod, Class subclass) {\n         Class current = subclass;\n         while(!current.equals(overridingMethod.getDeclaringClass())){\n@@ -67,7 +76,7 @@ public class ReflectionUtils {\n     }\n \n     private static boolean isOverriddenBy(Method superclassMethod, Method subclassMethod) {\n-        // if the declaring classes are the same or the subclass method is not defined in the subbclass\n+        // if the declaring classes are the same or the subclass method is not defined in the subclass\n         // hierarchy of the given superclass method or the method names are not the same then\n         // subclassMethod does not override superclassMethod\n         if (superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass())\n"
    },
    {
        "commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "previous commit hash": "1ed1bb29a87d8faadbc919b64a585bc9cf3ee3c8",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Listener.java",
            "additions": 3,
            "deletions": 1
        },
        "diff content": "@@ -17,10 +17,12 @@ public @interface Listener {\n \n \tFilter[] filters() default {}; // no filters by default\n \n-    Mode dispatch() default Mode.Synchronous;\n+    Mode delivery() default Mode.Sequential;\n \n     int priority() default 0;\n \n     boolean rejectSubtypes() default false;\n \n+    boolean enabled() default true;\n+\n }\n"
    },
    {
        "commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "previous commit hash": "1ed1bb29a87d8faadbc919b64a585bc9cf3ee3c8",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java",
            "additions": 4,
            "deletions": 1
        },
        "diff content": "@@ -31,7 +31,7 @@ public class MessageHandlerMetadata {\n         this.handler = handler;\n         this.filter = filter;\n         this.listenerConfig = listenerConfig;\n-        this.isAsynchronous = listenerConfig.dispatch().equals(Mode.Asynchronous);\n+        this.isAsynchronous = listenerConfig.delivery().equals(Mode.Concurrent);\n         this.envelope = handler.getAnnotation(Enveloped.class);\n         this.acceptsSubtypes = !listenerConfig.rejectSubtypes();\n         if(this.envelope != null){\n@@ -86,4 +86,7 @@ public class MessageHandlerMetadata {\n     }\n \n \n+    public boolean isEnabled() {\n+        return listenerConfig.enabled();\n+    }\n }\n"
    },
    {
        "commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "previous commit hash": "1ed1bb29a87d8faadbc919b64a585bc9cf3ee3c8",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MetadataReader.java",
            "additions": 26,
            "deletions": 11
        },
        "diff content": "@@ -59,19 +59,31 @@ public class MetadataReader {\n     // get all listeners defined by the given class (includes\n     // listeners defined in super classes)\n     public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n-        // get all handlers (this will include overridden handlers)\n-        List<Method> allMethods = ReflectionUtils.getMethods(AllMessageHandlers, target);\n-        List<MessageHandlerMetadata>  handlers = new LinkedList<MessageHandlerMetadata>();\n-        for(Method handler : allMethods){\n-            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n-            if(overriddenHandler == null && isValidMessageHandler(handler)){\n-                // add the handler only if it has not been overridden because\n-                // either the override in the subclass deactivates the handler (by not specifying the @Listener)\n-                // or the handler defined in the subclass is part of the list and will be processed itself\n-                handlers.add(getHandlerMetadata(handler));\n+        // get all handlers (this will include all (inherited) methods directly annotated using @Listener)\n+        List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n+        // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n+        List<Method> bottomMostHandlers = new LinkedList<Method>();\n+        for(Method handler : allHandlers){\n+            if(!ReflectionUtils.containsOverridingMethod(allHandlers, handler)){\n+                bottomMostHandlers.add(handler);\n             }\n         }\n-        return handlers;\n+\n+\n+        List<MessageHandlerMetadata>  filteredHandlers = new LinkedList<MessageHandlerMetadata>();\n+        // for each handler there will be no overriding method that specifies @Listener annotation\n+        // but an overriding method does inherit the listener configuration of the overwritten method\n+        for(Method handler : bottomMostHandlers){\n+            Listener listener = handler.getAnnotation(Listener.class);\n+            if(!listener.enabled() || !isValidMessageHandler(handler)) continue; // disabled or invalid listeners are ignored\n+            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n+            // if a handler is overwritten it inherits the configuration of its parent method\n+            MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n+                    getFilter(listener), listener);\n+            filteredHandlers.add(handlerMetadata);\n+\n+        }\n+        return filteredHandlers;\n     }\n \n \n@@ -82,6 +94,9 @@ public class MetadataReader {\n \n \n     private boolean isValidMessageHandler(Method handler) {\n+        if(handler == null || handler.getAnnotation(Listener.class) == null){\n+            return false;\n+        }\n         if (handler.getParameterTypes().length != 1) {\n             // a messageHandler only defines one parameter (the message)\n             System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n"
    },
    {
        "commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "previous commit hash": "1ed1bb29a87d8faadbc919b64a585bc9cf3ee3c8",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Mode.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -8,5 +8,5 @@ package net.engio.mbassy.listener;\n * To change this template use File | Settings | File Templates.\n */\n public enum Mode {\n-    Synchronous,Asynchronous\n+    Sequential, Concurrent\n }\n"
    },
    {
        "commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "previous commit hash": "1ed1bb29a87d8faadbc919b64a585bc9cf3ee3c8",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AllTests.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -15,7 +15,8 @@ import org.junit.runners.Suite;\n         MessagePublicationTest.class,\n         FilterTest.class,\n         MetadataReaderTest.class,\n-        ListenerSubscriptionTest.class\n+        ListenerSubscriptionTest.class,\n+        MethodDispatchTest.class\n })\n public class AllTests {\n }\n"
    },
    {
        "commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "previous commit hash": "1ed1bb29a87d8faadbc919b64a585bc9cf3ee3c8",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MetadataReaderTest.java",
            "additions": 9,
            "deletions": 2
        },
        "diff content": "@@ -131,7 +131,14 @@ public class MetadataReaderTest extends UnitTest {\n     }\n \n     // the same handlers as its super class\n-    public class EventListener2 extends EventListener1 {}\n+    public class EventListener2 extends EventListener1 {\n+\n+        // redefine handler implementation (not configuration)\n+        public void handleString(String s) {\n+\n+        }\n+\n+    }\n \n     public class EventListener3 extends EventListener2 {\n \n@@ -141,7 +148,7 @@ public class MetadataReaderTest extends UnitTest {\n \n         }\n \n-        // remove this handler\n+        @Listener(enabled = false)\n         public void handleString(String s) {\n \n         }\n"
    },
    {
        "commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "previous commit hash": "1ed1bb29a87d8faadbc919b64a585bc9cf3ee3c8",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MethodDispatchTest.java",
            "additions": 55,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,55 @@\n+package net.engio.mbassy;\n+\n+import net.engio.mbassy.common.UnitTest;\n+import net.engio.mbassy.listener.Listener;\n+import org.junit.Test;\n+\n+/**\n+ * Very simple test to verify dispatch to correct message handler\n+ *\n+ * @author bennidi\n+ *         Date: 1/17/13\n+ */\n+public class MethodDispatchTest extends UnitTest{\n+\n+   private boolean listener1Called = false;\n+   private boolean listener2Called = false;\n+\n+\n+\n+    // a simple event listener\n+    public class EventListener1 {\n+\n+        @Listener\n+        public void handleString(String s) {\n+             listener1Called = true;\n+        }\n+\n+    }\n+\n+    // the same handlers as its super class\n+    public class EventListener2 extends EventListener1 {\n+\n+        // redefine handler implementation (not configuration)\n+        public void handleString(String s) {\n+           listener2Called = true;\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testDispatch1(){\n+        MBassador bus = new MBassador(BusConfiguration.Default());\n+        EventListener2 listener2 = new EventListener2();\n+        bus.subscribe(listener2);\n+        bus.post(\"jfndf\").now();\n+        assertTrue(listener2Called);\n+        assertFalse(listener1Called);\n+\n+        EventListener1 listener1 = new EventListener1();\n+        bus.subscribe(listener1);\n+        bus.post(\"jfndf\").now();\n+        assertTrue(listener1Called);\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "previous commit hash": "1ed1bb29a87d8faadbc919b64a585bc9cf3ee3c8",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -20,7 +20,7 @@ public class EventingTestBean {\n     }\n \n     // this handler will be invoked asynchronously\n-    @Listener(priority = 0, dispatch = Mode.Asynchronous)\n+    @Listener(priority = 0, delivery = Mode.Concurrent)\n     public void handleSubTestEvent(SubTestEvent event) {\n         event.counter.incrementAndGet();\n     }\n@@ -29,7 +29,7 @@ public class EventingTestBean {\n     // or any subtabe and that passes the given filter\n     @Listener(\n             priority = 10,\n-            dispatch = Mode.Synchronous,\n+            delivery = Mode.Sequential,\n             filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n     public void handleFiltered(SubTestEvent event) {\n         event.counter.incrementAndGet();\n"
    },
    {
        "commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "previous commit hash": "1ed1bb29a87d8faadbc919b64a585bc9cf3ee3c8",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -11,7 +11,7 @@ import net.engio.mbassy.listener.Mode;\n public class EventingTestBean2 extends EventingTestBean{\n \n     // redefine the configuration for this handler\n-    @Listener(dispatch = Mode.Synchronous)\n+    @Listener(delivery = Mode.Sequential)\n     public void handleSubTestEvent(SubTestEvent event) {\n         super.handleSubTestEvent(event);\n     }\n"
    },
    {
        "commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "previous commit hash": "1ed1bb29a87d8faadbc919b64a585bc9cf3ee3c8",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -12,7 +12,7 @@ public class EventingTestBean3 extends EventingTestBean2{\n \n \n     // this handler will be invoked asynchronously\n-    @Listener(priority = 0, dispatch = Mode.Synchronous)\n+    @Listener(priority = 0, delivery = Mode.Sequential)\n     public void handleSubTestEventAgain(SubTestEvent event) {\n         event.counter.incrementAndGet();\n     }\n"
    },
    {
        "commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "previous commit hash": "1ed1bb29a87d8faadbc919b64a585bc9cf3ee3c8",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -18,7 +18,7 @@ import net.engio.mbassy.subscription.MessageEnvelope;\n public class MultiEventHandler {\n \n \n-    @Listener(dispatch = Mode.Synchronous)\n+    @Listener(delivery = Mode.Sequential)\n     @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n     public void handleEvents(MessageEnvelope envelope) {\n         if(TestEvent.class.isAssignableFrom(envelope.getMessage().getClass())){\n@@ -31,7 +31,7 @@ public class MultiEventHandler {\n         }\n     }\n \n-    @Listener(dispatch = Mode.Synchronous, filters = @Filter(Filters.RejectSubtypes.class))\n+    @Listener(delivery = Mode.Sequential, filters = @Filter(Filters.RejectSubtypes.class))\n     @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n     public void handleSuperTypeEvents(MessageEnvelope envelope) {\n         if(TestEvent.class.isAssignableFrom(envelope.getMessage().getClass())){\n"
    },
    {
        "commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "previous commit hash": "1ed1bb29a87d8faadbc919b64a585bc9cf3ee3c8",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/NonListeningBean.java",
            "additions": 4,
            "deletions": 0
        },
        "diff content": "@@ -2,6 +2,7 @@ package net.engio.mbassy.listeners;\n \n import net.engio.mbassy.events.SubTestEvent;\n import net.engio.mbassy.events.TestEvent;\n+import net.engio.mbassy.listener.Listener;\n \n /**\n  * This bean overrides all the handlers defined in its superclass. Since it does not specify any annotations\n@@ -14,16 +15,19 @@ public class NonListeningBean extends EventingTestBean{\n \n \n     @Override\n+    @Listener(enabled = false)\n     public void handleTestEvent(TestEvent event) {\n         event.counter.incrementAndGet();   // should never be called\n     }\n \n     @Override\n+    @Listener(enabled = false)\n     public void handleSubTestEvent(SubTestEvent event) {\n         event.counter.incrementAndGet();   // should never be called\n     }\n \n     @Override\n+    @Listener(enabled = false)\n     public void handleFiltered(SubTestEvent event) {\n         event.counter.incrementAndGet();   // should never be called\n     }\n"
    },
    {
        "commit hash": "d08470c339d317693d86b3efc356e16b1f16ad97",
        "previous commit hash": "1ed1bb29a87d8faadbc919b64a585bc9cf3ee3c8",
        "diff stats": {
            "file_path": "wiki-listener-def.md",
            "additions": 124,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,124 @@\n+Listener Definition\n+===================\n+\n+MBassador allows a variety of message handler configurations that will affect how a message\n+is delivered to a specific listener. There are properties to control the handling of subclasses\n+of the specified message (the method parameter), the execution order of handlers for the same message,\n+filters, delivery modes etc.\n+\n+<h2>Message handler properties</h2>\n+\n+<table>\n+  <tr> <td>Property</td> <td>Meaning</td> <td>Default</td> </tr>\n+\n+  <tr>\n+        <td>delivery</td>\n+        <td>Message delivery can either run sequentially(i.e. one listener at a time) or concurrently\n+            (i.e. multiple threads are used to deliver the same message to different listeners).\n+            Note:The number of parallel threads is configurable per instance using the BusConfiguration</td>\n+        <td>Sequential</td>\n+  </tr>\n+\n+  <tr>\n+        <td>priority</td>\n+        <td>The priority is used to determine the order in which a message is delivered to\n+            different message handlers that consume the same message type. Higher priority means\n+            higher precedence in message delivery.</td>\n+        <td>0</td>\n+  </tr>\n+\n+  <tr>\n+          <td>rejectSubtypes</td>\n+          <td>The primary message type consumed by a message handler is determined by the type of\n+              its parameter.Polymorphism does allow any sub type of that message type to be delivered\n+              to the handler as well, which is the default behaviour of any message handler.\n+              The handler can be configured to not receiving any sub types by specifying thus using this\n+              property.\n+          </td>\n+          <td>false</td>\n+  </tr>\n+\n+  <tr>\n+            <td>enabled</td>\n+            <td>A handler can be explicitly disabled to not take part in message delivery.\n+            </td>\n+            <td>true</td>\n+    </tr>\n+\n+\n+</table>\n+\n+<h2>Message handler definition</h2>\n+\n+The standard message handler definition looks like the following.It will\n+receive all messages of type TestEvent or any subtype sequentially.\n+\n+        // every message of type TestEvent or any subtype will be delivered\n+        // to this handler\n+        @Listener\n+\t\tpublic void handleTestEvent(TestEvent event) {\n+\t\t\t// do something\n+\t\t}\n+\n+\n+\n+This handler will receive all messages of type SubTestEvent or any subtype concurrently\n+\n+        // this handler will be invoked concurrently\n+\t\t@Listener(delivery = Mode.Concurrent)\n+\t\tpublic void handleSubTestEvent(SubTestEvent event) {\n+            // do something more expensive here\n+\t\t}\n+\n+This handler will receive all messages of type SubTestEvent or any subtype sequentially,\n+given that they pass the specified filters. This handler will be invoked before the formerly\n+defined one, since it specifies a higher priority\n+\n+\t\t// this handler will receive messages of type SubTestEvent\n+        // or any of its sub types that passe the given filter(s)\n+        @Listener(priority = 10,\n+                  dispatch = Mode.Synchronous,\n+                  filters = {@Filter(Filters.SpecialEvent.class)})\n+        public void handleFiltered(SubTestEvent event) {\n+           //do something special here\n+        }\n+\n+\n+        @Listener(dispatch = Mode.Synchronous, rejectSubtypes = true)\n+        @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n+        public void handleVariousEvents(MessageEnvelope envelope) {\n+            // the envelope will contain either an instance of TestEvent or TestEvent2\n+            // if rejectSubtypes were set to 'false' (default) also subtypes of TestEvent or TestEvent2 would be allowed\n+        }\n+\n+\n+\n+<h2>Enveloped message handlers</h2>\n+\n+Since one parameter (the message) does not offer a great deal of flexibility if different types\n+of messages should be consumed, there exists the possibility to wrap a message inside an envelope.\n+An enveloped message handler specifies the message type it consumes by using the @Enveloped annotation\n+in addition to the @Listener annotation. All configurations of @Listener apply to each of the specified\n+message types.\n+\n+        @Listener(dispatch = Mode.Synchronous, rejectSubtypes = true)\n+        @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n+        public void handleVariousEvents(MessageEnvelope envelope) {\n+            // the envelope will contain either an instance of TestEvent or TestEvent2\n+            // if rejectSubtypes were set to 'false' (default) also subtypes of TestEvent or TestEvent2 would be allowed\n+        }\n+\n+\n+<h2>Inheritance</h2>\n+\n+Message handler inheritance corresponds to inheritance of methods as defined in the Java language itself.\n+A subclass of any class that defines message handlers will inherit these handler and their configuration.\n+It is possible to change (override) the configuration simply by overriding the super class' method and\n+specifying a different configuration. This way, it is also possible to deactivate a message handler of\n+a super class by using the \"enabled\" property on the overridden method.\n+If a class overrides a method that is configured as a message handler in one of its super classes\n+it is still considered a message handler but of course the implementation of the overriding class\n+will be used.\n+\n+\n+\n"
    },
    {
        "commit hash": "1ed1bb29a87d8faadbc919b64a585bc9cf3ee3c8",
        "previous commit hash": "f2a61c16b8e533770ab0d6c7ca512c15b7a4ba85",
        "diff stats": {
            "file_path": "README.md",
            "additions": 10,
            "deletions": 8
        },
        "diff content": "@@ -1,7 +1,7 @@\n-Mbassador\n+MBassador\n =========\n \n-Mbassador is a very light-weight message (event) bus implementation following the publish subscribe pattern. It is designed\n+MBassador is a very light-weight message (event) bus implementation following the publish subscribe pattern. It is designed\n for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. It uses a specialized\n data structure to allow high throughput for concurrent access.\n \n@@ -9,7 +9,7 @@ Read this documentation to get an overview of its features and how cool this mes\n You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n which also contains a partial list of the features of the compared implementations.\n \n-The current version is 1.1.0, see the release notes for more details.\n+The current version is 1.1.0 and it is available from the Maven Central Repository. See the release notes for more details.\n \n Table of contents:\n + [Features](#features)\n@@ -106,9 +106,10 @@ Message publication:\n         bus.post(subEvent).now(); // same as above\n \n <h2>Installation</h2>\n-This project contains a maven repository that will allow you to import MBassador as a dependency into your maven project.\n-Currently this is all that will be provided because publishing to a central repository requires extra project setup that\n-will be done as soon as enough people use this component. Until then, the following steps are necessary:\n+Beginning with version 1.1.0 MBassador is available from the Maven Central Repository (Hooray!). Older versions are\n+still available from the included maven repository in this github repo but will be deleted in the future.\n+The preferred way of using MBassador is to simply add the dependency as shown in step two. Step one is only necessary\n+if you want to use an older version that is not available in the central repository.\n \n  1. Add the repository location to your pom.xml\n     <pre><code class=\"xml\">\n@@ -123,9 +124,9 @@ will be done as soon as enough people use this component. Until then, the follow\n     the git repository online.\n     <pre><code class=\"xml\">\n         &lt;dependency&gt;\n-            &lt;groupId&gt;org.mbassy&lt;/groupId&gt;\n+            &lt;groupId&gt;net.engio&lt;/groupId&gt;\n             &lt;artifactId&gt;mbassador&lt;/artifactId&gt;\n-            &lt;version&gt;1.0.6.RC&lt;/version&gt;\n+            &lt;version&gt;1.1.0&lt;/version&gt;\n         &lt;/dependency&gt;\n     </pre></code>\n  3. Run mvn clean package to have maven download and install the required version into your local repository\n@@ -140,6 +141,7 @@ First stable release!\n \n  + Refactoring and repackaging\n  + More exhaustive unit tests\n+ + Installation from the central repository\n \n <h3>1.0.6.RC</h3>\n \n"
    },
    {
        "commit hash": "f2a61c16b8e533770ab0d6c7ca512c15b7a4ba85",
        "previous commit hash": "c83d8702f0a553d06503fcb54efd34bef5c6c97c",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.0</version>\n+    <version>1.1.1-SNAPSHOT</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -36,7 +36,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>mbassador-1.1.0</tag>\n+        <tag>HEAD</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "c83d8702f0a553d06503fcb54efd34bef5c6c97c",
        "previous commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,7 +9,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.1.0-SNAPSHOT</version>\n+    <version>1.1.0</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -36,7 +36,7 @@\n     <scm>\n         <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-        <tag>HEAD</tag>\n+        <tag>mbassador-1.1.0</tag>\n         <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": ".gitignore",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -8,7 +8,7 @@\n \n # root of compiled classes #\n target/**/*\n-target/*\n+target/**\n \n # the local maven repository #\n mvn-local-repo/**/*\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "README.md",
            "additions": 9,
            "deletions": 3
        },
        "diff content": "@@ -9,7 +9,7 @@ Read this documentation to get an overview of its features and how cool this mes\n You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n which also contains a partial list of the features of the compared implementations.\n \n-The current version is 1.0.6.RC, see the release notes for more details.\n+The current version is 1.1.0, see the release notes for more details.\n \n Table of contents:\n + [Features](#features)\n@@ -134,6 +134,13 @@ Of course you can always clone the repository and build from source\n \n <h2>Release Notes</h2>\n \n+<h3>1.1.0</h3>\n+\n+First stable release!\n+\n+ + Refactoring and repackaging\n+ + More exhaustive unit tests\n+\n <h3>1.0.6.RC</h3>\n \n  + Fixed behaviour with capacity bound blocking queue such that there now are two methods to schedule a message\n@@ -153,7 +160,6 @@ Of course you can always clone the repository and build from source\n \n \n <h2>Roadmap</h2>\n-+ Checkout MBassador from one of the official maven repositories (as soon as the user base is big enough)\n + Spring integration with support for conditional message dispatch in transactional context (dispatch only after\n successful commit etc.). Currently in beta, see <a href=\"https://github.com/bennidi/mbassador-spring\">this</a> repository\n \n@@ -161,7 +167,7 @@ successful commit etc.). Currently in beta, see <a href=\"https://github.com/benn\n <h2>Credits</h2>\n The initial inspiration for creating this component came from looking at Google Guava's event bus implementation. Since\n it did not provide all the features we needed in our project, I decided to create my own implementation. It matured to be\n-quite a feature rich and yet very efficient and performant message bus.\n+quite a feature rich and yet very efficient and performant implementation.\n \n I want to thank the development team from friendsurance (www.friendsurance.de) for their support and feedback on the bus\n implementation and the management of friendsurance for allowing me to publish the component as an open source project.\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "build.gradle",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,7 +1,7 @@\n usePlugin('java')\n \n group=\"org.mbassy\"\n-version=\"1.0.6.RC\"\n+version=\"1.10.0-SNAPSHOT\"\n \n dependencies {\n     addMavenRepo()\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 14,
            "deletions": 4
        },
        "diff content": "@@ -1,9 +1,15 @@\n <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n \n+    <parent>\n+        <groupId>org.sonatype.oss</groupId>\n+        <artifactId>oss-parent</artifactId>\n+        <version>7</version>\n+    </parent>\n+\n     <modelVersion>4.0.0</modelVersion>\n-    <groupId>org.mbassy</groupId>\n+    <groupId>net.engio</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.0.8-SNAPSHOT</version>\n+    <version>1.1.0-SNAPSHOT</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -28,9 +34,10 @@\n         </license>\n     </licenses>\n     <scm>\n-        <url>scm:git:git@github.com:bennidi/mbassador.git</url>\n+        <url>git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-      <tag>HEAD</tag>\n+        <tag>HEAD</tag>\n+        <developerConnection>scm:git:git@github.com:bennidi/mbassador.git</developerConnection>\n   </scm>\n     <developers>\n \n@@ -38,6 +45,7 @@\n             <id>bennidi</id>\n             <name>Benjamin Diedrichsen</name>\n             <timezone>+1</timezone>\n+            <email>b.diedrichsen@googlemail.com</email>\n         </developer>\n     </developers>\n \n@@ -58,12 +66,14 @@\n \n     </dependencies>\n \n+    <!--  Local repository (for testing)\n     <distributionManagement>\n         <repository>\n             <id>mbassador-github-repo</id>\n             <url>${github.url}</url>\n         </repository>\n     </distributionManagement>\n+    -->\n \n     <build>\n         <plugins>\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "pom.xml.releaseBackup",
            "additions": 0,
            "deletions": 152
        },
        "diff content": "@@ -1,152 +0,0 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-\n-    <modelVersion>4.0.0</modelVersion>\n-    <groupId>org.mbassy</groupId>\n-    <artifactId>mbassador</artifactId>\n-    <version>1.0.7.RC-SNAPSHOT</version>\n-    <packaging>jar</packaging>\n-    <name>mbassador</name>\n-    <description>\n-        Mbassador is a fast and flexible message bus system following the publish subscribe pattern.\n-        It is designed for ease of use and aims to be feature rich and extensible\n-        while preserving resource efficiency and performance.\n-\n-        It features:\n-        declarative listener definition via annotations,\n-        sync and/or async message delivery,\n-        weak-references,\n-        message filtering,\n-        ordering of message handlers etc.\n-\n-    </description>\n-\n-    <url>https://github.com/bennidi/mbassador</url>\n-    <licenses>\n-        <license>\n-            <name>MIT license</name>\n-            <url>http://www.opensource.org/licenses/mit-license.php</url>\n-        </license>\n-    </licenses>\n-    <scm>\n-        <url>scm:git:git@github.com:bennidi/mbassador.git</url>\n-        <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-    </scm>\n-    <developers>\n-\n-        <developer>\n-            <id>bennidi</id>\n-            <name>Benjamin Diedrichsen</name>\n-            <timezone>+1</timezone>\n-        </developer>\n-    </developers>\n-\n-    <properties>\n-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-        <project.build.java.version>1.6</project.build.java.version>\n-        <github.url>file://${project.basedir}/mvn-local-repo</github.url>\n-    </properties>\n-\n-    <dependencies>\n-\n-        <dependency>\n-            <groupId>junit</groupId>\n-            <artifactId>junit</artifactId>\n-            <version>4.10</version>\n-            <scope>test</scope>\n-        </dependency>\n-\n-    </dependencies>\n-\n-    <distributionManagement>\n-        <repository>\n-            <id>mbassador-github-repo</id>\n-            <url>${github.url}</url>\n-        </repository>\n-    </distributionManagement>\n-\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>${project.build.java.version}</source>\n-                    <target>${project.build.java.version}</target>\n-                </configuration>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-release-plugin</artifactId>\n-                <version>2.4</version>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-surefire-plugin</artifactId>\n-                <configuration>\n-                    <skipTests>false</skipTests>\n-                </configuration>\n-            </plugin>\n-\n-            <!-- bind the source attaching to package phase -->\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-source-plugin</artifactId>\n-                <executions>\n-                    <execution>\n-                        <id>attach-sources</id>\n-                        <goals>\n-                            <goal>jar</goal>\n-                        </goals>\n-                    </execution>\n-                </executions>\n-            </plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-javadoc-plugin</artifactId>\n-                <executions>\n-                    <execution>\n-                        <id>attach-javadocs</id>\n-                        <goals>\n-                            <goal>jar</goal>\n-                        </goals>\n-                    </execution>\n-                </executions>\n-            </plugin>\n-\n-        </plugins>\n-    </build>\n-\n-    <profiles>\n-        <profile>\n-            <id>release-sign-artifacts</id>\n-            <activation>\n-                <property>\n-                    <name>performRelease</name>\n-                    <value>true</value>\n-                </property>\n-            </activation>\n-            <build>\n-                <plugins>\n-                    <plugin>\n-                        <groupId>org.apache.maven.plugins</groupId>\n-                        <artifactId>maven-gpg-plugin</artifactId>\n-                        <version>1.4</version>\n-                        <executions>\n-                            <execution>\n-                                <id>sign-artifacts</id>\n-                                <phase>verify</phase>\n-                                <goals>\n-                                    <goal>sign</goal>\n-                                </goals>\n-                            </execution>\n-                        </executions>\n-                    </plugin>\n-                </plugins>\n-            </build>\n-        </profile>\n-    </profiles>\n-</project>\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/AbstractMessageBus.java",
            "additions": 7,
            "deletions": 8
        },
        "diff content": "@@ -1,15 +1,14 @@\n-package org.mbassy;\n+package net.engio.mbassy;\n \n-import org.mbassy.common.ReflectionUtils;\n-import org.mbassy.dispatch.MessagingContext;\n-import org.mbassy.listener.MessageHandlerMetadata;\n-import org.mbassy.listener.MetadataReader;\n-import org.mbassy.subscription.Subscription;\n-import org.mbassy.subscription.SubscriptionFactory;\n+import net.engio.mbassy.common.ReflectionUtils;\n+import net.engio.mbassy.dispatch.MessagingContext;\n+import net.engio.mbassy.listener.MessageHandlerMetadata;\n+import net.engio.mbassy.listener.MetadataReader;\n+import net.engio.mbassy.subscription.Subscription;\n+import net.engio.mbassy.subscription.SubscriptionFactory;\n \n import java.util.*;\n import java.util.concurrent.*;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n /**\n  * The base class for all message bus implementations.\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/BusConfiguration.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -1,7 +1,7 @@\n-package org.mbassy;\n+package net.engio.mbassy;\n \n-import org.mbassy.listener.MetadataReader;\n-import org.mbassy.subscription.SubscriptionFactory;\n+import net.engio.mbassy.listener.MetadataReader;\n+import net.engio.mbassy.subscription.SubscriptionFactory;\n \n import java.util.concurrent.*;\n \n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/IMessageBus.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy;\n+package net.engio.mbassy;\n \n import java.util.Collection;\n import java.util.concurrent.Executor;\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/IPublicationErrorHandler.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy;\n+package net.engio.mbassy;\n \n /**\n  * Publication error handlers are provided with a publication error every time an error occurs during message publication.\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/MBassador.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,6 @@\n-package org.mbassy;\n+package net.engio.mbassy;\n \n-import org.mbassy.subscription.Subscription;\n+import net.engio.mbassy.subscription.Subscription;\n \n import java.util.Collection;\n import java.util.concurrent.TimeUnit;\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/MessagePublication.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,6 @@\n-package org.mbassy;\n+package net.engio.mbassy;\n \n-import org.mbassy.subscription.Subscription;\n+import net.engio.mbassy.subscription.Subscription;\n \n import java.util.Collection;\n \n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/PublicationError.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy;\n+package net.engio.mbassy;\n \n import java.lang.reflect.Method;\n \n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/SyncAsyncPostCommand.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy;\n+package net.engio.mbassy;\n \n import java.util.concurrent.TimeUnit;\n \n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ConcurrentSet.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.common;\n+package net.engio.mbassy.common;\n \n \n import java.lang.ref.WeakReference;\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/IPredicate.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.common;\n+package net.engio.mbassy.common;\n \n /**\n  * Created with IntelliJ IDEA.\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/common/ReflectionUtils.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.common;\n+package net.engio.mbassy.common;\n \n import java.lang.reflect.Method;\n import java.util.Collection;\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/AbstractHandlerInvocation.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -1,7 +1,7 @@\n-package org.mbassy.dispatch;\n+package net.engio.mbassy.dispatch;\n \n-import org.mbassy.IPublicationErrorHandler;\n-import org.mbassy.PublicationError;\n+import net.engio.mbassy.IPublicationErrorHandler;\n+import net.engio.mbassy.PublicationError;\n \n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.dispatch;\n+package net.engio.mbassy.dispatch;\n \n import java.lang.reflect.Method;\n \n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -1,7 +1,7 @@\n-package org.mbassy.dispatch;\n+package net.engio.mbassy.dispatch;\n \n-import org.mbassy.common.ConcurrentSet;\n-import org.mbassy.subscription.MessageEnvelope;\n+import net.engio.mbassy.common.ConcurrentSet;\n+import net.engio.mbassy.subscription.MessageEnvelope;\n \n /**\n  * Todo: Add javadoc\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -1,7 +1,7 @@\n-package org.mbassy.dispatch;\n+package net.engio.mbassy.dispatch;\n \n-import org.mbassy.common.ConcurrentSet;\n-import org.mbassy.listener.IMessageFilter;\n+import net.engio.mbassy.common.ConcurrentSet;\n+import net.engio.mbassy.listener.IMessageFilter;\n \n /**\n  * A dispatcher that implements message filtering based on the filter configuration\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.dispatch;\n+package net.engio.mbassy.dispatch;\n \n import java.lang.reflect.Method;\n \n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,6 @@\n-package org.mbassy.dispatch;\n+package net.engio.mbassy.dispatch;\n \n-import org.mbassy.common.ConcurrentSet;\n+import net.engio.mbassy.common.ConcurrentSet;\n \n /**\n  * A message dispatcher provides the functionality to deliver a single message\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,8 +1,8 @@\n-package org.mbassy.dispatch;\n+package net.engio.mbassy.dispatch;\n \n import java.lang.reflect.Method;\n \n-import org.mbassy.common.ConcurrentSet;\n+import net.engio.mbassy.common.ConcurrentSet;\n \n /**\n  * Standard implementation for direct, unfiltered message delivery.\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/MessagingContext.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -1,7 +1,7 @@\n-package org.mbassy.dispatch;\n+package net.engio.mbassy.dispatch;\n \n-import org.mbassy.IMessageBus;\n-import org.mbassy.listener.MessageHandlerMetadata;\n+import net.engio.mbassy.IMessageBus;\n+import net.engio.mbassy.listener.MessageHandlerMetadata;\n \n /**\n  * The messaging context holds all data/objects that is relevant to successfully publish\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.dispatch;\n+package net.engio.mbassy.dispatch;\n \n import java.lang.reflect.Method;\n \n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Enveloped.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.listener;\n+package net.engio.mbassy.listener;\n \n import java.lang.annotation.*;\n \n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Filter.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.listener;\n+package net.engio.mbassy.listener;\n \n import java.lang.annotation.ElementType;\n import java.lang.annotation.Retention;\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Filters.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.listener;\n+package net.engio.mbassy.listener;\n \n /**\n  * Todo: Add javadoc\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/IMessageFilter.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.listener;\n+package net.engio.mbassy.listener;\n \n /**\n  * Message filters can be used to prevent certain messages to be delivered to a specific listener.\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Listener.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.listener;\n+package net.engio.mbassy.listener;\n \n import java.lang.annotation.*;\n \n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.listener;\n+package net.engio.mbassy.listener;\n \n import java.lang.reflect.Method;\n import java.util.LinkedList;\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,6 @@\n-package org.mbassy.listener;\n+package net.engio.mbassy.listener;\n \n-import org.mbassy.common.IPredicate;\n+import net.engio.mbassy.common.IPredicate;\n \n import java.util.LinkedList;\n import java.util.List;\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/MetadataReader.java",
            "additions": 4,
            "deletions": 5
        },
        "diff content": "@@ -1,10 +1,9 @@\n-package org.mbassy.listener;\n+package net.engio.mbassy.listener;\n \n-import org.mbassy.common.IPredicate;\n-import org.mbassy.common.ReflectionUtils;\n-import org.mbassy.subscription.MessageEnvelope;\n+import net.engio.mbassy.common.IPredicate;\n+import net.engio.mbassy.common.ReflectionUtils;\n+import net.engio.mbassy.subscription.MessageEnvelope;\n \n-import java.lang.annotation.Annotation;\n import java.lang.reflect.Method;\n import java.util.*;\n \n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/listener/Mode.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.listener;\n+package net.engio.mbassy.listener;\n \n /**\n * Created with IntelliJ IDEA.\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/MessageEnvelope.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.subscription;\n+package net.engio.mbassy.subscription;\n \n import java.sql.Timestamp;\n \n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/Subscription.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -1,11 +1,11 @@\n-package org.mbassy.subscription;\n+package net.engio.mbassy.subscription;\n \n import java.util.Comparator;\n import java.util.UUID;\n \n-import org.mbassy.common.ConcurrentSet;\n-import org.mbassy.dispatch.IMessageDispatcher;\n-import org.mbassy.dispatch.MessagingContext;\n+import net.engio.mbassy.common.ConcurrentSet;\n+import net.engio.mbassy.dispatch.IMessageDispatcher;\n+import net.engio.mbassy.dispatch.MessagingContext;\n \n /**\n  * A subscription is a thread safe container for objects that contain message handlers\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java",
            "additions": 9,
            "deletions": 9
        },
        "diff content": "@@ -1,13 +1,13 @@\n-package org.mbassy.subscription;\n+package net.engio.mbassy.subscription;\n \n-import org.mbassy.dispatch.AsynchronousHandlerInvocation;\n-import org.mbassy.dispatch.EnvelopedMessageDispatcher;\n-import org.mbassy.dispatch.FilteredMessageDispatcher;\n-import org.mbassy.dispatch.IHandlerInvocation;\n-import org.mbassy.dispatch.IMessageDispatcher;\n-import org.mbassy.dispatch.MessageDispatcher;\n-import org.mbassy.dispatch.MessagingContext;\n-import org.mbassy.dispatch.ReflectiveHandlerInvocation;\n+import net.engio.mbassy.dispatch.AsynchronousHandlerInvocation;\n+import net.engio.mbassy.dispatch.EnvelopedMessageDispatcher;\n+import net.engio.mbassy.dispatch.FilteredMessageDispatcher;\n+import net.engio.mbassy.dispatch.IHandlerInvocation;\n+import net.engio.mbassy.dispatch.IMessageDispatcher;\n+import net.engio.mbassy.dispatch.MessageDispatcher;\n+import net.engio.mbassy.dispatch.MessagingContext;\n+import net.engio.mbassy.dispatch.ReflectiveHandlerInvocation;\n \n /**\n  * Created with IntelliJ IDEA.\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/AllTests.java",
            "additions": 4,
            "deletions": 3
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy;\n+package net.engio.mbassy;\n \n import org.junit.runner.RunWith;\n import org.junit.runners.Suite;\n@@ -12,9 +12,10 @@ import org.junit.runners.Suite;\n @RunWith(Suite.class)\n @Suite.SuiteClasses({\n         ConcurrentSetTest.class,\n-        MBassadorTest.class,\n+        MessagePublicationTest.class,\n         FilterTest.class,\n-        MetadataReaderTest.class\n+        MetadataReaderTest.class,\n+        ListenerSubscriptionTest.class\n })\n public class AllTests {\n }\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ConcurrentSetTest.java",
            "additions": 4,
            "deletions": 2
        },
        "diff content": "@@ -1,8 +1,10 @@\n-package org.mbassy;\n+package net.engio.mbassy;\n \n import junit.framework.Assert;\n import org.junit.Test;\n-import org.mbassy.common.ConcurrentSet;\n+import net.engio.mbassy.common.ConcurrentExecutor;\n+import net.engio.mbassy.common.ConcurrentSet;\n+import net.engio.mbassy.common.UnitTest;\n \n import java.util.HashSet;\n import java.util.Iterator;\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/FilterTest.java",
            "additions": 11,
            "deletions": 9
        },
        "diff content": "@@ -1,15 +1,17 @@\n-package org.mbassy;\n+package net.engio.mbassy;\n \n import java.util.List;\n \n import org.junit.Test;\n-import org.mbassy.events.SubTestEvent;\n-import org.mbassy.events.TestEvent;\n-import org.mbassy.listener.Filter;\n-import org.mbassy.listener.Filters;\n-import org.mbassy.listener.Listener;\n-import org.mbassy.listeners.ListenerFactory;\n-import org.mbassy.listeners.NonListeningBean;\n+import net.engio.mbassy.common.TestUtil;\n+import net.engio.mbassy.common.UnitTest;\n+import net.engio.mbassy.events.SubTestEvent;\n+import net.engio.mbassy.events.TestEvent;\n+import net.engio.mbassy.listener.Filter;\n+import net.engio.mbassy.listener.Filters;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listeners.ListenerFactory;\n+import net.engio.mbassy.listeners.NonListeningBean;\n \n /**\n  * Testing of filter functionality\n@@ -17,7 +19,7 @@ import org.mbassy.listeners.NonListeningBean;\n  * @author bennidi\n  *         Date: 11/26/12\n  */\n-public class FilterTest extends UnitTest{\n+public class FilterTest extends UnitTest {\n \n     @Test\n     public void testSubclassFilter() throws Exception {\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/ListenerSubscriptionTest.java",
            "additions": 104,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,104 @@\n+package net.engio.mbassy;\n+\n+import org.junit.Test;\n+import net.engio.mbassy.common.TestUtil;\n+import net.engio.mbassy.common.UnitTest;\n+import net.engio.mbassy.events.SubTestEvent;\n+import net.engio.mbassy.events.TestEvent;\n+import net.engio.mbassy.listeners.*;\n+import net.engio.mbassy.subscription.Subscription;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * Testing different scenarios of subscribing objects (listeners and non-listeners) to the message bus.\n+ *\n+ * @author bennidi\n+ *         Date: 1/9/13\n+ */\n+public class ListenerSubscriptionTest extends UnitTest{\n+\n+\n+    // this is a single threaded test for subscribing and unsubscribing of a single listener\n+    @Test\n+    public void testSubscribeSimple() throws InterruptedException {\n+        MBassador bus = new MBassador(new BusConfiguration());\n+        List<Object> listeners = new LinkedList<Object>();\n+        int listenerCount = 200000;\n+\n+        // subscribe a number of listeners to the bus\n+        for (int i = 1; i <= listenerCount; i++) {\n+            EventingTestBean listener = new EventingTestBean();\n+            NonListeningBean nonListener = new NonListeningBean();\n+            listeners.add(listener);\n+\n+            bus.subscribe(listener);\n+            bus.subscribe(nonListener);\n+\n+            assertFalse(bus.unsubscribe(nonListener)); // these are not expected to be subscribed listeners\n+            assertFalse(bus.unsubscribe(new EventingTestBean()));\n+\n+        }\n+\n+        // check the generated subscriptions for existence of all previously subscribed valid listeners\n+        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n+        assertEquals(1, testEventsubscriptions.size());\n+        assertEquals(listenerCount, getNumberOfSubscribedListeners(testEventsubscriptions));\n+\n+        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n+        assertEquals(3, subTestEventsubscriptions.size());\n+        assertEquals(3 * listenerCount, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n+\n+        // unsubscribe the listeners\n+        for(Object listener : listeners){\n+            assertTrue(bus.unsubscribe(listener)); // this listener is expected to exist\n+        }\n+\n+        // no listener should be left\n+        testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n+        assertEquals(1, testEventsubscriptions.size());\n+        assertEquals(0, getNumberOfSubscribedListeners(testEventsubscriptions));\n+\n+        subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n+        assertEquals(3, subTestEventsubscriptions.size());\n+        assertEquals(0, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n+\n+    }\n+\n+    private int getNumberOfSubscribedListeners(Collection<Subscription> subscriptions) {\n+        int listeners = 0;\n+        for (Subscription sub : subscriptions) {\n+            listeners += sub.size();\n+        }\n+        return listeners;\n+    }\n+\n+    @Test\n+    public void testConcurrentSubscription() throws Exception {\n+\n+        MBassador bus = new MBassador(new BusConfiguration());\n+        ListenerFactory listenerFactory = new ListenerFactory()\n+                .create(10000, EventingTestBean.class)\n+                .create(10000, EventingTestBean2.class)\n+                .create(10000, EventingTestBean3.class)\n+                .create(10000, Object.class)\n+                .create(10000, NonListeningBean.class);\n+\n+        List<Object> listeners = listenerFactory.build();\n+\n+        // this will subscribe the listeners concurrently to the bus\n+        TestUtil.setup(bus, listeners, 10);\n+\n+        // check the generated subscriptions for existence of all previously subscribed valid listeners\n+        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n+        assertEquals(3, testEventsubscriptions.size());\n+        assertEquals(30000, getNumberOfSubscribedListeners(testEventsubscriptions));\n+\n+        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n+        assertEquals(10, subTestEventsubscriptions.size());\n+        assertEquals(100000, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n+\n+    }\n+}\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MessagePublicationTest.java",
            "additions": 144,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,144 @@\n+package net.engio.mbassy;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.junit.Test;\n+import net.engio.mbassy.common.ConcurrentExecutor;\n+import net.engio.mbassy.common.TestUtil;\n+import net.engio.mbassy.common.UnitTest;\n+import net.engio.mbassy.events.SubTestEvent;\n+import net.engio.mbassy.events.TestEvent;\n+import net.engio.mbassy.events.TestEvent2;\n+import net.engio.mbassy.listeners.EventingTestBean;\n+import net.engio.mbassy.listeners.EventingTestBean2;\n+import net.engio.mbassy.listeners.EventingTestBean3;\n+import net.engio.mbassy.listeners.ListenerFactory;\n+import net.engio.mbassy.listeners.MultiEventHandler;\n+import net.engio.mbassy.listeners.NonListeningBean;\n+\n+/**\n+ * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n+ *\n+ * @author bennidi\n+ *         Date: 2/8/12\n+ */\n+public class MessagePublicationTest extends UnitTest {\n+\n+    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n+    // otherwise the tests will fail since asynchronous processing might not have finished when\n+    // evaluation is run\n+    private int processingTimeInMS = 4000;\n+\n+\n+    @Test\n+    public void testAsynchronousMessagePublication() throws Exception {\n+\n+        MBassador bus = new MBassador(new BusConfiguration());\n+        ListenerFactory listenerFactory = new ListenerFactory()\n+                .create(10000, EventingTestBean.class)\n+                .create(10000, EventingTestBean2.class)\n+                .create(10000, EventingTestBean3.class)\n+                .create(10000, Object.class)\n+                .create(10000, NonListeningBean.class)\n+                .create(10000, MultiEventHandler.class);\n+\n+        List<Object> listeners = listenerFactory.build();\n+\n+        // this will subscribe the listeners concurrently to the bus\n+        TestUtil.setup(bus, listeners, 10);\n+\n+        TestEvent event = new TestEvent();\n+        TestEvent subEvent = new SubTestEvent();\n+        TestEvent2 event2 = new TestEvent2();\n+\n+        bus.publishAsync(event);\n+        bus.publishAsync(subEvent);\n+        bus.publishAsync(event2);\n+\n+        pause(processingTimeInMS);\n+\n+        assertEquals(50000, event.counter.get());\n+        assertEquals(80000, subEvent.counter.get());\n+        assertEquals(20000, event2.counter.get());\n+\n+    }\n+\n+    @Test\n+    public void testSynchronousMessagePublication() throws Exception {\n+\n+        MBassador bus = new MBassador(new BusConfiguration());\n+        ListenerFactory listenerFactory = new ListenerFactory()\n+                .create(10000, EventingTestBean.class)\n+                .create(10000, EventingTestBean2.class)\n+                .create(10000, EventingTestBean3.class)\n+                .create(10000, Object.class)\n+                .create(10000, NonListeningBean.class);\n+\n+        List<Object> listeners = listenerFactory.build();\n+\n+        // this will subscribe the listeners concurrently to the bus\n+        TestUtil.setup(bus, listeners, 10);\n+\n+        TestEvent event = new TestEvent();\n+        TestEvent subEvent = new SubTestEvent();\n+\n+        bus.publish(event);\n+        bus.publish(subEvent);\n+\n+        pause(processingTimeInMS);\n+\n+        assertEquals(30000, event.counter.get());\n+        assertEquals(70000, subEvent.counter.get());\n+\n+    }\n+\n+    @Test\n+    public void testConcurrentMixedMessagePublication() throws Exception {\n+        final CopyOnWriteArrayList<TestEvent> testEvents = new CopyOnWriteArrayList<TestEvent>();\n+        final CopyOnWriteArrayList<SubTestEvent> subtestEvents = new CopyOnWriteArrayList<SubTestEvent>();\n+        final int eventLoopsPerTHread = 100;\n+\n+\n+        final MBassador bus = new MBassador(new BusConfiguration());\n+        ListenerFactory listenerFactory = new ListenerFactory()\n+                .create(10000, EventingTestBean.class)\n+                .create(10000, EventingTestBean2.class)\n+                .create(10000, EventingTestBean3.class)\n+                .create(10000, Object.class)\n+                .create(10000, NonListeningBean.class);\n+\n+        List<Object> listeners = listenerFactory.build();\n+\n+        // this will subscribe the listeners concurrently to the bus\n+        TestUtil.setup(bus, listeners, 10);\n+\n+        ConcurrentExecutor.runConcurrent(new Runnable() {\n+            @Override\n+            public void run() {\n+                for (int i = 0; i < eventLoopsPerTHread; i++) {\n+                    TestEvent event = new TestEvent();\n+                    SubTestEvent subEvent = new SubTestEvent();\n+                    testEvents.add(event);\n+                    subtestEvents.add(subEvent);\n+\n+                    bus.publishAsync(event);\n+                    bus.publish(subEvent);\n+                }\n+            }\n+        }, 10);\n+\n+        pause(processingTimeInMS);\n+\n+        for (TestEvent event : testEvents) {\n+            assertEquals(30000, event.counter.get());\n+        }\n+\n+        for (SubTestEvent event : subtestEvents) {\n+            assertEquals(70000, event.counter.get());\n+        }\n+\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/MetadataReaderTest.java",
            "additions": 8,
            "deletions": 7
        },
        "diff content": "@@ -1,18 +1,19 @@\n-package org.mbassy;\n+package net.engio.mbassy;\n \n import org.junit.Test;\n-import org.mbassy.listener.Enveloped;\n-import org.mbassy.listener.Listener;\n-import org.mbassy.listener.MessageListenerMetadata;\n-import org.mbassy.listener.MetadataReader;\n-import org.mbassy.subscription.MessageEnvelope;\n+import net.engio.mbassy.common.UnitTest;\n+import net.engio.mbassy.listener.Enveloped;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.MessageListenerMetadata;\n+import net.engio.mbassy.listener.MetadataReader;\n+import net.engio.mbassy.subscription.MessageEnvelope;\n \n import java.io.BufferedReader;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n-import static org.mbassy.listener.MessageListenerMetadata.ForMessage;\n+import static net.engio.mbassy.listener.MessageListenerMetadata.ForMessage;\n \n /**\n  * Todo: Add javadoc\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/ConcurrentExecutor.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy;\n+package net.engio.mbassy.common;\n \n import java.util.ArrayList;\n import java.util.List;\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/TestUtil.java",
            "additions": 3,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,6 @@\n-package org.mbassy;\n+package net.engio.mbassy.common;\n+\n+import net.engio.mbassy.IMessageBus;\n \n import java.util.List;\n \n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/common/UnitTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy;\n+package net.engio.mbassy.common;\n \n import org.junit.Assert;\n \n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/events/SubTestEvent.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.events;\n+package net.engio.mbassy.events;\n \n /**\n  *\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/events/TestEvent.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.events;\n+package net.engio.mbassy.events;\n \n import java.util.concurrent.atomic.AtomicInteger;\n \n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/events/TestEvent2.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.events;\n+package net.engio.mbassy.events;\n \n import java.util.concurrent.atomic.AtomicInteger;\n \n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -1,8 +1,8 @@\n-package org.mbassy.listeners;\n+package net.engio.mbassy.listeners;\n \n-import org.mbassy.events.SubTestEvent;\n-import org.mbassy.events.TestEvent;\n-import org.mbassy.listener.*;\n+import net.engio.mbassy.events.SubTestEvent;\n+import net.engio.mbassy.events.TestEvent;\n+import net.engio.mbassy.listener.*;\n \n /**\n  * Basic bean that defines some event handlers to be used for different unit testting scenarios\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -1,8 +1,8 @@\n-package org.mbassy.listeners;\n+package net.engio.mbassy.listeners;\n \n-import org.mbassy.events.SubTestEvent;\n-import org.mbassy.listener.Listener;\n-import org.mbassy.listener.Mode;\n+import net.engio.mbassy.events.SubTestEvent;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.Mode;\n \n /**\n  * @author bennidi\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -1,8 +1,8 @@\n-package org.mbassy.listeners;\n+package net.engio.mbassy.listeners;\n \n-import org.mbassy.events.SubTestEvent;\n-import org.mbassy.listener.Listener;\n-import org.mbassy.listener.Mode;\n+import net.engio.mbassy.events.SubTestEvent;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.Mode;\n \n /**\n  * @author bennidi\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/ListenerFactory.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.listeners;\n+package net.engio.mbassy.listeners;\n \n import java.util.HashMap;\n import java.util.LinkedList;\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java",
            "additions": 9,
            "deletions": 9
        },
        "diff content": "@@ -1,13 +1,13 @@\n-package org.mbassy.listeners;\n+package net.engio.mbassy.listeners;\n \n-import org.mbassy.events.TestEvent;\n-import org.mbassy.events.TestEvent2;\n-import org.mbassy.listener.Enveloped;\n-import org.mbassy.listener.Filter;\n-import org.mbassy.listener.Filters;\n-import org.mbassy.listener.Listener;\n-import org.mbassy.listener.Mode;\n-import org.mbassy.subscription.MessageEnvelope;\n+import net.engio.mbassy.events.TestEvent;\n+import net.engio.mbassy.events.TestEvent2;\n+import net.engio.mbassy.listener.Enveloped;\n+import net.engio.mbassy.listener.Filter;\n+import net.engio.mbassy.listener.Filters;\n+import net.engio.mbassy.listener.Listener;\n+import net.engio.mbassy.listener.Mode;\n+import net.engio.mbassy.subscription.MessageEnvelope;\n \n /**\n  * Todo: Add javadoc\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/net/engio/mbassy/listeners/NonListeningBean.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -1,7 +1,7 @@\n-package org.mbassy.listeners;\n+package net.engio.mbassy.listeners;\n \n-import org.mbassy.events.SubTestEvent;\n-import org.mbassy.events.TestEvent;\n+import net.engio.mbassy.events.SubTestEvent;\n+import net.engio.mbassy.events.TestEvent;\n \n /**\n  * This bean overrides all the handlers defined in its superclass. Since it does not specify any annotations\n"
    },
    {
        "commit hash": "32bed9afccc4701a8c97b650383ac432c9c476d1",
        "previous commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/MBassadorTest.java",
            "additions": 0,
            "deletions": 221
        },
        "diff content": "@@ -1,221 +0,0 @@\n-package org.mbassy;\n-\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-\n-import org.junit.Test;\n-import org.mbassy.events.SubTestEvent;\n-import org.mbassy.events.TestEvent;\n-import org.mbassy.events.TestEvent2;\n-import org.mbassy.listeners.EventingTestBean;\n-import org.mbassy.listeners.EventingTestBean2;\n-import org.mbassy.listeners.EventingTestBean3;\n-import org.mbassy.listeners.ListenerFactory;\n-import org.mbassy.listeners.MultiEventHandler;\n-import org.mbassy.listeners.NonListeningBean;\n-import org.mbassy.subscription.Subscription;\n-\n-/**\n- * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n- *\n- * @author bennidi\n- *         Date: 2/8/12\n- */\n-public class MBassadorTest extends UnitTest {\n-\n-\n-    // this is a single threaded test for subscribing and unsubscribing of a single listener\n-    @Test\n-    public void testSubscribeSimple() throws InterruptedException {\n-        MBassador bus = new MBassador(new BusConfiguration());\n-        List<Object> listeners = new LinkedList<Object>();\n-        int listenerCount = 1000;\n-\n-        // subscribe a number of listeners to the bus\n-        for (int i = 1; i <= listenerCount; i++) {\n-            EventingTestBean listener = new EventingTestBean();\n-            NonListeningBean nonListener = new NonListeningBean();\n-            listeners.add(listener);\n-\n-            bus.subscribe(listener);\n-            bus.subscribe(nonListener);\n-\n-            assertFalse(bus.unsubscribe(nonListener)); // these are not expected to be subscribed listeners\n-            assertFalse(bus.unsubscribe(new EventingTestBean()));\n-\n-        }\n-\n-        // check the generated subscriptions for existence of all previously subscribed valid listeners\n-        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n-        assertEquals(1, testEventsubscriptions.size());\n-        assertEquals(listenerCount, getNumberOfSubscribedListeners(testEventsubscriptions));\n-\n-        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n-        assertEquals(3, subTestEventsubscriptions.size());\n-        assertEquals(3 * listenerCount, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n-\n-        // unsubscribe the listeners\n-        for(Object listener : listeners){\n-            assertTrue(bus.unsubscribe(listener)); // this listener is expected to exist\n-        }\n-\n-        // no listener should be left\n-        testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n-        assertEquals(1, testEventsubscriptions.size());\n-        assertEquals(0, getNumberOfSubscribedListeners(testEventsubscriptions));\n-\n-        subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n-        assertEquals(3, subTestEventsubscriptions.size());\n-        assertEquals(0, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n-\n-    }\n-\n-    private int getNumberOfSubscribedListeners(Collection<Subscription> subscriptions) {\n-        int listeners = 0;\n-        for (Subscription sub : subscriptions) {\n-            listeners += sub.size();\n-        }\n-        return listeners;\n-    }\n-\n-    @Test\n-    public void testConcurrentSubscription() throws Exception {\n-\n-        MBassador bus = new MBassador(new BusConfiguration());\n-        ListenerFactory listenerFactory = new ListenerFactory()\n-                .create(100, EventingTestBean.class)\n-                .create(100, EventingTestBean2.class)\n-                .create(100, EventingTestBean3.class)\n-                .create(100, Object.class)\n-                .create(100, NonListeningBean.class);\n-\n-        List<Object> listeners = listenerFactory.build();\n-\n-        // this will subscribe the listeners concurrently to the bus\n-        TestUtil.setup(bus, listeners, 10);\n-\n-        // check the generated subscriptions for existence of all previously subscribed valid listeners\n-        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n-        assertEquals(3, testEventsubscriptions.size());\n-        assertEquals(300, getNumberOfSubscribedListeners(testEventsubscriptions));\n-\n-        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n-        assertEquals(10, subTestEventsubscriptions.size());\n-        assertEquals(1000, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n-\n-    }\n-\n-\n-    @Test\n-    public void testAsynchronousMessagePublication() throws Exception {\n-\n-        MBassador bus = new MBassador(new BusConfiguration());\n-        ListenerFactory listenerFactory = new ListenerFactory()\n-                .create(100, EventingTestBean.class)\n-                .create(100, EventingTestBean2.class)\n-                .create(100, EventingTestBean3.class)\n-                .create(100, Object.class)\n-                .create(100, NonListeningBean.class)\n-                .create(100, MultiEventHandler.class);\n-\n-        List<Object> listeners = listenerFactory.build();\n-\n-        // this will subscribe the listeners concurrently to the bus\n-        TestUtil.setup(bus, listeners, 10);\n-\n-        TestEvent event = new TestEvent();\n-        TestEvent subEvent = new SubTestEvent();\n-        TestEvent2 event2 = new TestEvent2();\n-\n-        bus.publishAsync(event);\n-        bus.publishAsync(subEvent);\n-        bus.publishAsync(event2);\n-\n-        pause(2000);\n-\n-        assertEquals(500, event.counter.get());\n-        assertEquals(800, subEvent.counter.get());\n-        assertEquals(200, event2.counter.get());\n-\n-    }\n-\n-    @Test\n-    public void testSynchronousMessagePublication() throws Exception {\n-\n-        MBassador bus = new MBassador(new BusConfiguration());\n-        ListenerFactory listenerFactory = new ListenerFactory()\n-                .create(100, EventingTestBean.class)\n-                .create(100, EventingTestBean2.class)\n-                .create(100, EventingTestBean3.class)\n-                .create(100, Object.class)\n-                .create(100, NonListeningBean.class);\n-\n-        List<Object> listeners = listenerFactory.build();\n-\n-        // this will subscribe the listeners concurrently to the bus\n-        TestUtil.setup(bus, listeners, 10);\n-\n-        TestEvent event = new TestEvent();\n-        TestEvent subEvent = new SubTestEvent();\n-\n-        bus.publish(event);\n-        bus.publish(subEvent);\n-\n-        pause(2000);\n-\n-        assertEquals(300, event.counter.get());\n-        assertEquals(700, subEvent.counter.get());\n-\n-    }\n-\n-    @Test\n-    public void testConcurrentMixedMessagePublication() throws Exception {\n-        final CopyOnWriteArrayList<TestEvent> testEvents = new CopyOnWriteArrayList<TestEvent>();\n-        final CopyOnWriteArrayList<SubTestEvent> subtestEvents = new CopyOnWriteArrayList<SubTestEvent>();\n-        final int eventLoopsPerTHread = 100;\n-\n-\n-        final MBassador bus = new MBassador(new BusConfiguration());\n-        ListenerFactory listenerFactory = new ListenerFactory()\n-                .create(100, EventingTestBean.class)\n-                .create(100, EventingTestBean2.class)\n-                .create(100, EventingTestBean3.class)\n-                .create(100, Object.class)\n-                .create(100, NonListeningBean.class);\n-\n-        List<Object> listeners = listenerFactory.build();\n-\n-        // this will subscribe the listeners concurrently to the bus\n-        TestUtil.setup(bus, listeners, 10);\n-\n-        ConcurrentExecutor.runConcurrent(new Runnable() {\n-            @Override\n-            public void run() {\n-                for (int i = 0; i < eventLoopsPerTHread; i++) {\n-                    TestEvent event = new TestEvent();\n-                    SubTestEvent subEvent = new SubTestEvent();\n-                    testEvents.add(event);\n-                    subtestEvents.add(subEvent);\n-\n-                    bus.publishAsync(event);\n-                    bus.publish(subEvent);\n-                }\n-            }\n-        }, 10);\n-\n-        pause(3000);\n-\n-        for (TestEvent event : testEvents) {\n-            assertEquals(300, event.counter.get());\n-        }\n-\n-        for (SubTestEvent event : subtestEvents) {\n-            assertEquals(700, event.counter.get());\n-        }\n-\n-    }\n-\n-\n-}\n"
    },
    {
        "commit hash": "1c3444c2f0bbfc74e20b3a89e1f02d407f7eb17a",
        "previous commit hash": "7ca48b5966582b342029ee9b73a3704bbbfd3322",
        "diff stats": {
            "file_path": "pom.xml.releaseBackup",
            "additions": 152,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,152 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.mbassy</groupId>\n+    <artifactId>mbassador</artifactId>\n+    <version>1.0.7.RC-SNAPSHOT</version>\n+    <packaging>jar</packaging>\n+    <name>mbassador</name>\n+    <description>\n+        Mbassador is a fast and flexible message bus system following the publish subscribe pattern.\n+        It is designed for ease of use and aims to be feature rich and extensible\n+        while preserving resource efficiency and performance.\n+\n+        It features:\n+        declarative listener definition via annotations,\n+        sync and/or async message delivery,\n+        weak-references,\n+        message filtering,\n+        ordering of message handlers etc.\n+\n+    </description>\n+\n+    <url>https://github.com/bennidi/mbassador</url>\n+    <licenses>\n+        <license>\n+            <name>MIT license</name>\n+            <url>http://www.opensource.org/licenses/mit-license.php</url>\n+        </license>\n+    </licenses>\n+    <scm>\n+        <url>scm:git:git@github.com:bennidi/mbassador.git</url>\n+        <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n+    </scm>\n+    <developers>\n+\n+        <developer>\n+            <id>bennidi</id>\n+            <name>Benjamin Diedrichsen</name>\n+            <timezone>+1</timezone>\n+        </developer>\n+    </developers>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.build.java.version>1.6</project.build.java.version>\n+        <github.url>file://${project.basedir}/mvn-local-repo</github.url>\n+    </properties>\n+\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.10</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+    </dependencies>\n+\n+    <distributionManagement>\n+        <repository>\n+            <id>mbassador-github-repo</id>\n+            <url>${github.url}</url>\n+        </repository>\n+    </distributionManagement>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>${project.build.java.version}</source>\n+                    <target>${project.build.java.version}</target>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-release-plugin</artifactId>\n+                <version>2.4</version>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <skipTests>false</skipTests>\n+                </configuration>\n+            </plugin>\n+\n+            <!-- bind the source attaching to package phase -->\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-source-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <id>attach-sources</id>\n+                        <goals>\n+                            <goal>jar</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-javadoc-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <id>attach-javadocs</id>\n+                        <goals>\n+                            <goal>jar</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n+        </plugins>\n+    </build>\n+\n+    <profiles>\n+        <profile>\n+            <id>release-sign-artifacts</id>\n+            <activation>\n+                <property>\n+                    <name>performRelease</name>\n+                    <value>true</value>\n+                </property>\n+            </activation>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins</groupId>\n+                        <artifactId>maven-gpg-plugin</artifactId>\n+                        <version>1.4</version>\n+                        <executions>\n+                            <execution>\n+                                <id>sign-artifacts</id>\n+                                <phase>verify</phase>\n+                                <goals>\n+                                    <goal>sign</goal>\n+                                </goals>\n+                            </execution>\n+                        </executions>\n+                    </plugin>\n+                </plugins>\n+            </build>\n+        </profile>\n+    </profiles>\n+</project>\n"
    },
    {
        "commit hash": "7ca48b5966582b342029ee9b73a3704bbbfd3322",
        "previous commit hash": "95823abd9b3c6b0f1df822265886c753362145b1",
        "diff stats": {
            "file_path": ".gitignore",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -8,6 +8,7 @@\n \n # root of compiled classes #\n target/**/*\n+target/*\n \n # the local maven repository #\n mvn-local-repo/**/*\n"
    },
    {
        "commit hash": "7ca48b5966582b342029ee9b73a3704bbbfd3322",
        "previous commit hash": "95823abd9b3c6b0f1df822265886c753362145b1",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 3,
            "deletions": 0
        },
        "diff content": "@@ -80,6 +80,9 @@\n                 <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-release-plugin</artifactId>\n                 <version>2.4</version>\n+                <configuration>\n+                    <mavenExecutorId>forked-path</mavenExecutorId>\n+                </configuration>\n             </plugin>\n \n             <plugin>\n"
    },
    {
        "commit hash": "95823abd9b3c6b0f1df822265886c753362145b1",
        "previous commit hash": "3c135faccd93eca3f463bc40b1f619f10e007a1a",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -3,7 +3,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>org.mbassy</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.0.7</version>\n+    <version>1.0.8-SNAPSHOT</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -30,7 +30,7 @@\n     <scm>\n         <url>scm:git:git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-      <tag>mbassador-1.0.7</tag>\n+      <tag>HEAD</tag>\n   </scm>\n     <developers>\n \n"
    },
    {
        "commit hash": "3c135faccd93eca3f463bc40b1f619f10e007a1a",
        "previous commit hash": "81a1d3fa9b276f7154395b8f106a79a34e4d01d2",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -1,10 +1,9 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n \n     <modelVersion>4.0.0</modelVersion>\n     <groupId>org.mbassy</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.0.7.RC-SNAPSHOT</version>\n+    <version>1.0.7</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>\n@@ -31,7 +30,8 @@\n     <scm>\n         <url>scm:git:git@github.com:bennidi/mbassador.git</url>\n         <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n-    </scm>\n+      <tag>mbassador-1.0.7</tag>\n+  </scm>\n     <developers>\n \n         <developer>\n"
    },
    {
        "commit hash": "81a1d3fa9b276f7154395b8f106a79a34e4d01d2",
        "previous commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -44,7 +44,7 @@\n     <properties>\n         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n         <project.build.java.version>1.6</project.build.java.version>\n-        <github.url>file://${project.basedir}/maven</github.url>\n+        <github.url>file://${project.basedir}/mvn-local-repo</github.url>\n     </properties>\n \n     <dependencies>\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": ".gitignore",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -10,5 +10,5 @@\n target/**/*\n \n # the local maven repository #\n-maven/**/*\n+mvn-local-repo/**/*\n release.properties\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/maven-metadata.xml",
            "additions": 13,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,13 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<metadata>\n+  <groupId>org.mbassy</groupId>\n+  <artifactId>mbassador</artifactId>\n+  <version>1.0.7.RC-SNAPSHOT</version>\n+  <versioning>\n+    <snapshot>\n+      <timestamp>20121229.133808</timestamp>\n+      <buildNumber>1</buildNumber>\n+    </snapshot>\n+    <lastUpdated>20121229133808</lastUpdated>\n+  </versioning>\n+</metadata>\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/maven-metadata.xml.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+732608242394f6b316a7cf631208b635\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/maven-metadata.xml.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+2cae8933661f8cf18afc2c923436c2457e0b3809\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1-javadoc.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1-javadoc.jar differ\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1-javadoc.jar.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+d20f34dc532b790786a74566598e5e68\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1-javadoc.jar.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+13de5221308cf546ff55aa6b5a35ec1f78ecf691\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1-sources.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1-sources.jar differ\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1-sources.jar.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+ec63e6aa1e908e4036cca782675742df\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1-sources.jar.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+79eb0716f839f2b63cf5d3d9796800967d54fdb5\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1.jar differ\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1.jar.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+21ac5231ee676ba2461e31392e210b54\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1.jar.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+9cfcc0fe9534d2a530b48445331d451b97ca3342\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1.pom",
            "additions": 152,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,152 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.mbassy</groupId>\n+    <artifactId>mbassador</artifactId>\n+    <version>1.0.7.RC-SNAPSHOT</version>\n+    <packaging>jar</packaging>\n+    <name>mbassador</name>\n+    <description>\n+        Mbassador is a fast and flexible message bus system following the publish subscribe pattern.\n+        It is designed for ease of use and aims to be feature rich and extensible\n+        while preserving resource efficiency and performance.\n+\n+        It features:\n+        declarative listener definition via annotations,\n+        sync and/or async message delivery,\n+        weak-references,\n+        message filtering,\n+        ordering of message handlers etc.\n+\n+    </description>\n+\n+    <url>https://github.com/bennidi/mbassador</url>\n+    <licenses>\n+        <license>\n+            <name>MIT license</name>\n+            <url>http://www.opensource.org/licenses/mit-license.php</url>\n+        </license>\n+    </licenses>\n+    <scm>\n+        <url>scm:git:git@github.com:bennidi/mbassador.git</url>\n+        <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n+    </scm>\n+    <developers>\n+\n+        <developer>\n+            <id>bennidi</id>\n+            <name>Benjamin Diedrichsen</name>\n+            <timezone>+1</timezone>\n+        </developer>\n+    </developers>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.build.java.version>1.6</project.build.java.version>\n+        <github.url>file://${project.basedir}/maven</github.url>\n+    </properties>\n+\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.10</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+    </dependencies>\n+\n+    <distributionManagement>\n+        <repository>\n+            <id>mbassador-github-repo</id>\n+            <url>${github.url}</url>\n+        </repository>\n+    </distributionManagement>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>${project.build.java.version}</source>\n+                    <target>${project.build.java.version}</target>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-release-plugin</artifactId>\n+                <version>2.4</version>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <skipTests>false</skipTests>\n+                </configuration>\n+            </plugin>\n+\n+            <!-- bind the source attaching to package phase -->\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-source-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <id>attach-sources</id>\n+                        <goals>\n+                            <goal>jar</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-javadoc-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <id>attach-javadocs</id>\n+                        <goals>\n+                            <goal>jar</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n+        </plugins>\n+    </build>\n+\n+    <profiles>\n+        <profile>\n+            <id>release-sign-artifacts</id>\n+            <activation>\n+                <property>\n+                    <name>performRelease</name>\n+                    <value>true</value>\n+                </property>\n+            </activation>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins</groupId>\n+                        <artifactId>maven-gpg-plugin</artifactId>\n+                        <version>1.4</version>\n+                        <executions>\n+                            <execution>\n+                                <id>sign-artifacts</id>\n+                                <phase>verify</phase>\n+                                <goals>\n+                                    <goal>sign</goal>\n+                                </goals>\n+                            </execution>\n+                        </executions>\n+                    </plugin>\n+                </plugins>\n+            </build>\n+        </profile>\n+    </profiles>\n+</project>\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1.pom.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+05e16f4d46db6bc39529ebe889ff552d\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.7.RC-SNAPSHOT/mbassador-1.0.7.RC-20121229.133808-1.pom.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+5e078c7f168816392ca34e41cbc8f58c81b8c5d9\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -12,7 +12,8 @@\n       <version>1.0.4.RC</version>\n       <version>1.0.5.RC</version>\n       <version>1.0.6.RC</version>\n+      <version>1.0.7.RC-SNAPSHOT</version>\n     </versions>\n-    <lastUpdated>20121225161830</lastUpdated>\n+    <lastUpdated>20121229133808</lastUpdated>\n   </versioning>\n </metadata>\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.md5",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-3ad8909f1f842b3c7a9644c8ad1cdb84\n\\ No newline at end of file\n+46231d9bfb55280deeea69a9e18ed52b\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.sha1",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-025b0b9e37663a19aeaf95c12a7d6cf8d8e470fc\n\\ No newline at end of file\n+3608eef0e3183c20460c8b1839c6a3d5740dd63e\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "9ab78422e4e692177d01ecd7495a3fdd0dd85ffb",
        "previous commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -4,7 +4,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>org.mbassy</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.0.6.RC-SNAPSHOT</version>\n+    <version>1.0.7.RC-SNAPSHOT</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>\n"
    },
    {
        "commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "previous commit hash": "adc43a37453003567fdac40c19d9123069922f63",
        "diff stats": {
            "file_path": ".gitignore",
            "additions": 4,
            "deletions": 0
        },
        "diff content": "@@ -8,3 +8,7 @@\n \n # root of compiled classes #\n target/**/*\n+\n+# the local maven repository #\n+maven/**/*\n+release.properties\n"
    },
    {
        "commit hash": "b798f77b874e31e23e0c34227eb3c1b0b79f7c53",
        "previous commit hash": "adc43a37453003567fdac40c19d9123069922f63",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 96,
            "deletions": 2
        },
        "diff content": "@@ -4,12 +4,43 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>org.mbassy</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.0.6.RC</version>\n+    <version>1.0.6.RC-SNAPSHOT</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n-    <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n+    <description>\n+        Mbassador is a fast and flexible message bus system following the publish subscribe pattern.\n+        It is designed for ease of use and aims to be feature rich and extensible\n+        while preserving resource efficiency and performance.\n+\n+        It features:\n+        declarative listener definition via annotations,\n+        sync and/or async message delivery,\n+        weak-references,\n+        message filtering,\n+        ordering of message handlers etc.\n+\n     </description>\n \n+    <url>https://github.com/bennidi/mbassador</url>\n+    <licenses>\n+        <license>\n+            <name>MIT license</name>\n+            <url>http://www.opensource.org/licenses/mit-license.php</url>\n+        </license>\n+    </licenses>\n+    <scm>\n+        <url>scm:git:git@github.com:bennidi/mbassador.git</url>\n+        <connection>scm:git:git@github.com:bennidi/mbassador.git</connection>\n+    </scm>\n+    <developers>\n+\n+        <developer>\n+            <id>bennidi</id>\n+            <name>Benjamin Diedrichsen</name>\n+            <timezone>+1</timezone>\n+        </developer>\n+    </developers>\n+\n     <properties>\n         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n         <project.build.java.version>1.6</project.build.java.version>\n@@ -45,6 +76,12 @@\n                 </configuration>\n             </plugin>\n \n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-release-plugin</artifactId>\n+                <version>2.4</version>\n+            </plugin>\n+\n             <plugin>\n                 <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-surefire-plugin</artifactId>\n@@ -53,6 +90,63 @@\n                 </configuration>\n             </plugin>\n \n+            <!-- bind the source attaching to package phase -->\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-source-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <id>attach-sources</id>\n+                        <goals>\n+                            <goal>jar</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-javadoc-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <id>attach-javadocs</id>\n+                        <goals>\n+                            <goal>jar</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n         </plugins>\n     </build>\n+\n+    <profiles>\n+        <profile>\n+            <id>release-sign-artifacts</id>\n+            <activation>\n+                <property>\n+                    <name>performRelease</name>\n+                    <value>true</value>\n+                </property>\n+            </activation>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins</groupId>\n+                        <artifactId>maven-gpg-plugin</artifactId>\n+                        <version>1.4</version>\n+                        <executions>\n+                            <execution>\n+                                <id>sign-artifacts</id>\n+                                <phase>verify</phase>\n+                                <goals>\n+                                    <goal>sign</goal>\n+                                </goals>\n+                            </execution>\n+                        </executions>\n+                    </plugin>\n+                </plugins>\n+            </build>\n+        </profile>\n+    </profiles>\n </project>\n"
    },
    {
        "commit hash": "adc43a37453003567fdac40c19d9123069922f63",
        "previous commit hash": "acd19169afcab3332c446384f5ab2874b126daf2",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -77,7 +77,7 @@ Listener definition (in any bean):\n \n         @Listener(dispatch = Mode.Synchronous, rejectSubtypes = true)\n         @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n-        public void handleSuperTypeEvents(MessageEnvelope envelope) {\n+        public void handleVariousEvents(MessageEnvelope envelope) {\n             // the envelope will contain either an instance of TestEvent or TestEvent2\n             // if rejectSubtypes were set to 'false' (default) also subtypes of TestEvent or TestEvent2 would be allowed\n         }\n"
    },
    {
        "commit hash": "acd19169afcab3332c446384f5ab2874b126daf2",
        "previous commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "diff stats": {
            "file_path": "README.md",
            "additions": 6,
            "deletions": 5
        },
        "diff content": "@@ -66,19 +66,20 @@ Listener definition (in any bean):\n             // do something more expensive here\n \t\t}\n \n-\t\t// this handler will receive events of type SubTestEvent\n-        // or any subtabe and that passes the given filter(s)\n+\t\t// this handler will receive messages of type SubTestEvent\n+        // or any of its sub types that passe the given filter(s)\n         @Listener(priority = 10,\n                   dispatch = Mode.Synchronous,\n-                  filters = {@Filter(MessageFilter.None.class),@Filter(MessageFilter.All.class)})\n+                  filters = {@Filter(Filters.SpecialEvent.class)})\n         public void handleFiltered(SubTestEvent event) {\n            //do something special here\n         }\n \n-        @Listener(dispatch = Mode.Synchronous, filters = @Filter(Filters.RejectSubtypes.class))\n+        @Listener(dispatch = Mode.Synchronous, rejectSubtypes = true)\n         @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n         public void handleSuperTypeEvents(MessageEnvelope envelope) {\n-            // detect the type of event here and then decide the course of action\n+            // the envelope will contain either an instance of TestEvent or TestEvent2\n+            // if rejectSubtypes were set to 'false' (default) also subtypes of TestEvent or TestEvent2 would be allowed\n         }\n \n \n"
    },
    {
        "commit hash": "acd19169afcab3332c446384f5ab2874b126daf2",
        "previous commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.jar and b/maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.jar differ\n"
    },
    {
        "commit hash": "acd19169afcab3332c446384f5ab2874b126daf2",
        "previous commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.jar.md5",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-a2ddea6754519b5b4c029f48431e0605\n\\ No newline at end of file\n+dac16b8c129ee38d08e63d4cd487bdc9\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "acd19169afcab3332c446384f5ab2874b126daf2",
        "previous commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.jar.sha1",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-f2496df5cf69076115670219c0127968e3c7ad63\n\\ No newline at end of file\n+110fd15551d0a40fafd46cc4e66c590e4d1b2fc7\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "acd19169afcab3332c446384f5ab2874b126daf2",
        "previous commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -13,6 +13,6 @@\n       <version>1.0.5.RC</version>\n       <version>1.0.6.RC</version>\n     </versions>\n-    <lastUpdated>20121225153509</lastUpdated>\n+    <lastUpdated>20121225161830</lastUpdated>\n   </versioning>\n </metadata>\n"
    },
    {
        "commit hash": "acd19169afcab3332c446384f5ab2874b126daf2",
        "previous commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.md5",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-0cc21fcd52a994d6b22f9fe57f210143\n\\ No newline at end of file\n+3ad8909f1f842b3c7a9644c8ad1cdb84\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "acd19169afcab3332c446384f5ab2874b126daf2",
        "previous commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.sha1",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-dc58ab03113b6edefe5f3bfdfc464e5c344b253a\n\\ No newline at end of file\n+025b0b9e37663a19aeaf95c12a7d6cf8d8e470fc\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "acd19169afcab3332c446384f5ab2874b126daf2",
        "previous commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/Listener.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -21,6 +21,6 @@ public @interface Listener {\n \n     int priority() default 0;\n \n-    boolean handlesSubtypes() default true;\n+    boolean rejectSubtypes() default false;\n \n }\n"
    },
    {
        "commit hash": "acd19169afcab3332c446384f5ab2874b126daf2",
        "previous commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MessageHandlerMetadata.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -33,7 +33,7 @@ public class MessageHandlerMetadata {\n         this.listenerConfig = listenerConfig;\n         this.isAsynchronous = listenerConfig.dispatch().equals(Mode.Asynchronous);\n         this.envelope = handler.getAnnotation(Enveloped.class);\n-        this.acceptsSubtypes = listenerConfig.handlesSubtypes();\n+        this.acceptsSubtypes = !listenerConfig.rejectSubtypes();\n         if(this.envelope != null){\n             for(Class messageType : envelope.messages())\n                 handledMessages.add(messageType);\n"
    },
    {
        "commit hash": "acd19169afcab3332c446384f5ab2874b126daf2",
        "previous commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/MetadataReaderTest.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -111,7 +111,7 @@ public class MetadataReaderTest extends UnitTest {\n     // a simple event listener\n     public class EventListener1 {\n \n-        @Listener(handlesSubtypes = false)\n+        @Listener(rejectSubtypes = true)\n         public void handleObject(Object o) {\n \n         }\n@@ -135,7 +135,7 @@ public class MetadataReaderTest extends UnitTest {\n     public class EventListener3 extends EventListener2 {\n \n         // narrow the handler\n-        @Listener(handlesSubtypes = false)\n+        @Listener(rejectSubtypes = true)\n         public void handleAny(Object o) {\n \n         }\n@@ -150,7 +150,7 @@ public class MetadataReaderTest extends UnitTest {\n     public class EnvelopedListener{\n \n \n-        @Listener(handlesSubtypes = false)\n+        @Listener(rejectSubtypes = true)\n         @Enveloped(messages = {String.class, Integer.class, Long.class})\n         public void handleEnveloped(MessageEnvelope o) {\n \n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "README.md",
            "additions": 30,
            "deletions": 10
        },
        "diff content": "@@ -2,20 +2,20 @@ Mbassador\n =========\n \n Mbassador is a very light-weight message (event) bus implementation following the publish subscribe pattern. It is designed\n-for ease of use and aims to be feature rich, extensible while preserving resource efficiency and performance.\n-\n-It uses a specialized data structure to allow high throughput for concurrent access.\n+for ease of use and aims to be feature rich and extensible while preserving resource efficiency and performance. It uses a specialized\n+data structure to allow high throughput for concurrent access.\n \n Read this documentation to get an overview of its features and how cool this message (event) bus actually is.\n You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n which also contains a partial list of the features of the compared implementations.\n \n-The current version is 1.0.5.RC\n+The current version is 1.0.6.RC, see the release notes for more details.\n \n Table of contents:\n + [Features](#features)\n + [Usage](#usage)\n + [Installation](#installation)\n++ [Release Notes](#releasenotes)\n + [Roadmap](#roadmap)\n + [Credits](#credits)\n + [Contribute](#contribute)\n@@ -124,26 +124,46 @@ will be done as soon as enough people use this component. Until then, the follow\n         &lt;dependency&gt;\n             &lt;groupId&gt;org.mbassy&lt;/groupId&gt;\n             &lt;artifactId&gt;mbassador&lt;/artifactId&gt;\n-            &lt;version&gt;1.0.0.RC&lt;/version&gt;\n+            &lt;version&gt;1.0.6.RC&lt;/version&gt;\n         &lt;/dependency&gt;\n     </pre></code>\n  3. Run mvn clean package to have maven download and install the required version into your local repository\n \n Of course you can always clone the repository and build from source\n \n+<h2>Release Notes</h2>\n+\n+<h3>1.0.6.RC</h3>\n+\n+ + Fixed behaviour with capacity bound blocking queue such that there now are two methods to schedule a message\n+ asynchronously. One will block until capacity becomes available, the other will timeout after a specified amount of\n+ time.\n+ +  Added unit tests\n+\n+<h3>1.0.5.RC</h3>\n+\n+ + Added MessageEnvelope and @Enveloped annotation to configure handlers that might receive arbitrary message type\n+ + Added handler configuration property to @Listener annotation to move from message filtering to more specific implementation\n+ of this feature\n+\n+<h3>1.0.4.RC</h3>\n+\n+  + Introduced BusConfiguration as a central class to encapsulate configurational aspects\n+\n+\n <h2>Roadmap</h2>\n + Checkout MBassador from one of the official maven repositories (as soon as the user base is big enough)\n + Spring integration with support for conditional message dispatch in transactional context (dispatch only after\n successful commit etc.). Currently in beta, see <a href=\"https://github.com/bennidi/mbassador-spring\">this</a> repository\n-+ MessageEnvelope for each dispatch that is passed to the handler and can be used for communication between handlers\n-during the running dispatch\n \n \n <h2>Credits</h2>\n The initial inspiration for creating this component came from looking at Google Guava's event bus implementation. Since\n-it did not provide all the features we needed in our project, I decided to create my own implementation. When I saw that\n-it outperformed the Guava implementation by far, I decided to share it with the community to see if others consider it worth\n-a shot.\n+it did not provide all the features we needed in our project, I decided to create my own implementation. It matured to be\n+quite a feature rich and yet very efficient and performant message bus.\n+\n+I want to thank the development team from friendsurance (www.friendsurance.de) for their support and feedback on the bus\n+implementation and the management of friendsurance for allowing me to publish the component as an open source project.\n \n <h2>Contribute</h2>\n \n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "build.gradle",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,7 +1,7 @@\n usePlugin('java')\n \n group=\"org.mbassy\"\n-version=\"1.0.4.RC\"\n+version=\"1.0.6.RC\"\n \n dependencies {\n     addMavenRepo()\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.jar differ\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.jar.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+a2ddea6754519b5b4c029f48431e0605\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.jar.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+f2496df5cf69076115670219c0127968e3c7ad63\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.pom",
            "additions": 58,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,58 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.mbassy</groupId>\n+    <artifactId>mbassador</artifactId>\n+    <version>1.0.6.RC</version>\n+    <packaging>jar</packaging>\n+    <name>mbassador</name>\n+    <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n+    </description>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.build.java.version>1.6</project.build.java.version>\n+        <github.url>file://${project.basedir}/maven</github.url>\n+    </properties>\n+\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.10</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+    </dependencies>\n+\n+    <distributionManagement>\n+        <repository>\n+            <id>mbassador-github-repo</id>\n+            <url>${github.url}</url>\n+        </repository>\n+    </distributionManagement>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>${project.build.java.version}</source>\n+                    <target>${project.build.java.version}</target>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <skipTests>false</skipTests>\n+                </configuration>\n+            </plugin>\n+\n+        </plugins>\n+    </build>\n+</project>\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.pom.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+ebf2e22bfe53d858092befaa865d0bf4\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.6.RC/mbassador-1.0.6.RC.pom.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+950ca7e831a9060060f943ca02d313f7c7f5ccbf\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -11,7 +11,8 @@\n       <version>1.0.3.RC</version>\n       <version>1.0.4.RC</version>\n       <version>1.0.5.RC</version>\n+      <version>1.0.6.RC</version>\n     </versions>\n-    <lastUpdated>20121212135342</lastUpdated>\n+    <lastUpdated>20121225153509</lastUpdated>\n   </versioning>\n </metadata>\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.md5",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-e37de32d920e2182f2549b0500dc20d8\n\\ No newline at end of file\n+0cc21fcd52a994d6b22f9fe57f210143\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.sha1",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-6b5568c98223ec0a53f7b7ede78e965ba7f0080f\n\\ No newline at end of file\n+dc58ab03113b6edefe5f3bfdfc464e5c344b253a\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -4,7 +4,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>org.mbassy</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.0.5.RC</version>\n+    <version>1.0.6.RC</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/AbstractMessageBus.java",
            "additions": 26,
            "deletions": 12
        },
        "diff content": "@@ -5,7 +5,6 @@ import org.mbassy.dispatch.MessagingContext;\n import org.mbassy.listener.MessageHandlerMetadata;\n import org.mbassy.listener.MetadataReader;\n import org.mbassy.subscription.Subscription;\n-import org.mbassy.subscription.SubscriptionDeliveryRequest;\n import org.mbassy.subscription.SubscriptionFactory;\n \n import java.util.*;\n@@ -46,23 +45,19 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n \n     // all pending messages scheduled for asynchronous dispatch are queued here\n-    private final LinkedBlockingQueue<SubscriptionDeliveryRequest<T>> pendingMessages;\n+    private final BlockingQueue<MessagePublication<T>> pendingMessages;\n \n     // this factory is used to create specialized subscriptions based on the given message handler configuration\n     // it can be customized by implementing the getSubscriptionFactory() method\n     private final SubscriptionFactory subscriptionFactory;\n \n-    // indicates whether the shutdown method has been invoked\n-    // -> if true, then dispatchers will have been shutdown\n-    private final AtomicBoolean isShutDown = new AtomicBoolean(false);\n-\n \n \n     public AbstractMessageBus(BusConfiguration configuration) {\n         this.executor = configuration.getExecutor();\n         subscriptionFactory = configuration.getSubscriptionFactory();\n         this.metadataReader = configuration.getMetadataReader();\n-        pendingMessages  = new LinkedBlockingQueue<SubscriptionDeliveryRequest<T>>(configuration.getMaximumNumberOfPendingMessages());\n+        pendingMessages  = new LinkedBlockingQueue<MessagePublication<T>>(configuration.getMaximumNumberOfPendingMessages());\n         initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n         addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n     }\n@@ -156,8 +151,25 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         errorHandlers.add(handler);\n     }\n \n-    protected void addAsynchronousDeliveryRequest(SubscriptionDeliveryRequest<T> request) {\n-        pendingMessages.offer(request);\n+    // this method enqueues a message delivery request\n+    protected MessagePublication<T> addAsynchronousDeliveryRequest(MessagePublication<T> request){\n+        try {\n+            pendingMessages.put(request);\n+            return request.markScheduled();\n+        } catch (InterruptedException e) {\n+            return request.setError();\n+        }\n+    }\n+\n+    // this method enqueues a message delivery request\n+    protected MessagePublication<T> addAsynchronousDeliveryRequest(MessagePublication<T> request, long timeout, TimeUnit unit){\n+        try {\n+            return pendingMessages.offer(request, timeout, unit)\n+                    ? request.markScheduled()\n+                    : request.setError();\n+        } catch (InterruptedException e) {\n+            return request.setError();\n+        }\n     }\n \n     // obtain the set of subscriptions for the given message type\n@@ -169,8 +181,11 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         }\n         // TODO: get superclasses is eligible for caching\n         for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n-            if (subscriptionsPerMessage.get(eventSuperType) != null) {\n-                subscriptions.addAll(subscriptionsPerMessage.get(eventSuperType));\n+            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n+            if (subs != null) {\n+                for(Subscription sub : subs){\n+                    if(sub.handlesMessageType(messageType))subscriptions.add(sub);\n+                }\n             }\n         }\n         return subscriptions;\n@@ -209,7 +224,6 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n             dispatcher.interrupt();\n         }\n         executor.shutdown();\n-        isShutDown.set(true);\n     }\n \n     public boolean hasPendingMessages(){\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/BusConfiguration.java",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -42,6 +42,7 @@ public class BusConfiguration {\n         this.subscriptionFactory = new SubscriptionFactory();\n         this.executor = new ThreadPoolExecutor(10, 10, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), DaemonThreadFactory);\n         this.metadataReader = new MetadataReader();\n+\n     }\n \n     public MetadataReader getMetadataReader() {\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/IMessageBus.java",
            "additions": 23,
            "deletions": 4
        },
        "diff content": "@@ -2,6 +2,7 @@ package org.mbassy;\n \n import java.util.Collection;\n import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  *\n@@ -118,7 +119,7 @@ public interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n      * Subclasses may extend this interface and add functionality, e.g. different dispatch schemes.\n      *\n      */\n-    public static interface IPostCommand{\n+    public static interface IPostCommand<T>{\n \n         /**\n          * Execute the message publication immediately. This call blocks until every matching message handler\n@@ -127,10 +128,28 @@ public interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n         public void now();\n \n         /**\n-         * Execute the message publication asynchronously. This call return immediately and all matching message handlers\n-         * will be invoked in another thread.\n+         * Execute the message publication asynchronously. The behaviour of this method depends on the\n+         * configured queuing strategy:\n+         *\n+         * If an unbound queuing strategy is used the call returns immediately.\n+         * If a bounded queue is used the call might block until the message can be placed in the queue.\n+         *\n+         * @return A message publication that can be used to access information about the state of\n          */\n-        public void asynchronously();\n+        public MessagePublication<T> asynchronously();\n+\n+\n+        /**\n+         * Execute the message publication asynchronously. The behaviour of this method depends on the\n+         * configured queuing strategy:\n+         *\n+         * If an unbound queuing strategy is used the call returns immediately.\n+         * If a bounded queue is used the call will block until the message can be placed in the queue\n+         * or the timeout r\n+         *\n+         * @return A message publication that wraps up the publication request\n+         */\n+        public MessagePublication<T> asynchronously(long timeout, TimeUnit unit);\n \n     }\n \n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/MBassador.java",
            "additions": 26,
            "deletions": 20
        },
        "diff content": "@@ -1,20 +1,26 @@\n package org.mbassy;\n \n-import java.util.Collection;\n-\n import org.mbassy.subscription.Subscription;\n-import org.mbassy.subscription.SubscriptionDeliveryRequest;\n+\n+import java.util.Collection;\n+import java.util.concurrent.TimeUnit;\n \n \n-public class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>>{\n+public class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>> {\n \n-    public MBassador(BusConfiguration configuration){\n+    public MBassador(BusConfiguration configuration) {\n         super(configuration);\n     }\n \n \n-    public void publishAsync(T message){\n-        addAsynchronousDeliveryRequest(new SubscriptionDeliveryRequest<T>(getSubscriptionsByMessageType(message.getClass()), message));\n+    public MessagePublication<T> publishAsync(T message) {\n+        return addAsynchronousDeliveryRequest(MessagePublication.Create(\n+                getSubscriptionsByMessageType(message.getClass()), message));\n+    }\n+\n+    public MessagePublication<T> publishAsync(T message, long timeout, TimeUnit unit) {\n+        return addAsynchronousDeliveryRequest(MessagePublication.Create(\n+                getSubscriptionsByMessageType(message.getClass()), message), timeout, unit);\n     }\n \n \n@@ -24,23 +30,23 @@ public class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>>\n      *\n      * @param message\n      */\n-\tpublic void publish(T message){\n-\t\ttry {\n-\t\t\tfinal Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n-\t\t\tif(subscriptions == null){\n+    public void publish(T message) {\n+        try {\n+            final Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n+            if (subscriptions == null) {\n                 return; // TODO: Dead Event?\n             }\n-            for (Subscription subscription : subscriptions){\n+            for (Subscription subscription : subscriptions) {\n                 subscription.publish(message);\n             }\n-\t\t} catch (Throwable e) {\n-\t\t\thandlePublicationError(new PublicationError()\n-\t\t\t\t\t.setMessage(\"Error during publication of message\")\n-\t\t\t\t\t.setCause(e)\n-\t\t\t\t\t.setPublishedObject(message));\n-\t\t}\n-\n-\t}\n+        } catch (Throwable e) {\n+            handlePublicationError(new PublicationError()\n+                    .setMessage(\"Error during publication of message\")\n+                    .setCause(e)\n+                    .setPublishedObject(message));\n+        }\n+\n+    }\n \n \n     @Override\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/MessagePublication.java",
            "additions": 73,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,73 @@\n+package org.mbassy;\n+\n+import org.mbassy.subscription.Subscription;\n+\n+import java.util.Collection;\n+\n+/**\n+ * A message publication is created for each asynchronous message dispatch. It reflects the state\n+ * of the corresponding message publication process, i.e. provides information whether the\n+ * publication was successfully scheduled, is currently running etc.\n+ *\n+ * @author bennidi\n+ * Date: 11/16/12\n+ */\n+public class MessagePublication<T> {\n+\n+    public static <T> MessagePublication<T> Create(Collection<Subscription> subscriptions, T message){\n+        return new MessagePublication<T>(subscriptions, message, State.Initial);\n+    }\n+\n+    private Collection<Subscription> subscriptions;\n+\n+    private T message;\n+\n+    private State state = State.Scheduled;\n+\n+    private MessagePublication(Collection<Subscription> subscriptions, T message, State initialState) {\n+        this.subscriptions = subscriptions;\n+        this.message = message;\n+        this.state = initialState;\n+    }\n+\n+    public boolean add(Subscription subscription) {\n+        return subscriptions.add(subscription);\n+    }\n+\n+    protected void execute(){\n+        state = State.Running;\n+        for(Subscription sub : subscriptions){\n+            sub.publish(message);\n+        }\n+        state = State.Finished;\n+    }\n+\n+    public boolean isFinished() {\n+        return state.equals(State.Finished);\n+    }\n+\n+    public boolean isRunning() {\n+        return state.equals(State.Running);\n+    }\n+\n+    public boolean isScheduled() {\n+        return state.equals(State.Scheduled);\n+    }\n+\n+    public MessagePublication<T> markScheduled(){\n+        if(!state.equals(State.Initial))\n+            return this;\n+        state = State.Scheduled;\n+        return this;\n+    }\n+\n+    public MessagePublication<T> setError(){\n+        state = State.Error;\n+        return this;\n+    }\n+\n+    private enum State{\n+        Initial,Scheduled,Running,Finished,Error;\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/SyncAsyncPostCommand.java",
            "additions": 9,
            "deletions": 2
        },
        "diff content": "@@ -1,5 +1,7 @@\n package org.mbassy;\n \n+import java.util.concurrent.TimeUnit;\n+\n /**\n  * This post command provides access to standard synchronous and asynchronous dispatch\n  *\n@@ -22,7 +24,12 @@ public class SyncAsyncPostCommand<T> implements IMessageBus.IPostCommand {\n     }\n \n     @Override\n-    public void asynchronously() {\n-        mBassador.publishAsync(message);\n+    public MessagePublication<T> asynchronously() {\n+        return mBassador.publishAsync(message);\n+    }\n+\n+    @Override\n+    public MessagePublication asynchronously(long timeout, TimeUnit unit) {\n+        return mBassador.publishAsync(message, timeout, unit);\n     }\n }\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/Listener.java",
            "additions": 2,
            "deletions": 0
        },
        "diff content": "@@ -21,4 +21,6 @@ public @interface Listener {\n \n     int priority() default 0;\n \n+    boolean handlesSubtypes() default true;\n+\n }\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MessageHandlerMetadata.java",
            "additions": 17,
            "deletions": 0
        },
        "diff content": "@@ -24,6 +24,8 @@ public class MessageHandlerMetadata {\n \n     private List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n \n+    private boolean acceptsSubtypes = true;\n+\n \n     public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Listener listenerConfig) {\n         this.handler = handler;\n@@ -31,6 +33,7 @@ public class MessageHandlerMetadata {\n         this.listenerConfig = listenerConfig;\n         this.isAsynchronous = listenerConfig.dispatch().equals(Mode.Asynchronous);\n         this.envelope = handler.getAnnotation(Enveloped.class);\n+        this.acceptsSubtypes = listenerConfig.handlesSubtypes();\n         if(this.envelope != null){\n             for(Class messageType : envelope.messages())\n                 handledMessages.add(messageType);\n@@ -69,4 +72,18 @@ public class MessageHandlerMetadata {\n     public boolean isEnveloped() {\n         return envelope != null;\n     }\n+\n+    public boolean handlesMessage(Class<?> messageType){\n+        for(Class<?> handledMessage : handledMessages){\n+            if(handledMessage.equals(messageType))return true;\n+            if(handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean acceptsSubtypes(){\n+        return acceptsSubtypes;\n+    }\n+\n+\n }\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MessageListenerMetadata.java",
            "additions": 53,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,53 @@\n+package org.mbassy.listener;\n+\n+import org.mbassy.common.IPredicate;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * Provides information about the message listeners of a specific class. Each message handler\n+ * defined by the target class is represented as a single entity.\n+ *\n+ *\n+ * @author bennidi\n+ *         Date: 12/16/12\n+ */\n+public class MessageListenerMetadata<T> {\n+\n+\n+    public static final IPredicate<MessageHandlerMetadata> ForMessage(final Class<?> messageType){\n+        return new IPredicate<MessageHandlerMetadata>() {\n+            @Override\n+            public boolean apply(MessageHandlerMetadata target) {\n+                return target.handlesMessage(messageType);\n+            }\n+        };\n+    }\n+\n+    private List<MessageHandlerMetadata> handlers;\n+\n+    private Class<T> listenerDefinition;\n+\n+    public MessageListenerMetadata(List<MessageHandlerMetadata> handlers, Class<T> listenerDefinition) {\n+        this.handlers = handlers;\n+        this.listenerDefinition = listenerDefinition;\n+    }\n+\n+\n+    public List<MessageHandlerMetadata> getHandlers(IPredicate<MessageHandlerMetadata> filter){\n+        List<MessageHandlerMetadata> matching = new LinkedList<MessageHandlerMetadata>();\n+        for(MessageHandlerMetadata handler : handlers){\n+            if(filter.apply(handler))matching.add(handler);\n+        }\n+        return matching;\n+    }\n+\n+    public boolean handles(Class<?> messageType){\n+        return !getHandlers(ForMessage(messageType)).isEmpty();\n+    }\n+\n+    public Class<T> getListerDefinition(){\n+        return listenerDefinition;\n+    }\n+}\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MetadataReader.java",
            "additions": 15,
            "deletions": 22
        },
        "diff content": "@@ -60,35 +60,28 @@ public class MetadataReader {\n     // get all listeners defined by the given class (includes\n     // listeners defined in super classes)\n     public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n+        // get all handlers (this will include overridden handlers)\n         List<Method> allMethods = ReflectionUtils.getMethods(AllMessageHandlers, target);\n-        List<Method>  handlers = new LinkedList<Method>();\n-        for(Method listener : allMethods){\n-            Method overriddenHandler = ReflectionUtils.getOverridingMethod(listener, target);\n-\n-            if(overriddenHandler != null && isHandler(overriddenHandler)){\n-                handlers.add(overriddenHandler);\n-            }\n-            if(overriddenHandler == null){\n-                handlers.add(listener);\n+        List<MessageHandlerMetadata>  handlers = new LinkedList<MessageHandlerMetadata>();\n+        for(Method handler : allMethods){\n+            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n+            if(overriddenHandler == null && isValidMessageHandler(handler)){\n+                // add the handler only if it has not been overridden because\n+                // either the override in the subclass deactivates the handler (by not specifying the @Listener)\n+                // or the handler defined in the subclass is part of the list and will be processed itself\n+                handlers.add(getHandlerMetadata(handler));\n             }\n         }\n-        handlers =  ReflectionUtils.withoutOverridenSuperclassMethods(handlers);\n-        List<MessageHandlerMetadata> messageHandlers = new ArrayList<MessageHandlerMetadata>(handlers.size());\n-        for(Method handler : handlers){\n-            if(isValidMessageHandler(handler))\n-                messageHandlers.add(getHandlerMetadata(handler));\n-        }\n-        return messageHandlers;\n+        return handlers;\n     }\n \n-    private static boolean isHandler(Method m){\n-        Annotation[] annotations  = m.getDeclaredAnnotations();\n-        for(Annotation annotation : annotations){\n-            if(annotation.annotationType().equals(Listener.class))return true;\n-        }\n-        return false;\n+\n+    public <T> MessageListenerMetadata<T> getMessageListener(Class<T> target) {\n+        return new MessageListenerMetadata(getMessageHandlers(target), target);\n     }\n \n+\n+\n     private boolean isValidMessageHandler(Method handler) {\n         if (handler.getParameterTypes().length != 1) {\n             // a messageHandler only defines one parameter (the message)\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/Subscription.java",
            "additions": 5,
            "deletions": 0
        },
        "diff content": "@@ -26,6 +26,11 @@ public class Subscription {\n     }\n \n \n+    public boolean handlesMessageType(Class<?> messageType){\n+        return context.getHandlerMetadata().handlesMessage(messageType);\n+    }\n+\n+\n     public void publish(Object message){\n           dispatcher.dispatch(message, listeners);\n     }\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/SubscriptionDeliveryRequest.java",
            "additions": 0,
            "deletions": 28
        },
        "diff content": "@@ -1,28 +0,0 @@\n-package org.mbassy.subscription;\n-\n-import java.util.Collection;\n-\n-/**\n- * @author bennidi\n- * Date: 11/16/12\n- */\n-public class SubscriptionDeliveryRequest<T> {\n-\n-    private Collection<Subscription> subscriptions;\n-\n-    private T message;\n-\n-    public SubscriptionDeliveryRequest(Collection<Subscription> subscriptions, T message) {\n-        this.subscriptions = subscriptions;\n-        this.message = message;\n-    }\n-\n-    public boolean add(Subscription subscription) {\n-        return subscriptions.add(subscription);\n-    }\n-\n-    public void execute(){\n-        for(Subscription sub : subscriptions)\n-            sub.publish(message);\n-    }\n-}\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/AllTests.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -13,7 +13,8 @@ import org.junit.runners.Suite;\n @Suite.SuiteClasses({\n         ConcurrentSetTest.class,\n         MBassadorTest.class,\n-        FilterTest.class\n+        FilterTest.class,\n+        MetadataReaderTest.class\n })\n public class AllTests {\n }\n"
    },
    {
        "commit hash": "39ab0d61efad48fa65646a4aa829e70ed7e5b2f7",
        "previous commit hash": "bbc2004232f871fbe7df8cbba573f7f53a133b50",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/MetadataReaderTest.java",
            "additions": 178,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,178 @@\n+package org.mbassy;\n+\n+import org.junit.Test;\n+import org.mbassy.listener.Enveloped;\n+import org.mbassy.listener.Listener;\n+import org.mbassy.listener.MessageListenerMetadata;\n+import org.mbassy.listener.MetadataReader;\n+import org.mbassy.subscription.MessageEnvelope;\n+\n+import java.io.BufferedReader;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.mbassy.listener.MessageListenerMetadata.ForMessage;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 12/16/12\n+ */\n+public class MetadataReaderTest extends UnitTest {\n+\n+    private MetadataReader reader = new MetadataReader();\n+\n+    @Test\n+    public void testListenerWithoutInheritance() {\n+        MessageListenerMetadata<EventListener1> listener = reader.getMessageListener(EventListener1.class);\n+        ListenerValidator validator = new ListenerValidator()\n+                .expectHandlers(2, String.class)\n+                .expectHandlers(2, Object.class)\n+                .expectHandlers(1, BufferedReader.class);\n+        validator.check(listener);\n+    }\n+\n+\n+    @Test\n+    public void testListenerWithInheritance() {\n+        MessageListenerMetadata<EventListener2> listener = reader.getMessageListener(EventListener2.class);\n+        ListenerValidator validator = new ListenerValidator()\n+                .expectHandlers(2, String.class)\n+                .expectHandlers(2, Object.class)\n+                .expectHandlers(1, BufferedReader.class);\n+        validator.check(listener);\n+    }\n+\n+    @Test\n+    public void testListenerWithInheritanceOverriding() {\n+        MessageListenerMetadata<EventListener3> listener = reader.getMessageListener(EventListener3.class);\n+\n+        ListenerValidator validator = new ListenerValidator()\n+                .expectHandlers(0, String.class)\n+                .expectHandlers(2, Object.class)\n+                .expectHandlers(0, BufferedReader.class);\n+        validator.check(listener);\n+    }\n+\n+    @Test\n+    public void testEnveloped() {\n+        MessageListenerMetadata<EnvelopedListener> listener = reader.getMessageListener(EnvelopedListener.class);\n+        ListenerValidator validator = new ListenerValidator()\n+                .expectHandlers(1, String.class)\n+                .expectHandlers(2, Integer.class)\n+                .expectHandlers(2, Long.class)\n+                .expectHandlers(1, Double.class)\n+                .expectHandlers(1, Number.class)\n+                .expectHandlers(0, List.class);\n+        validator.check(listener);\n+    }\n+\n+    @Test\n+    public void testEnvelopedSubclass() {\n+        MessageListenerMetadata<EnvelopedListenerSubclass> listener = reader.getMessageListener(EnvelopedListenerSubclass.class);\n+        ListenerValidator validator = new ListenerValidator()\n+                .expectHandlers(1, String.class)\n+                .expectHandlers(2, Integer.class)\n+                .expectHandlers(1, Long.class)\n+                .expectHandlers(0, Double.class)\n+                .expectHandlers(0, Number.class);\n+        validator.check(listener);\n+    }\n+\n+\n+    private class ListenerValidator {\n+\n+        private Map<Class<?>, Integer> handlers = new HashMap<Class<?>, Integer>();\n+\n+        public ListenerValidator expectHandlers(Integer count, Class<?> messageType){\n+            handlers.put(messageType, count);\n+            return this;\n+        }\n+\n+        public void check(MessageListenerMetadata listener){\n+            for(Map.Entry<Class<?>, Integer> expectedHandler: handlers.entrySet()){\n+                if(expectedHandler.getValue() > 0){\n+                    assertTrue(listener.handles(expectedHandler.getKey()));\n+                }\n+                else{\n+                    assertFalse(listener.handles(expectedHandler.getKey()));\n+                }\n+                assertEquals(expectedHandler.getValue(), listener.getHandlers(ForMessage(expectedHandler.getKey())).size());\n+            }\n+        }\n+\n+    }\n+\n+\n+\n+\n+    // a simple event listener\n+    public class EventListener1 {\n+\n+        @Listener(handlesSubtypes = false)\n+        public void handleObject(Object o) {\n+\n+        }\n+\n+        @Listener\n+        public void handleAny(Object o) {\n+\n+        }\n+\n+\n+        @Listener\n+        public void handleString(String s) {\n+\n+        }\n+\n+    }\n+\n+    // the same handlers as its super class\n+    public class EventListener2 extends EventListener1 {}\n+\n+    public class EventListener3 extends EventListener2 {\n+\n+        // narrow the handler\n+        @Listener(handlesSubtypes = false)\n+        public void handleAny(Object o) {\n+\n+        }\n+\n+        // remove this handler\n+        public void handleString(String s) {\n+\n+        }\n+\n+    }\n+\n+    public class EnvelopedListener{\n+\n+\n+        @Listener(handlesSubtypes = false)\n+        @Enveloped(messages = {String.class, Integer.class, Long.class})\n+        public void handleEnveloped(MessageEnvelope o) {\n+\n+        }\n+\n+        @Listener\n+        @Enveloped(messages = {Number.class})\n+        public void handleEnveloped2(MessageEnvelope o) {\n+\n+        }\n+\n+    }\n+\n+    public class EnvelopedListenerSubclass extends EnvelopedListener{\n+\n+        // narrow to integer\n+        @Listener\n+        @Enveloped(messages = {Integer.class})\n+        public void handleEnveloped2(MessageEnvelope o) {\n+\n+        }\n+\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "a4f15c45645a5336add131b335948e2f8c1eee4e",
        "previous commit hash": "c8b60ef8545a8023734ec4461f2890e0fd27e7f0",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MetadataReader.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -85,7 +85,7 @@ public class MetadataReader {\n     private static boolean isHandler(Method m){\n         Annotation[] annotations  = m.getDeclaredAnnotations();\n         for(Annotation annotation : annotations){\n-            if(annotation.equals(Listener.class))return true;\n+            if(annotation.annotationType().equals(Listener.class))return true;\n         }\n         return false;\n     }\n"
    },
    {
        "commit hash": "4d617a2f854d8f6fa7aa3784d97858b43978d00a",
        "previous commit hash": "87557a1a0d69fd2720fbf410540c38491ff0b69a",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/MBassador.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -1,9 +1,9 @@\n package org.mbassy;\n \n-import org.mbassy.subscription.*;\n+import java.util.Collection;\n \n-import java.util.*;\n-import java.util.concurrent.*;\n+import org.mbassy.subscription.Subscription;\n+import org.mbassy.subscription.SubscriptionDeliveryRequest;\n \n \n public class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>>{\n"
    },
    {
        "commit hash": "4d617a2f854d8f6fa7aa3784d97858b43978d00a",
        "previous commit hash": "87557a1a0d69fd2720fbf410540c38491ff0b69a",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/common/ConcurrentSet.java",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -3,7 +3,6 @@ package org.mbassy.common;\n \n import java.lang.ref.WeakReference;\n import java.util.Iterator;\n-import java.util.Set;\n import java.util.WeakHashMap;\n \n /**\n"
    },
    {
        "commit hash": "4d617a2f854d8f6fa7aa3784d97858b43978d00a",
        "previous commit hash": "87557a1a0d69fd2720fbf410540c38491ff0b69a",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/common/ReflectionUtils.java",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1,7 +1,6 @@\n package org.mbassy.common;\n \n import java.lang.reflect.Method;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.LinkedList;\n import java.util.List;\n"
    },
    {
        "commit hash": "4d617a2f854d8f6fa7aa3784d97858b43978d00a",
        "previous commit hash": "87557a1a0d69fd2720fbf410540c38491ff0b69a",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/dispatch/AsynchronousHandlerInvocation.java",
            "additions": 0,
            "deletions": 5
        },
        "diff content": "@@ -1,11 +1,6 @@\n package org.mbassy.dispatch;\n \n-import org.mbassy.IPublicationErrorHandler;\n-import org.mbassy.PublicationError;\n-\n-import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n-import java.util.Collection;\n \n /**\n  * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n"
    },
    {
        "commit hash": "4d617a2f854d8f6fa7aa3784d97858b43978d00a",
        "previous commit hash": "87557a1a0d69fd2720fbf410540c38491ff0b69a",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/dispatch/IMessageDispatcher.java",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1,7 +1,6 @@\n package org.mbassy.dispatch;\n \n import org.mbassy.common.ConcurrentSet;\n-import org.mbassy.subscription.Subscription;\n \n /**\n  * A message dispatcher provides the functionality to deliver a single message\n"
    },
    {
        "commit hash": "4d617a2f854d8f6fa7aa3784d97858b43978d00a",
        "previous commit hash": "87557a1a0d69fd2720fbf410540c38491ff0b69a",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/dispatch/MessageDispatcher.java",
            "additions": 2,
            "deletions": 3
        },
        "diff content": "@@ -1,10 +1,9 @@\n package org.mbassy.dispatch;\n \n-import org.mbassy.common.ConcurrentSet;\n-import org.mbassy.subscription.Subscription;\n-\n import java.lang.reflect.Method;\n \n+import org.mbassy.common.ConcurrentSet;\n+\n /**\n  * Standard implementation for direct, unfiltered message delivery.\n  *\n"
    },
    {
        "commit hash": "4d617a2f854d8f6fa7aa3784d97858b43978d00a",
        "previous commit hash": "87557a1a0d69fd2720fbf410540c38491ff0b69a",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/Subscription.java",
            "additions": 3,
            "deletions": 11
        },
        "diff content": "@@ -1,19 +1,11 @@\n package org.mbassy.subscription;\n \n-import org.mbassy.IMessageBus;\n-import org.mbassy.IPublicationErrorHandler;\n+import java.util.Comparator;\n+import java.util.UUID;\n+\n import org.mbassy.common.ConcurrentSet;\n-import org.mbassy.PublicationError;\n import org.mbassy.dispatch.IMessageDispatcher;\n import org.mbassy.dispatch.MessagingContext;\n-import org.mbassy.listener.MessageHandlerMetadata;\n-\n-import javax.xml.ws.handler.MessageContext;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.util.Collection;\n-import java.util.Comparator;\n-import java.util.UUID;\n \n /**\n  * A subscription is a thread safe container for objects that contain message handlers\n"
    },
    {
        "commit hash": "4d617a2f854d8f6fa7aa3784d97858b43978d00a",
        "previous commit hash": "87557a1a0d69fd2720fbf410540c38491ff0b69a",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/SubscriptionDeliveryRequest.java",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1,7 +1,6 @@\n package org.mbassy.subscription;\n \n import java.util.Collection;\n-import java.util.LinkedList;\n \n /**\n  * @author bennidi\n"
    },
    {
        "commit hash": "4d617a2f854d8f6fa7aa3784d97858b43978d00a",
        "previous commit hash": "87557a1a0d69fd2720fbf410540c38491ff0b69a",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/SubscriptionFactory.java",
            "additions": 8,
            "deletions": 6
        },
        "diff content": "@@ -1,11 +1,13 @@\n package org.mbassy.subscription;\n \n-import org.mbassy.IMessageBus;\n-import org.mbassy.IPublicationErrorHandler;\n-import org.mbassy.dispatch.*;\n-import org.mbassy.listener.MessageHandlerMetadata;\n-\n-import java.util.Collection;\n+import org.mbassy.dispatch.AsynchronousHandlerInvocation;\n+import org.mbassy.dispatch.EnvelopedMessageDispatcher;\n+import org.mbassy.dispatch.FilteredMessageDispatcher;\n+import org.mbassy.dispatch.IHandlerInvocation;\n+import org.mbassy.dispatch.IMessageDispatcher;\n+import org.mbassy.dispatch.MessageDispatcher;\n+import org.mbassy.dispatch.MessagingContext;\n+import org.mbassy.dispatch.ReflectiveHandlerInvocation;\n \n /**\n  * Created with IntelliJ IDEA.\n"
    },
    {
        "commit hash": "4d617a2f854d8f6fa7aa3784d97858b43978d00a",
        "previous commit hash": "87557a1a0d69fd2720fbf410540c38491ff0b69a",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/FilterTest.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -1,15 +1,15 @@\n package org.mbassy;\n \n+import java.util.List;\n+\n import org.junit.Test;\n import org.mbassy.events.SubTestEvent;\n import org.mbassy.events.TestEvent;\n import org.mbassy.listener.Filter;\n import org.mbassy.listener.Filters;\n-import org.mbassy.listener.IMessageFilter;\n import org.mbassy.listener.Listener;\n-import org.mbassy.listeners.*;\n-\n-import java.util.List;\n+import org.mbassy.listeners.ListenerFactory;\n+import org.mbassy.listeners.NonListeningBean;\n \n /**\n  * Testing of filter functionality\n"
    },
    {
        "commit hash": "4d617a2f854d8f6fa7aa3784d97858b43978d00a",
        "previous commit hash": "87557a1a0d69fd2720fbf410540c38491ff0b69a",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/MBassadorTest.java",
            "additions": 11,
            "deletions": 8
        },
        "diff content": "@@ -1,19 +1,22 @@\n package org.mbassy;\n \n-import org.junit.Before;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n import org.junit.Test;\n import org.mbassy.events.SubTestEvent;\n import org.mbassy.events.TestEvent;\n import org.mbassy.events.TestEvent2;\n-import org.mbassy.listeners.*;\n+import org.mbassy.listeners.EventingTestBean;\n+import org.mbassy.listeners.EventingTestBean2;\n+import org.mbassy.listeners.EventingTestBean3;\n+import org.mbassy.listeners.ListenerFactory;\n+import org.mbassy.listeners.MultiEventHandler;\n+import org.mbassy.listeners.NonListeningBean;\n import org.mbassy.subscription.Subscription;\n \n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-\n /**\n  * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n  *\n"
    },
    {
        "commit hash": "4d617a2f854d8f6fa7aa3784d97858b43978d00a",
        "previous commit hash": "87557a1a0d69fd2720fbf410540c38491ff0b69a",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/listeners/MultiEventHandler.java",
            "additions": 5,
            "deletions": 2
        },
        "diff content": "@@ -1,9 +1,12 @@\n package org.mbassy.listeners;\n \n-import org.mbassy.events.SubTestEvent;\n import org.mbassy.events.TestEvent;\n import org.mbassy.events.TestEvent2;\n-import org.mbassy.listener.*;\n+import org.mbassy.listener.Enveloped;\n+import org.mbassy.listener.Filter;\n+import org.mbassy.listener.Filters;\n+import org.mbassy.listener.Listener;\n+import org.mbassy.listener.Mode;\n import org.mbassy.subscription.MessageEnvelope;\n \n /**\n"
    },
    {
        "commit hash": "4d617a2f854d8f6fa7aa3784d97858b43978d00a",
        "previous commit hash": "87557a1a0d69fd2720fbf410540c38491ff0b69a",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/listeners/NonListeningBean.java",
            "additions": 0,
            "deletions": 2
        },
        "diff content": "@@ -2,8 +2,6 @@ package org.mbassy.listeners;\n \n import org.mbassy.events.SubTestEvent;\n import org.mbassy.events.TestEvent;\n-import org.mbassy.listener.Listener;\n-import org.mbassy.listener.Mode;\n \n /**\n  * This bean overrides all the handlers defined in its superclass. Since it does not specify any annotations\n"
    },
    {
        "commit hash": "87557a1a0d69fd2720fbf410540c38491ff0b69a",
        "previous commit hash": "4459a56245bf234aec0b56874d8ef94afe11452a",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MetadataReader.java",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1,6 +1,5 @@\n package org.mbassy.listener;\n \n-import com.sun.xml.internal.messaging.saaj.soap.Envelope;\n import org.mbassy.common.IPredicate;\n import org.mbassy.common.ReflectionUtils;\n import org.mbassy.subscription.MessageEnvelope;\n"
    },
    {
        "commit hash": "11c337d512297085fc8baef3d06d3adbdb36ceb5",
        "previous commit hash": "9eacace23039d93416bfd0bce8417447fa5d2fed",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/SyncAsyncPostCommand.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -9,9 +9,9 @@ package org.mbassy;\n public class SyncAsyncPostCommand<T> implements IMessageBus.IPostCommand {\n \n     private T message;\n-    private MBassador mBassador;\n+    private MBassador<T> mBassador;\n \n-    public SyncAsyncPostCommand(MBassador mBassador, T message) {\n+    public SyncAsyncPostCommand(MBassador<T> mBassador, T message) {\n         this.mBassador = mBassador;\n         this.message = message;\n     }\n"
    },
    {
        "commit hash": "9eacace23039d93416bfd0bce8417447fa5d2fed",
        "previous commit hash": "c8b60ef8545a8023734ec4461f2890e0fd27e7f0",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/MBassador.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -44,8 +44,8 @@ public class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>>\n \n \n     @Override\n-    public SyncAsyncPostCommand post(T message) {\n-        return new SyncAsyncPostCommand(this, message);\n+    public SyncAsyncPostCommand<T> post(T message) {\n+        return new SyncAsyncPostCommand<T>(this, message);\n     }\n \n }\n"
    },
    {
        "commit hash": "c8b60ef8545a8023734ec4461f2890e0fd27e7f0",
        "previous commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 8
        },
        "diff content": "@@ -78,14 +78,7 @@ Listener definition (in any bean):\n         @Listener(dispatch = Mode.Synchronous, filters = @Filter(Filters.RejectSubtypes.class))\n         @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n         public void handleSuperTypeEvents(MessageEnvelope envelope) {\n-            if(TestEvent.class.isAssignableFrom(envelope.getMessage().getClass())){\n-                TestEvent event = envelope.getMessage();\n-                event.counter.incrementAndGet();\n-            }\n-            if(envelope.getMessage().getClass().equals(TestEvent2.class)){\n-                TestEvent2 event = envelope.getMessage();\n-                event.counter.incrementAndGet();\n-            }\n+            // detect the type of event here and then decide the course of action\n         }\n \n \n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "README.md",
            "additions": 17,
            "deletions": 1
        },
        "diff content": "@@ -10,7 +10,7 @@ Read this documentation to get an overview of its features and how cool this mes\n You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n which also contains a partial list of the features of the compared implementations.\n \n-The current version is 1.0.4.RC\n+The current version is 1.0.5.RC\n \n Table of contents:\n + [Features](#features)\n@@ -39,6 +39,8 @@ in certain environments where objects are created by frameworks, i.e. spring, gu\n ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.\n + <em><strong>Filtering</em></strong>: Mbassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to\n a single message handler\n++ <em><strong>Message envelopes</em></strong>: Message handlers can declare to receive an enveloped message. The envelope can wrap around different\n+types of messages. This allows for a single handler to handle multiple message types\n + <em><strong>Handler priorities</em></strong>: A listener can be associated with a priority to influence the order of the message delivery\n + <em><strong>Error handling</em></strong>: Errors during message delivery are sent to an error handler of which a custom implementation can easily be plugged-in.\n + <em><strong>Ease of Use</em></strong>: Using Mbassador in your project is very easy. Create as many instances of Mbassador as you like (usually a singleton will do),\n@@ -73,6 +75,20 @@ Listener definition (in any bean):\n            //do something special here\n         }\n \n+        @Listener(dispatch = Mode.Synchronous, filters = @Filter(Filters.RejectSubtypes.class))\n+        @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n+        public void handleSuperTypeEvents(MessageEnvelope envelope) {\n+            if(TestEvent.class.isAssignableFrom(envelope.getMessage().getClass())){\n+                TestEvent event = envelope.getMessage();\n+                event.counter.incrementAndGet();\n+            }\n+            if(envelope.getMessage().getClass().equals(TestEvent2.class)){\n+                TestEvent2 event = envelope.getMessage();\n+                event.counter.incrementAndGet();\n+            }\n+        }\n+\n+\n Creation of message bus and registration of listeners:\n \n         // create as many instances as necessary\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.5.RC/mbassador-1.0.5.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/maven/org/mbassy/mbassador/1.0.5.RC/mbassador-1.0.5.RC.jar differ\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.5.RC/mbassador-1.0.5.RC.jar.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+3ad14134e9752e3a073c75ab296427ef\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.5.RC/mbassador-1.0.5.RC.jar.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+bedef44bb92cbfafcba48624c91e185d692ea39d\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.5.RC/mbassador-1.0.5.RC.pom",
            "additions": 58,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,58 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.mbassy</groupId>\n+    <artifactId>mbassador</artifactId>\n+    <version>1.0.5.RC</version>\n+    <packaging>jar</packaging>\n+    <name>mbassador</name>\n+    <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n+    </description>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.build.java.version>1.6</project.build.java.version>\n+        <github.url>file://${project.basedir}/maven</github.url>\n+    </properties>\n+\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.10</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+    </dependencies>\n+\n+    <distributionManagement>\n+        <repository>\n+            <id>mbassador-github-repo</id>\n+            <url>${github.url}</url>\n+        </repository>\n+    </distributionManagement>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>${project.build.java.version}</source>\n+                    <target>${project.build.java.version}</target>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <skipTests>false</skipTests>\n+                </configuration>\n+            </plugin>\n+\n+        </plugins>\n+    </build>\n+</project>\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.5.RC/mbassador-1.0.5.RC.pom.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+0a781a5e9f22e5dafeb7f48fff65e46d\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.5.RC/mbassador-1.0.5.RC.pom.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+4378b82fa04f4c31f21321424d0c4c328905d3ad\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -10,7 +10,8 @@\n       <version>1.0.2.RC</version>\n       <version>1.0.3.RC</version>\n       <version>1.0.4.RC</version>\n+      <version>1.0.5.RC</version>\n     </versions>\n-    <lastUpdated>20121211111454</lastUpdated>\n+    <lastUpdated>20121212135342</lastUpdated>\n   </versioning>\n </metadata>\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.md5",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-ea8a55fc0698b7a0ab7811c938529e9c\n\\ No newline at end of file\n+e37de32d920e2182f2549b0500dc20d8\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.sha1",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-e9eedffd82184cc31168a051bbd9453e426d7e71\n\\ No newline at end of file\n+6b5568c98223ec0a53f7b7ede78e965ba7f0080f\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -4,7 +4,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>org.mbassy</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.0.4.RC</version>\n+    <version>1.0.5.RC</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/AbstractMessageBus.java",
            "additions": 11,
            "deletions": 20
        },
        "diff content": "@@ -2,12 +2,12 @@ package org.mbassy;\n \n import org.mbassy.common.ReflectionUtils;\n import org.mbassy.dispatch.MessagingContext;\n+import org.mbassy.listener.MessageHandlerMetadata;\n import org.mbassy.listener.MetadataReader;\n import org.mbassy.subscription.Subscription;\n import org.mbassy.subscription.SubscriptionDeliveryRequest;\n import org.mbassy.subscription.SubscriptionFactory;\n \n-import java.lang.reflect.Method;\n import java.util.*;\n import java.util.concurrent.*;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -118,21 +118,24 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n                 synchronized (this) { // new subscriptions must be processed sequentially\n                     subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                     if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n-                        List<Method> messageHandlers = metadataReader.getMessageHandlers(listeningClass);  // get all methods with subscriptions\n+                        List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listeningClass);\n                         if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                             nonListeners.add(listeningClass);\n                             return;\n                         }\n                         subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                         // create subscriptions for all detected listeners\n-                        for (Method messageHandler : messageHandlers) {\n-                            if (!isValidMessageHandler(messageHandler)) continue; // ignore invalid listeners\n-                            Class eventType = getMessageType(messageHandler);\n+                        for (MessageHandlerMetadata messageHandler : messageHandlers) {\n+                            // create the subscription\n                             Subscription subscription = subscriptionFactory\n-                                    .createSubscription(new MessagingContext(this, metadataReader.getHandlerMetadata(messageHandler)));\n+                                    .createSubscription(new MessagingContext(this, messageHandler));\n                             subscription.subscribe(listener);\n-                            addMessageTypeSubscription(eventType, subscription);\n-                            subscriptionsByListener.add(subscription);\n+                            subscriptionsByListener.add(subscription);// add it for the listener type (for future subscriptions)\n+\n+                            List<Class<?>> messageTypes = messageHandler.getHandledMessages();\n+                            for(Class<?> messageType : messageTypes){\n+                                addMessageTypeSubscription(messageType, subscription);\n+                            }\n                             //updateMessageTypeHierarchy(eventType);\n                         }\n                         subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n@@ -187,19 +190,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     }\n \n \n-    private boolean isValidMessageHandler(Method handler) {\n-        if (handler.getParameterTypes().length != 1) {\n-            // a messageHandler only defines one parameter (the message)\n-            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n-                    + \"]. A messageHandler must define exactly one parameter\");\n-            return false;\n-        }\n-        return true;\n-    }\n \n-    private static Class getMessageType(Method listener) {\n-        return listener.getParameterTypes()[0];\n-    }\n \n     public void handlePublicationError(PublicationError error) {\n         for (IPublicationErrorHandler errorHandler : errorHandlers){\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/BusConfiguration.java",
            "additions": 11,
            "deletions": 3
        },
        "diff content": "@@ -6,14 +6,22 @@ import org.mbassy.subscription.SubscriptionFactory;\n import java.util.concurrent.*;\n \n /**\n- *\n- *\n+ * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour. *\n  *\n  * @author bennidi\n  *         Date: 12/8/12\n  */\n public class BusConfiguration {\n \n+    private static final ThreadFactory DaemonThreadFactory = new ThreadFactory() {\n+        @Override\n+        public Thread newThread(Runnable r) {\n+            Thread thread = Executors.defaultThreadFactory().newThread(r);\n+            thread.setDaemon(true);\n+            return thread;\n+        }\n+    };\n+\n     public static final BusConfiguration Default(){\n         return new BusConfiguration();\n     }\n@@ -32,7 +40,7 @@ public class BusConfiguration {\n         this.numberOfMessageDispatchers = 2;\n         this.maximumNumberOfPendingMessages = Integer.MAX_VALUE;\n         this.subscriptionFactory = new SubscriptionFactory();\n-        this.executor = new ThreadPoolExecutor(5, 20, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>());\n+        this.executor = new ThreadPoolExecutor(10, 10, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), DaemonThreadFactory);\n         this.metadataReader = new MetadataReader();\n     }\n \n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/dispatch/EnvelopedMessageDispatcher.java",
            "additions": 34,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,34 @@\n+package org.mbassy.dispatch;\n+\n+import org.mbassy.common.ConcurrentSet;\n+import org.mbassy.subscription.MessageEnvelope;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 12/12/12\n+ */\n+public class EnvelopedMessageDispatcher implements IMessageDispatcher {\n+\n+    private IMessageDispatcher del;\n+\n+    public EnvelopedMessageDispatcher(IMessageDispatcher dispatcher) {\n+        this.del = dispatcher;\n+    }\n+\n+    @Override\n+    public void dispatch(Object message, ConcurrentSet listeners) {\n+        del.dispatch(new MessageEnvelope(message), listeners);\n+    }\n+\n+    @Override\n+    public MessagingContext getContext() {\n+        return del.getContext();\n+    }\n+\n+    @Override\n+    public IHandlerInvocation getInvocation() {\n+        return del.getInvocation();\n+    }\n+}\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/Enveloped.java",
            "additions": 23,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,23 @@\n+package org.mbassy.listener;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * Configure a handler to receive an enveloped message as a wrapper around the source\n+ * message. An enveloped message can be\n+ *\n+ * @author bennidi\n+ * Date: 2/8/12\n+ */\n+@Retention(value = RetentionPolicy.RUNTIME)\n+@Inherited\n+@Target(value = {ElementType.METHOD})\n+public @interface Enveloped {\n+\n+    /**\n+     * The set of messages that should be dispatched to the message handler\n+     */\n+\tClass[] messages();\n+\n+\n+}\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/Filters.java",
            "additions": 38,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,38 @@\n+package org.mbassy.listener;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 12/12/12\n+ */\n+public class Filters {\n+\n+    public static final class AllowAll implements IMessageFilter {\n+\n+        @Override\n+        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n+            return true;\n+        }\n+    }\n+\n+    public static final class RejectAll implements IMessageFilter {\n+\n+        @Override\n+        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n+            return false;\n+        }\n+    }\n+\n+\n+    public static final class RejectSubtypes implements IMessageFilter {\n+\n+        @Override\n+        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n+            for(Class handledMessage : metadata.getHandledMessages()){\n+                if(handledMessage.equals(event.getClass()))return true;\n+            }\n+            return false;\n+        }\n+    }\n+}\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/IMessageFilter.java",
            "additions": 0,
            "deletions": 31
        },
        "diff content": "@@ -1,8 +1,5 @@\n package org.mbassy.listener;\n \n-import java.util.HashMap;\n-import java.util.Map;\n-\n /**\n  * Message filters can be used to prevent certain messages to be delivered to a specific listener.\n  * If a filter is used the message will only be delivered if it passes the filter(s)\n@@ -23,32 +20,4 @@ public interface IMessageFilter {\n      */\n \tpublic boolean accepts(Object message, MessageHandlerMetadata metadata);\n \n-\n-\n-\tpublic static final class All implements IMessageFilter {\n-\n-\t\t@Override\n-\t\tpublic boolean accepts(Object event, MessageHandlerMetadata metadata) {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-    public static final class None implements IMessageFilter {\n-\n-        @Override\n-        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n-            return false;\n-        }\n-    }\n-\n-\n-    public static final class DontAllowSubtypes implements IMessageFilter {\n-\n-        @Override\n-        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n-            return event.getClass().equals(metadata.getDeclaredMessageType());\n-        }\n-    }\n-\n-\n }\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MessageHandlerMetadata.java",
            "additions": 20,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,8 @@\n package org.mbassy.listener;\n \n import java.lang.reflect.Method;\n+import java.util.LinkedList;\n+import java.util.List;\n \n /**\n  *\n@@ -18,12 +20,24 @@ public class MessageHandlerMetadata {\n \n     private boolean isAsynchronous = false;\n \n+    private Enveloped envelope = null;\n+\n+    private List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n+\n \n     public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Listener listenerConfig) {\n         this.handler = handler;\n         this.filter = filter;\n         this.listenerConfig = listenerConfig;\n         this.isAsynchronous = listenerConfig.dispatch().equals(Mode.Asynchronous);\n+        this.envelope = handler.getAnnotation(Enveloped.class);\n+        if(this.envelope != null){\n+            for(Class messageType : envelope.messages())\n+                handledMessages.add(messageType);\n+        }\n+        else{\n+            handledMessages.add(handler.getParameterTypes()[0]);\n+        }\n         this.handler.setAccessible(true);\n     }\n \n@@ -48,7 +62,11 @@ public class MessageHandlerMetadata {\n         return filter;\n     }\n \n-    public Class getDeclaredMessageType(){\n-        return handler.getParameterTypes()[0];\n+    public List<Class<?>> getHandledMessages(){\n+        return handledMessages;\n+    }\n+\n+    public boolean isEnveloped() {\n+        return envelope != null;\n     }\n }\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MetadataReader.java",
            "additions": 40,
            "deletions": 13
        },
        "diff content": "@@ -1,21 +1,20 @@\n package org.mbassy.listener;\n \n+import com.sun.xml.internal.messaging.saaj.soap.Envelope;\n import org.mbassy.common.IPredicate;\n import org.mbassy.common.ReflectionUtils;\n+import org.mbassy.subscription.MessageEnvelope;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Method;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n \n /**\n- * Created with IntelliJ IDEA.\n+ *\n+ * The meta data reader is responsible for parsing and validating message handler configurations.\n+ *\n  * @author bennidi\n  * Date: 11/16/12\n- * Time: 10:22 AM\n- * To change this template use File | Settings | File Templates.\n  */\n public class MetadataReader {\n \n@@ -31,15 +30,20 @@ public class MetadataReader {\n     private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n \n     // retrieve all instances of filters associated with the given subscription\n-    private IMessageFilter[] getFilter(Listener subscription) throws Exception{\n+    private IMessageFilter[] getFilter(Listener subscription){\n         if (subscription.filters().length == 0) return null;\n         IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n         int i = 0;\n         for (Filter filterDef : subscription.filters()) {\n             IMessageFilter filter = filterCache.get(filterDef.value());\n             if (filter == null) {\n+                try{\n                     filter = filterDef.value().newInstance();\n                     filterCache.put(filterDef.value(), filter);\n+                }\n+                catch (Exception e){\n+                    throw new RuntimeException(e);// propagate as runtime exception\n+                }\n \n             }\n             filters[i] = filter;\n@@ -49,15 +53,14 @@ public class MetadataReader {\n     }\n \n \n-    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler) throws Exception{\n+    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler){\n         Listener config = messageHandler.getAnnotation(Listener.class);\n-        IMessageFilter[] filter = getFilter(config);\n-        return new MessageHandlerMetadata(messageHandler, filter, config);\n+        return new MessageHandlerMetadata(messageHandler, getFilter(config), config);\n     }\n \n     // get all listeners defined by the given class (includes\n     // listeners defined in super classes)\n-    public List<Method> getMessageHandlers(Class<?> target) {\n+    public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n         List<Method> allMethods = ReflectionUtils.getMethods(AllMessageHandlers, target);\n         List<Method>  handlers = new LinkedList<Method>();\n         for(Method listener : allMethods){\n@@ -70,7 +73,13 @@ public class MetadataReader {\n                 handlers.add(listener);\n             }\n         }\n-        return ReflectionUtils.withoutOverridenSuperclassMethods(handlers);\n+        handlers =  ReflectionUtils.withoutOverridenSuperclassMethods(handlers);\n+        List<MessageHandlerMetadata> messageHandlers = new ArrayList<MessageHandlerMetadata>(handlers.size());\n+        for(Method handler : handlers){\n+            if(isValidMessageHandler(handler))\n+                messageHandlers.add(getHandlerMetadata(handler));\n+        }\n+        return messageHandlers;\n     }\n \n     private static boolean isHandler(Method m){\n@@ -79,7 +88,25 @@ public class MetadataReader {\n             if(annotation.equals(Listener.class))return true;\n         }\n         return false;\n+    }\n \n+    private boolean isValidMessageHandler(Method handler) {\n+        if (handler.getParameterTypes().length != 1) {\n+            // a messageHandler only defines one parameter (the message)\n+            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n+                    + \"]. A messageHandler must define exactly one parameter\");\n+            return false;\n+        }\n+        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n+        if(envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])){\n+            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n+            return false;\n+        }\n+        if(envelope != null && envelope.messages().length == 0){\n+            System.out.println(\"Message envelope configured but message types defined for handler\");\n+            return false;\n+        }\n+        return true;\n     }\n \n }\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/MessageEnvelope.java",
            "additions": 27,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,27 @@\n+package org.mbassy.subscription;\n+\n+import java.sql.Timestamp;\n+\n+/**\n+ * A message envelope is used to wrap messages of arbitrary type such that a handler\n+ * my receive messages of different types.\n+ *\n+ * @author bennidi\n+ *         Date: 12/12/12\n+ */\n+public class MessageEnvelope {\n+\n+    private Timestamp tsCreated = new Timestamp(System.currentTimeMillis());\n+\n+    private Object message;\n+\n+\n+    public MessageEnvelope(Object message) {\n+        this.message = message;\n+    }\n+\n+\n+    public <T> T getMessage(){\n+        return (T)message;\n+    }\n+}\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/SubscriptionFactory.java",
            "additions": 3,
            "deletions": 0
        },
        "diff content": "@@ -32,6 +32,9 @@ public class SubscriptionFactory {\n \n     protected IMessageDispatcher buildDispatcher(MessagingContext context, IHandlerInvocation invocation){\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n+       if(context.getHandlerMetadata().isEnveloped()){\n+          dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n+       }\n        if(context.getHandlerMetadata().isFiltered()){\n           dispatcher = new FilteredMessageDispatcher(dispatcher);\n        }\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/FilterTest.java",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -4,6 +4,7 @@ import org.junit.Test;\n import org.mbassy.events.SubTestEvent;\n import org.mbassy.events.TestEvent;\n import org.mbassy.listener.Filter;\n+import org.mbassy.listener.Filters;\n import org.mbassy.listener.IMessageFilter;\n import org.mbassy.listener.Listener;\n import org.mbassy.listeners.*;\n@@ -46,7 +47,7 @@ public class FilterTest extends UnitTest{\n \n     public static class FilteredMessageListener{\n \n-        @Listener(filters = {@Filter(IMessageFilter.DontAllowSubtypes.class)})\n+        @Listener(filters = {@Filter(Filters.RejectSubtypes.class)})\n         public void handleTestEvent(TestEvent event){\n             event.counter.incrementAndGet();\n         }\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/MBassadorTest.java",
            "additions": 8,
            "deletions": 3
        },
        "diff content": "@@ -4,6 +4,7 @@ import org.junit.Before;\n import org.junit.Test;\n import org.mbassy.events.SubTestEvent;\n import org.mbassy.events.TestEvent;\n+import org.mbassy.events.TestEvent2;\n import org.mbassy.listeners.*;\n import org.mbassy.subscription.Subscription;\n \n@@ -113,7 +114,8 @@ public class MBassadorTest extends UnitTest {\n                 .create(100, EventingTestBean2.class)\n                 .create(100, EventingTestBean3.class)\n                 .create(100, Object.class)\n-                .create(100, NonListeningBean.class);\n+                .create(100, NonListeningBean.class)\n+                .create(100, MultiEventHandler.class);\n \n         List<Object> listeners = listenerFactory.build();\n \n@@ -122,14 +124,17 @@ public class MBassadorTest extends UnitTest {\n \n         TestEvent event = new TestEvent();\n         TestEvent subEvent = new SubTestEvent();\n+        TestEvent2 event2 = new TestEvent2();\n \n         bus.publishAsync(event);\n         bus.publishAsync(subEvent);\n+        bus.publishAsync(event2);\n \n         pause(2000);\n \n-        assertEquals(300, event.counter.get());\n-        assertEquals(700, subEvent.counter.get());\n+        assertEquals(500, event.counter.get());\n+        assertEquals(800, subEvent.counter.get());\n+        assertEquals(200, event2.counter.get());\n \n     }\n \n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/events/TestEvent2.java",
            "additions": 15,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,15 @@\n+package org.mbassy.events;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ *\n+ *\n+* @author bennidi\n+* Date: 11/22/12\n+*/\n+public class TestEvent2 {\n+\n+    public AtomicInteger counter = new AtomicInteger();\n+\n+}\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/listeners/EventingTestBean.java",
            "additions": 2,
            "deletions": 5
        },
        "diff content": "@@ -2,10 +2,7 @@ package org.mbassy.listeners;\n \n import org.mbassy.events.SubTestEvent;\n import org.mbassy.events.TestEvent;\n-import org.mbassy.listener.Filter;\n-import org.mbassy.listener.IMessageFilter;\n-import org.mbassy.listener.Listener;\n-import org.mbassy.listener.Mode;\n+import org.mbassy.listener.*;\n \n /**\n  * Basic bean that defines some event handlers to be used for different unit testting scenarios\n@@ -33,7 +30,7 @@ public class EventingTestBean {\n     @Listener(\n             priority = 10,\n             dispatch = Mode.Synchronous,\n-            filters = {@Filter(IMessageFilter.None.class), @Filter(IMessageFilter.All.class)})\n+            filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n     public void handleFiltered(SubTestEvent event) {\n         event.counter.incrementAndGet();\n     }\n"
    },
    {
        "commit hash": "687fbb72ed2f716332e4ff08229b8566e31d4f91",
        "previous commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/listeners/MultiEventHandler.java",
            "additions": 44,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,44 @@\n+package org.mbassy.listeners;\n+\n+import org.mbassy.events.SubTestEvent;\n+import org.mbassy.events.TestEvent;\n+import org.mbassy.events.TestEvent2;\n+import org.mbassy.listener.*;\n+import org.mbassy.subscription.MessageEnvelope;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 12/12/12\n+ */\n+public class MultiEventHandler {\n+\n+\n+    @Listener(dispatch = Mode.Synchronous)\n+    @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n+    public void handleEvents(MessageEnvelope envelope) {\n+        if(TestEvent.class.isAssignableFrom(envelope.getMessage().getClass())){\n+            TestEvent event = envelope.getMessage();\n+            event.counter.incrementAndGet();\n+        }\n+        if(envelope.getMessage().getClass().equals(TestEvent2.class)){\n+            TestEvent2 event = envelope.getMessage();\n+            event.counter.incrementAndGet();\n+        }\n+    }\n+\n+    @Listener(dispatch = Mode.Synchronous, filters = @Filter(Filters.RejectSubtypes.class))\n+    @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n+    public void handleSuperTypeEvents(MessageEnvelope envelope) {\n+        if(TestEvent.class.isAssignableFrom(envelope.getMessage().getClass())){\n+            TestEvent event = envelope.getMessage();\n+            event.counter.incrementAndGet();\n+        }\n+        if(envelope.getMessage().getClass().equals(TestEvent2.class)){\n+            TestEvent2 event = envelope.getMessage();\n+            event.counter.incrementAndGet();\n+        }\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "previous commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -10,7 +10,7 @@ Read this documentation to get an overview of its features and how cool this mes\n You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n which also contains a partial list of the features of the compared implementations.\n \n-The current version is 1.0.3.RC\n+The current version is 1.0.4.RC\n \n Table of contents:\n + [Features](#features)\n"
    },
    {
        "commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "previous commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "diff stats": {
            "file_path": "build.gradle",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,7 +1,7 @@\n usePlugin('java')\n \n group=\"org.mbassy\"\n-version=\"1.0.2.RC\"\n+version=\"1.0.4.RC\"\n \n dependencies {\n     addMavenRepo()\n"
    },
    {
        "commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "previous commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.4.RC/mbassador-1.0.4.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/maven/org/mbassy/mbassador/1.0.4.RC/mbassador-1.0.4.RC.jar differ\n"
    },
    {
        "commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "previous commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.4.RC/mbassador-1.0.4.RC.jar.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+2dcb34daf560ac4b9a87a95924aa7be6\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "previous commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.4.RC/mbassador-1.0.4.RC.jar.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+275d892046554f6a86226d813202c5ab8a22cf92\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "previous commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.4.RC/mbassador-1.0.4.RC.pom",
            "additions": 58,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,58 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.mbassy</groupId>\n+    <artifactId>mbassador</artifactId>\n+    <version>1.0.4.RC</version>\n+    <packaging>jar</packaging>\n+    <name>mbassador</name>\n+    <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n+    </description>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.build.java.version>1.6</project.build.java.version>\n+        <github.url>file://${project.basedir}/maven</github.url>\n+    </properties>\n+\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.10</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+    </dependencies>\n+\n+    <distributionManagement>\n+        <repository>\n+            <id>mbassador-github-repo</id>\n+            <url>${github.url}</url>\n+        </repository>\n+    </distributionManagement>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>${project.build.java.version}</source>\n+                    <target>${project.build.java.version}</target>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <skipTests>false</skipTests>\n+                </configuration>\n+            </plugin>\n+\n+        </plugins>\n+    </build>\n+</project>\n"
    },
    {
        "commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "previous commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.4.RC/mbassador-1.0.4.RC.pom.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+75dda79a70a43a84877c3d62fdef401d\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "previous commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.4.RC/mbassador-1.0.4.RC.pom.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+ed21bd9587e9ee76e63b31ede3cbb6eedb04fa70\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "previous commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -9,7 +9,8 @@\n       <version>1.0.1.RC</version>\n       <version>1.0.2.RC</version>\n       <version>1.0.3.RC</version>\n+      <version>1.0.4.RC</version>\n     </versions>\n-    <lastUpdated>20121208081117</lastUpdated>\n+    <lastUpdated>20121211111454</lastUpdated>\n   </versioning>\n </metadata>\n"
    },
    {
        "commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "previous commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.md5",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-7ef914e14f2998dd2ce1665e2cfb30ba\n\\ No newline at end of file\n+ea8a55fc0698b7a0ab7811c938529e9c\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "previous commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.sha1",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-90c7ea303b6a468b004369a2f14691239ae9e8ea\n\\ No newline at end of file\n+e9eedffd82184cc31168a051bbd9453e426d7e71\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "previous commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -4,7 +4,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>org.mbassy</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.0.3.RC</version>\n+    <version>1.0.4.RC</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n"
    },
    {
        "commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "previous commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/AbstractMessageBus.java",
            "additions": 22,
            "deletions": 8
        },
        "diff content": "@@ -1,9 +1,7 @@\n package org.mbassy;\n \n-import org.mbassy.common.IPredicate;\n import org.mbassy.common.ReflectionUtils;\n import org.mbassy.dispatch.MessagingContext;\n-import org.mbassy.listener.Listener;\n import org.mbassy.listener.MetadataReader;\n import org.mbassy.subscription.Subscription;\n import org.mbassy.subscription.SubscriptionDeliveryRequest;\n@@ -12,6 +10,7 @@ import org.mbassy.subscription.SubscriptionFactory;\n import java.lang.reflect.Method;\n import java.util.*;\n import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n /**\n  * The base class for all message bus implementations.\n@@ -53,6 +52,10 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     // it can be customized by implementing the getSubscriptionFactory() method\n     private final SubscriptionFactory subscriptionFactory;\n \n+    // indicates whether the shutdown method has been invoked\n+    // -> if true, then dispatchers will have been shutdown\n+    private final AtomicBoolean isShutDown = new AtomicBoolean(false);\n+\n \n \n     public AbstractMessageBus(BusConfiguration configuration) {\n@@ -76,12 +79,13 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n                         try {\n                             pendingMessages.take().execute();\n                         } catch (InterruptedException e) {\n-                            handlePublicationError(new PublicationError(e, \"Asynchronous publication interrupted\", null, null, null));\n+                            Thread.currentThread().interrupt();\n                             return;\n                         }\n                     }\n                 }\n             });\n+            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n             dispatchers.add(dispatcher);\n             dispatcher.start();\n         }\n@@ -114,8 +118,8 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n                 synchronized (this) { // new subscriptions must be processed sequentially\n                     subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                     if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n-                        List<Method> messageHandlers = metadataReader.getListeners(listeningClass);  // get all methods with subscriptions\n-                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class\n+                        List<Method> messageHandlers = metadataReader.getMessageHandlers(listeningClass);  // get all methods with subscriptions\n+                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                             nonListeners.add(listeningClass);\n                             return;\n                         }\n@@ -160,6 +164,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         if (subscriptionsPerMessage.get(messageType) != null) {\n             subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n         }\n+        // TODO: get superclasses is eligible for caching\n         for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n             if (subscriptionsPerMessage.get(eventSuperType) != null) {\n                 subscriptions.addAll(subscriptionsPerMessage.get(eventSuperType));\n@@ -171,10 +176,11 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n \n \n     // associate a suscription with a message type\n+    // NOTE: Not thread-safe! must be synchronized in outer scope\n     private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n         Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n         if (subscriptions == null) {\n-            subscriptions = new CopyOnWriteArraySet<Subscription>();\n+            subscriptions = new LinkedList<Subscription>();\n             subscriptionsPerMessage.put(messageType, subscriptions);\n         }\n         subscriptions.add(subscription);\n@@ -195,8 +201,6 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         return listener.getParameterTypes()[0];\n     }\n \n-\n-\n     public void handlePublicationError(PublicationError error) {\n         for (IPublicationErrorHandler errorHandler : errorHandlers){\n             errorHandler.handleError(error);\n@@ -205,10 +209,20 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n \n     @Override\n     protected void finalize() throws Throwable {\n+        shutdown();\n         super.finalize();\n+    }\n+\n+    private void shutdown(){\n         for (Thread dispatcher : dispatchers) {\n             dispatcher.interrupt();\n         }\n+        executor.shutdown();\n+        isShutDown.set(true);\n+    }\n+\n+    public boolean hasPendingMessages(){\n+        return pendingMessages.size() > 0;\n     }\n \n     @Override\n"
    },
    {
        "commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "previous commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/IMessageBus.java",
            "additions": 7,
            "deletions": 0
        },
        "diff content": "@@ -104,6 +104,13 @@ public interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n      */\n     public Executor getExecutor();\n \n+    /**\n+     * Check whether any asynchronous message publications are pending for being processed\n+     *\n+     * @return\n+     */\n+    public boolean hasPendingMessages();\n+\n \n     /**\n      * A post command is used as an intermediate object created by a call to the message bus' post method.\n"
    },
    {
        "commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "previous commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MetadataReader.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -57,7 +57,7 @@ public class MetadataReader {\n \n     // get all listeners defined by the given class (includes\n     // listeners defined in super classes)\n-    public List<Method> getListeners(Class<?> target) {\n+    public List<Method> getMessageHandlers(Class<?> target) {\n         List<Method> allMethods = ReflectionUtils.getMethods(AllMessageHandlers, target);\n         List<Method>  handlers = new LinkedList<Method>();\n         for(Method listener : allMethods){\n"
    },
    {
        "commit hash": "95c5d8e535d0dc0c36438defd45f9917f124f713",
        "previous commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/TestUtil.java",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -10,6 +10,7 @@ import java.util.List;\n  */\n public class TestUtil {\n \n+\n     public static void setup(final IMessageBus bus, final List<Object> listeners, int numberOfThreads) {\n         Runnable[] setupUnits = new Runnable[numberOfThreads];\n         int partitionSize;\n"
    },
    {
        "commit hash": "ffb5d01b70c5999379f53f150cf056423c30a089",
        "previous commit hash": "634e257dd5a3f7943dd47c703a04d701cba1be71",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -10,7 +10,7 @@ Read this documentation to get an overview of its features and how cool this mes\n You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n which also contains a partial list of the features of the compared implementations.\n \n-The current version is 1.0.2.RC\n+The current version is 1.0.3.RC\n \n Table of contents:\n + [Features](#features)\n"
    },
    {
        "commit hash": "634e257dd5a3f7943dd47c703a04d701cba1be71",
        "previous commit hash": "0d6348adaee59b31dd00eb7521a9efab0b42ee95",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -77,7 +77,7 @@ Creation of message bus and registration of listeners:\n \n         // create as many instances as necessary\n         // bind it to any upper bound\n-        MBassador<TestEvent> bus = new MBassador<TestEvent>();\n+        MBassador<TestEvent> bus = new MBassador<TestEvent>(BusConfiguration.Default());\n         ListeningBean listener = new ListeningBean();\n         // the listener will be registered using a weak-reference\n         bus.subscribe(listener);\n"
    },
    {
        "commit hash": "0d6348adaee59b31dd00eb7521a9efab0b42ee95",
        "previous commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.3.RC/mbassador-1.0.3.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/maven/org/mbassy/mbassador/1.0.3.RC/mbassador-1.0.3.RC.jar differ\n"
    },
    {
        "commit hash": "0d6348adaee59b31dd00eb7521a9efab0b42ee95",
        "previous commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.3.RC/mbassador-1.0.3.RC.jar.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+2bcfd233f83cb6fc4241c91a99f74030\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "0d6348adaee59b31dd00eb7521a9efab0b42ee95",
        "previous commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.3.RC/mbassador-1.0.3.RC.jar.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+20df67988104be77a9c3e2edbb8ba615a664671b\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "0d6348adaee59b31dd00eb7521a9efab0b42ee95",
        "previous commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.3.RC/mbassador-1.0.3.RC.pom",
            "additions": 58,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,58 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.mbassy</groupId>\n+    <artifactId>mbassador</artifactId>\n+    <version>1.0.3.RC</version>\n+    <packaging>jar</packaging>\n+    <name>mbassador</name>\n+    <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n+    </description>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.build.java.version>1.6</project.build.java.version>\n+        <github.url>file://${project.basedir}/maven</github.url>\n+    </properties>\n+\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.10</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+    </dependencies>\n+\n+    <distributionManagement>\n+        <repository>\n+            <id>mbassador-github-repo</id>\n+            <url>${github.url}</url>\n+        </repository>\n+    </distributionManagement>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>${project.build.java.version}</source>\n+                    <target>${project.build.java.version}</target>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <skipTests>false</skipTests>\n+                </configuration>\n+            </plugin>\n+\n+        </plugins>\n+    </build>\n+</project>\n"
    },
    {
        "commit hash": "0d6348adaee59b31dd00eb7521a9efab0b42ee95",
        "previous commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.3.RC/mbassador-1.0.3.RC.pom.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+d766622aea3238ee52a60920313274d1\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "0d6348adaee59b31dd00eb7521a9efab0b42ee95",
        "previous commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.3.RC/mbassador-1.0.3.RC.pom.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+55c27ec10ee4067843f05fb735a2af95bc2c06cf\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "0d6348adaee59b31dd00eb7521a9efab0b42ee95",
        "previous commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -8,7 +8,8 @@\n       <version>1.0.0.RC</version>\n       <version>1.0.1.RC</version>\n       <version>1.0.2.RC</version>\n+      <version>1.0.3.RC</version>\n     </versions>\n-    <lastUpdated>20121130121617</lastUpdated>\n+    <lastUpdated>20121208081117</lastUpdated>\n   </versioning>\n </metadata>\n"
    },
    {
        "commit hash": "0d6348adaee59b31dd00eb7521a9efab0b42ee95",
        "previous commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.md5",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-f4ebc2213def52cc73bd6668fffd4d3a\n\\ No newline at end of file\n+7ef914e14f2998dd2ce1665e2cfb30ba\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "0d6348adaee59b31dd00eb7521a9efab0b42ee95",
        "previous commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.sha1",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-d9bd65993cedd101a8c962f21dfc61d5e6adbba1\n\\ No newline at end of file\n+90c7ea303b6a468b004369a2f14691239ae9e8ea\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "previous commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -4,7 +4,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>org.mbassy</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.0.2.RC</version>\n+    <version>1.0.3.RC</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n"
    },
    {
        "commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "previous commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/AbstractMessageBus.java",
            "additions": 16,
            "deletions": 23
        },
        "diff content": "@@ -2,6 +2,7 @@ package org.mbassy;\n \n import org.mbassy.common.IPredicate;\n import org.mbassy.common.ReflectionUtils;\n+import org.mbassy.dispatch.MessagingContext;\n import org.mbassy.listener.Listener;\n import org.mbassy.listener.MetadataReader;\n import org.mbassy.subscription.Subscription;\n@@ -21,10 +22,10 @@ import java.util.concurrent.*;\n public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n \n     // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n-    private ExecutorService executor;\n+    private final ExecutorService executor;\n \n     // the metadata reader that is used to parse objects passed to the subscribe method\n-    private MetadataReader metadataReader = new MetadataReader();\n+    private final MetadataReader metadataReader;\n \n     // all subscriptions per message type\n     // this is the primary list for dispatching a specific message\n@@ -40,13 +41,13 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     private final Collection<Class> nonListeners = new HashSet();\n \n     // this handler will receive all errors that occur during message dispatch or message handling\n-    private CopyOnWriteArrayList<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n+    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n \n     // all threads that are available for asynchronous message dispatching\n-    private final CopyOnWriteArrayList<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n+    private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n \n     // all pending messages scheduled for asynchronous dispatch are queued here\n-    private final LinkedBlockingQueue<SubscriptionDeliveryRequest<T>> pendingMessages = new LinkedBlockingQueue<SubscriptionDeliveryRequest<T>>();\n+    private final LinkedBlockingQueue<SubscriptionDeliveryRequest<T>> pendingMessages;\n \n     // this factory is used to create specialized subscriptions based on the given message handler configuration\n     // it can be customized by implementing the getSubscriptionFactory() method\n@@ -54,24 +55,15 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n \n \n \n-\n-    public AbstractMessageBus() {\n-        this(2);\n-    }\n-\n-    public AbstractMessageBus(int dispatcherThreadCount) {\n-        this(dispatcherThreadCount, new ThreadPoolExecutor(5, 50, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>()));\n-    }\n-\n-    public AbstractMessageBus(int dispatcherThreadCount, ExecutorService executor) {\n-        this.executor = executor;\n-        initDispatcherThreads(dispatcherThreadCount > 0 ? dispatcherThreadCount : 2);\n+    public AbstractMessageBus(BusConfiguration configuration) {\n+        this.executor = configuration.getExecutor();\n+        subscriptionFactory = configuration.getSubscriptionFactory();\n+        this.metadataReader = configuration.getMetadataReader();\n+        pendingMessages  = new LinkedBlockingQueue<SubscriptionDeliveryRequest<T>>(configuration.getMaximumNumberOfPendingMessages());\n+        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n         addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n-        subscriptionFactory = getSubscriptionFactory();\n     }\n \n-    // use this method to introduce a custom subscription factory for extension\n-    protected abstract SubscriptionFactory getSubscriptionFactory();\n \n     // initialize the dispatch workers\n     private void initDispatcherThreads(int numberOfThreads) {\n@@ -119,20 +111,21 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n                 return; // early reject of known classes that do not participate in eventing\n             Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n             if (subscriptionsByListener == null) { // if the type is registered for the first time\n-                synchronized (this) { // new subscriptions must be processed sequentially for each class\n+                synchronized (this) { // new subscriptions must be processed sequentially\n                     subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                     if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                         List<Method> messageHandlers = metadataReader.getListeners(listeningClass);  // get all methods with subscriptions\n-                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                         if (messageHandlers.isEmpty()) {  // remember the class as non listening class\n                             nonListeners.add(listeningClass);\n                             return;\n                         }\n+                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                         // create subscriptions for all detected listeners\n                         for (Method messageHandler : messageHandlers) {\n                             if (!isValidMessageHandler(messageHandler)) continue; // ignore invalid listeners\n                             Class eventType = getMessageType(messageHandler);\n-                            Subscription subscription = subscriptionFactory.createSubscription(metadataReader.getHandlerMetadata(messageHandler));\n+                            Subscription subscription = subscriptionFactory\n+                                    .createSubscription(new MessagingContext(this, metadataReader.getHandlerMetadata(messageHandler)));\n                             subscription.subscribe(listener);\n                             addMessageTypeSubscription(eventType, subscription);\n                             subscriptionsByListener.add(subscription);\n"
    },
    {
        "commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "previous commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/BusConfiguration.java",
            "additions": 85,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,85 @@\n+package org.mbassy;\n+\n+import org.mbassy.listener.MetadataReader;\n+import org.mbassy.subscription.SubscriptionFactory;\n+\n+import java.util.concurrent.*;\n+\n+/**\n+ *\n+ *\n+ *\n+ * @author bennidi\n+ *         Date: 12/8/12\n+ */\n+public class BusConfiguration {\n+\n+    public static final BusConfiguration Default(){\n+        return new BusConfiguration();\n+    }\n+\n+    private int numberOfMessageDispatchers;\n+\n+    private ExecutorService executor;\n+\n+    private int maximumNumberOfPendingMessages;\n+\n+    private SubscriptionFactory subscriptionFactory;\n+\n+    private MetadataReader metadataReader;\n+\n+    public BusConfiguration() {\n+        this.numberOfMessageDispatchers = 2;\n+        this.maximumNumberOfPendingMessages = Integer.MAX_VALUE;\n+        this.subscriptionFactory = new SubscriptionFactory();\n+        this.executor = new ThreadPoolExecutor(5, 20, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>());\n+        this.metadataReader = new MetadataReader();\n+    }\n+\n+    public MetadataReader getMetadataReader() {\n+        return metadataReader;\n+    }\n+\n+    public BusConfiguration setMetadataReader(MetadataReader metadataReader) {\n+        this.metadataReader = metadataReader;\n+        return this;\n+    }\n+\n+    public int getNumberOfMessageDispatchers() {\n+        return numberOfMessageDispatchers > 0 ? numberOfMessageDispatchers : 2;\n+    }\n+\n+    public BusConfiguration setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n+        this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n+        return this;\n+    }\n+\n+    public ExecutorService getExecutor() {\n+        return executor;\n+    }\n+\n+    public BusConfiguration setExecutor(ExecutorService executor) {\n+        this.executor = executor;\n+        return this;\n+    }\n+\n+    public int getMaximumNumberOfPendingMessages() {\n+        return maximumNumberOfPendingMessages;\n+    }\n+\n+    public BusConfiguration setMaximumNumberOfPendingMessages(int maximumNumberOfPendingMessages) {\n+        this.maximumNumberOfPendingMessages = maximumNumberOfPendingMessages > 0\n+                ? maximumNumberOfPendingMessages\n+                : Integer.MAX_VALUE;\n+        return this;\n+    }\n+\n+    public SubscriptionFactory getSubscriptionFactory() {\n+        return subscriptionFactory;\n+    }\n+\n+    public BusConfiguration setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n+        this.subscriptionFactory = subscriptionFactory;\n+        return this;\n+    }\n+}\n"
    },
    {
        "commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "previous commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/MBassador.java",
            "additions": 2,
            "deletions": 14
        },
        "diff content": "@@ -8,22 +8,10 @@ import java.util.concurrent.*;\n \n public class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>>{\n \n-    public MBassador(){\n-        this(2);\n+    public MBassador(BusConfiguration configuration){\n+        super(configuration);\n     }\n \n-    public MBassador(int dispatcherThreadCount){\n-        super(dispatcherThreadCount);\n-    }\n-\n-    public MBassador(int dispatcherThreadCount, ExecutorService executor){\n-        super(dispatcherThreadCount,executor);\n-    }\n-\n-    @Override\n-    protected SubscriptionFactory getSubscriptionFactory() {\n-        return new SubscriptionFactory(this);\n-    }\n \n     public void publishAsync(T message){\n         addAsynchronousDeliveryRequest(new SubscriptionDeliveryRequest<T>(getSubscriptionsByMessageType(message.getClass()), message));\n"
    },
    {
        "commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "previous commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/common/ConcurrentSet.java",
            "additions": 15,
            "deletions": 19
        },
        "diff content": "@@ -3,6 +3,7 @@ package org.mbassy.common;\n \n import java.lang.ref.WeakReference;\n import java.util.Iterator;\n+import java.util.Set;\n import java.util.WeakHashMap;\n \n /**\n@@ -12,8 +13,7 @@ import java.util.WeakHashMap;\n  * been reached by the iterator will not appear in that iterator anymore.\n  * <p/>\n  * The structure uses weak references to the elements. Iterators automatically perform cleanups of\n- * garbace collect objects during iteration.\n- * No dedicated maintenance operations need to be called or run in background.\n+ * garbage collected objects during iteration -> no dedicated maintenance operations need to be called or run in background.\n  * <p/>\n  * <p/>\n  * <p/>\n@@ -21,8 +21,7 @@ import java.util.WeakHashMap;\n  * @author bennidi\n  *         Date: 2/12/12\n  */\n-public class ConcurrentSet<T> implements Iterable<T> {\n-\n+public class ConcurrentSet<T> implements Iterable<T>{\n \n     private WeakHashMap<T, Entry<T>> entries = new WeakHashMap<T, Entry<T>>(); // maintain a map of entries for O(log n) lookup\n \n@@ -70,11 +69,13 @@ public class ConcurrentSet<T> implements Iterable<T> {\n         if (!entries.containsKey(element)) return false;\n         synchronized (this) {\n             Entry<T> listelement = entries.get(element);\n-            if(listelement == null)return false;\n+            if(listelement == null)return false; //removed by other thread\n             if (listelement != head) {\n                 listelement.remove();\n             } else {\n+                Entry<T> oldHead = head;\n                 head = head.next();\n+                oldHead.next = null; // optimize for GC\n             }\n             entries.remove(element);\n         }\n@@ -111,10 +112,9 @@ public class ConcurrentSet<T> implements Iterable<T> {\n \n             public void remove() {\n                 if (current == null) return;\n-                synchronized (ConcurrentSet.this) {\n-                    current.remove();\n-                    current = current.next();\n-                }\n+                Entry<T> newCurrent = current.next();\n+                ConcurrentSet.this.remove(current.getValue());\n+                current = newCurrent;\n             }\n         };\n     }\n@@ -143,26 +143,22 @@ public class ConcurrentSet<T> implements Iterable<T> {\n             return value.get();\n         }\n \n+        // not thread-safe! must be synchronized in enclosing context\n         public void remove() {\n             if (predecessor != null) {\n-                predecessor.setNext(next());\n-            } else if (next() != null) {\n+                predecessor.next = next;\n+                if(next != null)next.predecessor = predecessor;\n+            } else if (next != null) {\n                 next.predecessor = null;\n             }\n-        }\n-\n-        public void setNext(Entry<T> element) {\n-            this.next = element;\n-            if (element != null) element.predecessor = this;\n+            next = null;\n+            predecessor = null;\n         }\n \n         public Entry<T> next() {\n             return next;\n         }\n \n-        public boolean hasNext() {\n-            return next() != null;\n-        }\n \n     }\n }\n"
    },
    {
        "commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "previous commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/SubscriptionDeliveryRequest.java",
            "additions": 0,
            "deletions": 9
        },
        "diff content": "@@ -18,15 +18,6 @@ public class SubscriptionDeliveryRequest<T> {\n         this.message = message;\n     }\n \n-    public SubscriptionDeliveryRequest(T message){\n-        this.message = message;\n-        subscriptions = new LinkedList<Subscription>();\n-    }\n-\n-    public boolean addAll(Collection<? extends Subscription> c) {\n-        return subscriptions.addAll(c);\n-    }\n-\n     public boolean add(Subscription subscription) {\n         return subscriptions.add(subscription);\n     }\n"
    },
    {
        "commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "previous commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/SubscriptionFactory.java",
            "additions": 1,
            "deletions": 8
        },
        "diff content": "@@ -16,14 +16,7 @@ import java.util.Collection;\n  */\n public class SubscriptionFactory {\n \n-    private IMessageBus owner;\n-\n-    public SubscriptionFactory(IMessageBus owner) {\n-        this.owner = owner;\n-    }\n-\n-    public Subscription createSubscription(MessageHandlerMetadata messageHandlerMetadata){\n-        MessagingContext context = new MessagingContext(owner, messageHandlerMetadata);\n+    public Subscription createSubscription(MessagingContext context){\n         IHandlerInvocation invocation = buildInvocationForHandler(context);\n         IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n         return new Subscription(context, dispatcher);\n"
    },
    {
        "commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "previous commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/ConcurrentSetTest.java",
            "additions": 71,
            "deletions": 4
        },
        "diff content": "@@ -5,13 +5,14 @@ import org.junit.Test;\n import org.mbassy.common.ConcurrentSet;\n \n import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.Random;\n \n /**\n  * This test ensures the correct behaviour of the set implementation that is the building\n  * block of the subscription implementations used by the Mbassador message bus.\n- *\n+ * <p/>\n  * It should behave exactly like other set implementations do and as such all tests are based\n  * on comparing the outcome of sequence of operations applied to a standard set implementation\n  * and the concurrent set.\n@@ -102,7 +103,7 @@ public class ConcurrentSetTest extends UnitTest {\n     }\n \n     @Test\n-    public void testPerformance(){\n+    public void testPerformance() {\n         final HashSet<Object> source = new HashSet<Object>();\n \n         final HashSet<Object> hashSet = new HashSet<Object>();\n@@ -115,14 +116,14 @@ public class ConcurrentSetTest extends UnitTest {\n \n \n         long start = System.currentTimeMillis();\n-        for(Object o: source){\n+        for (Object o : source) {\n             hashSet.add(o);\n         }\n         long duration = System.currentTimeMillis() - start;\n         System.out.println(\"Performance of HashSet for 1.000.000 object insertions \" + duration);\n \n         start = System.currentTimeMillis();\n-        for(Object o: source){\n+        for (Object o : source) {\n             concurrentSet.add(o);\n         }\n         duration = System.currentTimeMillis() - start;\n@@ -217,4 +218,70 @@ public class ConcurrentSetTest extends UnitTest {\n         }\n     }\n \n+    @Test\n+    public void testCompleteRemoval() {\n+        final HashSet<Object> source = new HashSet<Object>();\n+        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n+\n+        // build set of candidates and mark subset for removal\n+        for (int i = 0; i < numberOfElements; i++) {\n+            Object candidate = new Object();\n+            source.add(candidate);\n+            testSet.add(candidate);\n+        }\n+\n+        // build test set by adding the candidates\n+        // and subsequently removing those marked for removal\n+        ConcurrentExecutor.runConcurrent(new Runnable() {\n+            @Override\n+            public void run() {\n+                for (Object src : source) {\n+                    testSet.remove(src);\n+                }\n+            }\n+        }, numberOfThreads);\n+\n+\n+        // ensure that the test set still contains all objects from the source set that have not been marked\n+        // for removal\n+        assertEquals(0, testSet.size());\n+        for(Object src : source){\n+            assertFalse(testSet.contains(src));\n+        }\n+    }\n+\n+    @Test\n+    public void testRemovalViaIterator() {\n+        final HashSet<Object> source = new HashSet<Object>();\n+        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n+\n+        // build set of candidates and mark subset for removal\n+        for (int i = 0; i < numberOfElements; i++) {\n+            Object candidate = new Object();\n+            source.add(candidate);\n+            testSet.add(candidate);\n+        }\n+\n+        // build test set by adding the candidates\n+        // and subsequently removing those marked for removal\n+        ConcurrentExecutor.runConcurrent(new Runnable() {\n+            @Override\n+            public void run() {\n+                Iterator<Object> iterator = testSet.iterator();\n+                while(iterator.hasNext()){\n+                    iterator.remove();\n+                }\n+            }\n+        }, numberOfThreads);\n+\n+\n+        // ensure that the test set still contains all objects from the source set that have not been marked\n+        // for removal\n+        assertEquals(0, testSet.size());\n+        for(Object src : source){\n+            assertFalse(testSet.contains(src));\n+        }\n+    }\n+\n+\n }\n"
    },
    {
        "commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "previous commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/FilterTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -21,7 +21,7 @@ public class FilterTest extends UnitTest{\n     @Test\n     public void testSubclassFilter() throws Exception {\n \n-        MBassador bus = new MBassador();\n+        MBassador bus = new MBassador(new BusConfiguration());\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(100, FilteredMessageListener.class)\n                 .create(100, Object.class)\n"
    },
    {
        "commit hash": "21385b605ed17f0de1b9e2c845b6128ceeae81ca",
        "previous commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/MBassadorTest.java",
            "additions": 7,
            "deletions": 5
        },
        "diff content": "@@ -1,5 +1,6 @@\n package org.mbassy;\n \n+import org.junit.Before;\n import org.junit.Test;\n import org.mbassy.events.SubTestEvent;\n import org.mbassy.events.TestEvent;\n@@ -20,10 +21,11 @@ import java.util.concurrent.CopyOnWriteArrayList;\n  */\n public class MBassadorTest extends UnitTest {\n \n+\n     // this is a single threaded test for subscribing and unsubscribing of a single listener\n     @Test\n     public void testSubscribeSimple() throws InterruptedException {\n-        MBassador bus = new MBassador();\n+        MBassador bus = new MBassador(new BusConfiguration());\n         List<Object> listeners = new LinkedList<Object>();\n         int listenerCount = 1000;\n \n@@ -77,7 +79,7 @@ public class MBassadorTest extends UnitTest {\n     @Test\n     public void testConcurrentSubscription() throws Exception {\n \n-        MBassador bus = new MBassador();\n+        MBassador bus = new MBassador(new BusConfiguration());\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(100, EventingTestBean.class)\n                 .create(100, EventingTestBean2.class)\n@@ -105,7 +107,7 @@ public class MBassadorTest extends UnitTest {\n     @Test\n     public void testAsynchronousMessagePublication() throws Exception {\n \n-        MBassador bus = new MBassador();\n+        MBassador bus = new MBassador(new BusConfiguration());\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(100, EventingTestBean.class)\n                 .create(100, EventingTestBean2.class)\n@@ -134,7 +136,7 @@ public class MBassadorTest extends UnitTest {\n     @Test\n     public void testSynchronousMessagePublication() throws Exception {\n \n-        MBassador bus = new MBassador();\n+        MBassador bus = new MBassador(new BusConfiguration());\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(100, EventingTestBean.class)\n                 .create(100, EventingTestBean2.class)\n@@ -167,7 +169,7 @@ public class MBassadorTest extends UnitTest {\n         final int eventLoopsPerTHread = 100;\n \n \n-        final MBassador bus = new MBassador();\n+        final MBassador bus = new MBassador(new BusConfiguration());\n         ListenerFactory listenerFactory = new ListenerFactory()\n                 .create(100, EventingTestBean.class)\n                 .create(100, EventingTestBean2.class)\n"
    },
    {
        "commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "previous commit hash": "a47b63288097d5c34a6819769acebe1cff15587b",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -10,7 +10,7 @@ Read this documentation to get an overview of its features and how cool this mes\n You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n which also contains a partial list of the features of the compared implementations.\n \n-The current version is 1.0.1.RC\n+The current version is 1.0.2.RC\n \n Table of contents:\n + [Features](#features)\n"
    },
    {
        "commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "previous commit hash": "a47b63288097d5c34a6819769acebe1cff15587b",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.2.RC/mbassador-1.0.2.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/maven/org/mbassy/mbassador/1.0.2.RC/mbassador-1.0.2.RC.jar differ\n"
    },
    {
        "commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "previous commit hash": "a47b63288097d5c34a6819769acebe1cff15587b",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.2.RC/mbassador-1.0.2.RC.jar.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+5ad621adc6addc2292ee1fc7a2bd756d\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "previous commit hash": "a47b63288097d5c34a6819769acebe1cff15587b",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.2.RC/mbassador-1.0.2.RC.jar.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+258a17785e15390e868efe2a51d5370aeb602129\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "previous commit hash": "a47b63288097d5c34a6819769acebe1cff15587b",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.2.RC/mbassador-1.0.2.RC.pom",
            "additions": 58,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,58 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.mbassy</groupId>\n+    <artifactId>mbassador</artifactId>\n+    <version>1.0.2.RC</version>\n+    <packaging>jar</packaging>\n+    <name>mbassador</name>\n+    <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n+    </description>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.build.java.version>1.6</project.build.java.version>\n+        <github.url>file://${project.basedir}/maven</github.url>\n+    </properties>\n+\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.10</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+    </dependencies>\n+\n+    <distributionManagement>\n+        <repository>\n+            <id>mbassador-github-repo</id>\n+            <url>${github.url}</url>\n+        </repository>\n+    </distributionManagement>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>${project.build.java.version}</source>\n+                    <target>${project.build.java.version}</target>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <skipTests>false</skipTests>\n+                </configuration>\n+            </plugin>\n+\n+        </plugins>\n+    </build>\n+</project>\n"
    },
    {
        "commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "previous commit hash": "a47b63288097d5c34a6819769acebe1cff15587b",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.2.RC/mbassador-1.0.2.RC.pom.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+f7972cec0f8ebde2a2a17a678ef36eb6\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "previous commit hash": "a47b63288097d5c34a6819769acebe1cff15587b",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.2.RC/mbassador-1.0.2.RC.pom.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+f8c24fe42f192dbdd1f5d2b29bff0220d40039dd\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "previous commit hash": "a47b63288097d5c34a6819769acebe1cff15587b",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -7,7 +7,8 @@\n     <versions>\n       <version>1.0.0.RC</version>\n       <version>1.0.1.RC</version>\n+      <version>1.0.2.RC</version>\n     </versions>\n-    <lastUpdated>20121122134301</lastUpdated>\n+    <lastUpdated>20121130121617</lastUpdated>\n   </versioning>\n </metadata>\n"
    },
    {
        "commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "previous commit hash": "a47b63288097d5c34a6819769acebe1cff15587b",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.md5",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-75a92cb9aba8b1ce38c7a5ed28de4c7f\n\\ No newline at end of file\n+f4ebc2213def52cc73bd6668fffd4d3a\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "31e6ca18bbd0d52b77f35317b5f89b2a72e7615a",
        "previous commit hash": "a47b63288097d5c34a6819769acebe1cff15587b",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.sha1",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-727a1ce27e63eac58e45150930755a8bcf582aef\n\\ No newline at end of file\n+d9bd65993cedd101a8c962f21dfc61d5e6adbba1\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "a47b63288097d5c34a6819769acebe1cff15587b",
        "previous commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "diff stats": {
            "file_path": "build.gradle",
            "additions": 10,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,10 @@\n+usePlugin('java')\n+\n+group=\"org.mbassy\"\n+version=\"1.0.2.RC\"\n+\n+dependencies {\n+    addMavenRepo()\n+\n+    testCompile \"junit:junit:4.10@jar\"\n+}\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "a47b63288097d5c34a6819769acebe1cff15587b",
        "previous commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -4,7 +4,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>org.mbassy</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.0.1.RC</version>\n+    <version>1.0.2.RC</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n"
    },
    {
        "commit hash": "a47b63288097d5c34a6819769acebe1cff15587b",
        "previous commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/AbstractMessageBus.java",
            "additions": 21,
            "deletions": 22
        },
        "diff content": "@@ -52,6 +52,27 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     // it can be customized by implementing the getSubscriptionFactory() method\n     private final SubscriptionFactory subscriptionFactory;\n \n+\n+\n+\n+    public AbstractMessageBus() {\n+        this(2);\n+    }\n+\n+    public AbstractMessageBus(int dispatcherThreadCount) {\n+        this(dispatcherThreadCount, new ThreadPoolExecutor(5, 50, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>()));\n+    }\n+\n+    public AbstractMessageBus(int dispatcherThreadCount, ExecutorService executor) {\n+        this.executor = executor;\n+        initDispatcherThreads(dispatcherThreadCount > 0 ? dispatcherThreadCount : 2);\n+        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n+        subscriptionFactory = getSubscriptionFactory();\n+    }\n+\n+    // use this method to introduce a custom subscription factory for extension\n+    protected abstract SubscriptionFactory getSubscriptionFactory();\n+\n     // initialize the dispatch workers\n     private void initDispatcherThreads(int numberOfThreads) {\n         for (int i = 0; i < numberOfThreads; i++) {\n@@ -74,28 +95,6 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         }\n     }\n \n-\n-    public AbstractMessageBus() {\n-        this(2);\n-    }\n-\n-    public AbstractMessageBus(int dispatcherThreadCount) {\n-        this(2, new ThreadPoolExecutor(5, 50, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>()));\n-    }\n-\n-    public AbstractMessageBus(int dispatcherThreadCount, ExecutorService executor) {\n-        this.executor = executor;\n-        initDispatcherThreads(dispatcherThreadCount > 0 ? dispatcherThreadCount : 2);\n-        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n-        subscriptionFactory = getSubscriptionFactory();\n-        initialize();\n-    }\n-\n-    protected abstract SubscriptionFactory getSubscriptionFactory();\n-\n-    protected void initialize() {\n-    }\n-\n     @Override\n     public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n         return Collections.unmodifiableCollection(errorHandlers);\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/AbstractMessageBus.java",
            "additions": 7,
            "deletions": 13
        },
        "diff content": "@@ -48,6 +48,8 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     // all pending messages scheduled for asynchronous dispatch are queued here\n     private final LinkedBlockingQueue<SubscriptionDeliveryRequest<T>> pendingMessages = new LinkedBlockingQueue<SubscriptionDeliveryRequest<T>>();\n \n+    // this factory is used to create specialized subscriptions based on the given message handler configuration\n+    // it can be customized by implementing the getSubscriptionFactory() method\n     private final SubscriptionFactory subscriptionFactory;\n \n     // initialize the dispatch workers\n@@ -72,6 +74,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         }\n     }\n \n+\n     public AbstractMessageBus() {\n         this(2);\n     }\n@@ -102,9 +105,9 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         if (listener == null) return false;\n         Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n         if (subscriptions == null) return false;\n-        boolean isRemoved = false;\n+        boolean isRemoved = true;\n         for (Subscription subscription : subscriptions) {\n-            isRemoved = isRemoved || subscription.unsubscribe(listener);\n+            isRemoved = isRemoved && subscription.unsubscribe(listener);\n         }\n         return isRemoved;\n     }\n@@ -165,24 +168,15 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         if (subscriptionsPerMessage.get(messageType) != null) {\n             subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n         }\n-        for (Class eventSuperType : getSuperclasses(messageType)) {\n+        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n             if (subscriptionsPerMessage.get(eventSuperType) != null) {\n                 subscriptions.addAll(subscriptionsPerMessage.get(eventSuperType));\n             }\n         }\n-        // IMPROVEMENT: use tree list that sorts during insertion\n-        //Collections.sort(subscriptions, new SubscriptionByPriorityDesc());\n         return subscriptions;\n     }\n \n-    private Collection<Class> getSuperclasses(Class from) {\n-        Collection<Class> superclasses = new LinkedList<Class>();\n-        while (!from.equals(Object.class)) {\n-            superclasses.add(from.getSuperclass());\n-            from = from.getSuperclass();\n-        }\n-        return superclasses;\n-    }\n+\n \n     // associate a suscription with a message type\n     private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/IMessageBus.java",
            "additions": 36,
            "deletions": 12
        },
        "diff content": "@@ -7,8 +7,8 @@ import java.util.concurrent.Executor;\n  *\n  * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n  * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n- * The dispatch mechanism can by controlled for each concrete message publication.\n- * A message publication is the publication of any message using one of the bus' publish(..) methods.\n+ * The dispatch mechanism can by controlled for per message handler and message publication.\n+ * A message publication is the publication of any message using one of the bus' publication methods.\n  * <p/>\n  * Each message publication is isolated from all other running publications such that it does not interfere with them.\n  * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n@@ -22,19 +22,22 @@ import java.util.concurrent.Executor;\n  * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n  * removed on-the-fly as messages get dispatched.\n  * <p/>\n- * Generally message handlers will be invoked in inverse sequence of insertion (subscription) but any\n- * class using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n+ * Generally message handlers will be invoked in inverse sequence of subscription but any\n+ * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n  * a specific message exactly once to each of the subscribed message handlers.\n  * <p/>\n  * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n  * a message handler may define filters to narrow the set of messages that it accepts.\n  * <p/>\n  * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n- * Any messageHandler may only be subscribed once (subsequent subscriptions of an already subscribed messageHandler will be silently ignored)\n+ * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n+ * will be silently ignored)\n  * <p/>\n- * Removing a listener means removing all subscribed message handlers of that object. This remove operation\n- * immediately takes effect and on all running dispatch processes. A removed listener (a listener\n+ * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n+ * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n  * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n+ * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n+ * after the remove operation completed.\n  *\n  * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n  * get dispatched to all message handlers that take an instance of List as their parameter\n@@ -55,11 +58,12 @@ public interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n \n \n     /**\n-     * Immediately unsubscribe all registered message handlers (if any) of the given listener. When this call returns\n+     * Immediately remove all registered message handlers (if any) of the given listener. When this call returns all handlers\n      * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n-     * publications that have been published when the messageHandler was still subscribed).\n-     * A call to this method passing null, an already subscribed message or any message that does not define any listeners\n-     * will not have any effect.\n+     * publications that have been published when the message listener was still subscribed).\n+     *\n+     * A call to this method passing null, an already unsubscribed listener or any object that does not define any message\n+     * handlers will not have any effect and is silently ignored.\n      *\n      * @param listener\n      * @return  true, if the listener was found and successfully removed\n@@ -91,14 +95,34 @@ public interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n      */\n     public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n \n-    public Executor getExecutor();\n \n+    /**\n+     * Get the executor service that is used to asynchronous message publication.\n+     * The executor is passed to the message bus at creation time.\n+     *\n+     * @return\n+     */\n+    public Executor getExecutor();\n \n \n+    /**\n+     * A post command is used as an intermediate object created by a call to the message bus' post method.\n+     * It encapsulates the functionality provided by the message bus that created the command.\n+     * Subclasses may extend this interface and add functionality, e.g. different dispatch schemes.\n+     *\n+     */\n     public static interface IPostCommand{\n \n+        /**\n+         * Execute the message publication immediately. This call blocks until every matching message handler\n+         * has been invoked.\n+         */\n         public void now();\n \n+        /**\n+         * Execute the message publication asynchronously. This call return immediately and all matching message handlers\n+         * will be invoked in another thread.\n+         */\n         public void asynchronously();\n \n     }\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/IPublicationErrorHandler.java",
            "additions": 9,
            "deletions": 1
        },
        "diff content": "@@ -1,13 +1,21 @@\n package org.mbassy;\n \n /**\n- * TODO. Insert class description here\n+ * Publication error handlers are provided with a publication error every time an error occurs during message publication.\n+ * A handler might fail with an exception, not be accessible because of the presence of a security manager\n+ * or other reasons might lead to failures during the message publication process.\n+ *\n  * <p/>\n  * @author bennidi\n  * Date: 2/22/12\n  */\n public interface IPublicationErrorHandler {\n \n+    /**\n+     * Handle the given publication error.\n+     *\n+     * @param error\n+     */\n \tpublic void handleError(PublicationError error);\n \n     // This is the default error handler it will simply log to standard out and\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/MBassador.java",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -6,7 +6,7 @@ import java.util.*;\n import java.util.concurrent.*;\n \n \n-public class MBassador<T> extends AbstractMessageBus<T, SimplePostCommand<T>>{\n+public class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>>{\n \n     public MBassador(){\n         this(2);\n@@ -56,8 +56,8 @@ public class MBassador<T> extends AbstractMessageBus<T, SimplePostCommand<T>>{\n \n \n     @Override\n-    public SimplePostCommand post(T message) {\n-        return new SimplePostCommand(this, message);\n+    public SyncAsyncPostCommand post(T message) {\n+        return new SyncAsyncPostCommand(this, message);\n     }\n \n }\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/SyncAsyncPostCommand.java",
            "additions": 7,
            "deletions": 8
        },
        "diff content": "@@ -1,18 +1,17 @@\n package org.mbassy;\n \n /**\n-* Created with IntelliJ IDEA.\n-* @author bennidi\n-* Date: 11/12/12\n-* Time: 8:44 PM\n-* To change this template use File | Settings | File Templates.\n-*/\n-public class SimplePostCommand<T> implements IMessageBus.IPostCommand {\n+ * This post command provides access to standard synchronous and asynchronous dispatch\n+ *\n+ * @author bennidi\n+ *         Date: 11/12/12\n+ */\n+public class SyncAsyncPostCommand<T> implements IMessageBus.IPostCommand {\n \n     private T message;\n     private MBassador mBassador;\n \n-    public SimplePostCommand(MBassador mBassador, T message) {\n+    public SyncAsyncPostCommand(MBassador mBassador, T message) {\n         this.mBassador = mBassador;\n         this.message = message;\n     }\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/common/ReflectionUtils.java",
            "additions": 10,
            "deletions": 0
        },
        "diff content": "@@ -2,6 +2,7 @@ package org.mbassy.common;\n \n import java.lang.reflect.Method;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.LinkedList;\n import java.util.List;\n \n@@ -50,6 +51,15 @@ public class ReflectionUtils {\n         return filtered;\n     }\n \n+    public static Collection<Class> getSuperclasses(Class from) {\n+        Collection<Class> superclasses = new LinkedList<Class>();\n+        while (!from.equals(Object.class)) {\n+            superclasses.add(from.getSuperclass());\n+            from = from.getSuperclass();\n+        }\n+        return superclasses;\n+    }\n+\n     public static boolean containsOverridingMethod(List<Method> allMethods, Method methodToCheck) {\n         for (Method method : allMethods) {\n             if (isOverriddenBy(methodToCheck, method)) return true;\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/dispatch/AbstractHandlerInvocation.java",
            "additions": 65,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,65 @@\n+package org.mbassy.dispatch;\n+\n+import org.mbassy.IPublicationErrorHandler;\n+import org.mbassy.PublicationError;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 11/23/12\n+ */\n+public class AbstractHandlerInvocation {\n+\n+    private MessagingContext context;\n+\n+    protected void handlePublicationError(PublicationError error){\n+        Collection<IPublicationErrorHandler> handlers = getContext().getOwningBus().getRegisteredErrorHandlers();\n+        for(IPublicationErrorHandler handler : handlers){\n+            handler.handleError(error);\n+        }\n+    }\n+\n+    protected void invokeHandler(final Object message, final Object listener, Method handler){\n+        try {\n+            handler.invoke(listener, message);\n+        }catch(IllegalAccessException e){\n+            handlePublicationError(\n+                    new PublicationError(e, \"Error during messageHandler notification. \" +\n+                            \"The class or method is not accessible\",\n+                            handler, listener, message));\n+        }\n+        catch(IllegalArgumentException e){\n+            handlePublicationError(\n+                    new PublicationError(e, \"Error during messageHandler notification. \" +\n+                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n+                            + \"Expected: \" + handler.getParameterTypes()[0],\n+                            handler, listener, message));\n+        }\n+        catch (InvocationTargetException e) {\n+            handlePublicationError(\n+                    new PublicationError(e, \"Error during messageHandler notification. \" +\n+                            \"Message handler threw exception\",\n+                            handler, listener, message));\n+        }\n+        catch (Throwable e) {\n+            handlePublicationError(\n+                    new PublicationError(e, \"Error during messageHandler notification. \" +\n+                            \"Unexpected exception\",\n+                            handler, listener, message));\n+        }\n+    }\n+\n+\n+    public AbstractHandlerInvocation(MessagingContext context) {\n+        this.context = context;\n+    }\n+\n+    public MessagingContext getContext() {\n+        return context;\n+    }\n+}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/dispatch/AsynchronousHandlerInvocation.java",
            "additions": 39,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,39 @@\n+package org.mbassy.dispatch;\n+\n+import org.mbassy.IPublicationErrorHandler;\n+import org.mbassy.PublicationError;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+\n+/**\n+ * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n+ *\n+ * @author bennidi\n+ *         Date: 11/23/12\n+ */\n+public class AsynchronousHandlerInvocation implements IHandlerInvocation {\n+\n+    private IHandlerInvocation delegate;\n+\n+    public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n+        super();\n+        this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public void invoke(final Method handler, final Object listener, final Object message) {\n+        getContext().getOwningBus().getExecutor().execute(new Runnable() {\n+            @Override\n+            public void run() {\n+                delegate.invoke(handler, listener, message);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public MessagingContext getContext() {\n+        return delegate.getContext();\n+    }\n+}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/dispatch/FilteredMessageDispatcher.java",
            "additions": 57,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,57 @@\n+package org.mbassy.dispatch;\n+\n+import org.mbassy.common.ConcurrentSet;\n+import org.mbassy.listener.IMessageFilter;\n+\n+/**\n+ * A dispatcher that implements message filtering based on the filter configuration\n+ * of the associated message handler. It will delegate message delivery to another\n+ * message dispatcher after having performed the filtering logic.\n+ *\n+ * @author bennidi\n+ *         Date: 11/23/12\n+ */\n+public class FilteredMessageDispatcher implements IMessageDispatcher {\n+\n+    private final IMessageFilter[] filter;\n+\n+    private IMessageDispatcher del;\n+\n+    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\n+        this.del = dispatcher;\n+        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\n+    }\n+\n+    private boolean passesFilter(Object message) {\n+\n+        if (filter == null) {\n+            return true;\n+        }\n+        else {\n+            for (int i = 0; i < filter.length; i++) {\n+                if (!filter[i].accepts(message, getContext().getHandlerMetadata())) return false;\n+            }\n+            return true;\n+        }\n+    }\n+\n+\n+    @Override\n+    public void dispatch(Object message, ConcurrentSet listeners) {\n+         if(passesFilter(message)){\n+             del.dispatch(message, listeners);\n+         }\n+    }\n+\n+    @Override\n+    public MessagingContext getContext() {\n+        return del.getContext();\n+    }\n+\n+    @Override\n+    public IHandlerInvocation getInvocation() {\n+        return del.getInvocation();\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/dispatch/IHandlerInvocation.java",
            "additions": 31,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,31 @@\n+package org.mbassy.dispatch;\n+\n+import java.lang.reflect.Method;\n+\n+/**\n+ * A handler invocation encapsulates the logic that is used to invoke a single\n+ * message handler to process a given message.\n+ * A handler invocation might come in different flavours and can be composed\n+ * of various independent invocations be means of delegation (decorator pattern)\n+ *\n+ * @author bennidi\n+ *         Date: 11/23/12\n+ */\n+public interface IHandlerInvocation {\n+\n+    /**\n+     * Invoke the message delivery logic of this handler invocation\n+     *\n+     * @param handler The method that represents the actual message handler logic of the listener\n+     * @param listener The listener that will receive the message\n+     * @param message  The message to be delivered to the listener\n+     */\n+    public void invoke(final Method handler, final Object listener, final Object message);\n+\n+    /**\n+     * Get the messaging context associated with this invocation\n+     * @return\n+     */\n+    public MessagingContext getContext();\n+\n+}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/dispatch/IMessageDispatcher.java",
            "additions": 46,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,46 @@\n+package org.mbassy.dispatch;\n+\n+import org.mbassy.common.ConcurrentSet;\n+import org.mbassy.subscription.Subscription;\n+\n+/**\n+ * A message dispatcher provides the functionality to deliver a single message\n+ * to a set of listeners. A message dispatcher uses a message context to access\n+ * all information necessary for the message delivery.\n+ *\n+ * The delivery of a single message to a single listener is responsibility of the\n+ * handler invocation object associated with the dispatcher.\n+ *\n+ * Implementations if IMessageDispatcher are partially designed using decorator pattern\n+ * such that it is possible to compose different message dispatchers to achieve more complex\n+ * dispatch logic.\n+ *\n+ * @author bennidi\n+ *         Date: 11/23/12\n+ */\n+public interface IMessageDispatcher {\n+\n+    /**\n+     * Delivers the given message to the given set of listeners.\n+     * Delivery may be delayed, aborted or restricted in various ways, depending\n+     * on the configuration of the dispatcher\n+     *\n+     * @param message The message that should be delivered to the listeners\n+     * @param listeners The listeners that should receive the message\n+     */\n+    public void dispatch(Object message, ConcurrentSet listeners);\n+\n+    /**\n+     * Get the messaging context associated with this dispatcher\n+     *\n+     * @return\n+     */\n+    public MessagingContext getContext();\n+\n+    /**\n+     * Get the handler invocation that will be used to deliver the message to each\n+     * listener\n+     * @return\n+     */\n+    public IHandlerInvocation getInvocation();\n+}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/dispatch/MessageDispatcher.java",
            "additions": 45,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,45 @@\n+package org.mbassy.dispatch;\n+\n+import org.mbassy.common.ConcurrentSet;\n+import org.mbassy.subscription.Subscription;\n+\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Standard implementation for direct, unfiltered message delivery.\n+ *\n+ * For each message delivery, this dispatcher iterates over the listeners\n+ * and uses the previously provided handler invocation to deliver the message\n+ * to each listener\n+ *\n+ * @author bennidi\n+ *         Date: 11/23/12\n+ */\n+public class MessageDispatcher implements IMessageDispatcher {\n+\n+    private MessagingContext context;\n+\n+    private IHandlerInvocation invocation;\n+\n+    public MessageDispatcher(MessagingContext context, IHandlerInvocation invocation) {\n+        this.context = context;\n+        this.invocation = invocation;\n+    }\n+\n+    @Override\n+    public void dispatch(Object message, ConcurrentSet listeners) {\n+        Method handler = getContext().getHandlerMetadata().getHandler();\n+        for(Object listener: listeners){\n+            getInvocation().invoke(handler, listener, message);\n+        }\n+    }\n+\n+    public MessagingContext getContext() {\n+        return context;\n+    }\n+\n+    @Override\n+    public IHandlerInvocation getInvocation() {\n+        return invocation;\n+    }\n+}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/dispatch/MessagingContext.java",
            "additions": 44,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,44 @@\n+package org.mbassy.dispatch;\n+\n+import org.mbassy.IMessageBus;\n+import org.mbassy.listener.MessageHandlerMetadata;\n+\n+/**\n+ * The messaging context holds all data/objects that is relevant to successfully publish\n+ * a message within a subscription. A one-to-one relation between a subscription and\n+ * MessagingContext holds -> a messaging context is created for each distinct subscription\n+ * that lives inside a message bus.\n+ *\n+ * @author bennidi\n+ *         Date: 11/23/12\n+ */\n+public class MessagingContext {\n+\n+    private IMessageBus owningBus;\n+\n+    private MessageHandlerMetadata handlerMetadata;\n+\n+    public MessagingContext(IMessageBus owningBus, MessageHandlerMetadata handlerMetadata) {\n+        this.owningBus = owningBus;\n+        this.handlerMetadata = handlerMetadata;\n+    }\n+\n+    /**\n+     * Get a reference to the message bus this context belongs to\n+     * @return\n+     */\n+    public IMessageBus getOwningBus() {\n+        return owningBus;\n+    }\n+\n+\n+    /**\n+     * Get the meta data that specifies the characteristics of the message handler\n+     * that is associated with this context\n+     * @return\n+     */\n+    public MessageHandlerMetadata getHandlerMetadata() {\n+        return handlerMetadata;\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/dispatch/ReflectiveHandlerInvocation.java",
            "additions": 21,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,21 @@\n+package org.mbassy.dispatch;\n+\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Uses reflection to invoke a message handler for a given message.\n+ *\n+ * @author bennidi\n+ *         Date: 11/23/12\n+ */\n+public class ReflectiveHandlerInvocation extends AbstractHandlerInvocation implements IHandlerInvocation {\n+\n+    public ReflectiveHandlerInvocation(MessagingContext context) {\n+        super(context);\n+    }\n+\n+    @Override\n+    public void invoke(final Method handler, final Object listener, final Object message) {\n+        invokeHandler(message, listener, handler);\n+    }\n+}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/Filter.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -12,12 +12,12 @@ import java.lang.annotation.Target;\n  * to the message listener or not.\n  *\n  * <p/>\n- * @author  benni\n+ * @author  bennidi\n  * Date: 2/14/12\n  */\n @Retention(value = RetentionPolicy.RUNTIME)\n @Target(value = {ElementType.ANNOTATION_TYPE})\n public @interface Filter {\n \n-\tClass<? extends MessageFilter> value();\n+\tClass<? extends IMessageFilter> value();\n }\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/IMessageFilter.java",
            "additions": 54,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,54 @@\n+package org.mbassy.listener;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Message filters can be used to prevent certain messages to be delivered to a specific listener.\n+ * If a filter is used the message will only be delivered if it passes the filter(s)\n+ *\n+ * NOTE: A message filter must provide either a no-arg constructor.\n+ *\n+ * @author bennidi\n+ * Date: 2/8/12\n+ */\n+public interface IMessageFilter {\n+\n+    /**\n+     * Evaluate the message to ensure that it matches the handler configuration\n+     *\n+     *\n+     * @param message the message to be delivered\n+     * @return\n+     */\n+\tpublic boolean accepts(Object message, MessageHandlerMetadata metadata);\n+\n+\n+\n+\tpublic static final class All implements IMessageFilter {\n+\n+\t\t@Override\n+\t\tpublic boolean accepts(Object event, MessageHandlerMetadata metadata) {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+    public static final class None implements IMessageFilter {\n+\n+        @Override\n+        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n+            return false;\n+        }\n+    }\n+\n+\n+    public static final class DontAllowSubtypes implements IMessageFilter {\n+\n+        @Override\n+        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n+            return event.getClass().equals(metadata.getDeclaredMessageType());\n+        }\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/Listener.java",
            "additions": 4,
            "deletions": 3
        },
        "diff content": "@@ -3,17 +3,18 @@ package org.mbassy.listener;\n import java.lang.annotation.*;\n \n /**\n- * TODO. Insert class description here\n- * <p/>\n+ * Mark any method of any object as a message handler and configure the handler\n+ * using different properties.\n+ *\n  * @author bennidi\n  * Date: 2/8/12\n- * Time: 3:35 PM\n  */\n @Retention(value = RetentionPolicy.RUNTIME)\n @Inherited\n @Target(value = {ElementType.METHOD})\n public @interface Listener {\n \n+\n \tFilter[] filters() default {}; // no filters by default\n \n     Mode dispatch() default Mode.Synchronous;\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MessageFilter.java",
            "additions": 0,
            "deletions": 40
        },
        "diff content": "@@ -1,40 +0,0 @@\n-package org.mbassy.listener;\n-\n-/**\n- * Object filters can be used to prevent certain messages to be delivered to a specific listener.\n- * If a filter is used the message will only be delivered if it passes the filter(s)\n- *\n- * @author bennidi\n- * Date: 2/8/12\n- */\n-public interface MessageFilter {\n-\n-    /**\n-     * Evaluate the message and listener to ensure that the message should be handled by the listener\n-     *\n-     *\n-     * @param event the event to be delivered\n-     * @param listener the listener instance that would receive the event if it passes the filter\n-     * @return\n-     */\n-\tpublic boolean accepts(Object event, Object listener);\n-\n-\n-\tpublic static final class All implements MessageFilter {\n-\n-\t\t@Override\n-\t\tpublic boolean accepts(Object event, Object listener) {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-    public static final class None implements MessageFilter {\n-\n-        @Override\n-        public boolean accepts(Object event, Object listener) {\n-            return false;\n-        }\n-    }\n-\n-\n-}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MessageHandlerMetadata.java",
            "additions": 11,
            "deletions": 8
        },
        "diff content": "@@ -1,12 +1,10 @@\n package org.mbassy.listener;\n \n-import org.mbassy.listener.Listener;\n-import org.mbassy.listener.Mode;\n-import org.mbassy.listener.MessageFilter;\n-\n import java.lang.reflect.Method;\n \n /**\n+ *\n+ *\n  * @author bennidi\n  * Date: 11/14/12\n  */\n@@ -14,18 +12,19 @@ public class MessageHandlerMetadata {\n \n     private Method handler;\n \n-    private MessageFilter[] filter;\n+    private IMessageFilter[] filter;\n \n     private Listener listenerConfig;\n \n     private boolean isAsynchronous = false;\n \n \n-    public MessageHandlerMetadata(Method handler, MessageFilter[] filter, Listener listenerConfig) {\n+    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Listener listenerConfig) {\n         this.handler = handler;\n         this.filter = filter;\n         this.listenerConfig = listenerConfig;\n         this.isAsynchronous = listenerConfig.dispatch().equals(Mode.Asynchronous);\n+        this.handler.setAccessible(true);\n     }\n \n \n@@ -34,7 +33,7 @@ public class MessageHandlerMetadata {\n     }\n \n     public boolean isFiltered(){\n-        return filter == null || filter.length == 0;\n+        return filter != null && filter.length > 0;\n     }\n \n     public int getPriority(){\n@@ -45,7 +44,11 @@ public class MessageHandlerMetadata {\n         return handler;\n     }\n \n-    public MessageFilter[] getFilter() {\n+    public IMessageFilter[] getFilter() {\n         return filter;\n     }\n+\n+    public Class getDeclaredMessageType(){\n+        return handler.getParameterTypes()[0];\n+    }\n }\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MetadataReader.java",
            "additions": 5,
            "deletions": 5
        },
        "diff content": "@@ -28,15 +28,15 @@ public class MetadataReader {\n     };\n \n     // cache already created filter instances\n-    private final Map<Class<? extends MessageFilter>, MessageFilter> filterCache = new HashMap<Class<? extends MessageFilter>, MessageFilter>();\n+    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n \n     // retrieve all instances of filters associated with the given subscription\n-    private MessageFilter[] getFilter(Listener subscription) throws Exception{\n+    private IMessageFilter[] getFilter(Listener subscription) throws Exception{\n         if (subscription.filters().length == 0) return null;\n-        MessageFilter[] filters = new MessageFilter[subscription.filters().length];\n+        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n         int i = 0;\n         for (Filter filterDef : subscription.filters()) {\n-            MessageFilter filter = filterCache.get(filterDef.value());\n+            IMessageFilter filter = filterCache.get(filterDef.value());\n             if (filter == null) {\n                     filter = filterDef.value().newInstance();\n                     filterCache.put(filterDef.value(), filter);\n@@ -51,7 +51,7 @@ public class MetadataReader {\n \n     public MessageHandlerMetadata getHandlerMetadata(Method messageHandler) throws Exception{\n         Listener config = messageHandler.getAnnotation(Listener.class);\n-        MessageFilter[] filter = getFilter(config);\n+        IMessageFilter[] filter = getFilter(config);\n         return new MessageHandlerMetadata(messageHandler, filter, config);\n     }\n \n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/FilteredAsynchronousSubscription.java",
            "additions": 0,
            "deletions": 33
        },
        "diff content": "@@ -1,33 +0,0 @@\n-package org.mbassy.subscription;\n-\n-import org.mbassy.IMessageBus;\n-import org.mbassy.IPublicationErrorHandler;\n-import org.mbassy.listener.MessageFilter;\n-import org.mbassy.listener.MessageHandlerMetadata;\n-\n-import java.lang.reflect.Method;\n-import java.util.Collection;\n-\n-/**\n-* Created with IntelliJ IDEA.\n-* @author bennidi\n-* Date: 11/14/12\n-* Time: 3:50 PM\n-* To change this template use File | Settings | File Templates.\n-*/\n-public class FilteredAsynchronousSubscription extends FilteredSubscription{\n-\n-    public FilteredAsynchronousSubscription(IMessageBus mBassador, MessageHandlerMetadata messageHandler) {\n-        super(mBassador, messageHandler);\n-    }\n-\n-    protected void dispatch(final Object message, final Object listener){\n-\n-        getMessageBus().getExecutor().execute(new Runnable() {\n-            @Override\n-            public void run() {\n-                invokeHandler(message, listener);\n-            }\n-        });\n-    }\n-}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/FilteredSubscription.java",
            "additions": 0,
            "deletions": 53
        },
        "diff content": "@@ -1,53 +0,0 @@\n-package org.mbassy.subscription;\n-\n-import org.mbassy.IMessageBus;\n-import org.mbassy.IPublicationErrorHandler;\n-import org.mbassy.MBassador;\n-import org.mbassy.listener.MessageFilter;\n-import org.mbassy.listener.MessageHandlerMetadata;\n-\n-import java.lang.reflect.Method;\n-import java.util.Collection;\n-import java.util.Iterator;\n-\n-/**\n-* Created with IntelliJ IDEA.\n-* @author bennidi\n-* Date: 11/14/12\n-* Time: 3:48 PM\n-* To change this template use File | Settings | File Templates.\n-*/\n-public abstract class FilteredSubscription extends Subscription{\n-\n-    private final MessageFilter[] filter;\n-\n-\n-    public FilteredSubscription(IMessageBus mBassador, MessageHandlerMetadata messageHandler) {\n-        super(mBassador, messageHandler);\n-        this.filter = messageHandler.getFilter();\n-    }\n-\n-    private boolean passesFilter(Object message, Object listener) {\n-\n-        if (filter == null) {\n-            return true;\n-        }\n-        else {\n-            for (int i = 0; i < filter.length; i++) {\n-                if (!filter[i].accepts(message, listener)) return false;\n-            }\n-            return true;\n-        }\n-    }\n-\n-    public void publish(Object message) {\n-\n-        Iterator<Object> iterator = listeners.iterator();\n-        Object listener = null;\n-        while ((listener = iterator.next()) != null) {\n-            if(passesFilter(message, listener)) {\n-                dispatch(message, listener);\n-            }\n-        }\n-    }\n-}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/FilteredSynchronousSubscription.java",
            "additions": 0,
            "deletions": 28
        },
        "diff content": "@@ -1,28 +0,0 @@\n-package org.mbassy.subscription;\n-\n-import org.mbassy.IMessageBus;\n-import org.mbassy.IPublicationErrorHandler;\n-import org.mbassy.listener.MessageFilter;\n-import org.mbassy.listener.MessageHandlerMetadata;\n-\n-import java.lang.reflect.Method;\n-import java.util.Collection;\n-\n-/**\n-* Created with IntelliJ IDEA.\n-* @author bennidi\n-* Date: 11/14/12\n-* Time: 3:49 PM\n-* To change this template use File | Settings | File Templates.\n-*/\n-public class FilteredSynchronousSubscription extends FilteredSubscription {\n-\n-\n-    public FilteredSynchronousSubscription(IMessageBus mBassador, MessageHandlerMetadata messageHandler) {\n-        super(mBassador, messageHandler);\n-    }\n-\n-    protected void dispatch(final Object message, final Object listener){\n-        invokeHandler(message, listener);\n-    }\n-}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/Subscription.java",
            "additions": 20,
            "deletions": 55
        },
        "diff content": "@@ -4,8 +4,11 @@ import org.mbassy.IMessageBus;\n import org.mbassy.IPublicationErrorHandler;\n import org.mbassy.common.ConcurrentSet;\n import org.mbassy.PublicationError;\n+import org.mbassy.dispatch.IMessageDispatcher;\n+import org.mbassy.dispatch.MessagingContext;\n import org.mbassy.listener.MessageHandlerMetadata;\n \n+import javax.xml.ws.handler.MessageContext;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.util.Collection;\n@@ -13,81 +16,39 @@ import java.util.Comparator;\n import java.util.UUID;\n \n /**\n- * Subscription is a thread safe container for objects that contain message handlers\n+ * A subscription is a thread safe container for objects that contain message handlers\n  */\n-public abstract class Subscription {\n+public class Subscription {\n \n     private UUID id = UUID.randomUUID();\n \n-    private final Method handler;\n-\n     protected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n \n-    private int priority = 0;\n+    private IMessageDispatcher dispatcher;\n \n-    private IMessageBus owningBus ;\n+    private MessagingContext context;\n \n-    public Subscription(IMessageBus owningBus, MessageHandlerMetadata messageHandler) {\n-        this.owningBus = owningBus;\n-        this.priority = messageHandler.getPriority();\n-        this.handler = messageHandler.getHandler();\n-        this.handler.setAccessible(true);\n+    public Subscription(MessagingContext context, IMessageDispatcher dispatcher) {\n+        this.context = context;\n+        this.dispatcher = dispatcher;\n     }\n \n-    public abstract void publish(Object message);\n-\n-    protected abstract void dispatch(final Object message, final Object listener);\n \n+    public void publish(Object message){\n+          dispatcher.dispatch(message, listeners);\n+    }\n \n-    protected IMessageBus getMessageBus(){\n-        return owningBus;\n+    public MessagingContext getContext(){\n+        return context;\n     }\n \n     public int getPriority(){\n-        return priority;\n+        return context.getHandlerMetadata().getPriority();\n     }\n \n \n     public void subscribe(Object o) {\n         listeners.add(o);\n-\n-    }\n-\n-    protected void handlePublicationError(PublicationError error){\n-        Collection<IPublicationErrorHandler> handlers = owningBus.getRegisteredErrorHandlers();\n-        for(IPublicationErrorHandler handler : handlers){\n-            handler.handleError(error);\n-        }\n-    }\n-\n-    protected void invokeHandler(final Object message, final Object listener){\n-        try {\n-            handler.invoke(listener, message);\n-        }catch(IllegalAccessException e){\n-            handlePublicationError(\n-                    new PublicationError(e, \"Error during messageHandler notification. \" +\n-                            \"The class or method is not accessible\",\n-                            handler, listener, message));\n-        }\n-        catch(IllegalArgumentException e){\n-            handlePublicationError(\n-                    new PublicationError(e, \"Error during messageHandler notification. \" +\n-                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n-                            + \"Expected: \" + handler.getParameterTypes()[0],\n-                            handler, listener, message));\n-        }\n-        catch (InvocationTargetException e) {\n-            handlePublicationError(\n-                    new PublicationError(e, \"Error during messageHandler notification. \" +\n-                            \"Message handler threw exception\",\n-                            handler, listener, message));\n-        }\n-        catch (Throwable e) {\n-            handlePublicationError(\n-                    new PublicationError(e, \"Error during messageHandler notification. \" +\n-                            \"Unexpected exception\",\n-                            handler, listener, message));\n-        }\n     }\n \n \n@@ -95,6 +56,10 @@ public abstract class Subscription {\n         return listeners.remove(existingListener);\n     }\n \n+    public int size(){\n+        return listeners.size();\n+    }\n+\n \n     public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n         @Override\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/SubscriptionFactory.java",
            "additions": 20,
            "deletions": 16
        },
        "diff content": "@@ -2,6 +2,7 @@ package org.mbassy.subscription;\n \n import org.mbassy.IMessageBus;\n import org.mbassy.IPublicationErrorHandler;\n+import org.mbassy.dispatch.*;\n import org.mbassy.listener.MessageHandlerMetadata;\n \n import java.util.Collection;\n@@ -17,27 +18,30 @@ public class SubscriptionFactory {\n \n     private IMessageBus owner;\n \n-\n     public SubscriptionFactory(IMessageBus owner) {\n         this.owner = owner;\n     }\n \n     public Subscription createSubscription(MessageHandlerMetadata messageHandlerMetadata){\n-        if(messageHandlerMetadata.isFiltered()){\n-            if(messageHandlerMetadata.isAsynchronous()){\n-                return new UnfilteredAsynchronousSubscription(owner, messageHandlerMetadata);\n-            }\n-            else{\n-                return new UnfilteredSynchronousSubscription(owner, messageHandlerMetadata);\n-            }\n-        }\n-        else{\n-            if(messageHandlerMetadata.isAsynchronous()){\n-                return new FilteredAsynchronousSubscription(owner, messageHandlerMetadata);\n-            }\n-            else{\n-                return new FilteredSynchronousSubscription(owner, messageHandlerMetadata);\n-            }\n+        MessagingContext context = new MessagingContext(owner, messageHandlerMetadata);\n+        IHandlerInvocation invocation = buildInvocationForHandler(context);\n+        IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n+        return new Subscription(context, dispatcher);\n+    }\n+\n+    protected IHandlerInvocation buildInvocationForHandler(MessagingContext context){\n+        IHandlerInvocation invocation = new ReflectiveHandlerInvocation(context);\n+        if(context.getHandlerMetadata().isAsynchronous()){\n+            invocation = new AsynchronousHandlerInvocation(invocation);\n         }\n+        return invocation;\n+    }\n+\n+    protected IMessageDispatcher buildDispatcher(MessagingContext context, IHandlerInvocation invocation){\n+       IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n+       if(context.getHandlerMetadata().isFiltered()){\n+          dispatcher = new FilteredMessageDispatcher(dispatcher);\n+       }\n+       return dispatcher;\n     }\n }\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/UnfilteredAsynchronousSubscription.java",
            "additions": 0,
            "deletions": 33
        },
        "diff content": "@@ -1,33 +0,0 @@\n-package org.mbassy.subscription;\n-\n-import org.mbassy.IMessageBus;\n-import org.mbassy.IPublicationErrorHandler;\n-import org.mbassy.MBassador;\n-import org.mbassy.listener.MessageHandlerMetadata;\n-\n-import java.lang.reflect.Method;\n-import java.util.Collection;\n-\n-/**\n-* Created with IntelliJ IDEA.\n-* @author bennidi\n-* Date: 11/14/12\n-* Time: 3:48 PM\n-* To change this template use File | Settings | File Templates.\n-*/\n-public class UnfilteredAsynchronousSubscription extends UnfilteredSubscription {\n-\n-    public UnfilteredAsynchronousSubscription(IMessageBus mBassador, MessageHandlerMetadata messageHandler) {\n-        super(mBassador, messageHandler);\n-    }\n-\n-    protected void dispatch(final Object message, final Object listener){\n-            getMessageBus().getExecutor().execute(new Runnable() {\n-                @Override\n-                public void run() {\n-                    invokeHandler(message, listener);\n-                }\n-            });\n-\n-    }\n-}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/UnfilteredSubscription.java",
            "additions": 0,
            "deletions": 34
        },
        "diff content": "@@ -1,34 +0,0 @@\n-package org.mbassy.subscription;\n-\n-import org.mbassy.IMessageBus;\n-import org.mbassy.IPublicationErrorHandler;\n-import org.mbassy.MBassador;\n-import org.mbassy.listener.MessageHandlerMetadata;\n-\n-import java.lang.reflect.Method;\n-import java.util.Collection;\n-import java.util.Iterator;\n-\n-/**\n-* Created with IntelliJ IDEA.\n-* @author bennidi\n-* Date: 11/14/12\n-* Time: 3:45 PM\n-* To change this template use File | Settings | File Templates.\n-*/\n-public abstract class UnfilteredSubscription extends Subscription{\n-\n-\n-    public UnfilteredSubscription(IMessageBus mBassador, MessageHandlerMetadata messageHandler) {\n-        super(mBassador, messageHandler);\n-    }\n-\n-    public void publish(Object message) {\n-\n-        Iterator<Object> iterator = listeners.iterator();\n-        Object listener = null;\n-        while ((listener = iterator.next()) != null) {\n-            dispatch(message, listener);\n-        }\n-    }\n-}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/UnfilteredSynchronousSubscription.java",
            "additions": 0,
            "deletions": 27
        },
        "diff content": "@@ -1,27 +0,0 @@\n-package org.mbassy.subscription;\n-\n-import org.mbassy.IMessageBus;\n-import org.mbassy.IPublicationErrorHandler;\n-import org.mbassy.MBassador;\n-import org.mbassy.listener.MessageHandlerMetadata;\n-\n-import java.lang.reflect.Method;\n-import java.util.Collection;\n-\n-/**\n-* Created with IntelliJ IDEA.\n-* @author bennidi\n-* Date: 11/14/12\n-* Time: 3:49 PM\n-* To change this template use File | Settings | File Templates.\n-*/\n-public class UnfilteredSynchronousSubscription extends UnfilteredSubscription{\n-\n-    public UnfilteredSynchronousSubscription(IMessageBus mBassador, MessageHandlerMetadata messageHandler) {\n-        super(mBassador, messageHandler);\n-    }\n-\n-    protected void dispatch(final Object message, final Object listener){\n-        invokeHandler(message, listener);\n-    }\n-}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/AllTests.java",
            "additions": 19,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,19 @@\n+package org.mbassy;\n+\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Suite;\n+\n+/**\n+ * Test suite for running all available unit tests\n+ *\n+ * @author bennidi\n+ *         Date: 11/23/12\n+ */\n+@RunWith(Suite.class)\n+@Suite.SuiteClasses({\n+        ConcurrentSetTest.class,\n+        MBassadorTest.class,\n+        FilterTest.class\n+})\n+public class AllTests {\n+}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/ConcurrentSetTest.java",
            "additions": 95,
            "deletions": 65
        },
        "diff content": "@@ -9,13 +9,17 @@ import java.util.LinkedList;\n import java.util.Random;\n \n /**\n- * Created with IntelliJ IDEA.\n+ * This test ensures the correct behaviour of the set implementation that is the building\n+ * block of the subscription implementations used by the Mbassador message bus.\n+ *\n+ * It should behave exactly like other set implementations do and as such all tests are based\n+ * on comparing the outcome of sequence of operations applied to a standard set implementation\n+ * and the concurrent set.\n+ *\n  * @author bennidi\n- * Date: 11/12/12\n- * Time: 3:02 PM\n- * To change this template use File | Settings | File Templates.\n+ *         Date: 11/12/12\n  */\n-public class ConcurrentSetTest extends  UnitTest{\n+public class ConcurrentSetTest extends UnitTest {\n \n     private int numberOfElements = 100000;\n \n@@ -23,27 +27,27 @@ public class ConcurrentSetTest extends  UnitTest{\n \n \n     @Test\n-    public void testIterator(){\n-        final HashSet<Object> distinct = new HashSet<Object>();\n-\n-        final ConcurrentSet<Object> target = new ConcurrentSet<Object>();\n+    public void testIteratorCleanup() {\n+        final HashSet<Object> persistingCandidates = new HashSet<Object>();\n+        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n         Random rand = new Random();\n \n-        for(int i=0;i < numberOfElements ; i++){\n+        for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n \n-            if(rand.nextInt() % 3 == 0){\n-                distinct.add(candidate);\n+            if (rand.nextInt() % 3 == 0) {\n+                persistingCandidates.add(candidate);\n             }\n-            target.add(candidate);\n+            testSet.add(candidate);\n         }\n \n+        // this will remove all objects that have not been inserted into the set of persisting candidates\n         runGC();\n \n         ConcurrentExecutor.runConcurrent(new Runnable() {\n             @Override\n             public void run() {\n-                for(Object src : target){\n+                for (Object testObject : testSet) {\n                     // do nothing\n                     // just iterate to trigger automatic clean up\n                     System.currentTimeMillis();\n@@ -51,139 +55,165 @@ public class ConcurrentSetTest extends  UnitTest{\n             }\n         }, numberOfThreads);\n \n-\n-\n-\n-        for(Object tar : target){\n-            Assert.assertTrue(distinct.contains(tar));\n+        assertEquals(persistingCandidates.size(), testSet.size());\n+        for (Object test : testSet) {\n+            assertTrue(persistingCandidates.contains(test));\n         }\n \n \n-\n     }\n \n \n-        @Test\n-    public void testInsert(){\n+    @Test\n+    public void testUniqueness() {\n         final LinkedList<Object> duplicates = new LinkedList<Object>();\n         final HashSet<Object> distinct = new HashSet<Object>();\n \n-        final ConcurrentSet<Object> target = new ConcurrentSet<Object>();\n+        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n         Random rand = new Random();\n \n+        // build set of distinct objects and list of duplicates\n         Object candidate = new Object();\n-        for(int i=0;i < numberOfElements ; i++){\n-            if(rand.nextInt() % 3 == 0){\n+        for (int i = 0; i < numberOfElements; i++) {\n+            if (rand.nextInt() % 3 == 0) {\n                 candidate = new Object();\n             }\n             duplicates.add(candidate);\n             distinct.add(candidate);\n         }\n \n-\n+        // insert all elements (containing duplicates) into the set\n         ConcurrentExecutor.runConcurrent(new Runnable() {\n             @Override\n             public void run() {\n-                for(Object src : duplicates){\n-                    target.add(src);\n+                for (Object src : duplicates) {\n+                    testSet.add(src);\n                 }\n             }\n         }, numberOfThreads);\n \n-        pause(3000);\n+        // check that the control set and the test set contain the exact same elements\n+        assertEquals(distinct.size(), testSet.size());\n+        for (Object uniqueObject : distinct) {\n+            assertTrue(testSet.contains(uniqueObject));\n+        }\n+\n \n+    }\n \n-        for(Object tar : target){\n-            Assert.assertTrue(distinct.contains(tar));\n+    @Test\n+    public void testPerformance(){\n+        final HashSet<Object> source = new HashSet<Object>();\n+\n+        final HashSet<Object> hashSet = new HashSet<Object>();\n+\n+        final ConcurrentSet<Object> concurrentSet = new ConcurrentSet<Object>();\n+\n+        for (int i = 0; i < 1000000; i++) {\n+            source.add(new Object());\n         }\n \n-        for(Object src : distinct){\n-            Assert.assertTrue(target.contains(src));\n+\n+        long start = System.currentTimeMillis();\n+        for(Object o: source){\n+            hashSet.add(o);\n         }\n+        long duration = System.currentTimeMillis() - start;\n+        System.out.println(\"Performance of HashSet for 1.000.000 object insertions \" + duration);\n \n-        Assert.assertEquals(distinct.size(), target.size());\n+        start = System.currentTimeMillis();\n+        for(Object o: source){\n+            concurrentSet.add(o);\n+        }\n+        duration = System.currentTimeMillis() - start;\n+        System.out.println(\"Performance of ConcurrentSet for 1.000.000 object insertions \" + duration);\n     }\n \n \n-\n     @Test\n-    public void testRemove1(){\n+    public void testRemove2() {\n         final HashSet<Object> source = new HashSet<Object>();\n         final HashSet<Object> toRemove = new HashSet<Object>();\n \n-        final ConcurrentSet<Object> target = new ConcurrentSet<Object>();\n-        for(int i=0;i < numberOfElements ; i++){\n+        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n+        // build set of distinct objects and mark a subset of those for removal\n+        for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n             source.add(candidate);\n-            if(i % 3 == 0){\n+            if (i % 3 == 0) {\n                 toRemove.add(candidate);\n             }\n         }\n \n-\n+        // build the test set from the set of candidates\n         ConcurrentExecutor.runConcurrent(new Runnable() {\n             @Override\n             public void run() {\n-                for(Object src : source){\n-                    target.add(src);\n+                for (Object src : source) {\n+                    testSet.add(src);\n                 }\n             }\n         }, numberOfThreads);\n \n+        // remove all candidates that have previously been marked for removal from the test set\n         ConcurrentExecutor.runConcurrent(new Runnable() {\n             @Override\n             public void run() {\n-                for(Object src : toRemove){\n-                    target.remove(src);\n+                for (Object src : toRemove) {\n+                    testSet.remove(src);\n                 }\n             }\n         }, numberOfThreads);\n \n-        pause(3000);\n-\n-        for(Object tar : target){\n+        // ensure that the test set does not contain any of the elements that have been removed from it\n+        for (Object tar : testSet) {\n             Assert.assertTrue(!toRemove.contains(tar));\n         }\n-\n-        for(Object src : source){\n-            if(!toRemove.contains(src))Assert.assertTrue(target.contains(src));\n+        // ensure that the test set still contains all objects from the source set that have not been marked\n+        // for removal\n+        assertEquals(source.size() - toRemove.size(), testSet.size());\n+        for (Object src : source) {\n+            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n         }\n     }\n \n     @Test\n-    public void testRemove2(){\n+    public void testRemoval() {\n         final HashSet<Object> source = new HashSet<Object>();\n         final HashSet<Object> toRemove = new HashSet<Object>();\n \n-        final ConcurrentSet<Object> target = new ConcurrentSet<Object>();\n-        for(int i=0;i < numberOfElements ; i++){\n+        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n+        // build set of candidates and mark subset for removal\n+        for (int i = 0; i < numberOfElements; i++) {\n             Object candidate = new Object();\n             source.add(candidate);\n-            if(i % 3 == 0){\n+            if (i % 3 == 0) {\n                 toRemove.add(candidate);\n             }\n         }\n \n-\n+        // build test set by adding the candidates\n+        // and subsequently removing those marked for removal\n         ConcurrentExecutor.runConcurrent(new Runnable() {\n             @Override\n             public void run() {\n-                for(Object src : source){\n-                    target.add(src);\n-                    if(toRemove.contains(src))\n-                        target.remove(src);\n+                for (Object src : source) {\n+                    testSet.add(src);\n+                    if (toRemove.contains(src))\n+                        testSet.remove(src);\n                 }\n             }\n         }, numberOfThreads);\n \n-        pause(3000);\n-\n-        for(Object tar : target){\n+        // ensure that the test set does not contain any of the elements that have been removed from it\n+        for (Object tar : testSet) {\n             Assert.assertTrue(!toRemove.contains(tar));\n         }\n-\n-        for(Object src : source){\n-            if(!toRemove.contains(src))Assert.assertTrue(target.contains(src));\n+        // ensure that the test set still contains all objects from the source set that have not been marked\n+        // for removal\n+        assertEquals(source.size() - toRemove.size(), testSet.size());\n+        for (Object src : source) {\n+            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n         }\n     }\n \n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/FilterTest.java",
            "additions": 57,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,57 @@\n+package org.mbassy;\n+\n+import org.junit.Test;\n+import org.mbassy.events.SubTestEvent;\n+import org.mbassy.events.TestEvent;\n+import org.mbassy.listener.Filter;\n+import org.mbassy.listener.IMessageFilter;\n+import org.mbassy.listener.Listener;\n+import org.mbassy.listeners.*;\n+\n+import java.util.List;\n+\n+/**\n+ * Testing of filter functionality\n+ *\n+ * @author bennidi\n+ *         Date: 11/26/12\n+ */\n+public class FilterTest extends UnitTest{\n+\n+    @Test\n+    public void testSubclassFilter() throws Exception {\n+\n+        MBassador bus = new MBassador();\n+        ListenerFactory listenerFactory = new ListenerFactory()\n+                .create(100, FilteredMessageListener.class)\n+                .create(100, Object.class)\n+                .create(100, NonListeningBean.class);\n+\n+        List<Object> listeners = listenerFactory.build();\n+\n+        // this will subscribe the listeners concurrently to the bus\n+        TestUtil.setup(bus, listeners, 10);\n+\n+        TestEvent event = new TestEvent();\n+        TestEvent subTestEvent = new SubTestEvent();\n+\n+        bus.post(event).now();\n+        bus.post(subTestEvent).now();\n+\n+        assertEquals(100, event.counter.get());\n+        assertEquals(0, subTestEvent.counter.get());\n+\n+    }\n+\n+\n+    public static class FilteredMessageListener{\n+\n+        @Listener(filters = {@Filter(IMessageFilter.DontAllowSubtypes.class)})\n+        public void handleTestEvent(TestEvent event){\n+            event.counter.incrementAndGet();\n+        }\n+\n+\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/MBassadorTest.java",
            "additions": 101,
            "deletions": 60
        },
        "diff content": "@@ -4,8 +4,11 @@ import org.junit.Test;\n import org.mbassy.events.SubTestEvent;\n import org.mbassy.events.TestEvent;\n import org.mbassy.listeners.*;\n+import org.mbassy.subscription.Subscription;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n import java.util.List;\n import java.util.concurrent.CopyOnWriteArrayList;\n \n@@ -17,27 +20,62 @@ import java.util.concurrent.CopyOnWriteArrayList;\n  */\n public class MBassadorTest extends UnitTest {\n \n-\n+    // this is a single threaded test for subscribing and unsubscribing of a single listener\n     @Test\n     public void testSubscribeSimple() throws InterruptedException {\n-\n         MBassador bus = new MBassador();\n+        List<Object> listeners = new LinkedList<Object>();\n         int listenerCount = 1000;\n \n+        // subscribe a number of listeners to the bus\n         for (int i = 1; i <= listenerCount; i++) {\n             EventingTestBean listener = new EventingTestBean();\n             NonListeningBean nonListener = new NonListeningBean();\n+            listeners.add(listener);\n+\n             bus.subscribe(listener);\n             bus.subscribe(nonListener);\n-            assertTrue(bus.unsubscribe(listener));\n-            assertFalse(bus.unsubscribe(nonListener));\n+\n+            assertFalse(bus.unsubscribe(nonListener)); // these are not expected to be subscribed listeners\n             assertFalse(bus.unsubscribe(new EventingTestBean()));\n \n         }\n+\n+        // check the generated subscriptions for existence of all previously subscribed valid listeners\n+        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n+        assertEquals(1, testEventsubscriptions.size());\n+        assertEquals(listenerCount, getNumberOfSubscribedListeners(testEventsubscriptions));\n+\n+        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n+        assertEquals(3, subTestEventsubscriptions.size());\n+        assertEquals(3 * listenerCount, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n+\n+        // unsubscribe the listeners\n+        for(Object listener : listeners){\n+            assertTrue(bus.unsubscribe(listener)); // this listener is expected to exist\n+        }\n+\n+        // no listener should be left\n+        testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n+        assertEquals(1, testEventsubscriptions.size());\n+        assertEquals(0, getNumberOfSubscribedListeners(testEventsubscriptions));\n+\n+        subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n+        assertEquals(3, subTestEventsubscriptions.size());\n+        assertEquals(0, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n+\n+    }\n+\n+    private int getNumberOfSubscribedListeners(Collection<Subscription> subscriptions) {\n+        int listeners = 0;\n+        for (Subscription sub : subscriptions) {\n+            listeners += sub.size();\n+        }\n+        return listeners;\n     }\n \n     @Test\n-    public void testSubscribeConcurrent() throws Exception {\n+    public void testConcurrentSubscription() throws Exception {\n \n         MBassador bus = new MBassador();\n         ListenerFactory listenerFactory = new ListenerFactory()\n@@ -48,34 +86,37 @@ public class MBassadorTest extends UnitTest {\n                 .create(100, NonListeningBean.class);\n \n         List<Object> listeners = listenerFactory.build();\n-        TestUtil.setup(bus, listeners, 10);\n \n-        TestEvent event = new TestEvent();\n-        SubTestEvent subEvent = new SubTestEvent();\n-\n-        bus.publish(event);\n-        bus.publish(subEvent);\n+        // this will subscribe the listeners concurrently to the bus\n+        TestUtil.setup(bus, listeners, 10);\n \n-        pause(4000);\n+        // check the generated subscriptions for existence of all previously subscribed valid listeners\n+        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n+        assertEquals(3, testEventsubscriptions.size());\n+        assertEquals(300, getNumberOfSubscribedListeners(testEventsubscriptions));\n \n-        assertEquals(300, event.counter.get());\n-        assertEquals(700, subEvent.counter.get());\n+        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n+        assertEquals(10, subTestEventsubscriptions.size());\n+        assertEquals(1000, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n \n     }\n \n \n     @Test\n-    public void testAsynchronous() throws InterruptedException {\n+    public void testAsynchronousMessagePublication() throws Exception {\n \n         MBassador bus = new MBassador();\n-        int listenerCount = 1000;\n-        List<EventingTestBean> persistentReferences = new ArrayList();\n+        ListenerFactory listenerFactory = new ListenerFactory()\n+                .create(100, EventingTestBean.class)\n+                .create(100, EventingTestBean2.class)\n+                .create(100, EventingTestBean3.class)\n+                .create(100, Object.class)\n+                .create(100, NonListeningBean.class);\n \n-        for (int i = 1; i <= listenerCount; i++) {\n-            EventingTestBean bean = new EventingTestBean();\n-            persistentReferences.add(bean);\n-            bus.subscribe(bean);\n-        }\n+        List<Object> listeners = listenerFactory.build();\n+\n+        // this will subscribe the listeners concurrently to the bus\n+        TestUtil.setup(bus, listeners, 10);\n \n         TestEvent event = new TestEvent();\n         TestEvent subEvent = new SubTestEvent();\n@@ -85,64 +126,64 @@ public class MBassadorTest extends UnitTest {\n \n         pause(2000);\n \n-        assertTrue(event.counter.get() == 1000);\n-        assertTrue(subEvent.counter.get() == 1000 * 2);\n+        assertEquals(300, event.counter.get());\n+        assertEquals(700, subEvent.counter.get());\n \n     }\n \n     @Test\n-    public void testSynchronous() throws InterruptedException {\n+    public void testSynchronousMessagePublication() throws Exception {\n \n         MBassador bus = new MBassador();\n-        int listenerCount = 10;\n-        List<EventingTestBean> persistentReferences = new ArrayList();\n-        for (int i = 1; i <= listenerCount; i++) {\n-\n-\n-            EventingTestBean bean = new EventingTestBean();\n-            persistentReferences.add(bean);\n-            bus.subscribe(bean);\n+        ListenerFactory listenerFactory = new ListenerFactory()\n+                .create(100, EventingTestBean.class)\n+                .create(100, EventingTestBean2.class)\n+                .create(100, EventingTestBean3.class)\n+                .create(100, Object.class)\n+                .create(100, NonListeningBean.class);\n \n-            TestEvent event = new TestEvent();\n-            TestEvent subEvent = new SubTestEvent();\n+        List<Object> listeners = listenerFactory.build();\n \n-            bus.publish(event);\n-            bus.publish(subEvent);\n+        // this will subscribe the listeners concurrently to the bus\n+        TestUtil.setup(bus, listeners, 10);\n \n-            assertEquals(i, event.counter.get());\n+        TestEvent event = new TestEvent();\n+        TestEvent subEvent = new SubTestEvent();\n \n-            pause(50);\n+        bus.publish(event);\n+        bus.publish(subEvent);\n \n-            assertEquals(i * 2, subEvent.counter.get());\n+        pause(2000);\n \n-        }\n+        assertEquals(300, event.counter.get());\n+        assertEquals(700, subEvent.counter.get());\n \n     }\n \n     @Test\n-    public void testConcurrentPublication() {\n-        final MBassador bus = new MBassador();\n-        final int listenerCount = 100;\n-        final int concurrency = 20;\n+    public void testConcurrentMixedMessagePublication() throws Exception {\n         final CopyOnWriteArrayList<TestEvent> testEvents = new CopyOnWriteArrayList<TestEvent>();\n         final CopyOnWriteArrayList<SubTestEvent> subtestEvents = new CopyOnWriteArrayList<SubTestEvent>();\n-        final CopyOnWriteArrayList<EventingTestBean> persistentReferences = new CopyOnWriteArrayList<EventingTestBean>();\n+        final int eventLoopsPerTHread = 100;\n \n-        ConcurrentExecutor.runConcurrent(new Runnable() {\n-            @Override\n-            public void run() {\n-                for (int i = 0; i < listenerCount; i++) {\n-                    EventingTestBean bean = new EventingTestBean();\n-                    persistentReferences.add(bean);\n-                    bus.subscribe(bean);\n-                }\n-            }\n-        }, concurrency);\n+\n+        final MBassador bus = new MBassador();\n+        ListenerFactory listenerFactory = new ListenerFactory()\n+                .create(100, EventingTestBean.class)\n+                .create(100, EventingTestBean2.class)\n+                .create(100, EventingTestBean3.class)\n+                .create(100, Object.class)\n+                .create(100, NonListeningBean.class);\n+\n+        List<Object> listeners = listenerFactory.build();\n+\n+        // this will subscribe the listeners concurrently to the bus\n+        TestUtil.setup(bus, listeners, 10);\n \n         ConcurrentExecutor.runConcurrent(new Runnable() {\n             @Override\n             public void run() {\n-                for (int i = 0; i < listenerCount; i++) {\n+                for (int i = 0; i < eventLoopsPerTHread; i++) {\n                     TestEvent event = new TestEvent();\n                     SubTestEvent subEvent = new SubTestEvent();\n                     testEvents.add(event);\n@@ -152,16 +193,16 @@ public class MBassadorTest extends UnitTest {\n                     bus.publish(subEvent);\n                 }\n             }\n-        }, concurrency);\n+        }, 10);\n \n         pause(3000);\n \n         for (TestEvent event : testEvents) {\n-            assertEquals(listenerCount * concurrency, event.counter.get());\n+            assertEquals(300, event.counter.get());\n         }\n \n         for (SubTestEvent event : subtestEvents) {\n-            assertEquals(listenerCount * concurrency * 2, event.counter.get());\n+            assertEquals(700, event.counter.get());\n         }\n \n     }\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/listeners/EventingTestBean.java",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -3,8 +3,8 @@ package org.mbassy.listeners;\n import org.mbassy.events.SubTestEvent;\n import org.mbassy.events.TestEvent;\n import org.mbassy.listener.Filter;\n+import org.mbassy.listener.IMessageFilter;\n import org.mbassy.listener.Listener;\n-import org.mbassy.listener.MessageFilter;\n import org.mbassy.listener.Mode;\n \n /**\n@@ -33,7 +33,7 @@ public class EventingTestBean {\n     @Listener(\n             priority = 10,\n             dispatch = Mode.Synchronous,\n-            filters = {@Filter(MessageFilter.None.class), @Filter(MessageFilter.All.class)})\n+            filters = {@Filter(IMessageFilter.None.class), @Filter(IMessageFilter.All.class)})\n     public void handleFiltered(SubTestEvent event) {\n         event.counter.incrementAndGet();\n     }\n"
    },
    {
        "commit hash": "89f44544bd9d68c94c5fc84dcef167cb33b25df5",
        "previous commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/listeners/NonListeningBean.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -7,7 +7,7 @@ import org.mbassy.listener.Mode;\n \n /**\n  * This bean overrides all the handlers defined in its superclass. Since it does not specify any annotations\n- * it should be considered a message lister\n+ * it should not be considered a message listener\n  *\n  * @author bennidi\n  * Date: 11/22/12\n"
    },
    {
        "commit hash": "2718a4afb2535679b63f212b8e65f17b3f22c04f",
        "previous commit hash": "bb4997d4989503d58d25f183dcdfb8b41fea8e8c",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -50,6 +50,7 @@ sending messages to your listeners using one of Mbassador's publication methods\n <h2>Usage</h2>\n \n Listener definition (in any bean):\n+\n         // every event of type TestEvent or any subtype will be delivered\n         // to this handler\n         @Listener\n"
    },
    {
        "commit hash": "bb4997d4989503d58d25f183dcdfb8b41fea8e8c",
        "previous commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.1.RC/mbassador-1.0.1.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/maven/org/mbassy/mbassador/1.0.1.RC/mbassador-1.0.1.RC.jar differ\n"
    },
    {
        "commit hash": "bb4997d4989503d58d25f183dcdfb8b41fea8e8c",
        "previous commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.1.RC/mbassador-1.0.1.RC.jar.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+933328ff6220f5910770b9b5f13f2eeb\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "bb4997d4989503d58d25f183dcdfb8b41fea8e8c",
        "previous commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.1.RC/mbassador-1.0.1.RC.jar.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+003aa85106cfbab5ce618ffd1a6fe36cd0e37b71\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "bb4997d4989503d58d25f183dcdfb8b41fea8e8c",
        "previous commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.1.RC/mbassador-1.0.1.RC.pom",
            "additions": 58,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,58 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.mbassy</groupId>\n+    <artifactId>mbassador</artifactId>\n+    <version>1.0.1.RC</version>\n+    <packaging>jar</packaging>\n+    <name>mbassador</name>\n+    <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n+    </description>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.build.java.version>1.6</project.build.java.version>\n+        <github.url>file://${project.basedir}/maven</github.url>\n+    </properties>\n+\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.10</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+    </dependencies>\n+\n+    <distributionManagement>\n+        <repository>\n+            <id>mbassador-github-repo</id>\n+            <url>${github.url}</url>\n+        </repository>\n+    </distributionManagement>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>${project.build.java.version}</source>\n+                    <target>${project.build.java.version}</target>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <skipTests>false</skipTests>\n+                </configuration>\n+            </plugin>\n+\n+        </plugins>\n+    </build>\n+</project>\n"
    },
    {
        "commit hash": "bb4997d4989503d58d25f183dcdfb8b41fea8e8c",
        "previous commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.1.RC/mbassador-1.0.1.RC.pom.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+5959d236fd411d499f3b46ecedc28a84\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "bb4997d4989503d58d25f183dcdfb8b41fea8e8c",
        "previous commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.1.RC/mbassador-1.0.1.RC.pom.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+5203632e409974a234ff8ce0ea88c5897a8cbffe\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "bb4997d4989503d58d25f183dcdfb8b41fea8e8c",
        "previous commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -6,7 +6,8 @@\n   <versioning>\n     <versions>\n       <version>1.0.0.RC</version>\n+      <version>1.0.1.RC</version>\n     </versions>\n-    <lastUpdated>20121119145820</lastUpdated>\n+    <lastUpdated>20121122134301</lastUpdated>\n   </versioning>\n </metadata>\n"
    },
    {
        "commit hash": "bb4997d4989503d58d25f183dcdfb8b41fea8e8c",
        "previous commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.md5",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-006f75456dc73e47019a2b8befeeac1d\n\\ No newline at end of file\n+75a92cb9aba8b1ce38c7a5ed28de4c7f\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "bb4997d4989503d58d25f183dcdfb8b41fea8e8c",
        "previous commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.sha1",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-0396418ec7c57ea6a92a0b9c7c741883464f2261\n\\ No newline at end of file\n+727a1ce27e63eac58e45150930755a8bcf582aef\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "README.md",
            "additions": 4,
            "deletions": 0
        },
        "diff content": "@@ -4,10 +4,14 @@ Mbassador\n Mbassador is a very light-weight message (event) bus implementation following the publish subscribe pattern. It is designed\n for ease of use and aims to be feature rich, extensible while preserving resource efficiency and performance.\n \n+It uses a specialized data structure to allow high throughput for concurrent access.\n+\n Read this documentation to get an overview of its features and how cool this message (event) bus actually is.\n You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n which also contains a partial list of the features of the compared implementations.\n \n+The current version is 1.0.1.RC\n+\n Table of contents:\n + [Features](#features)\n + [Usage](#usage)\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -4,7 +4,7 @@\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>org.mbassy</groupId>\n     <artifactId>mbassador</artifactId>\n-    <version>1.0.0.RC</version>\n+    <version>1.0.1.RC</version>\n     <packaging>jar</packaging>\n     <name>mbassador</name>\n     <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/AbstractMessageBus.java",
            "additions": 22,
            "deletions": 26
        },
        "diff content": "@@ -12,23 +12,18 @@ import java.lang.reflect.Method;\n import java.util.*;\n import java.util.concurrent.*;\n \n-\n+/**\n+ * The base class for all message bus implementations.\n+ *\n+ * @param <T>\n+ * @param <P>\n+ */\n public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n \n-\n-    //  This predicate is used to find all message listeners (methods annotated with @Listener)\n-    private static final IPredicate<Method> AllMessageListeners = new IPredicate<Method>() {\n-        @Override\n-        public boolean apply(Method target) {\n-            return target.getAnnotation(Listener.class) != null;\n-        }\n-    };\n-\n-\n-\n     // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n     private ExecutorService executor;\n \n+    // the metadata reader that is used to parse objects passed to the subscribe method\n     private MetadataReader metadataReader = new MetadataReader();\n \n     // all subscriptions per message type\n@@ -64,7 +59,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n                 public void run() {\n                     while (true) {\n                         try {\n-                           pendingMessages.take().execute();\n+                            pendingMessages.take().execute();\n                         } catch (InterruptedException e) {\n                             handlePublicationError(new PublicationError(e, \"Asynchronous publication interrupted\", null, null, null));\n                             return;\n@@ -95,20 +90,23 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n \n     protected abstract SubscriptionFactory getSubscriptionFactory();\n \n-    protected void initialize(){}\n+    protected void initialize() {\n+    }\n \n     @Override\n     public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n         return Collections.unmodifiableCollection(errorHandlers);\n     }\n \n-    public void unsubscribe(Object listener) {\n-        if (listener == null) return;\n+    public boolean unsubscribe(Object listener) {\n+        if (listener == null) return false;\n         Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n-        if (subscriptions == null) return;\n+        if (subscriptions == null) return false;\n+        boolean isRemoved = false;\n         for (Subscription subscription : subscriptions) {\n-            subscription.unsubscribe(listener);\n+            isRemoved = isRemoved || subscription.unsubscribe(listener);\n         }\n+        return isRemoved;\n     }\n \n \n@@ -122,7 +120,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n                 synchronized (this) { // new subscriptions must be processed sequentially for each class\n                     subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                     if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n-                        List<Method> messageHandlers = getListeners(listeningClass);  // get all methods with subscriptions\n+                        List<Method> messageHandlers = metadataReader.getListeners(listeningClass);  // get all methods with subscriptions\n                         subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                         if (messageHandlers.isEmpty()) {  // remember the class as non listening class\n                             nonListeners.add(listeningClass);\n@@ -143,7 +141,9 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n                 }\n             }\n             // register the listener to the existing subscriptions\n-            for (Subscription sub : subscriptionsByListener) sub.subscribe(listener);\n+            for (Subscription sub : subscriptionsByListener){\n+                sub.subscribe(listener);\n+            }\n         } catch (Exception e) {\n             throw new RuntimeException(e);\n         }\n@@ -209,16 +209,12 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         return listener.getParameterTypes()[0];\n     }\n \n-    // get all listeners defined by the given class (includes\n-    // listeners defined in super classes)\n-    private static List<Method> getListeners(Class<?> target) {\n-        return ReflectionUtils.getMethods(AllMessageListeners, target);\n-    }\n \n \n     public void handlePublicationError(PublicationError error) {\n-        for (IPublicationErrorHandler errorHandler : errorHandlers)\n+        for (IPublicationErrorHandler errorHandler : errorHandlers){\n             errorHandler.handleError(error);\n+        }\n     }\n \n     @Override\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/IMessageBus.java",
            "additions": 3,
            "deletions": 1
        },
        "diff content": "@@ -62,8 +62,10 @@ public interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n      * will not have any effect.\n      *\n      * @param listener\n+     * @return  true, if the listener was found and successfully removed\n+     *          false otherwise\n      */\n-    public void unsubscribe(Object listener);\n+    public boolean unsubscribe(Object listener);\n \n     /**\n      *\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/IPublicationErrorHandler.java",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -3,9 +3,8 @@ package org.mbassy;\n /**\n  * TODO. Insert class description here\n  * <p/>\n- * User: benni\n+ * @author bennidi\n  * Date: 2/22/12\n- * Time: 5:03 PM\n  */\n public interface IPublicationErrorHandler {\n \n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/PublicationError.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -6,7 +6,7 @@ import java.lang.reflect.Method;\n  * Publication errors are created when object publication fails for some reason and contain details\n  * as to the cause and location where they occured.\n  * <p/>\n- * User: benni\n+ * @author bennidi\n  * Date: 2/22/12\n  * Time: 4:59 PM\n  */\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/SimplePostCommand.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -2,7 +2,7 @@ package org.mbassy;\n \n /**\n * Created with IntelliJ IDEA.\n-* User: benni\n+* @author bennidi\n * Date: 11/12/12\n * Time: 8:44 PM\n * To change this template use File | Settings | File Templates.\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/common/ConcurrentSet.java",
            "additions": 4,
            "deletions": 4
        },
        "diff content": "@@ -66,11 +66,11 @@ public class ConcurrentSet<T> implements Iterable<T> {\n         return this;\n     }\n \n-    public ConcurrentSet<T> remove(T element) {\n-        if (!entries.containsKey(element)) return this;\n+    public boolean remove(T element) {\n+        if (!entries.containsKey(element)) return false;\n         synchronized (this) {\n             Entry<T> listelement = entries.get(element);\n-            if(listelement == null)return this;\n+            if(listelement == null)return false;\n             if (listelement != head) {\n                 listelement.remove();\n             } else {\n@@ -78,7 +78,7 @@ public class ConcurrentSet<T> implements Iterable<T> {\n             }\n             entries.remove(element);\n         }\n-        return this;\n+        return true;\n     }\n \n     public Iterator<T> iterator() {\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/common/IPredicate.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -2,7 +2,7 @@ package org.mbassy.common;\n \n /**\n  * Created with IntelliJ IDEA.\n- * User: benni\n+ * @author bennidi\n  * Date: 10/22/12\n  * Time: 9:33 AM\n  * To change this template use File | Settings | File Templates.\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/common/ReflectionUtils.java",
            "additions": 70,
            "deletions": 49
        },
        "diff content": "@@ -1,64 +1,85 @@\n package org.mbassy.common;\n \n-import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n+import java.util.Arrays;\n import java.util.LinkedList;\n import java.util.List;\n \n /**\n- * User: benni\n- * Date: 2/16/12\n- * Time: 12:14 PM\n+ * @author bennidi\n+ *         Date: 2/16/12\n+ *         Time: 12:14 PM\n  */\n public class ReflectionUtils {\n \n-\tpublic static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n-\t\tList<Method> methods = new LinkedList<Method>();\n-\t\ttry {\n-\t\t\tfor (Method method : target.getDeclaredMethods()) {\n-\t\t\t\tif (condition.apply(method)) {\n-\t\t\t\t\tmethods.add(method);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\t//nop\n-\t\t}\n-\t\tif (!target.equals(Object.class)) {\n-\t\t\tmethods.addAll(getMethods(condition, target.getSuperclass()));\n-\t\t}\n-\t\treturn methods;\n-\t}\n+    public static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n+        List<Method> methods = new LinkedList<Method>();\n+        try {\n+            for (Method method : target.getDeclaredMethods()) {\n+                if (condition.apply(method)) {\n+                    methods.add(method);\n+                }\n+            }\n+        } catch (Exception e) {\n+            //nop\n+        }\n+        if (!target.equals(Object.class)) {\n+            methods.addAll(getMethods(condition, target.getSuperclass()));\n+        }\n+        return methods;\n+    }\n \n-\tpublic static List<Field> getFields(IPredicate<Field> condition, Class<?> target) {\n-\t\tList<Field> methods = new LinkedList<Field>();\n-\t\ttry {\n-\t\t\tfor (Field method : target.getDeclaredFields()) {\n-\t\t\t\tif (condition.apply(method)) {\n-\t\t\t\t\tmethods.add(method);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\t//nop\n-\t\t}\n-\t\tif (!target.equals(Object.class)) {\n-\t\t\tmethods.addAll(getFields(condition, target.getSuperclass()));\n-\t\t}\n-\t\treturn methods;\n-\t}\n+    public static Method getOverridingMethod(Method overridingMethod, Class subclass) {\n+        Class current = subclass;\n+        while(!current.equals(overridingMethod.getDeclaringClass())){\n+            try {\n+                Method overridden = current.getDeclaredMethod(overridingMethod.getName(), overridingMethod.getParameterTypes());\n+                return overridden;\n+            } catch (NoSuchMethodException e) {\n+                current = current.getSuperclass();\n+            }\n+        }\n+        return null;\n+    }\n \n-\tpublic static Object callMethod(Object o, final String methodName, Object... args) {\n+    public static List<Method> withoutOverridenSuperclassMethods(List<Method> allMethods) {\n+        List<Method> filtered = new LinkedList<Method>();\n+        for (Method method : allMethods) {\n+            if (!containsOverridingMethod(allMethods, method)) filtered.add(method);\n+        }\n+        return filtered;\n+    }\n \n-\t\tif(o == null || methodName == null) {\n-\t\t\treturn null;\n-\t\t}\n+    public static boolean containsOverridingMethod(List<Method> allMethods, Method methodToCheck) {\n+        for (Method method : allMethods) {\n+            if (isOverriddenBy(methodToCheck, method)) return true;\n+        }\n+        return false;\n+    }\n+\n+    private static boolean isOverriddenBy(Method superclassMethod, Method subclassMethod) {\n+        // if the declaring classes are the same or the subclass method is not defined in the subbclass\n+        // hierarchy of the given superclass method or the method names are not the same then\n+        // subclassMethod does not override superclassMethod\n+        if (superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass())\n+                || !superclassMethod.getDeclaringClass().isAssignableFrom(subclassMethod.getDeclaringClass())\n+                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n+            return false;\n+        }\n+\n+        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n+        Class[] subClassMethodParameters = superclassMethod.getParameterTypes();\n+        // method must specify the same number of parameters\n+        if(subClassMethodParameters.length != subClassMethodParameters.length){\n+            return false;\n+        }\n+        //the parameters must occur in the exact same order\n+        for(int i = 0 ; i< subClassMethodParameters.length; i++){\n+           if(!superClassMethodParameters[i].equals(subClassMethodParameters[i])){\n+               return false;\n+           }\n+        }\n+        return true;\n+    }\n \n-\t\tObject res = null;\n-\t\ttry {\n-\t\t\tMethod m = o.getClass().getMethod(methodName);\n-\t\t\tres = m.invoke(o, args);\n-\t\t} catch (Exception e) {\n-\t\t\t//logger.warn(\"Not possible to get value\", e);\n-\t\t}\n-\t\treturn res;\n-\t}\n }\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/Listener.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -5,7 +5,7 @@ import java.lang.annotation.*;\n /**\n  * TODO. Insert class description here\n  * <p/>\n- * User: benni\n+ * @author bennidi\n  * Date: 2/8/12\n  * Time: 3:35 PM\n  */\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MessageFilter.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -4,7 +4,7 @@ package org.mbassy.listener;\n  * Object filters can be used to prevent certain messages to be delivered to a specific listener.\n  * If a filter is used the message will only be delivered if it passes the filter(s)\n  *\n- * User: benni\n+ * @author bennidi\n  * Date: 2/8/12\n  */\n public interface MessageFilter {\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MessageHandlerMetadata.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -7,7 +7,7 @@ import org.mbassy.listener.MessageFilter;\n import java.lang.reflect.Method;\n \n /**\n- * User: benni\n+ * @author bennidi\n  * Date: 11/14/12\n  */\n public class MessageHandlerMetadata {\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MetadataReader.java",
            "additions": 43,
            "deletions": 1
        },
        "diff content": "@@ -1,18 +1,32 @@\n package org.mbassy.listener;\n \n+import org.mbassy.common.IPredicate;\n+import org.mbassy.common.ReflectionUtils;\n+\n+import java.lang.annotation.Annotation;\n import java.lang.reflect.Method;\n import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n import java.util.Map;\n \n /**\n  * Created with IntelliJ IDEA.\n- * User: benni\n+ * @author bennidi\n  * Date: 11/16/12\n  * Time: 10:22 AM\n  * To change this template use File | Settings | File Templates.\n  */\n public class MetadataReader {\n \n+    //  This predicate is used to find all message listeners (methods annotated with @Listener)\n+    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n+        @Override\n+        public boolean apply(Method target) {\n+            return target.getAnnotation(Listener.class) != null;\n+        }\n+    };\n+\n     // cache already created filter instances\n     private final Map<Class<? extends MessageFilter>, MessageFilter> filterCache = new HashMap<Class<? extends MessageFilter>, MessageFilter>();\n \n@@ -40,4 +54,32 @@ public class MetadataReader {\n         MessageFilter[] filter = getFilter(config);\n         return new MessageHandlerMetadata(messageHandler, filter, config);\n     }\n+\n+    // get all listeners defined by the given class (includes\n+    // listeners defined in super classes)\n+    public List<Method> getListeners(Class<?> target) {\n+        List<Method> allMethods = ReflectionUtils.getMethods(AllMessageHandlers, target);\n+        List<Method>  handlers = new LinkedList<Method>();\n+        for(Method listener : allMethods){\n+            Method overriddenHandler = ReflectionUtils.getOverridingMethod(listener, target);\n+\n+            if(overriddenHandler != null && isHandler(overriddenHandler)){\n+                handlers.add(overriddenHandler);\n+            }\n+            if(overriddenHandler == null){\n+                handlers.add(listener);\n+            }\n+        }\n+        return ReflectionUtils.withoutOverridenSuperclassMethods(handlers);\n+    }\n+\n+    private static boolean isHandler(Method m){\n+        Annotation[] annotations  = m.getDeclaredAnnotations();\n+        for(Annotation annotation : annotations){\n+            if(annotation.equals(Listener.class))return true;\n+        }\n+        return false;\n+\n+    }\n+\n }\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/Mode.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -2,7 +2,7 @@ package org.mbassy.listener;\n \n /**\n * Created with IntelliJ IDEA.\n-* User: benni\n+* @author bennidi\n * Date: 11/16/12\n * Time: 10:01 AM\n * To change this template use File | Settings | File Templates.\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/FilteredAsynchronousSubscription.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -10,7 +10,7 @@ import java.util.Collection;\n \n /**\n * Created with IntelliJ IDEA.\n-* User: benni\n+* @author bennidi\n * Date: 11/14/12\n * Time: 3:50 PM\n * To change this template use File | Settings | File Templates.\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/FilteredSubscription.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -12,7 +12,7 @@ import java.util.Iterator;\n \n /**\n * Created with IntelliJ IDEA.\n-* User: benni\n+* @author bennidi\n * Date: 11/14/12\n * Time: 3:48 PM\n * To change this template use File | Settings | File Templates.\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/FilteredSynchronousSubscription.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -10,7 +10,7 @@ import java.util.Collection;\n \n /**\n * Created with IntelliJ IDEA.\n-* User: benni\n+* @author bennidi\n * Date: 11/14/12\n * Time: 3:49 PM\n * To change this template use File | Settings | File Templates.\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/Subscription.java",
            "additions": 6,
            "deletions": 3
        },
        "diff content": "@@ -10,12 +10,15 @@ import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.util.Collection;\n import java.util.Comparator;\n+import java.util.UUID;\n \n /**\n  * Subscription is a thread safe container for objects that contain message handlers\n  */\n public abstract class Subscription {\n \n+    private UUID id = UUID.randomUUID();\n+\n     private final Method handler;\n \n     protected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n@@ -88,8 +91,8 @@ public abstract class Subscription {\n     }\n \n \n-    public void unsubscribe(Object existingListener) {\n-        listeners.remove(existingListener);\n+    public boolean unsubscribe(Object existingListener) {\n+        return listeners.remove(existingListener);\n     }\n \n \n@@ -97,7 +100,7 @@ public abstract class Subscription {\n         @Override\n         public int compare(Subscription o1, Subscription o2) {\n             int result =  o1.getPriority() - o2.getPriority();\n-            return result == 0 ? o1.handler.hashCode() - o2.handler.hashCode() : result;\n+            return result == 0 ? o1.id.compareTo(o2.id): result;\n         }\n     };\n \n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/SubscriptionDeliveryRequest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -4,7 +4,7 @@ import java.util.Collection;\n import java.util.LinkedList;\n \n /**\n- * User: benni\n+ * @author bennidi\n  * Date: 11/16/12\n  */\n public class SubscriptionDeliveryRequest<T> {\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/SubscriptionFactory.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -8,7 +8,7 @@ import java.util.Collection;\n \n /**\n  * Created with IntelliJ IDEA.\n- * User: benni\n+ * @author bennidi\n  * Date: 11/16/12\n  * Time: 10:39 AM\n  * To change this template use File | Settings | File Templates.\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/UnfilteredAsynchronousSubscription.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -10,7 +10,7 @@ import java.util.Collection;\n \n /**\n * Created with IntelliJ IDEA.\n-* User: benni\n+* @author bennidi\n * Date: 11/14/12\n * Time: 3:48 PM\n * To change this template use File | Settings | File Templates.\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/UnfilteredSubscription.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -11,7 +11,7 @@ import java.util.Iterator;\n \n /**\n * Created with IntelliJ IDEA.\n-* User: benni\n+* @author bennidi\n * Date: 11/14/12\n * Time: 3:45 PM\n * To change this template use File | Settings | File Templates.\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/UnfilteredSynchronousSubscription.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -10,7 +10,7 @@ import java.util.Collection;\n \n /**\n * Created with IntelliJ IDEA.\n-* User: benni\n+* @author bennidi\n * Date: 11/14/12\n * Time: 3:49 PM\n * To change this template use File | Settings | File Templates.\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/ConcurrentSetTest.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -10,7 +10,7 @@ import java.util.Random;\n \n /**\n  * Created with IntelliJ IDEA.\n- * User: benni\n+ * @author bennidi\n  * Date: 11/12/12\n  * Time: 3:02 PM\n  * To change this template use File | Settings | File Templates.\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/MBassadorTest.java",
            "additions": 85,
            "deletions": 126
        },
        "diff content": "@@ -1,141 +1,147 @@\n package org.mbassy;\n \n-import org.junit.Assert;\n import org.junit.Test;\n-import org.mbassy.listener.Filter;\n-import org.mbassy.listener.Listener;\n-import org.mbassy.listener.MessageFilter;\n-import org.mbassy.listener.Mode;\n+import org.mbassy.events.SubTestEvent;\n+import org.mbassy.events.TestEvent;\n+import org.mbassy.listeners.*;\n \n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n  * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n  *\n  * @author bennidi\n- * Date: 2/8/12\n+ *         Date: 2/8/12\n  */\n-public class MBassadorTest {\n-\n+public class MBassadorTest extends UnitTest {\n \n \n     @Test\n-    public void testSubscribe() throws InterruptedException {\n+    public void testSubscribeSimple() throws InterruptedException {\n \n         MBassador bus = new MBassador();\n         int listenerCount = 1000;\n \n         for (int i = 1; i <= listenerCount; i++) {\n-            EventingTestBean bean = new EventingTestBean();\n-            bus.subscribe(bean);\n-            bus.unsubscribe(new EventingTestBean());\n+            EventingTestBean listener = new EventingTestBean();\n+            NonListeningBean nonListener = new NonListeningBean();\n+            bus.subscribe(listener);\n+            bus.subscribe(nonListener);\n+            assertTrue(bus.unsubscribe(listener));\n+            assertFalse(bus.unsubscribe(nonListener));\n+            assertFalse(bus.unsubscribe(new EventingTestBean()));\n \n         }\n     }\n \n     @Test\n-    public void testUnSubscribe() throws InterruptedException {\n+    public void testSubscribeConcurrent() throws Exception {\n \n         MBassador bus = new MBassador();\n-        int listenerCount = 1000;\n+        ListenerFactory listenerFactory = new ListenerFactory()\n+                .create(100, EventingTestBean.class)\n+                .create(100, EventingTestBean2.class)\n+                .create(100, EventingTestBean3.class)\n+                .create(100, Object.class)\n+                .create(100, NonListeningBean.class);\n \n-        for (int i = 1; i <= listenerCount; i++) {\n-            bus.unsubscribe(new EventingTestBean());\n+        List<Object> listeners = listenerFactory.build();\n+        TestUtil.setup(bus, listeners, 10);\n+\n+        TestEvent event = new TestEvent();\n+        SubTestEvent subEvent = new SubTestEvent();\n+\n+        bus.publish(event);\n+        bus.publish(subEvent);\n+\n+        pause(4000);\n+\n+        assertEquals(300, event.counter.get());\n+        assertEquals(700, subEvent.counter.get());\n \n-        }\n     }\n \n \n-\t@Test\n-\tpublic void testAsynchronous() throws InterruptedException {\n+    @Test\n+    public void testAsynchronous() throws InterruptedException {\n \n-\t\tMBassador bus = new MBassador();\n-\t\tint listenerCount = 1000;\n-\t\tList<EventingTestBean> persistentReferences = new ArrayList();\n+        MBassador bus = new MBassador();\n+        int listenerCount = 1000;\n+        List<EventingTestBean> persistentReferences = new ArrayList();\n \n         for (int i = 1; i <= listenerCount; i++) {\n-\t\t\tEventingTestBean bean = new EventingTestBean();\n-\t\t\tpersistentReferences.add(bean);\n-\t\t\tbus.subscribe(bean);\n-\t\t}\n+            EventingTestBean bean = new EventingTestBean();\n+            persistentReferences.add(bean);\n+            bus.subscribe(bean);\n+        }\n \n-\t\tTestEvent event = new TestEvent();\n-\t\tTestEvent subEvent = new SubTestEvent();\n+        TestEvent event = new TestEvent();\n+        TestEvent subEvent = new SubTestEvent();\n \n-\t\tbus.publishAsync(event);\n-\t\tbus.publishAsync(subEvent);\n+        bus.publishAsync(event);\n+        bus.publishAsync(subEvent);\n \n-\t\tThread.sleep(2000);\n+        pause(2000);\n \n-\t\tAssert.assertTrue(event.counter.get() == 1000);\n-\t\tAssert.assertTrue(subEvent.counter.get() == 1000 * 2);\n+        assertTrue(event.counter.get() == 1000);\n+        assertTrue(subEvent.counter.get() == 1000 * 2);\n \n-\t}\n+    }\n \n     @Test\n-\tpublic void testSynchronous() throws InterruptedException {\n+    public void testSynchronous() throws InterruptedException {\n \n-\t\tMBassador bus = new MBassador();\n-\t\tint listenerCount = 100;\n-\t\tList<EventingTestBean> persistentReferences = new ArrayList();\n-\t\tfor (int i = 1; i <= listenerCount; i++) {\n+        MBassador bus = new MBassador();\n+        int listenerCount = 10;\n+        List<EventingTestBean> persistentReferences = new ArrayList();\n+        for (int i = 1; i <= listenerCount; i++) {\n \n \n-\t\t\tEventingTestBean bean = new EventingTestBean();\n-\t\t\tpersistentReferences.add(bean);\n-\t\t\tbus.subscribe(bean);\n+            EventingTestBean bean = new EventingTestBean();\n+            persistentReferences.add(bean);\n+            bus.subscribe(bean);\n \n-\t\t\tTestEvent event = new TestEvent();\n-\t\t\tTestEvent subEvent = new SubTestEvent();\n+            TestEvent event = new TestEvent();\n+            TestEvent subEvent = new SubTestEvent();\n \n-\t\t\tbus.publish(event);\n-\t\t\tbus.publish(subEvent);\n+            bus.publish(event);\n+            bus.publish(subEvent);\n \n-            Assert.assertEquals(i, event.counter.get());\n+            assertEquals(i, event.counter.get());\n \n-            try {\n-                Thread.sleep(10);\n-            } catch (InterruptedException e) {\n-                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n-            }\n+            pause(50);\n \n-\t\t\tAssert.assertEquals(i * 2, subEvent.counter.get());\n+            assertEquals(i * 2, subEvent.counter.get());\n \n-\t\t}\n+        }\n \n-\t}\n+    }\n \n     @Test\n-\tpublic void testConcurrentPublication() {\n+    public void testConcurrentPublication() {\n         final MBassador bus = new MBassador();\n         final int listenerCount = 100;\n-        final int concurenny = 20;\n+        final int concurrency = 20;\n         final CopyOnWriteArrayList<TestEvent> testEvents = new CopyOnWriteArrayList<TestEvent>();\n         final CopyOnWriteArrayList<SubTestEvent> subtestEvents = new CopyOnWriteArrayList<SubTestEvent>();\n         final CopyOnWriteArrayList<EventingTestBean> persistentReferences = new CopyOnWriteArrayList<EventingTestBean>();\n \n-\t\tConcurrentExecutor.runConcurrent(new Runnable() {\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tlong start = System.currentTimeMillis();\n-\t\t\t\tfor (int i = 0; i < listenerCount; i++) {\n-\t\t\t\t\tEventingTestBean bean = new EventingTestBean();\n-\t\t\t\t\tpersistentReferences.add(bean);\n+        ConcurrentExecutor.runConcurrent(new Runnable() {\n+            @Override\n+            public void run() {\n+                for (int i = 0; i < listenerCount; i++) {\n+                    EventingTestBean bean = new EventingTestBean();\n+                    persistentReferences.add(bean);\n                     bus.subscribe(bean);\n-\t\t\t\t}\n-\n-\t\t\t\tlong end = System.currentTimeMillis();\n-\t\t\t\tSystem.out.println(\"MBassador: Creating \" + listenerCount + \" listeners took \" + (end - start) + \" ms\");\n-\t\t\t}\n-\t\t}, concurenny);\n+                }\n+            }\n+        }, concurrency);\n \n         ConcurrentExecutor.runConcurrent(new Runnable() {\n             @Override\n             public void run() {\n-                long start = System.currentTimeMillis();\n                 for (int i = 0; i < listenerCount; i++) {\n                     TestEvent event = new TestEvent();\n                     SubTestEvent subEvent = new SubTestEvent();\n@@ -145,67 +151,20 @@ public class MBassadorTest {\n                     bus.publishAsync(event);\n                     bus.publish(subEvent);\n                 }\n-\n-                long end = System.currentTimeMillis();\n-                System.out.println(\"MBassador: Publishing \" + 2 * listenerCount + \" events took \" + (end - start) + \" ms\");\n             }\n-        }, concurenny);\n-\n-        try {\n-            Thread.sleep(3000);\n-        } catch (InterruptedException e) {\n-            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n-        }\n+        }, concurrency);\n \n-        for(TestEvent event : testEvents){\n-            Assert.assertEquals(listenerCount * concurenny, event.counter.get());\n-        }\n+        pause(3000);\n \n-        for(SubTestEvent event : subtestEvents){\n-            Assert.assertEquals(listenerCount * concurenny * 2, event.counter.get());\n+        for (TestEvent event : testEvents) {\n+            assertEquals(listenerCount * concurrency, event.counter.get());\n         }\n \n-\t}\n-\n-\n-\tpublic static class TestEvent {\n-\n-\t\tpublic AtomicInteger counter = new AtomicInteger();\n-\n-\t}\n-\n-\tpublic static class SubTestEvent extends TestEvent {\n-\n-\t}\n-\n-\n-\tpublic class EventingTestBean {\n-\n-        // every event of type TestEvent or any subtype will be delivered\n-        // to this listener\n-\t\t@Listener\n-\t\tpublic void handleTestEvent(TestEvent event) {\n-\t\t\tevent.counter.incrementAndGet();\n-\t\t}\n-\n-        // this handler will be invoked asynchronously\n-\t\t@Listener(priority = 0, dispatch = Mode.Asynchronous)\n-\t\tpublic void handleSubTestEvent(SubTestEvent event) {\n-            event.counter.incrementAndGet();\n-\t\t}\n-\n-        // this handler will receive events of type SubTestEvent\n-        // or any subtabe and that passes the given filter\n-        @Listener(\n-                priority = 10,\n-                dispatch = Mode.Synchronous,\n-                filters = {@Filter(MessageFilter.None.class),@Filter(MessageFilter.All.class)})\n-        public void handleFiltered(SubTestEvent event) {\n-            event.counter.incrementAndGet();\n+        for (SubTestEvent event : subtestEvents) {\n+            assertEquals(listenerCount * concurrency * 2, event.counter.get());\n         }\n \n-\n-\t}\n+    }\n \n \n }\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/TestUtil.java",
            "additions": 46,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,46 @@\n+package org.mbassy;\n+\n+import java.util.List;\n+\n+/**\n+ * Todo: Add javadoc\n+ *\n+ * @author bennidi\n+ *         Date: 11/22/12\n+ */\n+public class TestUtil {\n+\n+    public static void setup(final IMessageBus bus, final List<Object> listeners, int numberOfThreads) {\n+        Runnable[] setupUnits = new Runnable[numberOfThreads];\n+        int partitionSize;\n+        if(listeners.size() >= numberOfThreads){\n+          partitionSize =  (int)Math.floor(listeners.size() / numberOfThreads);\n+        }\n+        else{\n+            partitionSize = 1;\n+            numberOfThreads = listeners.size();\n+        }\n+\n+        for(int i = 0; i < numberOfThreads; i++){\n+            final int partitionStart = i * partitionSize;\n+            final int partitionEnd = (i+1 < numberOfThreads)\n+                    ? partitionStart + partitionSize + 1\n+                    : listeners.size();\n+            setupUnits[i] = new Runnable() {\n+\n+                private List<Object> listenerSubset = listeners.subList(partitionStart, partitionEnd);\n+\n+                public void run() {\n+                   for(Object listener : listenerSubset){\n+                       bus.subscribe(listener);\n+                   }\n+                }\n+            };\n+\n+        }\n+\n+        ConcurrentExecutor.runConcurrent(setupUnits);\n+\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/UnitTest.java",
            "additions": 39,
            "deletions": 1
        },
        "diff content": "@@ -1,10 +1,12 @@\n package org.mbassy;\n \n+import org.junit.Assert;\n+\n import java.lang.ref.WeakReference;\n \n /**\n  * Created with IntelliJ IDEA.\n- * User: benni\n+ * @author bennidi\n  * Date: 11/12/12\n  * Time: 3:16 PM\n  * To change this template use File | Settings | File Templates.\n@@ -31,4 +33,40 @@ public class UnitTest {\n             System.gc();\n         }\n     }\n+\n+    public void fail(String message) {\n+        Assert.fail(message);\n+    }\n+\n+    public void fail() {\n+        Assert.fail();\n+    }\n+\n+    public void assertTrue(Boolean condition) {\n+        Assert.assertTrue(condition);\n+    }\n+\n+    public void assertTrue(String message, Boolean condition) {\n+        Assert.assertTrue(message, condition);\n+    }\n+\n+    public void assertFalse(Boolean condition) {\n+        Assert.assertFalse(condition);\n+    }\n+\n+    public void assertNull(Object object) {\n+        Assert.assertNull(object);\n+    }\n+\n+    public void assertNotNull(Object object) {\n+        Assert.assertNotNull(object);\n+    }\n+\n+    public void assertFalse(String message, Boolean condition) {\n+        Assert.assertFalse(message, condition);\n+    }\n+\n+    public void assertEquals(Object expected, Object actual) {\n+        Assert.assertEquals(expected, actual);\n+    }\n }\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/events/SubTestEvent.java",
            "additions": 10,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,10 @@\n+package org.mbassy.events;\n+\n+/**\n+ *\n+ * @author bennidi\n+ *         Date: 11/22/12\n+ */\n+public class SubTestEvent extends TestEvent {\n+\n+}\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/events/TestEvent.java",
            "additions": 15,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,15 @@\n+package org.mbassy.events;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ *\n+ *\n+* @author bennidi\n+* Date: 11/22/12\n+*/\n+public class TestEvent {\n+\n+    public AtomicInteger counter = new AtomicInteger();\n+\n+}\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/listeners/EventingTestBean.java",
            "additions": 42,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,42 @@\n+package org.mbassy.listeners;\n+\n+import org.mbassy.events.SubTestEvent;\n+import org.mbassy.events.TestEvent;\n+import org.mbassy.listener.Filter;\n+import org.mbassy.listener.Listener;\n+import org.mbassy.listener.MessageFilter;\n+import org.mbassy.listener.Mode;\n+\n+/**\n+ * Basic bean that defines some event handlers to be used for different unit testting scenarios\n+ *\n+ * @author bennidi\n+ * Date: 11/22/12\n+ */\n+public class EventingTestBean {\n+\n+    // every event of type TestEvent or any subtype will be delivered\n+    // to this listener\n+    @Listener\n+    public void handleTestEvent(TestEvent event) {\n+        event.counter.incrementAndGet();\n+    }\n+\n+    // this handler will be invoked asynchronously\n+    @Listener(priority = 0, dispatch = Mode.Asynchronous)\n+    public void handleSubTestEvent(SubTestEvent event) {\n+        event.counter.incrementAndGet();\n+    }\n+\n+    // this handler will receive events of type SubTestEvent\n+    // or any subtabe and that passes the given filter\n+    @Listener(\n+            priority = 10,\n+            dispatch = Mode.Synchronous,\n+            filters = {@Filter(MessageFilter.None.class), @Filter(MessageFilter.All.class)})\n+    public void handleFiltered(SubTestEvent event) {\n+        event.counter.incrementAndGet();\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/listeners/EventingTestBean2.java",
            "additions": 18,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,18 @@\n+package org.mbassy.listeners;\n+\n+import org.mbassy.events.SubTestEvent;\n+import org.mbassy.listener.Listener;\n+import org.mbassy.listener.Mode;\n+\n+/**\n+ * @author bennidi\n+ * Date: 11/22/12\n+ */\n+public class EventingTestBean2 extends EventingTestBean{\n+\n+    // redefine the configuration for this handler\n+    @Listener(dispatch = Mode.Synchronous)\n+    public void handleSubTestEvent(SubTestEvent event) {\n+        super.handleSubTestEvent(event);\n+    }\n+}\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/listeners/EventingTestBean3.java",
            "additions": 20,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,20 @@\n+package org.mbassy.listeners;\n+\n+import org.mbassy.events.SubTestEvent;\n+import org.mbassy.listener.Listener;\n+import org.mbassy.listener.Mode;\n+\n+/**\n+ * @author bennidi\n+ * Date: 11/22/12\n+ */\n+public class EventingTestBean3 extends EventingTestBean2{\n+\n+\n+    // this handler will be invoked asynchronously\n+    @Listener(priority = 0, dispatch = Mode.Synchronous)\n+    public void handleSubTestEventAgain(SubTestEvent event) {\n+        event.counter.incrementAndGet();\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/listeners/ListenerFactory.java",
            "additions": 39,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,39 @@\n+package org.mbassy.listeners;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * This factory will create a list of beans according to some specified configuration.\n+ * It can be used to setup different test scenarios.\n+ *\n+ * @author bennidi\n+ *         Date: 11/22/12\n+ */\n+public class ListenerFactory {\n+\n+    private Map<Class, Integer> requiredBeans = new HashMap<Class, Integer>();\n+\n+\n+\n+    public ListenerFactory create(int numberOfInstance, Class clazz){\n+        requiredBeans.put(clazz, numberOfInstance);\n+        return this;\n+    }\n+\n+\n+    public List<Object> build() throws Exception{\n+        List<Object> beans = new LinkedList<Object>();\n+        for(Class clazz : requiredBeans.keySet()){\n+            int numberOfRequiredBeans = requiredBeans.get(clazz);\n+            for(int i = 0; i < numberOfRequiredBeans; i++){\n+                beans.add(clazz.newInstance());\n+            }\n+        }\n+        return beans;\n+    }\n+\n+\n+}\n"
    },
    {
        "commit hash": "989ed67285d81de444ebc40630c5ccb78125c7ed",
        "previous commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/listeners/NonListeningBean.java",
            "additions": 32,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,32 @@\n+package org.mbassy.listeners;\n+\n+import org.mbassy.events.SubTestEvent;\n+import org.mbassy.events.TestEvent;\n+import org.mbassy.listener.Listener;\n+import org.mbassy.listener.Mode;\n+\n+/**\n+ * This bean overrides all the handlers defined in its superclass. Since it does not specify any annotations\n+ * it should be considered a message lister\n+ *\n+ * @author bennidi\n+ * Date: 11/22/12\n+ */\n+public class NonListeningBean extends EventingTestBean{\n+\n+\n+    @Override\n+    public void handleTestEvent(TestEvent event) {\n+        event.counter.incrementAndGet();   // should never be called\n+    }\n+\n+    @Override\n+    public void handleSubTestEvent(SubTestEvent event) {\n+        event.counter.incrementAndGet();   // should never be called\n+    }\n+\n+    @Override\n+    public void handleFiltered(SubTestEvent event) {\n+        event.counter.incrementAndGet();   // should never be called\n+    }\n+}\n"
    },
    {
        "commit hash": "271a445a97ae4773086e17612eadbd1fc90446c2",
        "previous commit hash": "15fe30711ecb6094ebd8dd4be6b69b43292d9bd4",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -120,7 +120,7 @@ Of course you can always clone the repository and build from source\n <h2>Roadmap</h2>\n + Checkout MBassador from one of the official maven repositories (as soon as the user base is big enough)\n + Spring integration with support for conditional message dispatch in transactional context (dispatch only after\n-successful commit etc.). Currently in beta, see <a href=\"https://github.com/bennidi/mbassador-spring>this</a> repository\n+successful commit etc.). Currently in beta, see <a href=\"https://github.com/bennidi/mbassador-spring\">this</a> repository\n + MessageEnvelope for each dispatch that is passed to the handler and can be used for communication between handlers\n during the running dispatch\n \n"
    },
    {
        "commit hash": "15fe30711ecb6094ebd8dd4be6b69b43292d9bd4",
        "previous commit hash": "9969f2b160dd51e15d83ecadf3713409cae45015",
        "diff stats": {
            "file_path": "README.md",
            "additions": 3,
            "deletions": 3
        },
        "diff content": "@@ -1,12 +1,12 @@\n Mbassador\n =========\n \n-Mbassador is a very light-weight message bus (event bus) implementation following the publish subscribe pattern. It is designed\n+Mbassador is a very light-weight message (event) bus implementation following the publish subscribe pattern. It is designed\n for ease of use and aims to be feature rich, extensible while preserving resource efficiency and performance.\n \n-Read this documentation to get an overview of its features and how cool this event bus actually is.\n+Read this documentation to get an overview of its features and how cool this message (event) bus actually is.\n You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n-which also reviews part of the features of the compared implementations.\n+which also contains a partial list of the features of the compared implementations.\n \n Table of contents:\n + [Features](#features)\n"
    },
    {
        "commit hash": "9969f2b160dd51e15d83ecadf3713409cae45015",
        "previous commit hash": "77fe2c7f296ef1dfc864eed92156ea29343d0cdd",
        "diff stats": {
            "file_path": "README.md",
            "additions": 10,
            "deletions": 3
        },
        "diff content": "@@ -14,12 +14,13 @@ Table of contents:\n + [Installation](#installation)\n + [Roadmap](#roadmap)\n + [Credits](#credits)\n++ [Contribute](#contribute)\n + [License](#license)\n \n \n <h2 name=\"features\">Features</h2>\n \n-At its core it offers the following:\n+At its core MBassador offers the following features:\n \n + <em><strong>Annotation driven</em></strong>: To define and customize a message handler simply mark it with @Listener annotation\n + <em><strong>Delivers everything</em></strong>: Messages must not implement any interface and can be of any type (-> message bus is typed using generics with upper\n@@ -117,9 +118,9 @@ will be done as soon as enough people use this component. Until then, the follow\n Of course you can always clone the repository and build from source\n \n <h2>Roadmap</h2>\n-+ Make MBassador available in one of the official maven repositories as soon as the user base is big enough\n++ Checkout MBassador from one of the official maven repositories (as soon as the user base is big enough)\n + Spring integration with support for conditional message dispatch in transactional context (dispatch only after\n-successful commit etc.) -> coming in december 2012\n+successful commit etc.). Currently in beta, see <a href=\"https://github.com/bennidi/mbassador-spring>this</a> repository\n + MessageEnvelope for each dispatch that is passed to the handler and can be used for communication between handlers\n during the running dispatch\n \n@@ -130,6 +131,10 @@ it did not provide all the features we needed in our project, I decided to creat\n it outperformed the Guava implementation by far, I decided to share it with the community to see if others consider it worth\n a shot.\n \n+<h2>Contribute</h2>\n+\n+Any feature requests and feedback are more than welcome. You may suggest improvements either by submitting an\n+issue or by forking the repo and creating a pull request. I will try to respond as quickly as possible.\n \n <h2>License</h2>\n \n@@ -138,3 +143,5 @@ This project is distributed under the terms of the MIT License. See file \"LICENS\n \n \n \n+\n+\n"
    },
    {
        "commit hash": "77fe2c7f296ef1dfc864eed92156ea29343d0cdd",
        "previous commit hash": "67b03aa9566612a89259c21a2ef3f0808feea6a9",
        "diff stats": {
            "file_path": "README.md",
            "additions": 3,
            "deletions": 2
        },
        "diff content": "@@ -127,8 +127,9 @@ during the running dispatch\n <h2>Credits</h2>\n The initial inspiration for creating this component came from looking at Google Guava's event bus implementation. Since\n it did not provide all the features we needed in our project, I decided to create my own implementation. When I saw that\n-it outperformed the Guava implementation by far, I decided to share it with the community (I was longing to give something\n-back to the community for quite a while).\n+it outperformed the Guava implementation by far, I decided to share it with the community to see if others consider it worth\n+a shot.\n+\n \n <h2>License</h2>\n \n"
    },
    {
        "commit hash": "67b03aa9566612a89259c21a2ef3f0808feea6a9",
        "previous commit hash": "20ce38440bf6ad12b81f047593edcbe06fd78e08",
        "diff stats": {
            "file_path": "README.md",
            "additions": 6,
            "deletions": 6
        },
        "diff content": "@@ -17,7 +17,7 @@ Table of contents:\n + [License](#license)\n \n \n-<h2 name=\"features\">Feature overview</h2>\n+<h2 name=\"features\">Features</h2>\n \n At its core it offers the following:\n \n@@ -42,7 +42,7 @@ sending messages to your listeners using one of Mbassador's publication methods\n \n \n \n-<h2 name=\"usage\">Usage</h2>\n+<h2>Usage</h2>\n \n Listener definition (in any bean):\n         // every event of type TestEvent or any subtype will be delivered\n@@ -89,7 +89,7 @@ Message publication:\n         bus.publish(subEvent);   // will return after each handler has been invoked\n         bus.post(subEvent).now(); // same as above\n \n-<h2 name=\"installation\">Installation</h2>\n+<h2>Installation</h2>\n This project contains a maven repository that will allow you to import MBassador as a dependency into your maven project.\n Currently this is all that will be provided because publishing to a central repository requires extra project setup that\n will be done as soon as enough people use this component. Until then, the following steps are necessary:\n@@ -116,7 +116,7 @@ will be done as soon as enough people use this component. Until then, the follow\n \n Of course you can always clone the repository and build from source\n \n-<h2 name=\"roadmap\">Feature Roadmap</h2>\n+<h2>Roadmap</h2>\n + Make MBassador available in one of the official maven repositories as soon as the user base is big enough\n + Spring integration with support for conditional message dispatch in transactional context (dispatch only after\n successful commit etc.) -> coming in december 2012\n@@ -124,13 +124,13 @@ successful commit etc.) -> coming in december 2012\n during the running dispatch\n \n \n-<h2 name=\"credits\">Credits</h2>\n+<h2>Credits</h2>\n The initial inspiration for creating this component came from looking at Google Guava's event bus implementation. Since\n it did not provide all the features we needed in our project, I decided to create my own implementation. When I saw that\n it outperformed the Guava implementation by far, I decided to share it with the community (I was longing to give something\n back to the community for quite a while).\n \n-<h2 name=\"license\">License</h2>\n+<h2>License</h2>\n \n This project is distributed under the terms of the MIT License. See file \"LICENSE\" for further reference.\n \n"
    },
    {
        "commit hash": "20ce38440bf6ad12b81f047593edcbe06fd78e08",
        "previous commit hash": "82fb04e90a5f5839e711cc432c8aa9b57e7ff1c7",
        "diff stats": {
            "file_path": "README.md",
            "additions": 24,
            "deletions": 7
        },
        "diff content": "@@ -4,13 +4,20 @@ Mbassador\n Mbassador is a very light-weight message bus (event bus) implementation following the publish subscribe pattern. It is designed\n for ease of use and aims to be feature rich, extensible while preserving resource efficiency and performance.\n \n-Table of contents\n+Read this documentation to get an overview of its features and how cool this event bus actually is.\n+You can also check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a>\n+which also reviews part of the features of the compared implementations.\n+\n+Table of contents:\n + [Features](#features)\n++ [Usage](#usage)\n++ [Installation](#installation)\n++ [Roadmap](#roadmap)\n++ [Credits](#credits)\n + [License](#license)\n \n-Check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a> which also reviews part of the features of the compared implementations\n \n- <h2 name=\"features\">Feature overview</h2>\n+<h2 name=\"features\">Feature overview</h2>\n \n At its core it offers the following:\n \n@@ -35,7 +42,7 @@ sending messages to your listeners using one of Mbassador's publication methods\n \n \n \n- <h2>Usage</h2>\n+<h2 name=\"usage\">Usage</h2>\n \n Listener definition (in any bean):\n         // every event of type TestEvent or any subtype will be delivered\n@@ -82,7 +89,7 @@ Message publication:\n         bus.publish(subEvent);   // will return after each handler has been invoked\n         bus.post(subEvent).now(); // same as above\n \n-<h2>Import using maven</h2>\n+<h2 name=\"installation\">Installation</h2>\n This project contains a maven repository that will allow you to import MBassador as a dependency into your maven project.\n Currently this is all that will be provided because publishing to a central repository requires extra project setup that\n will be done as soon as enough people use this component. Until then, the following steps are necessary:\n@@ -107,11 +114,21 @@ will be done as soon as enough people use this component. Until then, the follow\n     </pre></code>\n  3. Run mvn clean package to have maven download and install the required version into your local repository\n \n+Of course you can always clone the repository and build from source\n \n-<h2>Feature Roadmap</h2>\n-+ Make MBassador available in one of the official maven repositories\n+<h2 name=\"roadmap\">Feature Roadmap</h2>\n++ Make MBassador available in one of the official maven repositories as soon as the user base is big enough\n + Spring integration with support for conditional message dispatch in transactional context (dispatch only after\n successful commit etc.) -> coming in december 2012\n++ MessageEnvelope for each dispatch that is passed to the handler and can be used for communication between handlers\n+during the running dispatch\n+\n+\n+<h2 name=\"credits\">Credits</h2>\n+The initial inspiration for creating this component came from looking at Google Guava's event bus implementation. Since\n+it did not provide all the features we needed in our project, I decided to create my own implementation. When I saw that\n+it outperformed the Guava implementation by far, I decided to share it with the community (I was longing to give something\n+back to the community for quite a while).\n \n <h2 name=\"license\">License</h2>\n \n"
    },
    {
        "commit hash": "82fb04e90a5f5839e711cc432c8aa9b57e7ff1c7",
        "previous commit hash": "71bdeda364ece356698067308d8fa9cd24229964",
        "diff stats": {
            "file_path": "README.md",
            "additions": 7,
            "deletions": 3
        },
        "diff content": "@@ -5,10 +5,13 @@ Mbassador is a very light-weight message bus (event bus) implementation followin\n for ease of use and aims to be feature rich, extensible while preserving resource efficiency and performance.\n \n Table of contents\n-[License](#license)\n++ [Features](#features)\n++ [License](#license)\n \n Check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a> which also reviews part of the features of the compared implementations\n \n+ <h2 name=\"features\">Feature overview</h2>\n+\n At its core it offers the following:\n \n + <em><strong>Annotation driven</em></strong>: To define and customize a message handler simply mark it with @Listener annotation\n@@ -81,7 +84,8 @@ Message publication:\n \n <h2>Import using maven</h2>\n This project contains a maven repository that will allow you to import MBassador as a dependency into your maven project.\n-The following steps are necessary:\n+Currently this is all that will be provided because publishing to a central repository requires extra project setup that\n+will be done as soon as enough people use this component. Until then, the following steps are necessary:\n \n  1. Add the repository location to your pom.xml\n     <pre><code class=\"xml\">\n@@ -109,7 +113,7 @@ The following steps are necessary:\n + Spring integration with support for conditional message dispatch in transactional context (dispatch only after\n successful commit etc.) -> coming in december 2012\n \n-<h2><h name=\"license\">License</a></h2>\n+<h2 name=\"license\">License</h2>\n \n This project is distributed under the terms of the MIT License. See file \"LICENSE\" for further reference.\n \n"
    },
    {
        "commit hash": "71bdeda364ece356698067308d8fa9cd24229964",
        "previous commit hash": "2a19fd75b2e83176a829c2a532028a4adb001c8d",
        "diff stats": {
            "file_path": "README.md",
            "additions": 5,
            "deletions": 1
        },
        "diff content": "@@ -3,6 +3,10 @@ Mbassador\n \n Mbassador is a very light-weight message bus (event bus) implementation following the publish subscribe pattern. It is designed\n for ease of use and aims to be feature rich, extensible while preserving resource efficiency and performance.\n+\n+Table of contents\n+[License](#license)\n+\n Check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a> which also reviews part of the features of the compared implementations\n \n At its core it offers the following:\n@@ -105,7 +109,7 @@ The following steps are necessary:\n + Spring integration with support for conditional message dispatch in transactional context (dispatch only after\n successful commit etc.) -> coming in december 2012\n \n-<h2>License</h2>\n+<h2><h name=\"license\">License</a></h2>\n \n This project is distributed under the terms of the MIT License. See file \"LICENSE\" for further reference.\n \n"
    },
    {
        "commit hash": "2a19fd75b2e83176a829c2a532028a4adb001c8d",
        "previous commit hash": "b11ad6e600d5262e0c78f524062748acc50731cb",
        "diff stats": {
            "file_path": "README.md",
            "additions": 0,
            "deletions": 2
        },
        "diff content": "@@ -31,7 +31,6 @@ sending messages to your listeners using one of Mbassador's publication methods\n  <h2>Usage</h2>\n \n Listener definition (in any bean):\n-        <pre><code class=\"java\">\n         // every event of type TestEvent or any subtype will be delivered\n         // to this handler\n         @Listener\n@@ -53,7 +52,6 @@ Listener definition (in any bean):\n         public void handleFiltered(SubTestEvent event) {\n            //do something special here\n         }\n-        </pre></code>\n \n Creation of message bus and registration of listeners:\n \n"
    },
    {
        "commit hash": "b11ad6e600d5262e0c78f524062748acc50731cb",
        "previous commit hash": "b223a1b8b91a03deab1dad8aae9c209e9232f455",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 1
        },
        "diff content": "@@ -31,7 +31,7 @@ sending messages to your listeners using one of Mbassador's publication methods\n  <h2>Usage</h2>\n \n Listener definition (in any bean):\n-\n+        <pre><code class=\"java\">\n         // every event of type TestEvent or any subtype will be delivered\n         // to this handler\n         @Listener\n@@ -53,6 +53,7 @@ Listener definition (in any bean):\n         public void handleFiltered(SubTestEvent event) {\n            //do something special here\n         }\n+        </pre></code>\n \n Creation of message bus and registration of listeners:\n \n"
    },
    {
        "commit hash": "b223a1b8b91a03deab1dad8aae9c209e9232f455",
        "previous commit hash": "5d2be4a7db318523b7c7ebf604a5ee00d851288c",
        "diff stats": {
            "file_path": "README.md",
            "additions": 13,
            "deletions": 13
        },
        "diff content": "@@ -81,22 +81,22 @@ This project contains a maven repository that will allow you to import MBassador\n The following steps are necessary:\n \n  1. Add the repository location to your pom.xml\n-    ```xml\n-    <repositories>\n-        <repository>\n-            <id>mbassador-github-repo</id>\n-            <url>https://raw.github.com/bennidi/mbassador/master/maven</url>\n-        </repository>\n-    </repositories>\n-    ```\n+    <pre><code class=\"xml\">\n+    &lt;repositories&gt;\n+        &lt;repository&gt;\n+            &lt;id&gt;mbassador-github-repo&lt;/id&gt;\n+            &lt;url&gt;https://raw.github.com/bennidi/mbassador/master/maven &lt;/url&gt;\n+        &lt;/repository&gt;\n+    &lt;/repositories&gt;\n+    </pre></code>\n  2. Add the MBassador dependency to your pom.xml. You can check which versions are available by browsing\n     the git repository online.\n     <pre><code class=\"xml\">\n-        &ltdependency&gt\n-            &ltgroupId&gtorg.mbassy&lt/groupId&gt\n-            &ltartifactId&gtmbassador&lt/artifactId&gt\n-            &ltversion&gt1.0.0.RC&lt/version&gt\n-        &lt/dependency&gt\n+        &lt;dependency&gt;\n+            &lt;groupId&gt;org.mbassy&lt;/groupId&gt;\n+            &lt;artifactId&gt;mbassador&lt;/artifactId&gt;\n+            &lt;version&gt;1.0.0.RC&lt;/version&gt;\n+        &lt;/dependency&gt;\n     </pre></code>\n  3. Run mvn clean package to have maven download and install the required version into your local repository\n \n"
    },
    {
        "commit hash": "5d2be4a7db318523b7c7ebf604a5ee00d851288c",
        "previous commit hash": "a339f96cb7b7b64127b213ea443fc64d23807dc6",
        "diff stats": {
            "file_path": "README.md",
            "additions": 6,
            "deletions": 6
        },
        "diff content": "@@ -82,12 +82,12 @@ The following steps are necessary:\n \n  1. Add the repository location to your pom.xml\n     ```xml\n-        <repositories>\n-            <repository>\n-                <id>mbassador-github-repo</id>\n-                <url>https://raw.github.com/bennidi/mbassador/master/maven</url>\n-            </repository>\n-        </repositories>\n+    <repositories>\n+        <repository>\n+            <id>mbassador-github-repo</id>\n+            <url>https://raw.github.com/bennidi/mbassador/master/maven</url>\n+        </repository>\n+    </repositories>\n     ```\n  2. Add the MBassador dependency to your pom.xml. You can check which versions are available by browsing\n     the git repository online.\n"
    },
    {
        "commit hash": "a339f96cb7b7b64127b213ea443fc64d23807dc6",
        "previous commit hash": "b683a6336a1e2e8482209db98c8f3b3517e9d925",
        "diff stats": {
            "file_path": "README.md",
            "additions": 8,
            "deletions": 8
        },
        "diff content": "@@ -81,14 +81,14 @@ This project contains a maven repository that will allow you to import MBassador\n The following steps are necessary:\n \n  1. Add the repository location to your pom.xml\n-    <pre><code class=\"xml\">\n-        &lt;repositories&gt;\n-            &lt;repository&gt;\n-                &lt;id&gt;mbassador-github-repo&lt;/id&gt;\n-                &lt;url&gt;https://raw.github.com/bennidi/mbassador/master/maven&lt;/url&gt;\n-            &lt;/repository&gt;\n-        &lt;/repositories&gt;\n-    </pre></code>\n+    ```xml\n+        <repositories>\n+            <repository>\n+                <id>mbassador-github-repo</id>\n+                <url>https://raw.github.com/bennidi/mbassador/master/maven</url>\n+            </repository>\n+        </repositories>\n+    ```\n  2. Add the MBassador dependency to your pom.xml. You can check which versions are available by browsing\n     the git repository online.\n     <pre><code class=\"xml\">\n"
    },
    {
        "commit hash": "b683a6336a1e2e8482209db98c8f3b3517e9d925",
        "previous commit hash": "5510d515a7105853c6346c909a47f60a39f8f034",
        "diff stats": {
            "file_path": "README.md",
            "additions": 6,
            "deletions": 6
        },
        "diff content": "@@ -82,12 +82,12 @@ The following steps are necessary:\n \n  1. Add the repository location to your pom.xml\n     <pre><code class=\"xml\">\n-        <repositories>\n-            <repository>\n-                <id>mbassador-github-repo</id>\n-                <url>https://raw.github.com/bennidi/mbassador/master/maven</url>\n-            </repository>\n-        </repositories>\n+        &lt;repositories&gt;\n+            &lt;repository&gt;\n+                &lt;id&gt;mbassador-github-repo&lt;/id&gt;\n+                &lt;url&gt;https://raw.github.com/bennidi/mbassador/master/maven&lt;/url&gt;\n+            &lt;/repository&gt;\n+        &lt;/repositories&gt;\n     </pre></code>\n  2. Add the MBassador dependency to your pom.xml. You can check which versions are available by browsing\n     the git repository online.\n"
    },
    {
        "commit hash": "5510d515a7105853c6346c909a47f60a39f8f034",
        "previous commit hash": "438e378dd87b966665be1f10bfd5e171974141b8",
        "diff stats": {
            "file_path": "README.md",
            "additions": 7,
            "deletions": 7
        },
        "diff content": "@@ -81,13 +81,13 @@ This project contains a maven repository that will allow you to import MBassador\n The following steps are necessary:\n \n  1. Add the repository location to your pom.xml\n-    <pre><code>\n-        &ltrepositories&gt\n-            &ltrepository&gt\n-                &ltid&gtmbassador-github-repo&lt/id&gt\n-                &lturl&gthttps://raw.github.com/bennidi/mbassador/master/maven&lt/url&gt\n-            &lt/repository&gt\n-        &lt/repositories&gt\n+    <pre><code class=\"xml\">\n+        <repositories>\n+            <repository>\n+                <id>mbassador-github-repo</id>\n+                <url>https://raw.github.com/bennidi/mbassador/master/maven</url>\n+            </repository>\n+        </repositories>\n     </pre></code>\n  2. Add the MBassador dependency to your pom.xml. You can check which versions are available by browsing\n     the git repository online.\n"
    },
    {
        "commit hash": "438e378dd87b966665be1f10bfd5e171974141b8",
        "previous commit hash": "aa4edc04101ae77361fb9ea3d7aa0d7b973c8f39",
        "diff stats": {
            "file_path": "README.md",
            "additions": 4,
            "deletions": 2
        },
        "diff content": "@@ -81,21 +81,23 @@ This project contains a maven repository that will allow you to import MBassador\n The following steps are necessary:\n \n  1. Add the repository location to your pom.xml\n+    <pre><code>\n         &ltrepositories&gt\n             &ltrepository&gt\n                 &ltid&gtmbassador-github-repo&lt/id&gt\n                 &lturl&gthttps://raw.github.com/bennidi/mbassador/master/maven&lt/url&gt\n             &lt/repository&gt\n         &lt/repositories&gt\n-\n+    </pre></code>\n  2. Add the MBassador dependency to your pom.xml. You can check which versions are available by browsing\n     the git repository online.\n-\n+    <pre><code class=\"xml\">\n         &ltdependency&gt\n             &ltgroupId&gtorg.mbassy&lt/groupId&gt\n             &ltartifactId&gtmbassador&lt/artifactId&gt\n             &ltversion&gt1.0.0.RC&lt/version&gt\n         &lt/dependency&gt\n+    </pre></code>\n  3. Run mvn clean package to have maven download and install the required version into your local repository\n \n \n"
    },
    {
        "commit hash": "aa4edc04101ae77361fb9ea3d7aa0d7b973c8f39",
        "previous commit hash": "899125ee0933c3c816ca9cb98beab871b179da39",
        "diff stats": {
            "file_path": "README.md",
            "additions": 13,
            "deletions": 15
        },
        "diff content": "@@ -81,23 +81,21 @@ This project contains a maven repository that will allow you to import MBassador\n The following steps are necessary:\n \n  1. Add the repository location to your pom.xml\n-    <pre><code>\n-        <repositories>\n-            <repository>\n-                <id>mbassador-github-repo</id>\n-                <url>https://raw.github.com/bennidi/mbassador/master/maven</url>\n-            </repository>\n-        </repositories>\n-    </pre></code>\n+        &ltrepositories&gt\n+            &ltrepository&gt\n+                &ltid&gtmbassador-github-repo&lt/id&gt\n+                &lturl&gthttps://raw.github.com/bennidi/mbassador/master/maven&lt/url&gt\n+            &lt/repository&gt\n+        &lt/repositories&gt\n+\n  2. Add the MBassador dependency to your pom.xml. You can check which versions are available by browsing\n     the git repository online.\n-    <pre><code>\n-        <dependency>\n-            <groupId>org.mbassy</groupId>\n-            <artifactId>mbassador</artifactId>\n-            <version>1.0.0.RC</version>\n-        </dependency>\n-    </pre></code>\n+\n+        &ltdependency&gt\n+            &ltgroupId&gtorg.mbassy&lt/groupId&gt\n+            &ltartifactId&gtmbassador&lt/artifactId&gt\n+            &ltversion&gt1.0.0.RC&lt/version&gt\n+        &lt/dependency&gt\n  3. Run mvn clean package to have maven download and install the required version into your local repository\n \n \n"
    },
    {
        "commit hash": "899125ee0933c3c816ca9cb98beab871b179da39",
        "previous commit hash": "5b91a2d976915a0437913c0c5bcfe0d60024c722",
        "diff stats": {
            "file_path": "README.md",
            "additions": 15,
            "deletions": 15
        },
        "diff content": "@@ -81,23 +81,23 @@ This project contains a maven repository that will allow you to import MBassador\n The following steps are necessary:\n \n  1. Add the repository location to your pom.xml\n-\n-    <repositories>\n-        <repository>\n-            <id>mbassador-github-repo</id>\n-            <url>https://raw.github.com/bennidi/mbassador/master/maven</url>\n-        </repository>\n-    </repositories>\n-\n+    <pre><code>\n+        <repositories>\n+            <repository>\n+                <id>mbassador-github-repo</id>\n+                <url>https://raw.github.com/bennidi/mbassador/master/maven</url>\n+            </repository>\n+        </repositories>\n+    </pre></code>\n  2. Add the MBassador dependency to your pom.xml. You can check which versions are available by browsing\n     the git repository online.\n-\n-    <dependency>\n-        <groupId>org.mbassy</groupId>\n-        <artifactId>mbassador</artifactId>\n-        <version>1.0.0.RC</version>\n-    </dependency>\n-\n+    <pre><code>\n+        <dependency>\n+            <groupId>org.mbassy</groupId>\n+            <artifactId>mbassador</artifactId>\n+            <version>1.0.0.RC</version>\n+        </dependency>\n+    </pre></code>\n  3. Run mvn clean package to have maven download and install the required version into your local repository\n \n \n"
    },
    {
        "commit hash": "5b91a2d976915a0437913c0c5bcfe0d60024c722",
        "previous commit hash": "b3fa0642173516c5d7add7d929ab6351735ff46b",
        "diff stats": {
            "file_path": "README.md",
            "additions": 26,
            "deletions": 3
        },
        "diff content": "@@ -76,12 +76,35 @@ Message publication:\n         bus.publish(subEvent);   // will return after each handler has been invoked\n         bus.post(subEvent).now(); // same as above\n \n+<h2>Import using maven</h2>\n+This project contains a maven repository that will allow you to import MBassador as a dependency into your maven project.\n+The following steps are necessary:\n \n-<h2>Planned features</h2>\n+ 1. Add the repository location to your pom.xml\n \n-+ Maven dependency: Add Mbassador to your project using maven. Coming soon!\n+    <repositories>\n+        <repository>\n+            <id>mbassador-github-repo</id>\n+            <url>https://raw.github.com/bennidi/mbassador/master/maven</url>\n+        </repository>\n+    </repositories>\n+\n+ 2. Add the MBassador dependency to your pom.xml. You can check which versions are available by browsing\n+    the git repository online.\n+\n+    <dependency>\n+        <groupId>org.mbassy</groupId>\n+        <artifactId>mbassador</artifactId>\n+        <version>1.0.0.RC</version>\n+    </dependency>\n+\n+ 3. Run mvn clean package to have maven download and install the required version into your local repository\n+\n+\n+<h2>Feature Roadmap</h2>\n++ Make MBassador available in one of the official maven repositories\n + Spring integration with support for conditional message dispatch in transactional context (dispatch only after\n-successful commit etc.)\n+successful commit etc.) -> coming in december 2012\n \n <h2>License</h2>\n \n"
    },
    {
        "commit hash": "b3fa0642173516c5d7add7d929ab6351735ff46b",
        "previous commit hash": "201518d9f4e8943646bbf598afd0f64e2b1dfc02",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/AbstractMessageBus.java",
            "additions": 1,
            "deletions": 11
        },
        "diff content": "@@ -24,17 +24,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n         }\n     };\n \n-    // This is the default error handler it will simply log to standard out and\n-    // print stack trace if available\n-    protected static final class ConsoleLogger implements IPublicationErrorHandler {\n-        @Override\n-        public void handleError(PublicationError error) {\n-            System.out.println(error);\n-            if (error.getCause() != null) error.getCause().printStackTrace();\n-        }\n-    }\n \n-    ;\n \n     // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n     private ExecutorService executor;\n@@ -98,7 +88,7 @@ public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand>\n     public AbstractMessageBus(int dispatcherThreadCount, ExecutorService executor) {\n         this.executor = executor;\n         initDispatcherThreads(dispatcherThreadCount > 0 ? dispatcherThreadCount : 2);\n-        addErrorHandler(new ConsoleLogger());\n+        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n         subscriptionFactory = getSubscriptionFactory();\n         initialize();\n     }\n"
    },
    {
        "commit hash": "b3fa0642173516c5d7add7d929ab6351735ff46b",
        "previous commit hash": "201518d9f4e8943646bbf598afd0f64e2b1dfc02",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/IPublicationErrorHandler.java",
            "additions": 12,
            "deletions": 0
        },
        "diff content": "@@ -10,4 +10,16 @@ package org.mbassy;\n public interface IPublicationErrorHandler {\n \n \tpublic void handleError(PublicationError error);\n+\n+    // This is the default error handler it will simply log to standard out and\n+    // print stack trace if available\n+    static final class ConsoleLogger implements IPublicationErrorHandler {\n+        @Override\n+        public void handleError(PublicationError error) {\n+            System.out.println(error);\n+            if (error.getCause() != null) error.getCause().printStackTrace();\n+        }\n+    }\n+\n+    ;\n }\n"
    },
    {
        "commit hash": "b3fa0642173516c5d7add7d929ab6351735ff46b",
        "previous commit hash": "201518d9f4e8943646bbf598afd0f64e2b1dfc02",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/common/ReflectionUtils.java",
            "additions": 0,
            "deletions": 5
        },
        "diff content": "@@ -1,8 +1,5 @@\n package org.mbassy.common;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.util.LinkedList;\n@@ -15,8 +12,6 @@ import java.util.List;\n  */\n public class ReflectionUtils {\n \n-\tprivate static final Logger logger = LoggerFactory.getLogger(ReflectionUtils.class);\n-\n \tpublic static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n \t\tList<Method> methods = new LinkedList<Method>();\n \t\ttry {\n"
    },
    {
        "commit hash": "201518d9f4e8943646bbf598afd0f64e2b1dfc02",
        "previous commit hash": "b66eeb59a6d3085fc48bc27fd8872b84b09e49ae",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar and b/maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar differ\n"
    },
    {
        "commit hash": "201518d9f4e8943646bbf598afd0f64e2b1dfc02",
        "previous commit hash": "b66eeb59a6d3085fc48bc27fd8872b84b09e49ae",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar.md5",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-979e7cc560c4cb58ba6a89641e22bb26\n\\ No newline at end of file\n+d53edd50a68307a4c209fd21fa0625d7\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "201518d9f4e8943646bbf598afd0f64e2b1dfc02",
        "previous commit hash": "b66eeb59a6d3085fc48bc27fd8872b84b09e49ae",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar.sha1",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-bc0484e10bdc22cbdcfce1389f14cd7c9957201e\n\\ No newline at end of file\n+f2ed26a15178d83c80212ccce73584e97e7d6fb8\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "201518d9f4e8943646bbf598afd0f64e2b1dfc02",
        "previous commit hash": "b66eeb59a6d3085fc48bc27fd8872b84b09e49ae",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.pom",
            "additions": 42,
            "deletions": 53
        },
        "diff content": "@@ -1,42 +1,31 @@\n <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-\n-\t<modelVersion>4.0.0</modelVersion>\n-\t<groupId>org.mbassy</groupId>\n-\t<artifactId>mbassador</artifactId>\n-\t<version>1.0.0.RC</version>\n-\t<packaging>jar</packaging>\n-\t<name>mbassador</name>\n-\t<description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern</description>\n-\n-\t<properties>\n-\t\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-\t\t<project.build.java.version>1.6</project.build.java.version>\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.mbassy</groupId>\n+    <artifactId>mbassador</artifactId>\n+    <version>1.0.0.RC</version>\n+    <packaging>jar</packaging>\n+    <name>mbassador</name>\n+    <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n+    </description>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.build.java.version>1.6</project.build.java.version>\n         <github.url>file://${project.basedir}/maven</github.url>\n-\t</properties>\n+    </properties>\n \n-\t<dependencies>\n+    <dependencies>\n \n         <dependency>\n-\t\t\t<groupId>junit</groupId>\n-\t\t\t<artifactId>junit</artifactId>\n-\t\t\t<version>4.10</version>\n-\t\t\t<scope>compile</scope>\n-\t\t</dependency>\n-\n-        <dependency>\n-            <groupId>org.slf4j</groupId>\n-            <artifactId>slf4j-api</artifactId>\n-            <version>1.5.2</version>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.10</version>\n+            <scope>test</scope>\n         </dependency>\n \n-        <dependency>\n-            <groupId>org.slf4j</groupId>\n-            <artifactId>slf4j-log4j12</artifactId>\n-            <version>1.5.2</version>\n-        </dependency>\n-\n-\t</dependencies>\n+    </dependencies>\n \n     <distributionManagement>\n         <repository>\n@@ -45,25 +34,25 @@\n         </repository>\n     </distributionManagement>\n \n-\t<build>\n-\t\t<plugins>\n-\t\t\t<plugin>\n-\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n-\t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n-\t\t\t\t<configuration>\n-\t\t\t\t\t<source>${project.build.java.version}</source>\n-\t\t\t\t\t<target>${project.build.java.version}</target>\n-\t\t\t\t</configuration>\n-\t\t\t</plugin>\n-\n-\t\t\t<plugin>\n-\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n-\t\t\t\t<artifactId>maven-surefire-plugin</artifactId>\n-\t\t\t\t<configuration>\n-\t\t\t\t\t<skipTests>false</skipTests>\n-\t\t\t\t</configuration>\n-\t\t\t</plugin>\n-\n-\t\t</plugins>\n-\t</build>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>${project.build.java.version}</source>\n+                    <target>${project.build.java.version}</target>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <skipTests>false</skipTests>\n+                </configuration>\n+            </plugin>\n+\n+        </plugins>\n+    </build>\n </project>\n"
    },
    {
        "commit hash": "201518d9f4e8943646bbf598afd0f64e2b1dfc02",
        "previous commit hash": "b66eeb59a6d3085fc48bc27fd8872b84b09e49ae",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.pom.md5",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-bf33617f2df2dba6777f9f7ce20ec347\n\\ No newline at end of file\n+760688c8fb33fc90918146e68dab2646\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "201518d9f4e8943646bbf598afd0f64e2b1dfc02",
        "previous commit hash": "b66eeb59a6d3085fc48bc27fd8872b84b09e49ae",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.pom.sha1",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-551e714a8213d342d7f9d62ea23c6a86c9573fa4\n\\ No newline at end of file\n+0abf762df11d85841f8f8b7f28361ff19549f019\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "201518d9f4e8943646bbf598afd0f64e2b1dfc02",
        "previous commit hash": "b66eeb59a6d3085fc48bc27fd8872b84b09e49ae",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -7,6 +7,6 @@\n     <versions>\n       <version>1.0.0.RC</version>\n     </versions>\n-    <lastUpdated>20121119144226</lastUpdated>\n+    <lastUpdated>20121119145820</lastUpdated>\n   </versioning>\n </metadata>\n"
    },
    {
        "commit hash": "201518d9f4e8943646bbf598afd0f64e2b1dfc02",
        "previous commit hash": "b66eeb59a6d3085fc48bc27fd8872b84b09e49ae",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.md5",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-8477cb6b6bf78760091124da1c2fedf9\n\\ No newline at end of file\n+006f75456dc73e47019a2b8befeeac1d\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "201518d9f4e8943646bbf598afd0f64e2b1dfc02",
        "previous commit hash": "b66eeb59a6d3085fc48bc27fd8872b84b09e49ae",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.sha1",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1 +1 @@\n-51d06df27a7c04cfec12b802d9f3cf0e98e4255e\n\\ No newline at end of file\n+0396418ec7c57ea6a92a0b9c7c741883464f2261\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "b66eeb59a6d3085fc48bc27fd8872b84b09e49ae",
        "previous commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 42,
            "deletions": 53
        },
        "diff content": "@@ -1,42 +1,31 @@\n <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-\n-\t<modelVersion>4.0.0</modelVersion>\n-\t<groupId>org.mbassy</groupId>\n-\t<artifactId>mbassador</artifactId>\n-\t<version>1.0.0.RC</version>\n-\t<packaging>jar</packaging>\n-\t<name>mbassador</name>\n-\t<description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern</description>\n-\n-\t<properties>\n-\t\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-\t\t<project.build.java.version>1.6</project.build.java.version>\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.mbassy</groupId>\n+    <artifactId>mbassador</artifactId>\n+    <version>1.0.0.RC</version>\n+    <packaging>jar</packaging>\n+    <name>mbassador</name>\n+    <description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern\n+    </description>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.build.java.version>1.6</project.build.java.version>\n         <github.url>file://${project.basedir}/maven</github.url>\n-\t</properties>\n+    </properties>\n \n-\t<dependencies>\n+    <dependencies>\n \n         <dependency>\n-\t\t\t<groupId>junit</groupId>\n-\t\t\t<artifactId>junit</artifactId>\n-\t\t\t<version>4.10</version>\n-\t\t\t<scope>compile</scope>\n-\t\t</dependency>\n-\n-        <dependency>\n-            <groupId>org.slf4j</groupId>\n-            <artifactId>slf4j-api</artifactId>\n-            <version>1.5.2</version>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.10</version>\n+            <scope>test</scope>\n         </dependency>\n \n-        <dependency>\n-            <groupId>org.slf4j</groupId>\n-            <artifactId>slf4j-log4j12</artifactId>\n-            <version>1.5.2</version>\n-        </dependency>\n-\n-\t</dependencies>\n+    </dependencies>\n \n     <distributionManagement>\n         <repository>\n@@ -45,25 +34,25 @@\n         </repository>\n     </distributionManagement>\n \n-\t<build>\n-\t\t<plugins>\n-\t\t\t<plugin>\n-\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n-\t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n-\t\t\t\t<configuration>\n-\t\t\t\t\t<source>${project.build.java.version}</source>\n-\t\t\t\t\t<target>${project.build.java.version}</target>\n-\t\t\t\t</configuration>\n-\t\t\t</plugin>\n-\n-\t\t\t<plugin>\n-\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n-\t\t\t\t<artifactId>maven-surefire-plugin</artifactId>\n-\t\t\t\t<configuration>\n-\t\t\t\t\t<skipTests>false</skipTests>\n-\t\t\t\t</configuration>\n-\t\t\t</plugin>\n-\n-\t\t</plugins>\n-\t</build>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>${project.build.java.version}</source>\n+                    <target>${project.build.java.version}</target>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <skipTests>false</skipTests>\n+                </configuration>\n+            </plugin>\n+\n+        </plugins>\n+    </build>\n </project>\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar and b/maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar differ\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+979e7cc560c4cb58ba6a89641e22bb26\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+bc0484e10bdc22cbdcfce1389f14cd7c9957201e\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.pom",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -12,7 +12,7 @@\n \t<properties>\n \t\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n \t\t<project.build.java.version>1.6</project.build.java.version>\n-        <github.url>file://${project.basedir}</github.url>\n+        <github.url>file://${project.basedir}/maven</github.url>\n \t</properties>\n \n \t<dependencies>\n@@ -40,7 +40,7 @@\n \n     <distributionManagement>\n         <repository>\n-            <id>github-mbassador</id>\n+            <id>mbassador-github-repo</id>\n             <url>${github.url}</url>\n         </repository>\n     </distributionManagement>\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.pom.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+bf33617f2df2dba6777f9f7ce20ec347\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.pom.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+551e714a8213d342d7f9d62ea23c6a86c9573fa4\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -4,10 +4,9 @@\n   <artifactId>mbassador</artifactId>\n   <version>1.0.0.RC</version>\n   <versioning>\n-    <release>1.0.0.RC</release>\n     <versions>\n       <version>1.0.0.RC</version>\n     </versions>\n-    <lastUpdated>20121119141818</lastUpdated>\n+    <lastUpdated>20121119144226</lastUpdated>\n   </versioning>\n </metadata>\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+8477cb6b6bf78760091124da1c2fedf9\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "maven/org/mbassy/mbassador/maven-metadata.xml.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+51d06df27a7c04cfec12b802d9f3cf0e98e4255e\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC-javadoc.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC-javadoc.jar and /dev/null differ\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC-javadoc.jar.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-f1535dca2679e7b4e3ca8c1d3bcfc9b0\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC-javadoc.jar.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-50e2d5c3f4b1ee25b77d618215d9de07aaea6bf0\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC-sources.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC-sources.jar and /dev/null differ\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC-sources.jar.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-988795a0fad216d97eb98fd7150f2197\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC-sources.jar.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-3a0effa16b44dad99f51027946c3e1dfedb26cb4\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-de5950589a82de685b6a9544698035ca\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-5782892d448620fcbcd097681099c2323580f526\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.pom.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-629392673fc7bf8c8beed13987bd235e\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.pom.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-ec2982368c337481401f1e80b49f587fd28a9f2e\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/maven-metadata.xml.md5",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-b516b55cd37693149552143b3d7a4bba\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/maven-metadata.xml.sha1",
            "additions": 0,
            "deletions": 1
        },
        "diff content": "@@ -1 +0,0 @@\n-9c7d420679d08a5c90eb0522b6b99a9439518d47\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "49acafb88bf30a17ee15b2e8c105f02799e5a5f1",
        "previous commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -12,7 +12,7 @@\n \t<properties>\n \t\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n \t\t<project.build.java.version>1.6</project.build.java.version>\n-        <github.url>file://${project.basedir}</github.url>\n+        <github.url>file://${project.basedir}/maven</github.url>\n \t</properties>\n \n \t<dependencies>\n@@ -40,7 +40,7 @@\n \n     <distributionManagement>\n         <repository>\n-            <id>github-mbassador</id>\n+            <id>mbassador-github-repo</id>\n             <url>${github.url}</url>\n         </repository>\n     </distributionManagement>\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": ".gitignore",
            "additions": 0,
            "deletions": 2
        },
        "diff content": "@@ -2,11 +2,9 @@\n *.iml\n \n # Package Files #\n-*.jar\n *.war\n *.ear\n \n \n # root of compiled classes #\n target/**/*\n-*.class\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC-javadoc.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC-javadoc.jar differ\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC-javadoc.jar.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+f1535dca2679e7b4e3ca8c1d3bcfc9b0\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC-javadoc.jar.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+50e2d5c3f4b1ee25b77d618215d9de07aaea6bf0\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC-sources.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC-sources.jar differ\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC-sources.jar.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+988795a0fad216d97eb98fd7150f2197\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC-sources.jar.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+3a0effa16b44dad99f51027946c3e1dfedb26cb4\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar differ\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+de5950589a82de685b6a9544698035ca\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.jar.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+5782892d448620fcbcd097681099c2323580f526\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.pom",
            "additions": 69,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,69 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+\t<modelVersion>4.0.0</modelVersion>\n+\t<groupId>org.mbassy</groupId>\n+\t<artifactId>mbassador</artifactId>\n+\t<version>1.0.0.RC</version>\n+\t<packaging>jar</packaging>\n+\t<name>mbassador</name>\n+\t<description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern</description>\n+\n+\t<properties>\n+\t\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+\t\t<project.build.java.version>1.6</project.build.java.version>\n+        <github.url>file://${project.basedir}</github.url>\n+\t</properties>\n+\n+\t<dependencies>\n+\n+        <dependency>\n+\t\t\t<groupId>junit</groupId>\n+\t\t\t<artifactId>junit</artifactId>\n+\t\t\t<version>4.10</version>\n+\t\t\t<scope>compile</scope>\n+\t\t</dependency>\n+\n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>slf4j-api</artifactId>\n+            <version>1.5.2</version>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>slf4j-log4j12</artifactId>\n+            <version>1.5.2</version>\n+        </dependency>\n+\n+\t</dependencies>\n+\n+    <distributionManagement>\n+        <repository>\n+            <id>github-mbassador</id>\n+            <url>${github.url}</url>\n+        </repository>\n+    </distributionManagement>\n+\n+\t<build>\n+\t\t<plugins>\n+\t\t\t<plugin>\n+\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n+\t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n+\t\t\t\t<configuration>\n+\t\t\t\t\t<source>${project.build.java.version}</source>\n+\t\t\t\t\t<target>${project.build.java.version}</target>\n+\t\t\t\t</configuration>\n+\t\t\t</plugin>\n+\n+\t\t\t<plugin>\n+\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n+\t\t\t\t<artifactId>maven-surefire-plugin</artifactId>\n+\t\t\t\t<configuration>\n+\t\t\t\t\t<skipTests>false</skipTests>\n+\t\t\t\t</configuration>\n+\t\t\t</plugin>\n+\n+\t\t</plugins>\n+\t</build>\n+</project>\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.pom.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+629392673fc7bf8c8beed13987bd235e\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/1.0.0.RC/mbassador-1.0.0.RC.pom.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+ec2982368c337481401f1e80b49f587fd28a9f2e\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/maven-metadata.xml",
            "additions": 13,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,13 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<metadata>\n+  <groupId>org.mbassy</groupId>\n+  <artifactId>mbassador</artifactId>\n+  <version>1.0.0.RC</version>\n+  <versioning>\n+    <release>1.0.0.RC</release>\n+    <versions>\n+      <version>1.0.0.RC</version>\n+    </versions>\n+    <lastUpdated>20121119141818</lastUpdated>\n+  </versioning>\n+</metadata>\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/maven-metadata.xml.md5",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+b516b55cd37693149552143b3d7a4bba\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": "org/mbassy/mbassador/maven-metadata.xml.sha1",
            "additions": 1,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1 @@\n+9c7d420679d08a5c90eb0522b6b99a9439518d47\n\\ No newline at end of file\n"
    },
    {
        "commit hash": "da0e4dc551edf17fb6d2256c705c857ca6d5a451",
        "previous commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 8,
            "deletions": 0
        },
        "diff content": "@@ -12,6 +12,7 @@\n \t<properties>\n \t\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n \t\t<project.build.java.version>1.6</project.build.java.version>\n+        <github.url>file://${project.basedir}</github.url>\n \t</properties>\n \n \t<dependencies>\n@@ -37,6 +38,13 @@\n \n \t</dependencies>\n \n+    <distributionManagement>\n+        <repository>\n+            <id>github-mbassador</id>\n+            <url>${github.url}</url>\n+        </repository>\n+    </distributionManagement>\n+\n \t<build>\n \t\t<plugins>\n \t\t\t<plugin>\n"
    },
    {
        "commit hash": "04745a3fbc7d01be05695880461356dadf7d7422",
        "previous commit hash": "bc1e3a636e2d890e8af31da57de445109f53593d",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -3,7 +3,7 @@ Mbassador\n \n Mbassador is a very light-weight message bus (event bus) implementation following the publish subscribe pattern. It is designed\n for ease of use and aims to be feature rich, extensible while preserving resource efficiency and performance.\n-Check out the [performance comparison](http://codeblock.engio.net/?p=37) which also reviews part of the features of the compared implementations\n+Check out the <a href=\"http://codeblock.engio.net/?p=37\" target=\"_blank\">performance comparison</a> which also reviews part of the features of the compared implementations\n \n At its core it offers the following:\n \n"
    },
    {
        "commit hash": "bc1e3a636e2d890e8af31da57de445109f53593d",
        "previous commit hash": "9ce3ceb6f4f13ff016ee6c7e24ca6a38eb1c189f",
        "diff stats": {
            "file_path": "README.md",
            "additions": 13,
            "deletions": 6
        },
        "diff content": "@@ -1,8 +1,11 @@\n Mbassador\n =========\n \n-Mbassador is a very light-weight message bus implementation following the publish subscribe pattern. It is designed\n-for ease of use and aims to be resource efficient and very fast. At its core it offers the following:\n+Mbassador is a very light-weight message bus (event bus) implementation following the publish subscribe pattern. It is designed\n+for ease of use and aims to be feature rich, extensible while preserving resource efficiency and performance.\n+Check out the [performance comparison](http://codeblock.engio.net/?p=37) which also reviews part of the features of the compared implementations\n+\n+At its core it offers the following:\n \n + <em><strong>Annotation driven</em></strong>: To define and customize a message handler simply mark it with @Listener annotation\n + <em><strong>Delivers everything</em></strong>: Messages must not implement any interface and can be of any type (-> message bus is typed using generics with upper\n@@ -17,6 +20,7 @@ in certain environments where objects are created by frameworks, i.e. spring, gu\n ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.\n + <em><strong>Filtering</em></strong>: Mbassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to\n a single message handler\n++ <em><strong>Handler priorities</em></strong>: A listener can be associated with a priority to influence the order of the message delivery\n + <em><strong>Error handling</em></strong>: Errors during message delivery are sent to an error handler of which a custom implementation can easily be plugged-in.\n + <em><strong>Ease of Use</em></strong>: Using Mbassador in your project is very easy. Create as many instances of Mbassador as you like (usually a singleton will do),\n mark and configure your message handlers with @Listener annotations and finally register the listeners at any Mbassador instance. Start\n@@ -36,14 +40,16 @@ Listener definition (in any bean):\n \t\t}\n \n         // this handler will be invoked asynchronously\n-\t\t@Listener(mode = Listener.Dispatch.Asynchronous)\n+\t\t@Listener(dispatch = Mode.Asynchronous)\n \t\tpublic void handleSubTestEvent(SubTestEvent event) {\n             // do something more expensive here\n \t\t}\n \n \t\t// this handler will receive events of type SubTestEvent\n         // or any subtabe and that passes the given filter(s)\n-        @Listener({@Filter(SpecialEventsOnly.class),@Filter(AnotherFilter.class)})\n+        @Listener(priority = 10,\n+                  dispatch = Mode.Synchronous,\n+                  filters = {@Filter(MessageFilter.None.class),@Filter(MessageFilter.All.class)})\n         public void handleFiltered(SubTestEvent event) {\n            //do something special here\n         }\n@@ -52,7 +58,7 @@ Creation of message bus and registration of listeners:\n \n         // create as many instances as necessary\n         // bind it to any upper bound\n-        MBassador<TestEvent> bus = new MBassador<TestEvent();\n+        MBassador<TestEvent> bus = new MBassador<TestEvent>();\n         ListeningBean listener = new ListeningBean();\n         // the listener will be registered using a weak-reference\n         bus.subscribe(listener);\n@@ -66,13 +72,14 @@ Message publication:\n         TestEvent subEvent = new SubTestEvent();\n \n         bus.publishAsync(event); //returns immediately, publication will continue asynchronously\n+        bus.post(event).asynchronously(); // same as above\n         bus.publish(subEvent);   // will return after each handler has been invoked\n+        bus.post(subEvent).now(); // same as above\n \n \n <h2>Planned features</h2>\n \n + Maven dependency: Add Mbassador to your project using maven. Coming soon!\n-+ Message handler priority: Message handlers can specify priority to influence order of message delivery\n + Spring integration with support for conditional message dispatch in transactional context (dispatch only after\n successful commit etc.)\n \n"
    },
    {
        "commit hash": "9ce3ceb6f4f13ff016ee6c7e24ca6a38eb1c189f",
        "previous commit hash": "2ae0e5fae09cb0cf4127a5528b21de0e7b2cf60d",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/AbstractMessageBus.java",
            "additions": 247,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,247 @@\n+package org.mbassy;\n+\n+import org.mbassy.common.IPredicate;\n+import org.mbassy.common.ReflectionUtils;\n+import org.mbassy.listener.Listener;\n+import org.mbassy.listener.MetadataReader;\n+import org.mbassy.subscription.Subscription;\n+import org.mbassy.subscription.SubscriptionDeliveryRequest;\n+import org.mbassy.subscription.SubscriptionFactory;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.concurrent.*;\n+\n+\n+public abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n+\n+\n+    //  This predicate is used to find all message listeners (methods annotated with @Listener)\n+    private static final IPredicate<Method> AllMessageListeners = new IPredicate<Method>() {\n+        @Override\n+        public boolean apply(Method target) {\n+            return target.getAnnotation(Listener.class) != null;\n+        }\n+    };\n+\n+    // This is the default error handler it will simply log to standard out and\n+    // print stack trace if available\n+    protected static final class ConsoleLogger implements IPublicationErrorHandler {\n+        @Override\n+        public void handleError(PublicationError error) {\n+            System.out.println(error);\n+            if (error.getCause() != null) error.getCause().printStackTrace();\n+        }\n+    }\n+\n+    ;\n+\n+    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n+    private ExecutorService executor;\n+\n+    private MetadataReader metadataReader = new MetadataReader();\n+\n+    // all subscriptions per message type\n+    // this is the primary list for dispatching a specific message\n+    // write access is synchronized and happens very infrequently\n+    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n+\n+    // all subscriptions per messageHandler type\n+    // this list provides fast access for subscribing and unsubscribing\n+    // write access is synchronized and happens very infrequently\n+    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n+\n+    // remember already processed classes that do not contain any listeners\n+    private final Collection<Class> nonListeners = new HashSet();\n+\n+    // this handler will receive all errors that occur during message dispatch or message handling\n+    private CopyOnWriteArrayList<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n+\n+    // all threads that are available for asynchronous message dispatching\n+    private final CopyOnWriteArrayList<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n+\n+    // all pending messages scheduled for asynchronous dispatch are queued here\n+    private final LinkedBlockingQueue<SubscriptionDeliveryRequest<T>> pendingMessages = new LinkedBlockingQueue<SubscriptionDeliveryRequest<T>>();\n+\n+    private final SubscriptionFactory subscriptionFactory;\n+\n+    // initialize the dispatch workers\n+    private void initDispatcherThreads(int numberOfThreads) {\n+        for (int i = 0; i < numberOfThreads; i++) {\n+            // each thread will run forever and process incoming\n+            //dispatch requests\n+            Thread dispatcher = new Thread(new Runnable() {\n+                public void run() {\n+                    while (true) {\n+                        try {\n+                           pendingMessages.take().execute();\n+                        } catch (InterruptedException e) {\n+                            handlePublicationError(new PublicationError(e, \"Asynchronous publication interrupted\", null, null, null));\n+                            return;\n+                        }\n+                    }\n+                }\n+            });\n+            dispatchers.add(dispatcher);\n+            dispatcher.start();\n+        }\n+    }\n+\n+    public AbstractMessageBus() {\n+        this(2);\n+    }\n+\n+    public AbstractMessageBus(int dispatcherThreadCount) {\n+        this(2, new ThreadPoolExecutor(5, 50, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>()));\n+    }\n+\n+    public AbstractMessageBus(int dispatcherThreadCount, ExecutorService executor) {\n+        this.executor = executor;\n+        initDispatcherThreads(dispatcherThreadCount > 0 ? dispatcherThreadCount : 2);\n+        addErrorHandler(new ConsoleLogger());\n+        subscriptionFactory = getSubscriptionFactory();\n+        initialize();\n+    }\n+\n+    protected abstract SubscriptionFactory getSubscriptionFactory();\n+\n+    protected void initialize(){}\n+\n+    @Override\n+    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n+        return Collections.unmodifiableCollection(errorHandlers);\n+    }\n+\n+    public void unsubscribe(Object listener) {\n+        if (listener == null) return;\n+        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n+        if (subscriptions == null) return;\n+        for (Subscription subscription : subscriptions) {\n+            subscription.unsubscribe(listener);\n+        }\n+    }\n+\n+\n+    public void subscribe(Object listener) {\n+        try {\n+            Class listeningClass = listener.getClass();\n+            if (nonListeners.contains(listeningClass))\n+                return; // early reject of known classes that do not participate in eventing\n+            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n+            if (subscriptionsByListener == null) { // if the type is registered for the first time\n+                synchronized (this) { // new subscriptions must be processed sequentially for each class\n+                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n+                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n+                        List<Method> messageHandlers = getListeners(listeningClass);  // get all methods with subscriptions\n+                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n+                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class\n+                            nonListeners.add(listeningClass);\n+                            return;\n+                        }\n+                        // create subscriptions for all detected listeners\n+                        for (Method messageHandler : messageHandlers) {\n+                            if (!isValidMessageHandler(messageHandler)) continue; // ignore invalid listeners\n+                            Class eventType = getMessageType(messageHandler);\n+                            Subscription subscription = subscriptionFactory.createSubscription(metadataReader.getHandlerMetadata(messageHandler));\n+                            subscription.subscribe(listener);\n+                            addMessageTypeSubscription(eventType, subscription);\n+                            subscriptionsByListener.add(subscription);\n+                            //updateMessageTypeHierarchy(eventType);\n+                        }\n+                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n+                    }\n+                }\n+            }\n+            // register the listener to the existing subscriptions\n+            for (Subscription sub : subscriptionsByListener) sub.subscribe(listener);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+\n+    public void addErrorHandler(IPublicationErrorHandler handler) {\n+        errorHandlers.add(handler);\n+    }\n+\n+    protected void addAsynchronousDeliveryRequest(SubscriptionDeliveryRequest<T> request) {\n+        pendingMessages.offer(request);\n+    }\n+\n+    // obtain the set of subscriptions for the given message type\n+    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n+        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n+\n+        if (subscriptionsPerMessage.get(messageType) != null) {\n+            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n+        }\n+        for (Class eventSuperType : getSuperclasses(messageType)) {\n+            if (subscriptionsPerMessage.get(eventSuperType) != null) {\n+                subscriptions.addAll(subscriptionsPerMessage.get(eventSuperType));\n+            }\n+        }\n+        // IMPROVEMENT: use tree list that sorts during insertion\n+        //Collections.sort(subscriptions, new SubscriptionByPriorityDesc());\n+        return subscriptions;\n+    }\n+\n+    private Collection<Class> getSuperclasses(Class from) {\n+        Collection<Class> superclasses = new LinkedList<Class>();\n+        while (!from.equals(Object.class)) {\n+            superclasses.add(from.getSuperclass());\n+            from = from.getSuperclass();\n+        }\n+        return superclasses;\n+    }\n+\n+    // associate a suscription with a message type\n+    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n+        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n+        if (subscriptions == null) {\n+            subscriptions = new CopyOnWriteArraySet<Subscription>();\n+            subscriptionsPerMessage.put(messageType, subscriptions);\n+        }\n+        subscriptions.add(subscription);\n+    }\n+\n+\n+    private boolean isValidMessageHandler(Method handler) {\n+        if (handler.getParameterTypes().length != 1) {\n+            // a messageHandler only defines one parameter (the message)\n+            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n+                    + \"]. A messageHandler must define exactly one parameter\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private static Class getMessageType(Method listener) {\n+        return listener.getParameterTypes()[0];\n+    }\n+\n+    // get all listeners defined by the given class (includes\n+    // listeners defined in super classes)\n+    private static List<Method> getListeners(Class<?> target) {\n+        return ReflectionUtils.getMethods(AllMessageListeners, target);\n+    }\n+\n+\n+    public void handlePublicationError(PublicationError error) {\n+        for (IPublicationErrorHandler errorHandler : errorHandlers)\n+            errorHandler.handleError(error);\n+    }\n+\n+    @Override\n+    protected void finalize() throws Throwable {\n+        super.finalize();\n+        for (Thread dispatcher : dispatchers) {\n+            dispatcher.interrupt();\n+        }\n+    }\n+\n+    @Override\n+    public Executor getExecutor() {\n+        return executor;\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "9ce3ceb6f4f13ff016ee6c7e24ca6a38eb1c189f",
        "previous commit hash": "2ae0e5fae09cb0cf4127a5528b21de0e7b2cf60d",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/IMessageBus.java",
            "additions": 22,
            "deletions": 0
        },
        "diff content": "@@ -1,5 +1,8 @@\n package org.mbassy;\n \n+import java.util.Collection;\n+import java.util.concurrent.Executor;\n+\n /**\n  *\n  * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n@@ -69,6 +72,25 @@ public interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n      */\n     public P post(T message);\n \n+    /**\n+     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n+     * may not be accessible due to security constraints or is not annotated properly.\n+     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n+     * A call to this method will add the given error handler to the chain\n+     *\n+     * @param errorHandler\n+     */\n+    public void addErrorHandler(IPublicationErrorHandler errorHandler);\n+\n+    /**\n+     * Returns an immutable collection containing all the registered error handlers\n+     *\n+     * @return\n+     */\n+    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n+\n+    public Executor getExecutor();\n+\n \n \n     public static interface IPostCommand{\n"
    },
    {
        "commit hash": "9ce3ceb6f4f13ff016ee6c7e24ca6a38eb1c189f",
        "previous commit hash": "2ae0e5fae09cb0cf4127a5528b21de0e7b2cf60d",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/IPublicationErrorHandler.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.common;\n+package org.mbassy;\n \n /**\n  * TODO. Insert class description here\n"
    },
    {
        "commit hash": "9ce3ceb6f4f13ff016ee6c7e24ca6a38eb1c189f",
        "previous commit hash": "2ae0e5fae09cb0cf4127a5528b21de0e7b2cf60d",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/MBassador.java",
            "additions": 9,
            "deletions": 440
        },
        "diff content": "@@ -1,102 +1,32 @@\n package org.mbassy;\n \n-import org.mbassy.filter.Filter;\n-import org.mbassy.filter.MessageFilter;\n-import org.mbassy.common.*;\n+import org.mbassy.subscription.*;\n \n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n import java.util.*;\n import java.util.concurrent.*;\n \n \n-public class MBassador<T> implements IMessageBus<T, SimplePostCommand>{\n-\n-\n-\t//  This predicate is used to find all message listeners (methods annotated with @Listener)\n-\tprivate static final IPredicate<Method> AllMessageListeners = new IPredicate<Method>() {\n-\t\t@Override\n-\t\tpublic boolean apply(Method target) {\n-\t\t\treturn target.getAnnotation(Listener.class) != null;\n-\t\t}\n-\t};\n-\n-    // This is the default error handler it will simply log to standard out and\n-    // print stack trace if available\n-\tprotected static final class ConsoleLogger implements IPublicationErrorHandler {\n-\t\t@Override\n-\t\tpublic void handleError(PublicationError error) {\n-            System.out.println(error);\n-            if (error.getCause() != null) error.getCause().printStackTrace();\n-\t\t}\n-\t};\n-\n-    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n-    private ExecutorService executor;\n-\n-\t// cache already created filter instances\n-\tprivate final Map<Class<? extends MessageFilter>, MessageFilter> filterCache = new HashMap<Class<? extends MessageFilter>, MessageFilter>();\n-\n-\t// all subscriptions per message type\n-\t// this is the primary list for dispatching a specific message\n-    // write access is synchronized and happens very infrequently\n-\tprivate final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n-\n-\t// all subscriptions per messageHandler type\n-\t// this list provides fast access for subscribing and unsubscribing\n-\tprivate final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n-\n-\t// remember already processed classes that do not contain any listeners\n-\tprivate final Collection<Class> nonListeners = new HashSet();\n-\n-    // this handler will receive all errors that occur during message dispatch or message handling\n-\tprivate IPublicationErrorHandler errorHandler = new ConsoleLogger();\n-\n-\n-    // all threads that are available for asynchronous message dispatching\n-    private final CopyOnWriteArrayList<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n-\n-    // all pending messages scheduled for asynchronous dispatch are queued here\n-    private final LinkedBlockingQueue<T> pendingMessages = new LinkedBlockingQueue<T>();\n-\n-    // initialize the dispatch workers\n-    private void initDispatcherThreads(int numberOfThreads) {\n-        for (int i = 0; i < numberOfThreads; i++) {\n-            // each thread will run forever and process incoming\n-            //dispatch requests\n-            Thread dispatcher = new Thread(new Runnable() {\n-                public void run() {\n-                    while (true) {\n-                        try {\n-                            publish(pendingMessages.take());\n-                        } catch (InterruptedException e) {\n-                            errorHandler.handleError(new PublicationError(e, \"Asynchronous publication interrupted\", null, null, null));\n-                            return;\n-                        }\n-                    }\n-                }\n-            });\n-            dispatchers.add(dispatcher);\n-            dispatcher.start();\n-        }\n-    }\n+public class MBassador<T> extends AbstractMessageBus<T, SimplePostCommand<T>>{\n \n     public MBassador(){\n         this(2);\n     }\n \n     public MBassador(int dispatcherThreadCount){\n-        this(2, new ThreadPoolExecutor(5, 50, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>()));\n+        super(dispatcherThreadCount);\n     }\n \n     public MBassador(int dispatcherThreadCount, ExecutorService executor){\n-        this.executor = executor;\n-        initDispatcherThreads(dispatcherThreadCount > 0 ? dispatcherThreadCount : 2);\n+        super(dispatcherThreadCount,executor);\n     }\n \n+    @Override\n+    protected SubscriptionFactory getSubscriptionFactory() {\n+        return new SubscriptionFactory(this);\n+    }\n \n     public void publishAsync(T message){\n-        pendingMessages.offer(message);\n+        addAsynchronousDeliveryRequest(new SubscriptionDeliveryRequest<T>(getSubscriptionsByMessageType(message.getClass()), message));\n     }\n \n \n@@ -125,370 +55,9 @@ public class MBassador<T> implements IMessageBus<T, SimplePostCommand>{\n \t}\n \n \n-\tpublic void unsubscribe(Object listener){\n-\t\tif (listener == null) return;\n-\t\tCollection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n-\t\tif(subscriptions == null)return;\n-        for (Subscription subscription : subscriptions) {\n-\t\t\tsubscription.unsubscribe(listener);\n-\t\t}\n-\t}\n-\n     @Override\n     public SimplePostCommand post(T message) {\n         return new SimplePostCommand(this, message);\n     }\n \n-    public void subscribe(Object listener){\n-\t\tClass listeningClass = listener.getClass();\n-\t\tif (nonListeners.contains(listeningClass))\n-\t\t\treturn; // early reject of known classes that do not participate in eventing\n-\t\tCollection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n-\t\tif (subscriptionsByListener == null) { // if the type is registered for the first time\n-\t\t\tsynchronized (this) { // new subscriptions must be processed sequentially for each class\n-\t\t\t\tsubscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n-\t\t\t\tif (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n-\t\t\t\t\tList<Method> messageHandlers = getListeners(listeningClass);  // get all methods with subscriptions\n-\t\t\t\t\tsubscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n-\t\t\t\t\tif (messageHandlers.isEmpty()) {  // remember the class as non listening class\n-\t\t\t\t\t\tnonListeners.add(listeningClass);\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t\t// create subscriptions for all detected listeners\n-\t\t\t\t\tfor (Method messageHandler : messageHandlers) {\n-\t\t\t\t\t\tif (!isValidMessageHandler(messageHandler)) continue; // ignore invalid listeners\n-\t\t\t\t\t\tMessageFilter[] filter = getFilter(messageHandler.getAnnotation(Listener.class));\n-\t\t\t\t\t\tClass eventType = getMessageType(messageHandler);\n-\t\t\t\t\t\tSubscription subscription = createSubscription(messageHandler, filter);\n-\t\t\t\t\t\tsubscription.subscribe(listener);\n-\t\t\t\t\t\taddMessageTypeSubscription(eventType, subscription);\n-\t\t\t\t\t\tsubscriptionsByListener.add(subscription);\n-\t\t\t\t\t\t//updateMessageTypeHierarchy(eventType);\n-\t\t\t\t\t}\n-\t\t\t\t\tsubscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t// register the listener to the existing subscriptions\n-\t\tfor (Subscription sub : subscriptionsByListener) sub.subscribe(listener);\n-\t}\n-\n-\n-\tpublic void setErrorHandler(IPublicationErrorHandler handler){\n-\t\tthis.errorHandler = handler;\n-\t}\n-\n-\n-\n-\t// obtain the set of subscriptions for the given message type\n-\tprivate Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n-\t\tList<Subscription> subscriptions = new LinkedList<Subscription>();\n-\n-\t\tif(subscriptionsPerMessage.get(messageType) != null) {\n-\t\t\tsubscriptions.addAll(subscriptionsPerMessage.get(messageType));\n-\t\t}\n-\t\tfor (Class eventSuperType : getSuperclasses(messageType)){\n-           if(subscriptionsPerMessage.get(eventSuperType) != null){\n-               subscriptions.addAll(subscriptionsPerMessage.get(eventSuperType));\n-           }\n-        }\n-        // IMPROVEMENT: use tree list that sorts during insertion\n-\t\t//Collections.sort(subscriptions, new SubscriptionByPriorityDesc());\n-        return subscriptions;\n-\t}\n-\n-    private Collection<Class> getSuperclasses(Class from){\n-        Collection<Class> superclasses = new LinkedList<Class>();\n-        while(!from.equals(Object.class)){\n-            superclasses.add(from.getSuperclass());\n-            from = from.getSuperclass();\n-        }\n-        return superclasses;\n-    }\n-\n-\t// associate a suscription with a message type\n-\tprivate void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n-\t\tCollection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n-\t\tif (subscriptions == null) {\n-\t\t\tsubscriptions = new CopyOnWriteArraySet<Subscription>();\n-\t\t\tsubscriptionsPerMessage.put(messageType, subscriptions);\n-\t\t}\n-\t\tsubscriptions.add(subscription);\n-\t}\n-\n-\n-\tprivate boolean isValidMessageHandler(Method handler) {\n-\t\tif (handler.getParameterTypes().length != 1) {\n-\t\t\t// a messageHandler only defines one parameter (the message)\n-\t\t\tSystem.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n-\t\t\t\t\t+ \"]. A messageHandler must define exactly one parameter\");\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n-\tprivate static Class getMessageType(Method listener) {\n-\t\treturn listener.getParameterTypes()[0];\n-\t}\n-\n-\t// get all listeners defined by the given class (includes\n-\t// listeners defined in super classes)\n-\tprivate static List<Method> getListeners(Class<?> target) {\n-\t\treturn ReflectionUtils.getMethods(AllMessageListeners, target);\n-\t}\n-\n-\t// retrieve all instances of filters associated with the given subscription\n-\tprivate MessageFilter[] getFilter(Listener subscription) {\n-\t\tif (subscription.value().length == 0) return null;\n-\t\tMessageFilter[] filters = new MessageFilter[subscription.value().length];\n-\t\tint i = 0;\n-\t\tfor (Filter filterDef : subscription.value()) {\n-\t\t\tMessageFilter filter = filterCache.get(filterDef.value());\n-\t\t\tif (filter == null) {\n-\t\t\t\ttry {\n-\t\t\t\t\tfilter = filterDef.value().newInstance();\n-\t\t\t\t\tfilterCache.put(filterDef.value(), filter);\n-\t\t\t\t} catch (Throwable e) {\n-\t\t\t\t\thandlePublicationError(new PublicationError()\n-\t\t\t\t\t\t\t.setMessage(\"Error retrieving filter\"));\n-\t\t\t\t}\n-\n-\t\t\t}\n-\t\t\tfilters[i] = filter;\n-\t\t\ti++;\n-\t\t}\n-\t\treturn filters;\n-\t}\n-\n-\n-\n-\tprivate void handlePublicationError(PublicationError error) {\n-\t\terrorHandler.handleError(error);\n-\t}\n-\n-    @Override\n-    protected void finalize() throws Throwable {\n-        super.finalize();\n-        for(Thread dispatcher : dispatchers){\n-            dispatcher.interrupt();\n-        }\n-    }\n-\n-\n-    private Subscription createSubscription(Method messageHandler, MessageFilter[] filter){\n-        if(filter == null || filter.length == 0){\n-            if(isAsynchronous(messageHandler)){\n-                return new UnfilteredAsynchronousSubscription(messageHandler);\n-            }\n-            else{\n-                return new UnfilteredSynchronousSubscription(messageHandler);\n-            }\n-        }\n-        else{\n-            if(isAsynchronous(messageHandler)){\n-                return new FilteredAsynchronousSubscription(messageHandler, filter);\n-            }\n-            else{\n-                return new FilteredSynchronousSubscription(messageHandler, filter);\n-            }\n-        }\n-    }\n-\n-    private boolean isAsynchronous(Method messageHandler){\n-         return messageHandler.getAnnotation(Listener.class).mode().equals(Listener.Dispatch.Asynchronous);\n-    }\n-\n-\n-    /**\n-     * Subscription is a thread safe container for objects that contain message handlers\n-     */\n-\tprivate abstract class Subscription {\n-\n-\t\tprivate final Method messageHandler;\n-\n-\t\tprotected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n-\n-        private int priority = 0;\n-\n-\t\tprivate Subscription(Method messageHandler) {\n-            // TODO: init priority\n-\t\t\tthis.messageHandler = messageHandler;\n-            this.messageHandler.setAccessible(true);\n-\t\t}\n-\n-        protected abstract void publish(Object message);\n-\n-        protected abstract void dispatch(final Object message, final Object listener);\n-\n-\n-        public int getPriority(){\n-            return priority;\n-        }\n-\n-\n-\t\tpublic void subscribe(Object o) {\n-\t\t\tlisteners.add(o);\n-\n-\t\t}\n-\n-        protected void invokeHandler(final Object message, final Object listener){\n-            try {\n-                messageHandler.invoke(listener, message);\n-            }catch(IllegalAccessException e){\n-                MBassador.this.handlePublicationError(\n-                        new PublicationError(e, \"Error during messageHandler notification. \" +\n-                                \"The class or method is not accessible\",\n-                                messageHandler, listener, message));\n-            }\n-            catch(IllegalArgumentException e){\n-                MBassador.this.handlePublicationError(\n-                        new PublicationError(e, \"Error during messageHandler notification. \" +\n-                                \"Wrong arguments passed to method. Was: \" + message.getClass()\n-                                + \"Expected: \" + messageHandler.getParameterTypes()[0],\n-                                messageHandler, listener, message));\n-            }\n-            catch (InvocationTargetException e) {\n-                MBassador.this.handlePublicationError(\n-                        new PublicationError(e, \"Error during messageHandler notification. \" +\n-                                \"Message handler threw exception\",\n-                                messageHandler, listener, message));\n-            }\n-            catch (Throwable e) {\n-                MBassador.this.handlePublicationError(\n-                        new PublicationError(e, \"Error during messageHandler notification. \" +\n-                                \"Unexpected exception\",\n-                                messageHandler, listener, message));\n-            }\n-        }\n-\n-\n-\t\tpublic void unsubscribe(Object existingListener) {\n-\t\t\tlisteners.remove(existingListener);\n-\t\t}\n-\n-\n-\n-\n-\t}\n-\n-    private abstract class UnfilteredSubscription extends Subscription{\n-\n-\n-        private UnfilteredSubscription(Method messageHandler) {\n-            super(messageHandler);\n-        }\n-\n-        public void publish(Object message) {\n-\n-            Iterator<Object> iterator = listeners.iterator();\n-            Object listener = null;\n-            while ((listener = iterator.next()) != null) {\n-                dispatch(message, listener);\n-            }\n-        }\n-    }\n-\n-    private class UnfilteredAsynchronousSubscription extends UnfilteredSubscription{\n-\n-\n-        private UnfilteredAsynchronousSubscription(Method messageHandler) {\n-            super(messageHandler);\n-        }\n-\n-        protected void dispatch(final Object message, final Object listener){\n-                MBassador.this.executor.execute(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        invokeHandler(message, listener);\n-                    }\n-                });\n-\n-        }\n-    }\n-\n-    private class UnfilteredSynchronousSubscription extends UnfilteredSubscription{\n-\n-\n-        private UnfilteredSynchronousSubscription(Method messageHandler) {\n-            super(messageHandler);\n-        }\n-\n-        protected void dispatch(final Object message, final Object listener){\n-            invokeHandler(message, listener);\n-        }\n-    }\n-\n-    private abstract class FilteredSubscription extends Subscription{\n-\n-        private final MessageFilter[] filter;\n-\n-\n-        private FilteredSubscription(Method messageHandler, MessageFilter[] filter) {\n-            super(messageHandler);\n-            this.filter = filter;\n-        }\n-\n-        private boolean passesFilter(Object message, Object listener) {\n-\n-            if (filter == null) {\n-                return true;\n-            }\n-            else {\n-                for (int i = 0; i < filter.length; i++) {\n-                    if (!filter[i].accepts(message, listener)) return false;\n-                }\n-                return true;\n-            }\n-        }\n-\n-        protected void publish(Object message) {\n-\n-            Iterator<Object> iterator = listeners.iterator();\n-            Object listener = null;\n-            while ((listener = iterator.next()) != null) {\n-                if(passesFilter(message, listener)) {\n-                    dispatch(message, listener);\n-                }\n-            }\n-        }\n-    }\n-\n-    private class FilteredSynchronousSubscription extends FilteredSubscription{\n-\n-\n-        private FilteredSynchronousSubscription(Method messageHandler, MessageFilter[] filter) {\n-            super(messageHandler, filter);\n-        }\n-\n-        protected void dispatch(final Object message, final Object listener){\n-            MBassador.this.executor.execute(new Runnable() {\n-                @Override\n-                public void run() {\n-                    invokeHandler(message, listener);\n-                }\n-            });\n-\n-        }\n-    }\n-\n-    private class FilteredAsynchronousSubscription extends FilteredSubscription{\n-\n-\n-        private FilteredAsynchronousSubscription(Method messageHandler, MessageFilter[] filter) {\n-            super(messageHandler, filter);\n-        }\n-\n-        protected void dispatch(final Object message, final Object listener){\n-            invokeHandler(message, listener);\n-        }\n-    }\n-\n-\n-    private final class SubscriptionByPriorityDesc implements Comparator<Subscription> {\n-        @Override\n-        public int compare(Subscription o1, Subscription o2) {\n-            return o1.getPriority() - o2.getPriority();\n-        }\n-    };\n-\n }\n"
    },
    {
        "commit hash": "9ce3ceb6f4f13ff016ee6c7e24ca6a38eb1c189f",
        "previous commit hash": "2ae0e5fae09cb0cf4127a5528b21de0e7b2cf60d",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/PublicationError.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.common;\n+package org.mbassy;\n \n import java.lang.reflect.Method;\n \n"
    },
    {
        "commit hash": "9ce3ceb6f4f13ff016ee6c7e24ca6a38eb1c189f",
        "previous commit hash": "2ae0e5fae09cb0cf4127a5528b21de0e7b2cf60d",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/Filter.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.filter;\n+package org.mbassy.listener;\n \n import java.lang.annotation.ElementType;\n import java.lang.annotation.Retention;\n"
    },
    {
        "commit hash": "9ce3ceb6f4f13ff016ee6c7e24ca6a38eb1c189f",
        "previous commit hash": "2ae0e5fae09cb0cf4127a5528b21de0e7b2cf60d",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/Listener.java",
            "additions": 4,
            "deletions": 8
        },
        "diff content": "@@ -1,6 +1,4 @@\n-package org.mbassy;\n-\n-import org.mbassy.filter.Filter;\n+package org.mbassy.listener;\n \n import java.lang.annotation.*;\n \n@@ -16,12 +14,10 @@ import java.lang.annotation.*;\n @Target(value = {ElementType.METHOD})\n public @interface Listener {\n \n-\tFilter[] value() default {}; // no filters by default\n+\tFilter[] filters() default {}; // no filters by default\n \n-    Dispatch mode() default Dispatch.Synchronous;\n+    Mode dispatch() default Mode.Synchronous;\n \n-    public static enum Dispatch{\n-        Synchronous,Asynchronous\n-    }\n+    int priority() default 0;\n \n }\n"
    },
    {
        "commit hash": "9ce3ceb6f4f13ff016ee6c7e24ca6a38eb1c189f",
        "previous commit hash": "2ae0e5fae09cb0cf4127a5528b21de0e7b2cf60d",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MessageFilter.java",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -1,4 +1,4 @@\n-package org.mbassy.filter;\n+package org.mbassy.listener;\n \n /**\n  * Object filters can be used to prevent certain messages to be delivered to a specific listener.\n"
    },
    {
        "commit hash": "9ce3ceb6f4f13ff016ee6c7e24ca6a38eb1c189f",
        "previous commit hash": "2ae0e5fae09cb0cf4127a5528b21de0e7b2cf60d",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MessageHandlerMetadata.java",
            "additions": 51,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,51 @@\n+package org.mbassy.listener;\n+\n+import org.mbassy.listener.Listener;\n+import org.mbassy.listener.Mode;\n+import org.mbassy.listener.MessageFilter;\n+\n+import java.lang.reflect.Method;\n+\n+/**\n+ * User: benni\n+ * Date: 11/14/12\n+ */\n+public class MessageHandlerMetadata {\n+\n+    private Method handler;\n+\n+    private MessageFilter[] filter;\n+\n+    private Listener listenerConfig;\n+\n+    private boolean isAsynchronous = false;\n+\n+\n+    public MessageHandlerMetadata(Method handler, MessageFilter[] filter, Listener listenerConfig) {\n+        this.handler = handler;\n+        this.filter = filter;\n+        this.listenerConfig = listenerConfig;\n+        this.isAsynchronous = listenerConfig.dispatch().equals(Mode.Asynchronous);\n+    }\n+\n+\n+    public boolean isAsynchronous(){\n+        return isAsynchronous;\n+    }\n+\n+    public boolean isFiltered(){\n+        return filter == null || filter.length == 0;\n+    }\n+\n+    public int getPriority(){\n+        return listenerConfig.priority();\n+    }\n+\n+    public Method getHandler() {\n+        return handler;\n+    }\n+\n+    public MessageFilter[] getFilter() {\n+        return filter;\n+    }\n+}\n"
    },
    {
        "commit hash": "9ce3ceb6f4f13ff016ee6c7e24ca6a38eb1c189f",
        "previous commit hash": "2ae0e5fae09cb0cf4127a5528b21de0e7b2cf60d",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/MetadataReader.java",
            "additions": 43,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,43 @@\n+package org.mbassy.listener;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Created with IntelliJ IDEA.\n+ * User: benni\n+ * Date: 11/16/12\n+ * Time: 10:22 AM\n+ * To change this template use File | Settings | File Templates.\n+ */\n+public class MetadataReader {\n+\n+    // cache already created filter instances\n+    private final Map<Class<? extends MessageFilter>, MessageFilter> filterCache = new HashMap<Class<? extends MessageFilter>, MessageFilter>();\n+\n+    // retrieve all instances of filters associated with the given subscription\n+    private MessageFilter[] getFilter(Listener subscription) throws Exception{\n+        if (subscription.filters().length == 0) return null;\n+        MessageFilter[] filters = new MessageFilter[subscription.filters().length];\n+        int i = 0;\n+        for (Filter filterDef : subscription.filters()) {\n+            MessageFilter filter = filterCache.get(filterDef.value());\n+            if (filter == null) {\n+                    filter = filterDef.value().newInstance();\n+                    filterCache.put(filterDef.value(), filter);\n+\n+            }\n+            filters[i] = filter;\n+            i++;\n+        }\n+        return filters;\n+    }\n+\n+\n+    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler) throws Exception{\n+        Listener config = messageHandler.getAnnotation(Listener.class);\n+        MessageFilter[] filter = getFilter(config);\n+        return new MessageHandlerMetadata(messageHandler, filter, config);\n+    }\n+}\n"
    },
    {
        "commit hash": "9ce3ceb6f4f13ff016ee6c7e24ca6a38eb1c189f",
        "previous commit hash": "2ae0e5fae09cb0cf4127a5528b21de0e7b2cf60d",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/listener/Mode.java",
            "additions": 12,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,12 @@\n+package org.mbassy.listener;\n+\n+/**\n+* Created with IntelliJ IDEA.\n+* User: benni\n+* Date: 11/16/12\n+* Time: 10:01 AM\n+* To change this template use File | Settings | File Templates.\n+*/\n+public enum Mode {\n+    Synchronous,Asynchronous\n+}\n"
    },
    {
        "commit hash": "9ce3ceb6f4f13ff016ee6c7e24ca6a38eb1c189f",
        "previous commit hash": "2ae0e5fae09cb0cf4127a5528b21de0e7b2cf60d",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/MBassadorTest.java",
            "additions": 9,
            "deletions": 4
        },
        "diff content": "@@ -2,8 +2,10 @@ package org.mbassy;\n \n import org.junit.Assert;\n import org.junit.Test;\n-import org.mbassy.filter.Filter;\n-import org.mbassy.filter.MessageFilter;\n+import org.mbassy.listener.Filter;\n+import org.mbassy.listener.Listener;\n+import org.mbassy.listener.MessageFilter;\n+import org.mbassy.listener.Mode;\n \n import java.util.ArrayList;\n import java.util.List;\n@@ -187,14 +189,17 @@ public class MBassadorTest {\n \t\t}\n \n         // this handler will be invoked asynchronously\n-\t\t@Listener(mode = Listener.Dispatch.Asynchronous)\n+\t\t@Listener(priority = 0, dispatch = Mode.Asynchronous)\n \t\tpublic void handleSubTestEvent(SubTestEvent event) {\n             event.counter.incrementAndGet();\n \t\t}\n \n         // this handler will receive events of type SubTestEvent\n         // or any subtabe and that passes the given filter\n-        @Listener({@Filter(MessageFilter.None.class),@Filter(MessageFilter.All.class)})\n+        @Listener(\n+                priority = 10,\n+                dispatch = Mode.Synchronous,\n+                filters = {@Filter(MessageFilter.None.class),@Filter(MessageFilter.All.class)})\n         public void handleFiltered(SubTestEvent event) {\n             event.counter.incrementAndGet();\n         }\n"
    },
    {
        "commit hash": "2ae0e5fae09cb0cf4127a5528b21de0e7b2cf60d",
        "previous commit hash": "014f22df9ea53c61111fa935eb108ad3103eae72",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/FilteredAsynchronousSubscription.java",
            "additions": 33,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,33 @@\n+package org.mbassy.subscription;\n+\n+import org.mbassy.IMessageBus;\n+import org.mbassy.IPublicationErrorHandler;\n+import org.mbassy.listener.MessageFilter;\n+import org.mbassy.listener.MessageHandlerMetadata;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+\n+/**\n+* Created with IntelliJ IDEA.\n+* User: benni\n+* Date: 11/14/12\n+* Time: 3:50 PM\n+* To change this template use File | Settings | File Templates.\n+*/\n+public class FilteredAsynchronousSubscription extends FilteredSubscription{\n+\n+    public FilteredAsynchronousSubscription(IMessageBus mBassador, MessageHandlerMetadata messageHandler) {\n+        super(mBassador, messageHandler);\n+    }\n+\n+    protected void dispatch(final Object message, final Object listener){\n+\n+        getMessageBus().getExecutor().execute(new Runnable() {\n+            @Override\n+            public void run() {\n+                invokeHandler(message, listener);\n+            }\n+        });\n+    }\n+}\n"
    },
    {
        "commit hash": "2ae0e5fae09cb0cf4127a5528b21de0e7b2cf60d",
        "previous commit hash": "014f22df9ea53c61111fa935eb108ad3103eae72",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/FilteredSubscription.java",
            "additions": 53,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,53 @@\n+package org.mbassy.subscription;\n+\n+import org.mbassy.IMessageBus;\n+import org.mbassy.IPublicationErrorHandler;\n+import org.mbassy.MBassador;\n+import org.mbassy.listener.MessageFilter;\n+import org.mbassy.listener.MessageHandlerMetadata;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+/**\n+* Created with IntelliJ IDEA.\n+* User: benni\n+* Date: 11/14/12\n+* Time: 3:48 PM\n+* To change this template use File | Settings | File Templates.\n+*/\n+public abstract class FilteredSubscription extends Subscription{\n+\n+    private final MessageFilter[] filter;\n+\n+\n+    public FilteredSubscription(IMessageBus mBassador, MessageHandlerMetadata messageHandler) {\n+        super(mBassador, messageHandler);\n+        this.filter = messageHandler.getFilter();\n+    }\n+\n+    private boolean passesFilter(Object message, Object listener) {\n+\n+        if (filter == null) {\n+            return true;\n+        }\n+        else {\n+            for (int i = 0; i < filter.length; i++) {\n+                if (!filter[i].accepts(message, listener)) return false;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    public void publish(Object message) {\n+\n+        Iterator<Object> iterator = listeners.iterator();\n+        Object listener = null;\n+        while ((listener = iterator.next()) != null) {\n+            if(passesFilter(message, listener)) {\n+                dispatch(message, listener);\n+            }\n+        }\n+    }\n+}\n"
    },
    {
        "commit hash": "2ae0e5fae09cb0cf4127a5528b21de0e7b2cf60d",
        "previous commit hash": "014f22df9ea53c61111fa935eb108ad3103eae72",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/FilteredSynchronousSubscription.java",
            "additions": 28,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,28 @@\n+package org.mbassy.subscription;\n+\n+import org.mbassy.IMessageBus;\n+import org.mbassy.IPublicationErrorHandler;\n+import org.mbassy.listener.MessageFilter;\n+import org.mbassy.listener.MessageHandlerMetadata;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+\n+/**\n+* Created with IntelliJ IDEA.\n+* User: benni\n+* Date: 11/14/12\n+* Time: 3:49 PM\n+* To change this template use File | Settings | File Templates.\n+*/\n+public class FilteredSynchronousSubscription extends FilteredSubscription {\n+\n+\n+    public FilteredSynchronousSubscription(IMessageBus mBassador, MessageHandlerMetadata messageHandler) {\n+        super(mBassador, messageHandler);\n+    }\n+\n+    protected void dispatch(final Object message, final Object listener){\n+        invokeHandler(message, listener);\n+    }\n+}\n"
    },
    {
        "commit hash": "014f22df9ea53c61111fa935eb108ad3103eae72",
        "previous commit hash": "08f6e45c7cef622395da6e03832aaa66f48a21e3",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/Subscription.java",
            "additions": 104,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,104 @@\n+package org.mbassy.subscription;\n+\n+import org.mbassy.IMessageBus;\n+import org.mbassy.IPublicationErrorHandler;\n+import org.mbassy.common.ConcurrentSet;\n+import org.mbassy.PublicationError;\n+import org.mbassy.listener.MessageHandlerMetadata;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.Comparator;\n+\n+/**\n+ * Subscription is a thread safe container for objects that contain message handlers\n+ */\n+public abstract class Subscription {\n+\n+    private final Method handler;\n+\n+    protected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n+\n+    private int priority = 0;\n+\n+    private IMessageBus owningBus ;\n+\n+    public Subscription(IMessageBus owningBus, MessageHandlerMetadata messageHandler) {\n+        this.owningBus = owningBus;\n+        this.priority = messageHandler.getPriority();\n+        this.handler = messageHandler.getHandler();\n+        this.handler.setAccessible(true);\n+    }\n+\n+    public abstract void publish(Object message);\n+\n+    protected abstract void dispatch(final Object message, final Object listener);\n+\n+\n+    protected IMessageBus getMessageBus(){\n+        return owningBus;\n+    }\n+\n+    public int getPriority(){\n+        return priority;\n+    }\n+\n+\n+    public void subscribe(Object o) {\n+        listeners.add(o);\n+\n+    }\n+\n+    protected void handlePublicationError(PublicationError error){\n+        Collection<IPublicationErrorHandler> handlers = owningBus.getRegisteredErrorHandlers();\n+        for(IPublicationErrorHandler handler : handlers){\n+            handler.handleError(error);\n+        }\n+    }\n+\n+    protected void invokeHandler(final Object message, final Object listener){\n+        try {\n+            handler.invoke(listener, message);\n+        }catch(IllegalAccessException e){\n+            handlePublicationError(\n+                    new PublicationError(e, \"Error during messageHandler notification. \" +\n+                            \"The class or method is not accessible\",\n+                            handler, listener, message));\n+        }\n+        catch(IllegalArgumentException e){\n+            handlePublicationError(\n+                    new PublicationError(e, \"Error during messageHandler notification. \" +\n+                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n+                            + \"Expected: \" + handler.getParameterTypes()[0],\n+                            handler, listener, message));\n+        }\n+        catch (InvocationTargetException e) {\n+            handlePublicationError(\n+                    new PublicationError(e, \"Error during messageHandler notification. \" +\n+                            \"Message handler threw exception\",\n+                            handler, listener, message));\n+        }\n+        catch (Throwable e) {\n+            handlePublicationError(\n+                    new PublicationError(e, \"Error during messageHandler notification. \" +\n+                            \"Unexpected exception\",\n+                            handler, listener, message));\n+        }\n+    }\n+\n+\n+    public void unsubscribe(Object existingListener) {\n+        listeners.remove(existingListener);\n+    }\n+\n+\n+    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n+        @Override\n+        public int compare(Subscription o1, Subscription o2) {\n+            int result =  o1.getPriority() - o2.getPriority();\n+            return result == 0 ? o1.handler.hashCode() - o2.handler.hashCode() : result;\n+        }\n+    };\n+\n+}\n"
    },
    {
        "commit hash": "014f22df9ea53c61111fa935eb108ad3103eae72",
        "previous commit hash": "08f6e45c7cef622395da6e03832aaa66f48a21e3",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/SubscriptionDeliveryRequest.java",
            "additions": 38,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,38 @@\n+package org.mbassy.subscription;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+\n+/**\n+ * User: benni\n+ * Date: 11/16/12\n+ */\n+public class SubscriptionDeliveryRequest<T> {\n+\n+    private Collection<Subscription> subscriptions;\n+\n+    private T message;\n+\n+    public SubscriptionDeliveryRequest(Collection<Subscription> subscriptions, T message) {\n+        this.subscriptions = subscriptions;\n+        this.message = message;\n+    }\n+\n+    public SubscriptionDeliveryRequest(T message){\n+        this.message = message;\n+        subscriptions = new LinkedList<Subscription>();\n+    }\n+\n+    public boolean addAll(Collection<? extends Subscription> c) {\n+        return subscriptions.addAll(c);\n+    }\n+\n+    public boolean add(Subscription subscription) {\n+        return subscriptions.add(subscription);\n+    }\n+\n+    public void execute(){\n+        for(Subscription sub : subscriptions)\n+            sub.publish(message);\n+    }\n+}\n"
    },
    {
        "commit hash": "014f22df9ea53c61111fa935eb108ad3103eae72",
        "previous commit hash": "08f6e45c7cef622395da6e03832aaa66f48a21e3",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/SubscriptionFactory.java",
            "additions": 43,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,43 @@\n+package org.mbassy.subscription;\n+\n+import org.mbassy.IMessageBus;\n+import org.mbassy.IPublicationErrorHandler;\n+import org.mbassy.listener.MessageHandlerMetadata;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Created with IntelliJ IDEA.\n+ * User: benni\n+ * Date: 11/16/12\n+ * Time: 10:39 AM\n+ * To change this template use File | Settings | File Templates.\n+ */\n+public class SubscriptionFactory {\n+\n+    private IMessageBus owner;\n+\n+\n+    public SubscriptionFactory(IMessageBus owner) {\n+        this.owner = owner;\n+    }\n+\n+    public Subscription createSubscription(MessageHandlerMetadata messageHandlerMetadata){\n+        if(messageHandlerMetadata.isFiltered()){\n+            if(messageHandlerMetadata.isAsynchronous()){\n+                return new UnfilteredAsynchronousSubscription(owner, messageHandlerMetadata);\n+            }\n+            else{\n+                return new UnfilteredSynchronousSubscription(owner, messageHandlerMetadata);\n+            }\n+        }\n+        else{\n+            if(messageHandlerMetadata.isAsynchronous()){\n+                return new FilteredAsynchronousSubscription(owner, messageHandlerMetadata);\n+            }\n+            else{\n+                return new FilteredSynchronousSubscription(owner, messageHandlerMetadata);\n+            }\n+        }\n+    }\n+}\n"
    },
    {
        "commit hash": "014f22df9ea53c61111fa935eb108ad3103eae72",
        "previous commit hash": "08f6e45c7cef622395da6e03832aaa66f48a21e3",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/UnfilteredAsynchronousSubscription.java",
            "additions": 33,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,33 @@\n+package org.mbassy.subscription;\n+\n+import org.mbassy.IMessageBus;\n+import org.mbassy.IPublicationErrorHandler;\n+import org.mbassy.MBassador;\n+import org.mbassy.listener.MessageHandlerMetadata;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+\n+/**\n+* Created with IntelliJ IDEA.\n+* User: benni\n+* Date: 11/14/12\n+* Time: 3:48 PM\n+* To change this template use File | Settings | File Templates.\n+*/\n+public class UnfilteredAsynchronousSubscription extends UnfilteredSubscription {\n+\n+    public UnfilteredAsynchronousSubscription(IMessageBus mBassador, MessageHandlerMetadata messageHandler) {\n+        super(mBassador, messageHandler);\n+    }\n+\n+    protected void dispatch(final Object message, final Object listener){\n+            getMessageBus().getExecutor().execute(new Runnable() {\n+                @Override\n+                public void run() {\n+                    invokeHandler(message, listener);\n+                }\n+            });\n+\n+    }\n+}\n"
    },
    {
        "commit hash": "014f22df9ea53c61111fa935eb108ad3103eae72",
        "previous commit hash": "08f6e45c7cef622395da6e03832aaa66f48a21e3",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/UnfilteredSubscription.java",
            "additions": 34,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,34 @@\n+package org.mbassy.subscription;\n+\n+import org.mbassy.IMessageBus;\n+import org.mbassy.IPublicationErrorHandler;\n+import org.mbassy.MBassador;\n+import org.mbassy.listener.MessageHandlerMetadata;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+/**\n+* Created with IntelliJ IDEA.\n+* User: benni\n+* Date: 11/14/12\n+* Time: 3:45 PM\n+* To change this template use File | Settings | File Templates.\n+*/\n+public abstract class UnfilteredSubscription extends Subscription{\n+\n+\n+    public UnfilteredSubscription(IMessageBus mBassador, MessageHandlerMetadata messageHandler) {\n+        super(mBassador, messageHandler);\n+    }\n+\n+    public void publish(Object message) {\n+\n+        Iterator<Object> iterator = listeners.iterator();\n+        Object listener = null;\n+        while ((listener = iterator.next()) != null) {\n+            dispatch(message, listener);\n+        }\n+    }\n+}\n"
    },
    {
        "commit hash": "014f22df9ea53c61111fa935eb108ad3103eae72",
        "previous commit hash": "08f6e45c7cef622395da6e03832aaa66f48a21e3",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/subscription/UnfilteredSynchronousSubscription.java",
            "additions": 27,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,27 @@\n+package org.mbassy.subscription;\n+\n+import org.mbassy.IMessageBus;\n+import org.mbassy.IPublicationErrorHandler;\n+import org.mbassy.MBassador;\n+import org.mbassy.listener.MessageHandlerMetadata;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+\n+/**\n+* Created with IntelliJ IDEA.\n+* User: benni\n+* Date: 11/14/12\n+* Time: 3:49 PM\n+* To change this template use File | Settings | File Templates.\n+*/\n+public class UnfilteredSynchronousSubscription extends UnfilteredSubscription{\n+\n+    public UnfilteredSynchronousSubscription(IMessageBus mBassador, MessageHandlerMetadata messageHandler) {\n+        super(mBassador, messageHandler);\n+    }\n+\n+    protected void dispatch(final Object message, final Object listener){\n+        invokeHandler(message, listener);\n+    }\n+}\n"
    },
    {
        "commit hash": "08f6e45c7cef622395da6e03832aaa66f48a21e3",
        "previous commit hash": "611718c4ec38e4b5531f9d9c79a301592aad393b",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 0,
            "deletions": 6
        },
        "diff content": "@@ -35,12 +35,6 @@\n             <version>1.5.2</version>\n         </dependency>\n \n-        <dependency>\n-            <groupId>commons-collections</groupId>\n-            <artifactId>commons-collections</artifactId>\n-            <version>3.2</version>\n-        </dependency>\n-\n \t</dependencies>\n \n \t<build>\n"
    },
    {
        "commit hash": "611718c4ec38e4b5531f9d9c79a301592aad393b",
        "previous commit hash": "6aadcbe036b535732ef54f49cebc6498eb3f2d62",
        "diff stats": {
            "file_path": "README.md",
            "additions": 4,
            "deletions": 3
        },
        "diff content": "@@ -2,8 +2,7 @@ Mbassador\n =========\n \n Mbassador is a very light-weight message bus implementation following the publish subscribe pattern. It is designed\n-for ease of use and aims to be resource efficient and very fast. It was inspired by google guava's event bus which lacked some\n-features like weak references at that time. At its core it offers the following:\n+for ease of use and aims to be resource efficient and very fast. At its core it offers the following:\n \n + <em><strong>Annotation driven</em></strong>: To define and customize a message handler simply mark it with @Listener annotation\n + <em><strong>Delivers everything</em></strong>: Messages must not implement any interface and can be of any type (-> message bus is typed using generics with upper\n@@ -61,7 +60,7 @@ Creation of message bus and registration of listeners:\n         bus.subscribe(new ClassWithoutAnyDefinedHandlers());\n \n \n-Message puclication:\n+Message publication:\n \n         TestEvent event = new TestEvent();\n         TestEvent subEvent = new SubTestEvent();\n@@ -74,6 +73,8 @@ Message puclication:\n \n + Maven dependency: Add Mbassador to your project using maven. Coming soon!\n + Message handler priority: Message handlers can specify priority to influence order of message delivery\n++ Spring integration with support for conditional message dispatch in transactional context (dispatch only after\n+successful commit etc.)\n \n <h2>License</h2>\n \n"
    },
    {
        "commit hash": "6aadcbe036b535732ef54f49cebc6498eb3f2d62",
        "previous commit hash": "3f7b80bdebfc8aad7e70f9bb1544aafc1449f156",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 7,
            "deletions": 1
        },
        "diff content": "@@ -7,7 +7,7 @@\n \t<version>1.0.0.RC</version>\n \t<packaging>jar</packaging>\n \t<name>mbassador</name>\n-\t<description>Library for simple implementation of bidirectional conversions</description>\n+\t<description>Mbassador is a fast and flexible message bus system that follows the publish subscribe pattern</description>\n \n \t<properties>\n \t\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n@@ -35,6 +35,12 @@\n             <version>1.5.2</version>\n         </dependency>\n \n+        <dependency>\n+            <groupId>commons-collections</groupId>\n+            <artifactId>commons-collections</artifactId>\n+            <version>3.2</version>\n+        </dependency>\n+\n \t</dependencies>\n \n \t<build>\n"
    },
    {
        "commit hash": "6aadcbe036b535732ef54f49cebc6498eb3f2d62",
        "previous commit hash": "3f7b80bdebfc8aad7e70f9bb1544aafc1449f156",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/IMessageBus.java",
            "additions": 82,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,82 @@\n+package org.mbassy;\n+\n+/**\n+ *\n+ * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n+ * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n+ * The dispatch mechanism can by controlled for each concrete message publication.\n+ * A message publication is the publication of any message using one of the bus' publish(..) methods.\n+ * <p/>\n+ * Each message publication is isolated from all other running publications such that it does not interfere with them.\n+ * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n+ * messages get published asynchronously.\n+ * <p/>\n+ * A listener is any object that defines at least one message handler and that has been subscribed to at least\n+ * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n+ * as a message handler using the @Listener annotation.\n+ * <p/>\n+ * The bus uses weak references to all listeners such that registered listeners do not need to\n+ * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n+ * removed on-the-fly as messages get dispatched.\n+ * <p/>\n+ * Generally message handlers will be invoked in inverse sequence of insertion (subscription) but any\n+ * class using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n+ * a specific message exactly once to each of the subscribed message handlers.\n+ * <p/>\n+ * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n+ * a message handler may define filters to narrow the set of messages that it accepts.\n+ * <p/>\n+ * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n+ * Any messageHandler may only be subscribed once (subsequent subscriptions of an already subscribed messageHandler will be silently ignored)\n+ * <p/>\n+ * Removing a listener means removing all subscribed message handlers of that object. This remove operation\n+ * immediately takes effect and on all running dispatch processes. A removed listener (a listener\n+ * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n+ *\n+ * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n+ * get dispatched to all message handlers that take an instance of List as their parameter\n+ *\n+ * @Author bennidi\n+ * Date: 2/8/12\n+ */\n+public interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n+\n+    /**\n+     * Subscribe all listeners of the given message to receive message publications.\n+     * Any message may only be subscribed once (subsequent subscriptions of an already subscribed\n+     * message will be silently ignored)\n+     *\n+     * @param listener\n+     */\n+    public void subscribe(Object listener);\n+\n+\n+    /**\n+     * Immediately unsubscribe all registered message handlers (if any) of the given listener. When this call returns\n+     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n+     * publications that have been published when the messageHandler was still subscribed).\n+     * A call to this method passing null, an already subscribed message or any message that does not define any listeners\n+     * will not have any effect.\n+     *\n+     * @param listener\n+     */\n+    public void unsubscribe(Object listener);\n+\n+    /**\n+     *\n+     * @param message\n+     * @return\n+     */\n+    public P post(T message);\n+\n+\n+\n+    public static interface IPostCommand{\n+\n+        public void now();\n+\n+        public void asynchronously();\n+\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "6aadcbe036b535732ef54f49cebc6498eb3f2d62",
        "previous commit hash": "3f7b80bdebfc8aad7e70f9bb1544aafc1449f156",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/MBassador.java",
            "additions": 196,
            "deletions": 129
        },
        "diff content": "@@ -9,46 +9,8 @@ import java.lang.reflect.Method;\n import java.util.*;\n import java.util.concurrent.*;\n \n-/**\n- *\n- * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n- * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n- * The dispatch mechanism can by controlled for each concrete message publication.\n- * A message publication is the publication of any message using one of the bus' publish(..) methods.\n- * <p/>\n- * Each message publication is isolated from all other running publications such that it does not interfere with them.\n- * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n- * messages get published asynchronously.\n- * <p/>\n- * A listener is any object that defines at least one message handler and that has been subscribed to at least\n- * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n- * as a message handler using the @Listener annotation.\n- * <p/>\n- * The bus uses weak references to all listeners such that registered listeners do not need to\n- * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n- * removed on-the-fly as messages get dispatched.\n- * <p/>\n- * Generally message handlers will be invoked in inverse sequence of insertion (subscription) but any\n- * class using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n- * a specific message exactly once to each of the subscribed message handlers.\n- * <p/>\n- * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n- * a message handler may define filters to narrow the set of messages that it accepts.\n- * <p/>\n- * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n- * Any messageHandler may only be subscribed once (subsequent subscriptions of an already subscribed messageHandler will be silently ignored)\n- * <p/>\n- * Removing a listener means removing all subscribed message handlers of that object. This remove operation\n- * immediately takes effect and on all running dispatch processes. A removed listener (a listener\n- * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n- *\n- * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n- * get dispatched to all message handlers that take an instance of List as their parameter\n- *\n- * @Author bennidi\n- * Date: 2/8/12\n- */\n-public class MBassador<T>{\n+\n+public class MBassador<T> implements IMessageBus<T, SimplePostCommand>{\n \n \n \t//  This predicate is used to find all message listeners (methods annotated with @Listener)\n@@ -70,17 +32,18 @@ public class MBassador<T>{\n \t};\n \n     // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n-    private ExecutorService executor = new ThreadPoolExecutor(5, 50, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>());\n+    private ExecutorService executor;\n \n \t// cache already created filter instances\n \tprivate final Map<Class<? extends MessageFilter>, MessageFilter> filterCache = new HashMap<Class<? extends MessageFilter>, MessageFilter>();\n \n \t// all subscriptions per message type\n \t// this is the primary list for dispatching a specific message\n+    // write access is synchronized and happens very infrequently\n \tprivate final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n \n \t// all subscriptions per messageHandler type\n-\t// this list provides access for subscribing and unsubsribing\n+\t// this list provides fast access for subscribing and unsubscribing\n \tprivate final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n \n \t// remember already processed classes that do not contain any listeners\n@@ -107,7 +70,7 @@ public class MBassador<T>{\n                         try {\n                             publish(pendingMessages.take());\n                         } catch (InterruptedException e) {\n-                            errorHandler.handleError(new PublicationError(e, \"Asnchronous publication interupted\", null, null, null));\n+                            errorHandler.handleError(new PublicationError(e, \"Asynchronous publication interrupted\", null, null, null));\n                             return;\n                         }\n                     }\n@@ -119,10 +82,15 @@ public class MBassador<T>{\n     }\n \n     public MBassador(){\n-        initDispatcherThreads(2);\n+        this(2);\n     }\n \n     public MBassador(int dispatcherThreadCount){\n+        this(2, new ThreadPoolExecutor(5, 50, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>()));\n+    }\n+\n+    public MBassador(int dispatcherThreadCount, ExecutorService executor){\n+        this.executor = executor;\n         initDispatcherThreads(dispatcherThreadCount > 0 ? dispatcherThreadCount : 2);\n     }\n \n@@ -141,7 +109,12 @@ public class MBassador<T>{\n \tpublic void publish(T message){\n \t\ttry {\n \t\t\tfinal Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n-\t\t\tfor (Subscription subscription : subscriptions) subscription.publish(message);\n+\t\t\tif(subscriptions == null){\n+                return; // TODO: Dead Event?\n+            }\n+            for (Subscription subscription : subscriptions){\n+                subscription.publish(message);\n+            }\n \t\t} catch (Throwable e) {\n \t\t\thandlePublicationError(new PublicationError()\n \t\t\t\t\t.setMessage(\"Error during publication of message\")\n@@ -151,32 +124,22 @@ public class MBassador<T>{\n \n \t}\n \n-    /**\n-     * Immediately unsubscribe all registered message handlers (if any) of the given listener. When this call returns\n-     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n-     * publications that have been published when the messageHandler was still subscribed).\n-     * A call to this method passing null, an already subscribed message or any message that does not define any listeners\n-     * will not have any effect.\n-     *\n-     * @param listener\n-     */\n+\n \tpublic void unsubscribe(Object listener){\n \t\tif (listener == null) return;\n \t\tCollection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n-\t\tfor (Subscription subscription : subscriptions) {\n+\t\tif(subscriptions == null)return;\n+        for (Subscription subscription : subscriptions) {\n \t\t\tsubscription.unsubscribe(listener);\n \t\t}\n \t}\n \n+    @Override\n+    public SimplePostCommand post(T message) {\n+        return new SimplePostCommand(this, message);\n+    }\n \n-    /**\n-     * Subscribe all listeners of the given message to receive message publications.\n-     * Any message may only be subscribed once (subsequent subscriptions of an already subscribed\n-     * message will be silently ignored)\n-     *\n-     * @param listener\n-     */\n-\tpublic void subscribe(Object listener){\n+    public void subscribe(Object listener){\n \t\tClass listeningClass = listener.getClass();\n \t\tif (nonListeners.contains(listeningClass))\n \t\t\treturn; // early reject of known classes that do not participate in eventing\n@@ -196,7 +159,7 @@ public class MBassador<T>{\n \t\t\t\t\t\tif (!isValidMessageHandler(messageHandler)) continue; // ignore invalid listeners\n \t\t\t\t\t\tMessageFilter[] filter = getFilter(messageHandler.getAnnotation(Listener.class));\n \t\t\t\t\t\tClass eventType = getMessageType(messageHandler);\n-\t\t\t\t\t\tSubscription subscription = new Subscription(messageHandler, filter);\n+\t\t\t\t\t\tSubscription subscription = createSubscription(messageHandler, filter);\n \t\t\t\t\t\tsubscription.subscribe(listener);\n \t\t\t\t\t\taddMessageTypeSubscription(eventType, subscription);\n \t\t\t\t\t\tsubscriptionsByListener.add(subscription);\n@@ -206,7 +169,7 @@ public class MBassador<T>{\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\t// register the message to the existing subscriptions\n+\t\t// register the listener to the existing subscriptions\n \t\tfor (Subscription sub : subscriptionsByListener) sub.subscribe(listener);\n \t}\n \n@@ -219,8 +182,7 @@ public class MBassador<T>{\n \n \t// obtain the set of subscriptions for the given message type\n \tprivate Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n-\t\t// TODO improve with cache\n-\t\tCollection<Subscription> subscriptions = new LinkedList<Subscription>();\n+\t\tList<Subscription> subscriptions = new LinkedList<Subscription>();\n \n \t\tif(subscriptionsPerMessage.get(messageType) != null) {\n \t\t\tsubscriptions.addAll(subscriptionsPerMessage.get(messageType));\n@@ -230,8 +192,9 @@ public class MBassador<T>{\n                subscriptions.addAll(subscriptionsPerMessage.get(eventSuperType));\n            }\n         }\n-\n-\t\treturn subscriptions;\n+        // IMPROVEMENT: use tree list that sorts during insertion\n+\t\t//Collections.sort(subscriptions, new SubscriptionByPriorityDesc());\n+        return subscriptions;\n \t}\n \n     private Collection<Class> getSuperclasses(Class from){\n@@ -253,24 +216,11 @@ public class MBassador<T>{\n \t\tsubscriptions.add(subscription);\n \t}\n \n-    /*\n-\tprivate void updateMessageTypeHierarchy(Class messageType) {\n-\t\tfor (Class existingEventType : subscriptionsPerMessage.keySet()) {\n-\t\t\tif (existingEventType.equals(messageType)) continue;\n-\t\t\tif (messageType.isAssignableFrom(existingEventType)) //message is super type of existing\n-\t\t\t\tmessageTypeHierarchy.put(existingEventType, messageType);\n-\t\t\telse if (existingEventType.isAssignableFrom(messageType)) { // message is sub type of existing\n-\t\t\t\tmessageTypeHierarchy.put(messageType, existingEventType); // add direct super type\n-\t\t\t\tmessageTypeHierarchy.putAll(messageType, messageTypeHierarchy.get(existingEventType)); // add all super types of super type\n-\t\t\t}\n-\t\t}\n-\t}*/\n-\n \n \tprivate boolean isValidMessageHandler(Method handler) {\n \t\tif (handler.getParameterTypes().length != 1) {\n \t\t\t// a messageHandler only defines one parameter (the message)\n-\t\t\tSystem.out.println(\"Found nono or more than one parameter in messageHandler [\" + handler.getName()\n+\t\t\tSystem.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n \t\t\t\t\t+ \"]. A messageHandler must define exactly one parameter\");\n \t\t\treturn false;\n \t\t}\n@@ -324,48 +274,64 @@ public class MBassador<T>{\n         }\n     }\n \n+\n+    private Subscription createSubscription(Method messageHandler, MessageFilter[] filter){\n+        if(filter == null || filter.length == 0){\n+            if(isAsynchronous(messageHandler)){\n+                return new UnfilteredAsynchronousSubscription(messageHandler);\n+            }\n+            else{\n+                return new UnfilteredSynchronousSubscription(messageHandler);\n+            }\n+        }\n+        else{\n+            if(isAsynchronous(messageHandler)){\n+                return new FilteredAsynchronousSubscription(messageHandler, filter);\n+            }\n+            else{\n+                return new FilteredSynchronousSubscription(messageHandler, filter);\n+            }\n+        }\n+    }\n+\n+    private boolean isAsynchronous(Method messageHandler){\n+         return messageHandler.getAnnotation(Listener.class).mode().equals(Listener.Dispatch.Asynchronous);\n+    }\n+\n+\n     /**\n      * Subscription is a thread safe container for objects that contain message handlers\n-     *\n      */\n-\tprivate class Subscription {\n-\n-\t\tprivate final MessageFilter[] filter;\n+\tprivate abstract class Subscription {\n \n \t\tprivate final Method messageHandler;\n \n-\t\tprivate ConcurrentLinkedBag<Object> listeners = new ConcurrentLinkedBag<Object>();\n+\t\tprotected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n \n-        private boolean isAynchronous;\n+        private int priority = 0;\n \n-\t\tprivate Subscription(Method messageHandler, MessageFilter[] filter) {\n+\t\tprivate Subscription(Method messageHandler) {\n+            // TODO: init priority\n \t\t\tthis.messageHandler = messageHandler;\n-\t\t\tthis.filter = filter;\n             this.messageHandler.setAccessible(true);\n-            this.isAynchronous = messageHandler.getAnnotation(Listener.class).mode().equals(Listener.Dispatch.Asynchronous);\n \t\t}\n \n+        protected abstract void publish(Object message);\n+\n+        protected abstract void dispatch(final Object message, final Object listener);\n+\n+\n+        public int getPriority(){\n+            return priority;\n+        }\n+\n \n \t\tpublic void subscribe(Object o) {\n \t\t\tlisteners.add(o);\n \n \t\t}\n \n-        private void dispatch(final Object message, final Object listener){\n-            if(isAynchronous){\n-                 MBassador.this.executor.execute(new Runnable() {\n-                     @Override\n-                     public void run() {\n-                         invokeHandler(message, listener);\n-                     }\n-                 });\n-            }\n-            else{\n-                invokeHandler(message, listener);\n-            }\n-        }\n-\n-        private void invokeHandler(final Object message, final Object listener){\n+        protected void invokeHandler(final Object message, final Object listener){\n             try {\n                 messageHandler.invoke(listener, message);\n             }catch(IllegalAccessException e){\n@@ -395,33 +361,134 @@ public class MBassador<T>{\n             }\n         }\n \n-\t\tpublic void publish(Object message) {\n \n-\t\t\tIterator<Object> iterator = listeners.iterator();\n-\t\t\tObject listener = null;\n-\t\t\twhile ((listener = iterator.next()) != null) {\n-\t\t\t\t\tif(passesFilter(message, listener)) {\n-\t\t\t\t\t\tdispatch(message, listener);\n-\t\t\t\t\t}\n-\t\t\t}\n+\t\tpublic void unsubscribe(Object existingListener) {\n+\t\t\tlisteners.remove(existingListener);\n \t\t}\n \n-\t\tprivate boolean passesFilter(Object message, Object listener) {\n \n-\t\t\tif (filter == null) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tfor (int i = 0; i < filter.length; i++) {\n-\t\t\t\t\tif (!filter[i].accepts(message, listener)) return false;\n-\t\t\t\t}\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n \n-\t\tpublic void unsubscribe(Object existingListener) {\n-\t\t\tlisteners.remove(existingListener);\n-\t\t}\n+\n \t}\n \n+    private abstract class UnfilteredSubscription extends Subscription{\n+\n+\n+        private UnfilteredSubscription(Method messageHandler) {\n+            super(messageHandler);\n+        }\n+\n+        public void publish(Object message) {\n+\n+            Iterator<Object> iterator = listeners.iterator();\n+            Object listener = null;\n+            while ((listener = iterator.next()) != null) {\n+                dispatch(message, listener);\n+            }\n+        }\n+    }\n+\n+    private class UnfilteredAsynchronousSubscription extends UnfilteredSubscription{\n+\n+\n+        private UnfilteredAsynchronousSubscription(Method messageHandler) {\n+            super(messageHandler);\n+        }\n+\n+        protected void dispatch(final Object message, final Object listener){\n+                MBassador.this.executor.execute(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        invokeHandler(message, listener);\n+                    }\n+                });\n+\n+        }\n+    }\n+\n+    private class UnfilteredSynchronousSubscription extends UnfilteredSubscription{\n+\n+\n+        private UnfilteredSynchronousSubscription(Method messageHandler) {\n+            super(messageHandler);\n+        }\n+\n+        protected void dispatch(final Object message, final Object listener){\n+            invokeHandler(message, listener);\n+        }\n+    }\n+\n+    private abstract class FilteredSubscription extends Subscription{\n+\n+        private final MessageFilter[] filter;\n+\n+\n+        private FilteredSubscription(Method messageHandler, MessageFilter[] filter) {\n+            super(messageHandler);\n+            this.filter = filter;\n+        }\n+\n+        private boolean passesFilter(Object message, Object listener) {\n+\n+            if (filter == null) {\n+                return true;\n+            }\n+            else {\n+                for (int i = 0; i < filter.length; i++) {\n+                    if (!filter[i].accepts(message, listener)) return false;\n+                }\n+                return true;\n+            }\n+        }\n+\n+        protected void publish(Object message) {\n+\n+            Iterator<Object> iterator = listeners.iterator();\n+            Object listener = null;\n+            while ((listener = iterator.next()) != null) {\n+                if(passesFilter(message, listener)) {\n+                    dispatch(message, listener);\n+                }\n+            }\n+        }\n+    }\n+\n+    private class FilteredSynchronousSubscription extends FilteredSubscription{\n+\n+\n+        private FilteredSynchronousSubscription(Method messageHandler, MessageFilter[] filter) {\n+            super(messageHandler, filter);\n+        }\n+\n+        protected void dispatch(final Object message, final Object listener){\n+            MBassador.this.executor.execute(new Runnable() {\n+                @Override\n+                public void run() {\n+                    invokeHandler(message, listener);\n+                }\n+            });\n+\n+        }\n+    }\n+\n+    private class FilteredAsynchronousSubscription extends FilteredSubscription{\n+\n+\n+        private FilteredAsynchronousSubscription(Method messageHandler, MessageFilter[] filter) {\n+            super(messageHandler, filter);\n+        }\n+\n+        protected void dispatch(final Object message, final Object listener){\n+            invokeHandler(message, listener);\n+        }\n+    }\n+\n+\n+    private final class SubscriptionByPriorityDesc implements Comparator<Subscription> {\n+        @Override\n+        public int compare(Subscription o1, Subscription o2) {\n+            return o1.getPriority() - o2.getPriority();\n+        }\n+    };\n+\n }\n"
    },
    {
        "commit hash": "6aadcbe036b535732ef54f49cebc6498eb3f2d62",
        "previous commit hash": "3f7b80bdebfc8aad7e70f9bb1544aafc1449f156",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/SimplePostCommand.java",
            "additions": 29,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,29 @@\n+package org.mbassy;\n+\n+/**\n+* Created with IntelliJ IDEA.\n+* User: benni\n+* Date: 11/12/12\n+* Time: 8:44 PM\n+* To change this template use File | Settings | File Templates.\n+*/\n+public class SimplePostCommand<T> implements IMessageBus.IPostCommand {\n+\n+    private T message;\n+    private MBassador mBassador;\n+\n+    public SimplePostCommand(MBassador mBassador, T message) {\n+        this.mBassador = mBassador;\n+        this.message = message;\n+    }\n+\n+    @Override\n+    public void now() {\n+        mBassador.publish(message);\n+    }\n+\n+    @Override\n+    public void asynchronously() {\n+        mBassador.publishAsync(message);\n+    }\n+}\n"
    },
    {
        "commit hash": "6aadcbe036b535732ef54f49cebc6498eb3f2d62",
        "previous commit hash": "3f7b80bdebfc8aad7e70f9bb1544aafc1449f156",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/common/ConcurrentLinkedBag.java",
            "additions": 0,
            "deletions": 159
        },
        "diff content": "@@ -1,159 +0,0 @@\n-package org.mbassy.common;\n-\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Iterator;\n-import java.util.WeakHashMap;\n-\n-/**\n- * This data structure is optimized for non-blocking reads even when write operations occur.\n- * Running read iterators will not be affected by add operations since writes always insert at the head of the\n- * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n- * been reached by the iterator will not appear in that iterator anymore.\n- *\n- * The structure uses weak references to the elements. Iterators automatically perform cleanups of\n- * garbace collect objects during iteration.\n- * No dedicated maintenance operations need to be called or run in background.\n- *\n- *\n- * <p/>\n- * @author bennidi\n- * Date: 2/12/12\n- */\n-public class ConcurrentLinkedBag<T> implements Iterable<T> {\n-\n-\n-\tprivate WeakHashMap<T, ListEntry<T>> entries = new WeakHashMap<T, ListEntry<T>>(); // maintain a map of entries for O(log n) lookup\n-\n-\tprivate ListEntry<T> head; // reference to the first element\n-\n-\tpublic ConcurrentLinkedBag<T> add(T element) {\n-\t\tif (element == null || entries.containsKey(element)) return this;\n-\t\tsynchronized (this) {\n-\t\t\tinsert(element);\n-\t\t}\n-\t\treturn this;\n-\t}\n-\n-\tprivate void insert(T element) {\n-\t\tif(head == null){\n-\t\t\thead = new ListEntry<T>(element);\n-\t\t}\n-\t\telse{\n-\t\t\thead = new ListEntry<T>(element, head);\n-\t\t}\n-\t\tentries.put(element, head);\n-\t}\n-\n-\tpublic ConcurrentLinkedBag<T> addAll(Iterable<T> elements) {\n-\t\tfor (T element : elements) {\n-\t\t\tif (element == null || entries.containsKey(element)) return this;\n-\t\t\tsynchronized (this) {\n-\t\t\t\tinsert(element);\n-\t\t\t}\n-\t\t}\n-\t\treturn this;\n-\t}\n-\n-\tpublic ConcurrentLinkedBag<T> remove(T element) {\n-\t\tif (!entries.containsKey(element)) return this;\n-\t\tsynchronized (this) {\n-\t\t\tListEntry<T> listelement = entries.get(element);\n-\t\t\tif(listelement != head){\n-\t\t\t\tlistelement.remove();\n-\t\t\t}\n-\t\t\telse{\n-\t\t\t\thead = head.next();\n-\t\t\t}\n-\t\t\tentries.remove(element);\n-\t\t}\n-\t\treturn this;\n-\t}\n-\n-\tpublic Iterator<T> iterator() {\n-\t\treturn new Iterator<T>() {\n-\n-\t\t\tprivate ListEntry<T> current = head;\n-\n-\t\t\tpublic boolean hasNext() {\n-                if(current == null) return false;\n-                T value = current.getValue();\n-                if(value == null){    // auto-removal of orphan references\n-                    remove();\n-                    return hasNext();\n-                }\n-                else{\n-                    return true;\n-                }\n-\t\t\t}\n-\n-\t\t\tpublic T next() {\n-\t\t\t\tif(current == null) return null;\n-\t\t\t\tT value = current.getValue();\n-\t\t\t\tif(value == null){    // auto-removal of orphan references\n-\t\t\t\t\tremove();\n-\t\t\t\t\treturn next();\n-\t\t\t\t}\n-\t\t\t\telse{\n-\t\t\t\t\tcurrent = current.next();\n-\t\t\t\t\treturn value;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tpublic void remove() {\n-\t\t\t\tif(current == null)return;\n-\t\t\t\tsynchronized (ConcurrentLinkedBag.this){\n-\t\t\t\tcurrent.remove();\n-\t\t\t\tcurrent = current.next();}\n-\t\t\t}\n-\t\t};\n-\t}\n-\n-\n-\tpublic class ListEntry<T> {\n-\n-\t\tprivate WeakReference<T> value;\n-\n-\t\tprivate ListEntry<T> next;\n-\n-\t\tprivate ListEntry<T> predecessor;\n-\n-\n-\t\tprivate ListEntry(T value) {\n-\t\t\tthis.value = new WeakReference<T>(value);\n-\t\t}\n-\n-\t\tprivate ListEntry(T value, ListEntry<T> next) {\n-\t\t\tthis(value);\n-\t\t\tthis.next = next;\n-\t\t\tnext.predecessor = this;\n-\t\t}\n-\n-\t\tpublic T getValue() {\n-\t\t\treturn value.get();\n-\t\t}\n-\n-\t\tpublic void remove(){\n-\t\t\tif(predecessor != null){\n-\t\t\t\tpredecessor.setNext(next());\n-\t\t\t}\n-\t\t\telse if(next() != null){\n-\t\t\t\tnext.predecessor = null;\n-\t\t\t}\n-\t\t}\n-\n-\t\tpublic void setNext(ListEntry<T> element) {\n-\t\t\tthis.next = element;\n-\t\t\tif(element != null)element.predecessor = this;\n-\t\t}\n-\n-\t\tpublic ListEntry<T> next() {\n-\t\t\treturn next;\n-\t\t}\n-\n-\t\tpublic boolean hasNext() {\n-\t\t\treturn next() != null;\n-\t\t}\n-\n-\t}\n-}\n"
    },
    {
        "commit hash": "6aadcbe036b535732ef54f49cebc6498eb3f2d62",
        "previous commit hash": "3f7b80bdebfc8aad7e70f9bb1544aafc1449f156",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/common/ConcurrentSet.java",
            "additions": 168,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,168 @@\n+package org.mbassy.common;\n+\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Iterator;\n+import java.util.WeakHashMap;\n+\n+/**\n+ * This data structure is optimized for non-blocking reads even when write operations occur.\n+ * Running read iterators will not be affected by add operations since writes always insert at the head of the\n+ * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n+ * been reached by the iterator will not appear in that iterator anymore.\n+ * <p/>\n+ * The structure uses weak references to the elements. Iterators automatically perform cleanups of\n+ * garbace collect objects during iteration.\n+ * No dedicated maintenance operations need to be called or run in background.\n+ * <p/>\n+ * <p/>\n+ * <p/>\n+ *\n+ * @author bennidi\n+ *         Date: 2/12/12\n+ */\n+public class ConcurrentSet<T> implements Iterable<T> {\n+\n+\n+    private WeakHashMap<T, Entry<T>> entries = new WeakHashMap<T, Entry<T>>(); // maintain a map of entries for O(log n) lookup\n+\n+    private Entry<T> head; // reference to the first element\n+\n+    public ConcurrentSet<T> add(T element) {\n+        if (element == null || entries.containsKey(element)) return this;\n+        synchronized (this) {\n+            insert(element);\n+        }\n+        return this;\n+    }\n+\n+    public boolean contains(T element){\n+        Entry<T> entry = entries.get(element);\n+        return entry != null && entry.getValue() != null;\n+    }\n+\n+    private void insert(T element) {\n+        if (entries.containsKey(element)) return;\n+        if (head == null) {\n+            head = new Entry<T>(element);\n+        } else {\n+            head = new Entry<T>(element, head);\n+        }\n+        entries.put(element, head);\n+    }\n+\n+    public int size(){\n+        return entries.size();\n+    }\n+\n+    public ConcurrentSet<T> addAll(Iterable<T> elements) {\n+        synchronized (this) {\n+            for (T element : elements) {\n+                if (element == null || entries.containsKey(element)) return this;\n+\n+                insert(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    public ConcurrentSet<T> remove(T element) {\n+        if (!entries.containsKey(element)) return this;\n+        synchronized (this) {\n+            Entry<T> listelement = entries.get(element);\n+            if(listelement == null)return this;\n+            if (listelement != head) {\n+                listelement.remove();\n+            } else {\n+                head = head.next();\n+            }\n+            entries.remove(element);\n+        }\n+        return this;\n+    }\n+\n+    public Iterator<T> iterator() {\n+        return new Iterator<T>() {\n+\n+            private Entry<T> current = head;\n+\n+            public boolean hasNext() {\n+                if (current == null) return false;\n+                T value = current.getValue();\n+                if (value == null) {    // auto-removal of orphan references\n+                    remove();\n+                    return hasNext();\n+                } else {\n+                    return true;\n+                }\n+            }\n+\n+            public T next() {\n+                if (current == null) return null;\n+                T value = current.getValue();\n+                if (value == null) {    // auto-removal of orphan references\n+                    remove();\n+                    return next();\n+                } else {\n+                    current = current.next();\n+                    return value;\n+                }\n+            }\n+\n+            public void remove() {\n+                if (current == null) return;\n+                synchronized (ConcurrentSet.this) {\n+                    current.remove();\n+                    current = current.next();\n+                }\n+            }\n+        };\n+    }\n+\n+\n+    public class Entry<T> {\n+\n+        private WeakReference<T> value;\n+\n+        private Entry<T> next;\n+\n+        private Entry<T> predecessor;\n+\n+\n+        private Entry(T value) {\n+            this.value = new WeakReference<T>(value);\n+        }\n+\n+        private Entry(T value, Entry<T> next) {\n+            this(value);\n+            this.next = next;\n+            next.predecessor = this;\n+        }\n+\n+        public T getValue() {\n+            return value.get();\n+        }\n+\n+        public void remove() {\n+            if (predecessor != null) {\n+                predecessor.setNext(next());\n+            } else if (next() != null) {\n+                next.predecessor = null;\n+            }\n+        }\n+\n+        public void setNext(Entry<T> element) {\n+            this.next = element;\n+            if (element != null) element.predecessor = this;\n+        }\n+\n+        public Entry<T> next() {\n+            return next;\n+        }\n+\n+        public boolean hasNext() {\n+            return next() != null;\n+        }\n+\n+    }\n+}\n"
    },
    {
        "commit hash": "6aadcbe036b535732ef54f49cebc6498eb3f2d62",
        "previous commit hash": "3f7b80bdebfc8aad7e70f9bb1544aafc1449f156",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/ConcurrentSetTest.java",
            "additions": 190,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,190 @@\n+package org.mbassy;\n+\n+import junit.framework.Assert;\n+import org.junit.Test;\n+import org.mbassy.common.ConcurrentSet;\n+\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Random;\n+\n+/**\n+ * Created with IntelliJ IDEA.\n+ * User: benni\n+ * Date: 11/12/12\n+ * Time: 3:02 PM\n+ * To change this template use File | Settings | File Templates.\n+ */\n+public class ConcurrentSetTest extends  UnitTest{\n+\n+    private int numberOfElements = 100000;\n+\n+    private int numberOfThreads = 50;\n+\n+\n+    @Test\n+    public void testIterator(){\n+        final HashSet<Object> distinct = new HashSet<Object>();\n+\n+        final ConcurrentSet<Object> target = new ConcurrentSet<Object>();\n+        Random rand = new Random();\n+\n+        for(int i=0;i < numberOfElements ; i++){\n+            Object candidate = new Object();\n+\n+            if(rand.nextInt() % 3 == 0){\n+                distinct.add(candidate);\n+            }\n+            target.add(candidate);\n+        }\n+\n+        runGC();\n+\n+        ConcurrentExecutor.runConcurrent(new Runnable() {\n+            @Override\n+            public void run() {\n+                for(Object src : target){\n+                    // do nothing\n+                    // just iterate to trigger automatic clean up\n+                    System.currentTimeMillis();\n+                }\n+            }\n+        }, numberOfThreads);\n+\n+\n+\n+\n+        for(Object tar : target){\n+            Assert.assertTrue(distinct.contains(tar));\n+        }\n+\n+\n+\n+    }\n+\n+\n+        @Test\n+    public void testInsert(){\n+        final LinkedList<Object> duplicates = new LinkedList<Object>();\n+        final HashSet<Object> distinct = new HashSet<Object>();\n+\n+        final ConcurrentSet<Object> target = new ConcurrentSet<Object>();\n+        Random rand = new Random();\n+\n+        Object candidate = new Object();\n+        for(int i=0;i < numberOfElements ; i++){\n+            if(rand.nextInt() % 3 == 0){\n+                candidate = new Object();\n+            }\n+            duplicates.add(candidate);\n+            distinct.add(candidate);\n+        }\n+\n+\n+        ConcurrentExecutor.runConcurrent(new Runnable() {\n+            @Override\n+            public void run() {\n+                for(Object src : duplicates){\n+                    target.add(src);\n+                }\n+            }\n+        }, numberOfThreads);\n+\n+        pause(3000);\n+\n+\n+        for(Object tar : target){\n+            Assert.assertTrue(distinct.contains(tar));\n+        }\n+\n+        for(Object src : distinct){\n+            Assert.assertTrue(target.contains(src));\n+        }\n+\n+        Assert.assertEquals(distinct.size(), target.size());\n+    }\n+\n+\n+\n+    @Test\n+    public void testRemove1(){\n+        final HashSet<Object> source = new HashSet<Object>();\n+        final HashSet<Object> toRemove = new HashSet<Object>();\n+\n+        final ConcurrentSet<Object> target = new ConcurrentSet<Object>();\n+        for(int i=0;i < numberOfElements ; i++){\n+            Object candidate = new Object();\n+            source.add(candidate);\n+            if(i % 3 == 0){\n+                toRemove.add(candidate);\n+            }\n+        }\n+\n+\n+        ConcurrentExecutor.runConcurrent(new Runnable() {\n+            @Override\n+            public void run() {\n+                for(Object src : source){\n+                    target.add(src);\n+                }\n+            }\n+        }, numberOfThreads);\n+\n+        ConcurrentExecutor.runConcurrent(new Runnable() {\n+            @Override\n+            public void run() {\n+                for(Object src : toRemove){\n+                    target.remove(src);\n+                }\n+            }\n+        }, numberOfThreads);\n+\n+        pause(3000);\n+\n+        for(Object tar : target){\n+            Assert.assertTrue(!toRemove.contains(tar));\n+        }\n+\n+        for(Object src : source){\n+            if(!toRemove.contains(src))Assert.assertTrue(target.contains(src));\n+        }\n+    }\n+\n+    @Test\n+    public void testRemove2(){\n+        final HashSet<Object> source = new HashSet<Object>();\n+        final HashSet<Object> toRemove = new HashSet<Object>();\n+\n+        final ConcurrentSet<Object> target = new ConcurrentSet<Object>();\n+        for(int i=0;i < numberOfElements ; i++){\n+            Object candidate = new Object();\n+            source.add(candidate);\n+            if(i % 3 == 0){\n+                toRemove.add(candidate);\n+            }\n+        }\n+\n+\n+        ConcurrentExecutor.runConcurrent(new Runnable() {\n+            @Override\n+            public void run() {\n+                for(Object src : source){\n+                    target.add(src);\n+                    if(toRemove.contains(src))\n+                        target.remove(src);\n+                }\n+            }\n+        }, numberOfThreads);\n+\n+        pause(3000);\n+\n+        for(Object tar : target){\n+            Assert.assertTrue(!toRemove.contains(tar));\n+        }\n+\n+        for(Object src : source){\n+            if(!toRemove.contains(src))Assert.assertTrue(target.contains(src));\n+        }\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "6aadcbe036b535732ef54f49cebc6498eb3f2d62",
        "previous commit hash": "3f7b80bdebfc8aad7e70f9bb1544aafc1449f156",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/MBassadorTest.java",
            "additions": 28,
            "deletions": 0
        },
        "diff content": "@@ -19,6 +19,34 @@ import java.util.concurrent.atomic.AtomicInteger;\n public class MBassadorTest {\n \n \n+\n+    @Test\n+    public void testSubscribe() throws InterruptedException {\n+\n+        MBassador bus = new MBassador();\n+        int listenerCount = 1000;\n+\n+        for (int i = 1; i <= listenerCount; i++) {\n+            EventingTestBean bean = new EventingTestBean();\n+            bus.subscribe(bean);\n+            bus.unsubscribe(new EventingTestBean());\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testUnSubscribe() throws InterruptedException {\n+\n+        MBassador bus = new MBassador();\n+        int listenerCount = 1000;\n+\n+        for (int i = 1; i <= listenerCount; i++) {\n+            bus.unsubscribe(new EventingTestBean());\n+\n+        }\n+    }\n+\n+\n \t@Test\n \tpublic void testAsynchronous() throws InterruptedException {\n \n"
    },
    {
        "commit hash": "6aadcbe036b535732ef54f49cebc6498eb3f2d62",
        "previous commit hash": "3f7b80bdebfc8aad7e70f9bb1544aafc1449f156",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/UnitTest.java",
            "additions": 34,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,34 @@\n+package org.mbassy;\n+\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * Created with IntelliJ IDEA.\n+ * User: benni\n+ * Date: 11/12/12\n+ * Time: 3:16 PM\n+ * To change this template use File | Settings | File Templates.\n+ */\n+public class UnitTest {\n+\n+\n+    public void pause(long ms) {\n+        try {\n+            Thread.sleep(ms);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n+        }\n+    }\n+\n+    public void pause() {\n+        pause(10);\n+    }\n+\n+\n+    public void runGC() {\n+        WeakReference ref = new WeakReference<Object>(new Object());\n+        while(ref.get() != null) {\n+            System.gc();\n+        }\n+    }\n+}\n"
    },
    {
        "commit hash": "3f7b80bdebfc8aad7e70f9bb1544aafc1449f156",
        "previous commit hash": "1f4f087d7e3509708f5756566619375f5ecc67f1",
        "diff stats": {
            "file_path": "LICENSE",
            "additions": 13,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,13 @@\n+MIT License\n+\n+Copyright (c) 2012 Benjamin Diedrichsen\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n+to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n+and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
    },
    {
        "commit hash": "3f7b80bdebfc8aad7e70f9bb1544aafc1449f156",
        "previous commit hash": "1f4f087d7e3509708f5756566619375f5ecc67f1",
        "diff stats": {
            "file_path": "README.md",
            "additions": 4,
            "deletions": 0
        },
        "diff content": "@@ -75,6 +75,10 @@ Message puclication:\n + Maven dependency: Add Mbassador to your project using maven. Coming soon!\n + Message handler priority: Message handlers can specify priority to influence order of message delivery\n \n+<h2>License</h2>\n+\n+This project is distributed under the terms of the MIT License. See file \"LICENSE\" for further reference.\n+\n \n \n \n"
    },
    {
        "commit hash": "1f4f087d7e3509708f5756566619375f5ecc67f1",
        "previous commit hash": "9b1c586398bd85f1a36692d4ec2186a3ae82ac03",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 2
        },
        "diff content": "@@ -5,9 +5,9 @@ Mbassador is a very light-weight message bus implementation following the publis\n for ease of use and aims to be resource efficient and very fast. It was inspired by google guava's event bus which lacked some\n features like weak references at that time. At its core it offers the following:\n \n-+ <em><strong>Annotation driven</em></strong>: </br>To define and customize a message handler simply mark it with @Listener annotation\n++ <em><strong>Annotation driven</em></strong>: To define and customize a message handler simply mark it with @Listener annotation\n + <em><strong>Delivers everything</em></strong>: Messages must not implement any interface and can be of any type (-> message bus is typed using generics with upper\n-bound being Object.class).Class hierarchy of messages are considered during message delivery. This means that listeners will also receive\n+bound being Object.class). The class hierarchy of a message is considered during message delivery. This means that listeners will also receive\n subtypes of the message type they are listening for, e.g. a listener for Object.class receives everything.\n + <em><strong>Synchronous and asynchronous message delivery</em></strong>: A handler can be invoked to handle a message either synchronously or\n asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method\n"
    },
    {
        "commit hash": "9b1c586398bd85f1a36692d4ec2186a3ae82ac03",
        "previous commit hash": "6a52f2dadf7f5f11878c23c9bf4b263e49a1186c",
        "diff stats": {
            "file_path": "README.md",
            "additions": 7,
            "deletions": 7
        },
        "diff content": "@@ -5,21 +5,21 @@ Mbassador is a very light-weight message bus implementation following the publis\n for ease of use and aims to be resource efficient and very fast. It was inspired by google guava's event bus which lacked some\n features like weak references at that time. At its core it offers the following:\n \n-+ <em>Annotation driven</em>: To define and customize a message handler simply mark it with @Listener annotation\n-+ <em>Delivers everything</em>: Messages must not implement any interface and can be of any type (-> message bus is typed using generics with upper\n++ <em><strong>Annotation driven</em></strong>: </br>To define and customize a message handler simply mark it with @Listener annotation\n++ <em><strong>Delivers everything</em></strong>: Messages must not implement any interface and can be of any type (-> message bus is typed using generics with upper\n bound being Object.class).Class hierarchy of messages are considered during message delivery. This means that listeners will also receive\n subtypes of the message type they are listening for, e.g. a listener for Object.class receives everything.\n-+ <em>Synchronous and asynchronous message delivery</em>: A handler can be invoked to handle a message either synchronously or\n++ <em><strong>Synchronous and asynchronous message delivery</em></strong>: A handler can be invoked to handle a message either synchronously or\n asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method\n blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch\n-+ <em>Weak references</em>: Mbassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister\n++ <em><strong>Weak references</em></strong>: Mbassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister\n listeners that are not used anymore (of course it is also possible to explicitly unregister a listener if needed). This is very comfortable\n in certain environments where objects are created by frameworks, i.e. spring, guice etc. Just stuff everything into the message bus, it will\n ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.\n-+ <em>Filtering</em>: Mbassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to\n++ <em><strong>Filtering</em></strong>: Mbassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to\n a single message handler\n-+ <em>Error handling</em>: Errors during message delivery are sent to an error handler of which a custom implementation can easily be plugged-in.\n-+ <em>Ease of Use</em>: Using Mbassador in your project is very easy. Create as many instances of Mbassador as you like (usually a singleton will do),\n++ <em><strong>Error handling</em></strong>: Errors during message delivery are sent to an error handler of which a custom implementation can easily be plugged-in.\n++ <em><strong>Ease of Use</em></strong>: Using Mbassador in your project is very easy. Create as many instances of Mbassador as you like (usually a singleton will do),\n mark and configure your message handlers with @Listener annotations and finally register the listeners at any Mbassador instance. Start\n sending messages to your listeners using one of Mbassador's publication methods (sync or async). Done!\n \n"
    },
    {
        "commit hash": "6a52f2dadf7f5f11878c23c9bf4b263e49a1186c",
        "previous commit hash": "b0aed604b451f234232c8d452ddb20dd754cb230",
        "diff stats": {
            "file_path": "README.md",
            "additions": 8,
            "deletions": 9
        },
        "diff content": "@@ -5,22 +5,21 @@ Mbassador is a very light-weight message bus implementation following the publis\n for ease of use and aims to be resource efficient and very fast. It was inspired by google guava's event bus which lacked some\n features like weak references at that time. At its core it offers the following:\n \n-+ Delivers everything: Messages must not implement any interface and can be of any type (-> message bus is typed using generics with upper\n-bound being Object.class)\n-+ Follows type hierarchy: Class hierarchy of messages are considered during message delivery. This means that listeners will also receive\n++ <em>Annotation driven</em>: To define and customize a message handler simply mark it with @Listener annotation\n++ <em>Delivers everything</em>: Messages must not implement any interface and can be of any type (-> message bus is typed using generics with upper\n+bound being Object.class).Class hierarchy of messages are considered during message delivery. This means that listeners will also receive\n subtypes of the message type they are listening for, e.g. a listener for Object.class receives everything.\n-+ Annotation driven: To define and customize a message handler simply mark it with @Listener annotation\n-+ Synchronous and asynchronous message delivery: A handler can be invoked to handle a message either synchronously or\n++ <em>Synchronous and asynchronous message delivery</em>: A handler can be invoked to handle a message either synchronously or\n asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method\n blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch\n-+ Weak references: Mbassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister\n++ <em>Weak references</em>: Mbassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister\n listeners that are not used anymore (of course it is also possible to explicitly unregister a listener if needed). This is very comfortable\n in certain environments where objects are created by frameworks, i.e. spring, guice etc. Just stuff everything into the message bus, it will\n ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.\n-+ Filtering: Mbassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to\n++ <em>Filtering</em>: Mbassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to\n a single message handler\n-+ Error handling: Errors during message delivery are sent to an error handler of which a custom implementation can easily be plugged-in.\n-+ Ease of Use: Using Mbassador in your project is very easy. Create as many instances of Mbassador as you like (usually a singleton will do),\n++ <em>Error handling</em>: Errors during message delivery are sent to an error handler of which a custom implementation can easily be plugged-in.\n++ <em>Ease of Use</em>: Using Mbassador in your project is very easy. Create as many instances of Mbassador as you like (usually a singleton will do),\n mark and configure your message handlers with @Listener annotations and finally register the listeners at any Mbassador instance. Start\n sending messages to your listeners using one of Mbassador's publication methods (sync or async). Done!\n \n"
    },
    {
        "commit hash": "b0aed604b451f234232c8d452ddb20dd754cb230",
        "previous commit hash": "a6b436beb62b52854afd43e7efff9143b8751f39",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -45,7 +45,7 @@ Listener definition (in any bean):\n \n \t\t// this handler will receive events of type SubTestEvent\n         // or any subtabe and that passes the given filter(s)\n-        @Listener({@Filter(SpecialEventsOnly.class),@Filter(SpecialEventsOnly.class)})\n+        @Listener({@Filter(SpecialEventsOnly.class),@Filter(AnotherFilter.class)})\n         public void handleFiltered(SubTestEvent event) {\n            //do something special here\n         }\n"
    },
    {
        "commit hash": "a6b436beb62b52854afd43e7efff9143b8751f39",
        "previous commit hash": "d2a6395d4858da07e9093a0f9a62e543e37c4b3f",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -45,7 +45,7 @@ Listener definition (in any bean):\n \n \t\t// this handler will receive events of type SubTestEvent\n         // or any subtabe and that passes the given filter(s)\n-        @Listener({@Filter(value = SpecialEventsOnly.class),@Filter(value = SpecialEventsOnly.class)})\n+        @Listener({@Filter(SpecialEventsOnly.class),@Filter(SpecialEventsOnly.class)})\n         public void handleFiltered(SubTestEvent event) {\n            //do something special here\n         }\n"
    },
    {
        "commit hash": "d2a6395d4858da07e9093a0f9a62e543e37c4b3f",
        "previous commit hash": "4ce801c08642d8b347aafdc4abbe627a90740931",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 0
        },
        "diff content": "@@ -25,7 +25,7 @@ mark and configure your message handlers with @Listener annotations and finally\n sending messages to your listeners using one of Mbassador's publication methods (sync or async). Done!\n \n \n----------------------------------------\n+\n  <h2>Usage</h2>\n \n Listener definition (in any bean):\n@@ -70,7 +70,7 @@ Message puclication:\n         bus.publishAsync(event); //returns immediately, publication will continue asynchronously\n         bus.publish(subEvent);   // will return after each handler has been invoked\n \n----------------------------------------\n+\n <h2>Planned features</h2>\n \n + Maven dependency: Add Mbassador to your project using maven. Coming soon!\n"
    },
    {
        "commit hash": "4ce801c08642d8b347aafdc4abbe627a90740931",
        "previous commit hash": "db5803eb033a3cc35ec200d19c0e438ffcc03e2a",
        "diff stats": {
            "file_path": "README.md",
            "additions": 0,
            "deletions": 3
        },
        "diff content": "@@ -26,7 +26,6 @@ sending messages to your listeners using one of Mbassador's publication methods\n \n \n ---------------------------------------\n-\n  <h2>Usage</h2>\n \n Listener definition (in any bean):\n@@ -72,8 +71,6 @@ Message puclication:\n         bus.publish(subEvent);   // will return after each handler has been invoked\n \n ---------------------------------------\n-\n-\n <h2>Planned features</h2>\n \n + Maven dependency: Add Mbassador to your project using maven. Coming soon!\n"
    },
    {
        "commit hash": "db5803eb033a3cc35ec200d19c0e438ffcc03e2a",
        "previous commit hash": "279c9b6a7a7fd4098a89099b55aef5c02ec24677",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -29,8 +29,6 @@ sending messages to your listeners using one of Mbassador's publication methods\n \n  <h2>Usage</h2>\n \n----------------------------------------\n-\n Listener definition (in any bean):\n \n         // every event of type TestEvent or any subtype will be delivered\n@@ -76,7 +74,7 @@ Message puclication:\n ---------------------------------------\n \n \n-Planned features:\n+<h2>Planned features</h2>\n \n + Maven dependency: Add Mbassador to your project using maven. Coming soon!\n + Message handler priority: Message handlers can specify priority to influence order of message delivery\n"
    },
    {
        "commit hash": "279c9b6a7a7fd4098a89099b55aef5c02ec24677",
        "previous commit hash": "591e107f4e379dba9117505eccba1a0aa3efb339",
        "diff stats": {
            "file_path": "README.md",
            "additions": 9,
            "deletions": 3
        },
        "diff content": "@@ -27,9 +27,11 @@ sending messages to your listeners using one of Mbassador's publication methods\n \n ---------------------------------------\n \n-Usage:\n+ <h2>Usage</h2>\n \n-Listener Definition (in any Bean):\n+---------------------------------------\n+\n+Listener definition (in any bean):\n \n         // every event of type TestEvent or any subtype will be delivered\n         // to this handler\n@@ -57,7 +59,11 @@ Creation of message bus and registration of listeners:\n         // bind it to any upper bound\n         MBassador<TestEvent> bus = new MBassador<TestEvent();\n         ListeningBean listener = new ListeningBean();\n-        bus.subscribe(listener)\n+        // the listener will be registered using a weak-reference\n+        bus.subscribe(listener);\n+        // objects without handlers will be ignored\n+        bus.subscribe(new ClassWithoutAnyDefinedHandlers());\n+\n \n Message puclication:\n \n"
    },
    {
        "commit hash": "591e107f4e379dba9117505eccba1a0aa3efb339",
        "previous commit hash": "dbbeabebc96cc349f980a5f4f02b34189779b163",
        "diff stats": {
            "file_path": "README.md",
            "additions": 46,
            "deletions": 0
        },
        "diff content": "@@ -24,6 +24,52 @@ a single message handler\n mark and configure your message handlers with @Listener annotations and finally register the listeners at any Mbassador instance. Start\n sending messages to your listeners using one of Mbassador's publication methods (sync or async). Done!\n \n+\n+---------------------------------------\n+\n+Usage:\n+\n+Listener Definition (in any Bean):\n+\n+        // every event of type TestEvent or any subtype will be delivered\n+        // to this handler\n+        @Listener\n+\t\tpublic void handleTestEvent(TestEvent event) {\n+\t\t\t// do something\n+\t\t}\n+\n+        // this handler will be invoked asynchronously\n+\t\t@Listener(mode = Listener.Dispatch.Asynchronous)\n+\t\tpublic void handleSubTestEvent(SubTestEvent event) {\n+            // do something more expensive here\n+\t\t}\n+\n+\t\t// this handler will receive events of type SubTestEvent\n+        // or any subtabe and that passes the given filter(s)\n+        @Listener({@Filter(value = SpecialEventsOnly.class),@Filter(value = SpecialEventsOnly.class)})\n+        public void handleFiltered(SubTestEvent event) {\n+           //do something special here\n+        }\n+\n+Creation of message bus and registration of listeners:\n+\n+        // create as many instances as necessary\n+        // bind it to any upper bound\n+        MBassador<TestEvent> bus = new MBassador<TestEvent();\n+        ListeningBean listener = new ListeningBean();\n+        bus.subscribe(listener)\n+\n+Message puclication:\n+\n+        TestEvent event = new TestEvent();\n+        TestEvent subEvent = new SubTestEvent();\n+\n+        bus.publishAsync(event); //returns immediately, publication will continue asynchronously\n+        bus.publish(subEvent);   // will return after each handler has been invoked\n+\n+---------------------------------------\n+\n+\n Planned features:\n \n + Maven dependency: Add Mbassador to your project using maven. Coming soon!\n"
    },
    {
        "commit hash": "591e107f4e379dba9117505eccba1a0aa3efb339",
        "previous commit hash": "dbbeabebc96cc349f980a5f4f02b34189779b163",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/filter/MessageFilter.java",
            "additions": 9,
            "deletions": 0
        },
        "diff content": "@@ -28,4 +28,13 @@ public interface MessageFilter {\n \t\t}\n \t}\n \n+    public static final class None implements MessageFilter {\n+\n+        @Override\n+        public boolean accepts(Object event, Object listener) {\n+            return false;\n+        }\n+    }\n+\n+\n }\n"
    },
    {
        "commit hash": "591e107f4e379dba9117505eccba1a0aa3efb339",
        "previous commit hash": "dbbeabebc96cc349f980a5f4f02b34189779b163",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/MBassadorTest.java",
            "additions": 12,
            "deletions": 1
        },
        "diff content": "@@ -2,6 +2,8 @@ package org.mbassy;\n \n import org.junit.Assert;\n import org.junit.Test;\n+import org.mbassy.filter.Filter;\n+import org.mbassy.filter.MessageFilter;\n \n import java.util.ArrayList;\n import java.util.List;\n@@ -149,17 +151,26 @@ public class MBassadorTest {\n \n \tpublic class EventingTestBean {\n \n-\n+        // every event of type TestEvent or any subtype will be delivered\n+        // to this listener\n \t\t@Listener\n \t\tpublic void handleTestEvent(TestEvent event) {\n \t\t\tevent.counter.incrementAndGet();\n \t\t}\n \n+        // this handler will be invoked asynchronously\n \t\t@Listener(mode = Listener.Dispatch.Asynchronous)\n \t\tpublic void handleSubTestEvent(SubTestEvent event) {\n             event.counter.incrementAndGet();\n \t\t}\n \n+        // this handler will receive events of type SubTestEvent\n+        // or any subtabe and that passes the given filter\n+        @Listener({@Filter(MessageFilter.None.class),@Filter(MessageFilter.All.class)})\n+        public void handleFiltered(SubTestEvent event) {\n+            event.counter.incrementAndGet();\n+        }\n+\n \n \t}\n \n"
    },
    {
        "commit hash": "dbbeabebc96cc349f980a5f4f02b34189779b163",
        "previous commit hash": "d316b4c5ae24011b48d6e8865e53ae5e6ab03dd9",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 12,
            "deletions": 0
        },
        "diff content": "@@ -23,6 +23,18 @@\n \t\t\t<scope>compile</scope>\n \t\t</dependency>\n \n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>slf4j-api</artifactId>\n+            <version>1.5.2</version>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>slf4j-log4j12</artifactId>\n+            <version>1.5.2</version>\n+        </dependency>\n+\n \t</dependencies>\n \n \t<build>\n"
    },
    {
        "commit hash": "dbbeabebc96cc349f980a5f4f02b34189779b163",
        "previous commit hash": "d316b4c5ae24011b48d6e8865e53ae5e6ab03dd9",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/common/ReflectionUtils.java",
            "additions": 1,
            "deletions": 2
        },
        "diff content": "@@ -1,6 +1,5 @@\n package org.mbassy.common;\n \n-import com.google.common.base.Predicate;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -35,7 +34,7 @@ public class ReflectionUtils {\n \t\treturn methods;\n \t}\n \n-\tpublic static List<Field> getFields(Predicate<Field> condition, Class<?> target) {\n+\tpublic static List<Field> getFields(IPredicate<Field> condition, Class<?> target) {\n \t\tList<Field> methods = new LinkedList<Field>();\n \t\ttry {\n \t\t\tfor (Field method : target.getDeclaredFields()) {\n"
    },
    {
        "commit hash": "d316b4c5ae24011b48d6e8865e53ae5e6ab03dd9",
        "previous commit hash": "0d3228455641804df4b0c05858ec3a4272df452c",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -3,7 +3,7 @@ Mbassador\n \n Mbassador is a very light-weight message bus implementation following the publish subscribe pattern. It is designed\n for ease of use and aims to be resource efficient and very fast. It was inspired by google guava's event bus which lacked some\n-features like weak references and ended up being even faster but offering more features. At its core it offers the following:\n+features like weak references at that time. At its core it offers the following:\n \n + Delivers everything: Messages must not implement any interface and can be of any type (-> message bus is typed using generics with upper\n bound being Object.class)\n"
    },
    {
        "commit hash": "0d3228455641804df4b0c05858ec3a4272df452c",
        "previous commit hash": "cd4dd13555917505ede1f0e7966bea2843a5d8af",
        "diff stats": {
            "file_path": "README.md",
            "additions": 2,
            "deletions": 0
        },
        "diff content": "@@ -7,6 +7,8 @@ features like weak references and ended up being even faster but offering more f\n \n + Delivers everything: Messages must not implement any interface and can be of any type (-> message bus is typed using generics with upper\n bound being Object.class)\n++ Follows type hierarchy: Class hierarchy of messages are considered during message delivery. This means that listeners will also receive\n+subtypes of the message type they are listening for, e.g. a listener for Object.class receives everything.\n + Annotation driven: To define and customize a message handler simply mark it with @Listener annotation\n + Synchronous and asynchronous message delivery: A handler can be invoked to handle a message either synchronously or\n asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method\n"
    },
    {
        "commit hash": "cd4dd13555917505ede1f0e7966bea2843a5d8af",
        "previous commit hash": "c971e736a05dacd1a61983d7fb0cc8e8bf8468d7",
        "diff stats": {
            "file_path": "README.md",
            "additions": 8,
            "deletions": 0
        },
        "diff content": "@@ -22,3 +22,11 @@ a single message handler\n mark and configure your message handlers with @Listener annotations and finally register the listeners at any Mbassador instance. Start\n sending messages to your listeners using one of Mbassador's publication methods (sync or async). Done!\n \n+Planned features:\n+\n++ Maven dependency: Add Mbassador to your project using maven. Coming soon!\n++ Message handler priority: Message handlers can specify priority to influence order of message delivery\n+\n+\n+\n+\n"
    },
    {
        "commit hash": "c971e736a05dacd1a61983d7fb0cc8e8bf8468d7",
        "previous commit hash": "924fb5e93b575bdeb55f1f5c9ae6245ff5844776",
        "diff stats": {
            "file_path": "README.md",
            "additions": 1,
            "deletions": 1
        },
        "diff content": "@@ -17,7 +17,7 @@ in certain environments where objects are created by frameworks, i.e. spring, gu\n ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.\n + Filtering: Mbassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to\n a single message handler\n-+ Error handling: Errors during message delivery are sent to an error handler of which you might provide a custom implementation.\n++ Error handling: Errors during message delivery are sent to an error handler of which a custom implementation can easily be plugged-in.\n + Ease of Use: Using Mbassador in your project is very easy. Create as many instances of Mbassador as you like (usually a singleton will do),\n mark and configure your message handlers with @Listener annotations and finally register the listeners at any Mbassador instance. Start\n sending messages to your listeners using one of Mbassador's publication methods (sync or async). Done!\n"
    },
    {
        "commit hash": "924fb5e93b575bdeb55f1f5c9ae6245ff5844776",
        "previous commit hash": "ddfd9595b119dbeca15b2daddb7643e0ff9f42b1",
        "diff stats": {
            "file_path": ".gitignore",
            "additions": 5,
            "deletions": 1
        },
        "diff content": "@@ -1,8 +1,12 @@\n-*.class\n+# idea project settings #\n+*.iml\n \n # Package Files #\n *.jar\n *.war\n *.ear\n \n+\n+# root of compiled classes #\n target/**/*\n+*.class\n"
    },
    {
        "commit hash": "924fb5e93b575bdeb55f1f5c9ae6245ff5844776",
        "previous commit hash": "ddfd9595b119dbeca15b2daddb7643e0ff9f42b1",
        "diff stats": {
            "file_path": "README.md",
            "additions": 22,
            "deletions": 2
        },
        "diff content": "@@ -1,4 +1,24 @@\n-mbassador\n+Mbassador\n =========\n \n-Home of the source of the mbassador message bus\n\\ No newline at end of file\n+Mbassador is a very light-weight message bus implementation following the publish subscribe pattern. It is designed\n+for ease of use and aims to be resource efficient and very fast. It was inspired by google guava's event bus which lacked some\n+features like weak references and ended up being even faster but offering more features. At its core it offers the following:\n+\n++ Delivers everything: Messages must not implement any interface and can be of any type (-> message bus is typed using generics with upper\n+bound being Object.class)\n++ Annotation driven: To define and customize a message handler simply mark it with @Listener annotation\n++ Synchronous and asynchronous message delivery: A handler can be invoked to handle a message either synchronously or\n+asynchronously. This is configurable for each handler via annotations. Message publication itself supports synchronous (method\n+blocks until messages are delivered to all handlers) or asynchronous (fire and forget) dispatch\n++ Weak references: Mbassador uses weak references to all listening objects to relieve the programmer of the burden to explicitly unregister\n+listeners that are not used anymore (of course it is also possible to explicitly unregister a listener if needed). This is very comfortable\n+in certain environments where objects are created by frameworks, i.e. spring, guice etc. Just stuff everything into the message bus, it will\n+ignore objects without message handlers and automatically clean-up orphaned weak references after the garbage collector has done its job.\n++ Filtering: Mbassador offers static message filtering. Filters are configured using annotations and multiple filters can be attached to\n+a single message handler\n++ Error handling: Errors during message delivery are sent to an error handler of which you might provide a custom implementation.\n++ Ease of Use: Using Mbassador in your project is very easy. Create as many instances of Mbassador as you like (usually a singleton will do),\n+mark and configure your message handlers with @Listener annotations and finally register the listeners at any Mbassador instance. Start\n+sending messages to your listeners using one of Mbassador's publication methods (sync or async). Done!\n+\n"
    },
    {
        "commit hash": "ddfd9595b119dbeca15b2daddb7643e0ff9f42b1",
        "previous commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "diff stats": {
            "file_path": ".gitignore",
            "additions": 8,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,8 @@\n+*.class\n+\n+# Package Files #\n+*.jar\n+*.war\n+*.ear\n+\n+target/**/*\n"
    },
    {
        "commit hash": "ddfd9595b119dbeca15b2daddb7643e0ff9f42b1",
        "previous commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "diff stats": {
            "file_path": "mbassador.iml",
            "additions": 0,
            "deletions": 17
        },
        "diff content": "@@ -1,17 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_6\" inherit-compiler-output=\"false\">\n-    <output url=\"file://$MODULE_DIR$/target/classes\" />\n-    <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n-    <content url=\"file://$MODULE_DIR$\">\n-      <sourceFolder url=\"file://$MODULE_DIR$/src/main/java\" isTestSource=\"false\" />\n-      <sourceFolder url=\"file://$MODULE_DIR$/src/test/java\" isTestSource=\"true\" />\n-      <excludeFolder url=\"file://$MODULE_DIR$/target\" />\n-    </content>\n-    <orderEntry type=\"inheritedJdk\" />\n-    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n-    <orderEntry type=\"library\" name=\"Maven: junit:junit:4.10\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.hamcrest:hamcrest-core:1.1\" level=\"project\" />\n-  </component>\n-</module>\n-\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": ".gitignore",
            "additions": 0,
            "deletions": 8
        },
        "diff content": "@@ -1,8 +0,0 @@\n-*.class\n-\n-# Package Files #\n-*.jar\n-*.war\n-*.ear\n-\n-target/**/*\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/Listener$Dispatch.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/Listener$Dispatch.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/Listener.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/Listener.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/MBassador$1.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/MBassador$1.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/MBassador$2.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/MBassador$2.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/MBassador$ConsoleLogger.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/MBassador$ConsoleLogger.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/MBassador$Subscription$1.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/MBassador$Subscription$1.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/MBassador$Subscription.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/MBassador$Subscription.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/MBassador.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/MBassador.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/common/ConcurrentLinkedBag$1.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/common/ConcurrentLinkedBag$1.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/common/ConcurrentLinkedBag$ListEntry.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/common/ConcurrentLinkedBag$ListEntry.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/common/ConcurrentLinkedBag.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/common/ConcurrentLinkedBag.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/common/IPredicate.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/common/IPredicate.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/common/IPublicationErrorHandler.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/common/IPublicationErrorHandler.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/common/PublicationError.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/common/PublicationError.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/common/ReflectionUtils.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/common/ReflectionUtils.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/filter/Filter.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/filter/Filter.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/filter/MessageFilter$All.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/filter/MessageFilter$All.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/filter/MessageFilter.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/classes/org/mbassy/filter/MessageFilter.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/test-classes/org/mbassy/ConcurrentExecutor$1.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/test-classes/org/mbassy/ConcurrentExecutor$1.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/test-classes/org/mbassy/ConcurrentExecutor.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/test-classes/org/mbassy/ConcurrentExecutor.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/test-classes/org/mbassy/MBassadorTest$1.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/test-classes/org/mbassy/MBassadorTest$1.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/test-classes/org/mbassy/MBassadorTest$2.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/test-classes/org/mbassy/MBassadorTest$2.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/test-classes/org/mbassy/MBassadorTest$EventingTestBean.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/test-classes/org/mbassy/MBassadorTest$EventingTestBean.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/test-classes/org/mbassy/MBassadorTest$SubTestEvent.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/test-classes/org/mbassy/MBassadorTest$SubTestEvent.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/test-classes/org/mbassy/MBassadorTest$TestEvent.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/test-classes/org/mbassy/MBassadorTest$TestEvent.class and /dev/null differ\n"
    },
    {
        "commit hash": "f6d01fdbd026f7db8b07b4bad7b9c61cd30a7224",
        "previous commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "diff stats": {
            "file_path": "target/test-classes/org/mbassy/MBassadorTest.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files a/target/test-classes/org/mbassy/MBassadorTest.class and /dev/null differ\n"
    },
    {
        "commit hash": "bf84dfceac990b1f2c15d70b69616366d5f36385",
        "previous commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "diff stats": {
            "file_path": ".gitignore",
            "additions": 8,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,8 @@\n+*.class\n+\n+# Package Files #\n+*.jar\n+*.war\n+*.ear\n+\n+target/**/*\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "mbassador.iml",
            "additions": 17,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_6\" inherit-compiler-output=\"false\">\n+    <output url=\"file://$MODULE_DIR$/target/classes\" />\n+    <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n+    <content url=\"file://$MODULE_DIR$\">\n+      <sourceFolder url=\"file://$MODULE_DIR$/src/main/java\" isTestSource=\"false\" />\n+      <sourceFolder url=\"file://$MODULE_DIR$/src/test/java\" isTestSource=\"true\" />\n+      <excludeFolder url=\"file://$MODULE_DIR$/target\" />\n+    </content>\n+    <orderEntry type=\"inheritedJdk\" />\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n+    <orderEntry type=\"library\" name=\"Maven: junit:junit:4.10\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.hamcrest:hamcrest-core:1.1\" level=\"project\" />\n+  </component>\n+</module>\n+\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "pom.xml",
            "additions": 49,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,49 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+\t<modelVersion>4.0.0</modelVersion>\n+\t<groupId>org.mbassy</groupId>\n+\t<artifactId>mbassador</artifactId>\n+\t<version>1.0.0.RC</version>\n+\t<packaging>jar</packaging>\n+\t<name>mbassador</name>\n+\t<description>Library for simple implementation of bidirectional conversions</description>\n+\n+\t<properties>\n+\t\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+\t\t<project.build.java.version>1.6</project.build.java.version>\n+\t</properties>\n+\n+\t<dependencies>\n+\n+        <dependency>\n+\t\t\t<groupId>junit</groupId>\n+\t\t\t<artifactId>junit</artifactId>\n+\t\t\t<version>4.10</version>\n+\t\t\t<scope>compile</scope>\n+\t\t</dependency>\n+\n+\t</dependencies>\n+\n+\t<build>\n+\t\t<plugins>\n+\t\t\t<plugin>\n+\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n+\t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n+\t\t\t\t<configuration>\n+\t\t\t\t\t<source>${project.build.java.version}</source>\n+\t\t\t\t\t<target>${project.build.java.version}</target>\n+\t\t\t\t</configuration>\n+\t\t\t</plugin>\n+\n+\t\t\t<plugin>\n+\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n+\t\t\t\t<artifactId>maven-surefire-plugin</artifactId>\n+\t\t\t\t<configuration>\n+\t\t\t\t\t<skipTests>false</skipTests>\n+\t\t\t\t</configuration>\n+\t\t\t</plugin>\n+\n+\t\t</plugins>\n+\t</build>\n+</project>\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/Listener.java",
            "additions": 27,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,27 @@\n+package org.mbassy;\n+\n+import org.mbassy.filter.Filter;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * TODO. Insert class description here\n+ * <p/>\n+ * User: benni\n+ * Date: 2/8/12\n+ * Time: 3:35 PM\n+ */\n+@Retention(value = RetentionPolicy.RUNTIME)\n+@Inherited\n+@Target(value = {ElementType.METHOD})\n+public @interface Listener {\n+\n+\tFilter[] value() default {}; // no filters by default\n+\n+    Dispatch mode() default Dispatch.Synchronous;\n+\n+    public static enum Dispatch{\n+        Synchronous,Asynchronous\n+    }\n+\n+}\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/MBassador.java",
            "additions": 427,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,427 @@\n+package org.mbassy;\n+\n+import org.mbassy.filter.Filter;\n+import org.mbassy.filter.MessageFilter;\n+import org.mbassy.common.*;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.concurrent.*;\n+\n+/**\n+ *\n+ * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n+ * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n+ * The dispatch mechanism can by controlled for each concrete message publication.\n+ * A message publication is the publication of any message using one of the bus' publish(..) methods.\n+ * <p/>\n+ * Each message publication is isolated from all other running publications such that it does not interfere with them.\n+ * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n+ * messages get published asynchronously.\n+ * <p/>\n+ * A listener is any object that defines at least one message handler and that has been subscribed to at least\n+ * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n+ * as a message handler using the @Listener annotation.\n+ * <p/>\n+ * The bus uses weak references to all listeners such that registered listeners do not need to\n+ * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n+ * removed on-the-fly as messages get dispatched.\n+ * <p/>\n+ * Generally message handlers will be invoked in inverse sequence of insertion (subscription) but any\n+ * class using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n+ * a specific message exactly once to each of the subscribed message handlers.\n+ * <p/>\n+ * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n+ * a message handler may define filters to narrow the set of messages that it accepts.\n+ * <p/>\n+ * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n+ * Any messageHandler may only be subscribed once (subsequent subscriptions of an already subscribed messageHandler will be silently ignored)\n+ * <p/>\n+ * Removing a listener means removing all subscribed message handlers of that object. This remove operation\n+ * immediately takes effect and on all running dispatch processes. A removed listener (a listener\n+ * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n+ *\n+ * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n+ * get dispatched to all message handlers that take an instance of List as their parameter\n+ *\n+ * @Author bennidi\n+ * Date: 2/8/12\n+ */\n+public class MBassador<T>{\n+\n+\n+\t//  This predicate is used to find all message listeners (methods annotated with @Listener)\n+\tprivate static final IPredicate<Method> AllMessageListeners = new IPredicate<Method>() {\n+\t\t@Override\n+\t\tpublic boolean apply(Method target) {\n+\t\t\treturn target.getAnnotation(Listener.class) != null;\n+\t\t}\n+\t};\n+\n+    // This is the default error handler it will simply log to standard out and\n+    // print stack trace if available\n+\tprotected static final class ConsoleLogger implements IPublicationErrorHandler {\n+\t\t@Override\n+\t\tpublic void handleError(PublicationError error) {\n+            System.out.println(error);\n+            if (error.getCause() != null) error.getCause().printStackTrace();\n+\t\t}\n+\t};\n+\n+    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n+    private ExecutorService executor = new ThreadPoolExecutor(5, 50, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>());\n+\n+\t// cache already created filter instances\n+\tprivate final Map<Class<? extends MessageFilter>, MessageFilter> filterCache = new HashMap<Class<? extends MessageFilter>, MessageFilter>();\n+\n+\t// all subscriptions per message type\n+\t// this is the primary list for dispatching a specific message\n+\tprivate final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n+\n+\t// all subscriptions per messageHandler type\n+\t// this list provides access for subscribing and unsubsribing\n+\tprivate final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n+\n+\t// remember already processed classes that do not contain any listeners\n+\tprivate final Collection<Class> nonListeners = new HashSet();\n+\n+    // this handler will receive all errors that occur during message dispatch or message handling\n+\tprivate IPublicationErrorHandler errorHandler = new ConsoleLogger();\n+\n+\n+    // all threads that are available for asynchronous message dispatching\n+    private final CopyOnWriteArrayList<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n+\n+    // all pending messages scheduled for asynchronous dispatch are queued here\n+    private final LinkedBlockingQueue<T> pendingMessages = new LinkedBlockingQueue<T>();\n+\n+    // initialize the dispatch workers\n+    private void initDispatcherThreads(int numberOfThreads) {\n+        for (int i = 0; i < numberOfThreads; i++) {\n+            // each thread will run forever and process incoming\n+            //dispatch requests\n+            Thread dispatcher = new Thread(new Runnable() {\n+                public void run() {\n+                    while (true) {\n+                        try {\n+                            publish(pendingMessages.take());\n+                        } catch (InterruptedException e) {\n+                            errorHandler.handleError(new PublicationError(e, \"Asnchronous publication interupted\", null, null, null));\n+                            return;\n+                        }\n+                    }\n+                }\n+            });\n+            dispatchers.add(dispatcher);\n+            dispatcher.start();\n+        }\n+    }\n+\n+    public MBassador(){\n+        initDispatcherThreads(2);\n+    }\n+\n+    public MBassador(int dispatcherThreadCount){\n+        initDispatcherThreads(dispatcherThreadCount > 0 ? dispatcherThreadCount : 2);\n+    }\n+\n+\n+    public void publishAsync(T message){\n+        pendingMessages.offer(message);\n+    }\n+\n+\n+    /**\n+     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n+     * The call blocks until every messageHandler has processed the message.\n+     *\n+     * @param message\n+     */\n+\tpublic void publish(T message){\n+\t\ttry {\n+\t\t\tfinal Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n+\t\t\tfor (Subscription subscription : subscriptions) subscription.publish(message);\n+\t\t} catch (Throwable e) {\n+\t\t\thandlePublicationError(new PublicationError()\n+\t\t\t\t\t.setMessage(\"Error during publication of message\")\n+\t\t\t\t\t.setCause(e)\n+\t\t\t\t\t.setPublishedObject(message));\n+\t\t}\n+\n+\t}\n+\n+    /**\n+     * Immediately unsubscribe all registered message handlers (if any) of the given listener. When this call returns\n+     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n+     * publications that have been published when the messageHandler was still subscribed).\n+     * A call to this method passing null, an already subscribed message or any message that does not define any listeners\n+     * will not have any effect.\n+     *\n+     * @param listener\n+     */\n+\tpublic void unsubscribe(Object listener){\n+\t\tif (listener == null) return;\n+\t\tCollection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n+\t\tfor (Subscription subscription : subscriptions) {\n+\t\t\tsubscription.unsubscribe(listener);\n+\t\t}\n+\t}\n+\n+\n+    /**\n+     * Subscribe all listeners of the given message to receive message publications.\n+     * Any message may only be subscribed once (subsequent subscriptions of an already subscribed\n+     * message will be silently ignored)\n+     *\n+     * @param listener\n+     */\n+\tpublic void subscribe(Object listener){\n+\t\tClass listeningClass = listener.getClass();\n+\t\tif (nonListeners.contains(listeningClass))\n+\t\t\treturn; // early reject of known classes that do not participate in eventing\n+\t\tCollection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n+\t\tif (subscriptionsByListener == null) { // if the type is registered for the first time\n+\t\t\tsynchronized (this) { // new subscriptions must be processed sequentially for each class\n+\t\t\t\tsubscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n+\t\t\t\tif (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n+\t\t\t\t\tList<Method> messageHandlers = getListeners(listeningClass);  // get all methods with subscriptions\n+\t\t\t\t\tsubscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n+\t\t\t\t\tif (messageHandlers.isEmpty()) {  // remember the class as non listening class\n+\t\t\t\t\t\tnonListeners.add(listeningClass);\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t\t// create subscriptions for all detected listeners\n+\t\t\t\t\tfor (Method messageHandler : messageHandlers) {\n+\t\t\t\t\t\tif (!isValidMessageHandler(messageHandler)) continue; // ignore invalid listeners\n+\t\t\t\t\t\tMessageFilter[] filter = getFilter(messageHandler.getAnnotation(Listener.class));\n+\t\t\t\t\t\tClass eventType = getMessageType(messageHandler);\n+\t\t\t\t\t\tSubscription subscription = new Subscription(messageHandler, filter);\n+\t\t\t\t\t\tsubscription.subscribe(listener);\n+\t\t\t\t\t\taddMessageTypeSubscription(eventType, subscription);\n+\t\t\t\t\t\tsubscriptionsByListener.add(subscription);\n+\t\t\t\t\t\t//updateMessageTypeHierarchy(eventType);\n+\t\t\t\t\t}\n+\t\t\t\t\tsubscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t// register the message to the existing subscriptions\n+\t\tfor (Subscription sub : subscriptionsByListener) sub.subscribe(listener);\n+\t}\n+\n+\n+\tpublic void setErrorHandler(IPublicationErrorHandler handler){\n+\t\tthis.errorHandler = handler;\n+\t}\n+\n+\n+\n+\t// obtain the set of subscriptions for the given message type\n+\tprivate Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n+\t\t// TODO improve with cache\n+\t\tCollection<Subscription> subscriptions = new LinkedList<Subscription>();\n+\n+\t\tif(subscriptionsPerMessage.get(messageType) != null) {\n+\t\t\tsubscriptions.addAll(subscriptionsPerMessage.get(messageType));\n+\t\t}\n+\t\tfor (Class eventSuperType : getSuperclasses(messageType)){\n+           if(subscriptionsPerMessage.get(eventSuperType) != null){\n+               subscriptions.addAll(subscriptionsPerMessage.get(eventSuperType));\n+           }\n+        }\n+\n+\t\treturn subscriptions;\n+\t}\n+\n+    private Collection<Class> getSuperclasses(Class from){\n+        Collection<Class> superclasses = new LinkedList<Class>();\n+        while(!from.equals(Object.class)){\n+            superclasses.add(from.getSuperclass());\n+            from = from.getSuperclass();\n+        }\n+        return superclasses;\n+    }\n+\n+\t// associate a suscription with a message type\n+\tprivate void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n+\t\tCollection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n+\t\tif (subscriptions == null) {\n+\t\t\tsubscriptions = new CopyOnWriteArraySet<Subscription>();\n+\t\t\tsubscriptionsPerMessage.put(messageType, subscriptions);\n+\t\t}\n+\t\tsubscriptions.add(subscription);\n+\t}\n+\n+    /*\n+\tprivate void updateMessageTypeHierarchy(Class messageType) {\n+\t\tfor (Class existingEventType : subscriptionsPerMessage.keySet()) {\n+\t\t\tif (existingEventType.equals(messageType)) continue;\n+\t\t\tif (messageType.isAssignableFrom(existingEventType)) //message is super type of existing\n+\t\t\t\tmessageTypeHierarchy.put(existingEventType, messageType);\n+\t\t\telse if (existingEventType.isAssignableFrom(messageType)) { // message is sub type of existing\n+\t\t\t\tmessageTypeHierarchy.put(messageType, existingEventType); // add direct super type\n+\t\t\t\tmessageTypeHierarchy.putAll(messageType, messageTypeHierarchy.get(existingEventType)); // add all super types of super type\n+\t\t\t}\n+\t\t}\n+\t}*/\n+\n+\n+\tprivate boolean isValidMessageHandler(Method handler) {\n+\t\tif (handler.getParameterTypes().length != 1) {\n+\t\t\t// a messageHandler only defines one parameter (the message)\n+\t\t\tSystem.out.println(\"Found nono or more than one parameter in messageHandler [\" + handler.getName()\n+\t\t\t\t\t+ \"]. A messageHandler must define exactly one parameter\");\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tprivate static Class getMessageType(Method listener) {\n+\t\treturn listener.getParameterTypes()[0];\n+\t}\n+\n+\t// get all listeners defined by the given class (includes\n+\t// listeners defined in super classes)\n+\tprivate static List<Method> getListeners(Class<?> target) {\n+\t\treturn ReflectionUtils.getMethods(AllMessageListeners, target);\n+\t}\n+\n+\t// retrieve all instances of filters associated with the given subscription\n+\tprivate MessageFilter[] getFilter(Listener subscription) {\n+\t\tif (subscription.value().length == 0) return null;\n+\t\tMessageFilter[] filters = new MessageFilter[subscription.value().length];\n+\t\tint i = 0;\n+\t\tfor (Filter filterDef : subscription.value()) {\n+\t\t\tMessageFilter filter = filterCache.get(filterDef.value());\n+\t\t\tif (filter == null) {\n+\t\t\t\ttry {\n+\t\t\t\t\tfilter = filterDef.value().newInstance();\n+\t\t\t\t\tfilterCache.put(filterDef.value(), filter);\n+\t\t\t\t} catch (Throwable e) {\n+\t\t\t\t\thandlePublicationError(new PublicationError()\n+\t\t\t\t\t\t\t.setMessage(\"Error retrieving filter\"));\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t\tfilters[i] = filter;\n+\t\t\ti++;\n+\t\t}\n+\t\treturn filters;\n+\t}\n+\n+\n+\n+\tprivate void handlePublicationError(PublicationError error) {\n+\t\terrorHandler.handleError(error);\n+\t}\n+\n+    @Override\n+    protected void finalize() throws Throwable {\n+        super.finalize();\n+        for(Thread dispatcher : dispatchers){\n+            dispatcher.interrupt();\n+        }\n+    }\n+\n+    /**\n+     * Subscription is a thread safe container for objects that contain message handlers\n+     *\n+     */\n+\tprivate class Subscription {\n+\n+\t\tprivate final MessageFilter[] filter;\n+\n+\t\tprivate final Method messageHandler;\n+\n+\t\tprivate ConcurrentLinkedBag<Object> listeners = new ConcurrentLinkedBag<Object>();\n+\n+        private boolean isAynchronous;\n+\n+\t\tprivate Subscription(Method messageHandler, MessageFilter[] filter) {\n+\t\t\tthis.messageHandler = messageHandler;\n+\t\t\tthis.filter = filter;\n+            this.messageHandler.setAccessible(true);\n+            this.isAynchronous = messageHandler.getAnnotation(Listener.class).mode().equals(Listener.Dispatch.Asynchronous);\n+\t\t}\n+\n+\n+\t\tpublic void subscribe(Object o) {\n+\t\t\tlisteners.add(o);\n+\n+\t\t}\n+\n+        private void dispatch(final Object message, final Object listener){\n+            if(isAynchronous){\n+                 MBassador.this.executor.execute(new Runnable() {\n+                     @Override\n+                     public void run() {\n+                         invokeHandler(message, listener);\n+                     }\n+                 });\n+            }\n+            else{\n+                invokeHandler(message, listener);\n+            }\n+        }\n+\n+        private void invokeHandler(final Object message, final Object listener){\n+            try {\n+                messageHandler.invoke(listener, message);\n+            }catch(IllegalAccessException e){\n+                MBassador.this.handlePublicationError(\n+                        new PublicationError(e, \"Error during messageHandler notification. \" +\n+                                \"The class or method is not accessible\",\n+                                messageHandler, listener, message));\n+            }\n+            catch(IllegalArgumentException e){\n+                MBassador.this.handlePublicationError(\n+                        new PublicationError(e, \"Error during messageHandler notification. \" +\n+                                \"Wrong arguments passed to method. Was: \" + message.getClass()\n+                                + \"Expected: \" + messageHandler.getParameterTypes()[0],\n+                                messageHandler, listener, message));\n+            }\n+            catch (InvocationTargetException e) {\n+                MBassador.this.handlePublicationError(\n+                        new PublicationError(e, \"Error during messageHandler notification. \" +\n+                                \"Message handler threw exception\",\n+                                messageHandler, listener, message));\n+            }\n+            catch (Throwable e) {\n+                MBassador.this.handlePublicationError(\n+                        new PublicationError(e, \"Error during messageHandler notification. \" +\n+                                \"Unexpected exception\",\n+                                messageHandler, listener, message));\n+            }\n+        }\n+\n+\t\tpublic void publish(Object message) {\n+\n+\t\t\tIterator<Object> iterator = listeners.iterator();\n+\t\t\tObject listener = null;\n+\t\t\twhile ((listener = iterator.next()) != null) {\n+\t\t\t\t\tif(passesFilter(message, listener)) {\n+\t\t\t\t\t\tdispatch(message, listener);\n+\t\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate boolean passesFilter(Object message, Object listener) {\n+\n+\t\t\tif (filter == null) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tfor (int i = 0; i < filter.length; i++) {\n+\t\t\t\t\tif (!filter[i].accepts(message, listener)) return false;\n+\t\t\t\t}\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void unsubscribe(Object existingListener) {\n+\t\t\tlisteners.remove(existingListener);\n+\t\t}\n+\t}\n+\n+}\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/common/ConcurrentLinkedBag.java",
            "additions": 159,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,159 @@\n+package org.mbassy.common;\n+\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Iterator;\n+import java.util.WeakHashMap;\n+\n+/**\n+ * This data structure is optimized for non-blocking reads even when write operations occur.\n+ * Running read iterators will not be affected by add operations since writes always insert at the head of the\n+ * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n+ * been reached by the iterator will not appear in that iterator anymore.\n+ *\n+ * The structure uses weak references to the elements. Iterators automatically perform cleanups of\n+ * garbace collect objects during iteration.\n+ * No dedicated maintenance operations need to be called or run in background.\n+ *\n+ *\n+ * <p/>\n+ * @author bennidi\n+ * Date: 2/12/12\n+ */\n+public class ConcurrentLinkedBag<T> implements Iterable<T> {\n+\n+\n+\tprivate WeakHashMap<T, ListEntry<T>> entries = new WeakHashMap<T, ListEntry<T>>(); // maintain a map of entries for O(log n) lookup\n+\n+\tprivate ListEntry<T> head; // reference to the first element\n+\n+\tpublic ConcurrentLinkedBag<T> add(T element) {\n+\t\tif (element == null || entries.containsKey(element)) return this;\n+\t\tsynchronized (this) {\n+\t\t\tinsert(element);\n+\t\t}\n+\t\treturn this;\n+\t}\n+\n+\tprivate void insert(T element) {\n+\t\tif(head == null){\n+\t\t\thead = new ListEntry<T>(element);\n+\t\t}\n+\t\telse{\n+\t\t\thead = new ListEntry<T>(element, head);\n+\t\t}\n+\t\tentries.put(element, head);\n+\t}\n+\n+\tpublic ConcurrentLinkedBag<T> addAll(Iterable<T> elements) {\n+\t\tfor (T element : elements) {\n+\t\t\tif (element == null || entries.containsKey(element)) return this;\n+\t\t\tsynchronized (this) {\n+\t\t\t\tinsert(element);\n+\t\t\t}\n+\t\t}\n+\t\treturn this;\n+\t}\n+\n+\tpublic ConcurrentLinkedBag<T> remove(T element) {\n+\t\tif (!entries.containsKey(element)) return this;\n+\t\tsynchronized (this) {\n+\t\t\tListEntry<T> listelement = entries.get(element);\n+\t\t\tif(listelement != head){\n+\t\t\t\tlistelement.remove();\n+\t\t\t}\n+\t\t\telse{\n+\t\t\t\thead = head.next();\n+\t\t\t}\n+\t\t\tentries.remove(element);\n+\t\t}\n+\t\treturn this;\n+\t}\n+\n+\tpublic Iterator<T> iterator() {\n+\t\treturn new Iterator<T>() {\n+\n+\t\t\tprivate ListEntry<T> current = head;\n+\n+\t\t\tpublic boolean hasNext() {\n+                if(current == null) return false;\n+                T value = current.getValue();\n+                if(value == null){    // auto-removal of orphan references\n+                    remove();\n+                    return hasNext();\n+                }\n+                else{\n+                    return true;\n+                }\n+\t\t\t}\n+\n+\t\t\tpublic T next() {\n+\t\t\t\tif(current == null) return null;\n+\t\t\t\tT value = current.getValue();\n+\t\t\t\tif(value == null){    // auto-removal of orphan references\n+\t\t\t\t\tremove();\n+\t\t\t\t\treturn next();\n+\t\t\t\t}\n+\t\t\t\telse{\n+\t\t\t\t\tcurrent = current.next();\n+\t\t\t\t\treturn value;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tpublic void remove() {\n+\t\t\t\tif(current == null)return;\n+\t\t\t\tsynchronized (ConcurrentLinkedBag.this){\n+\t\t\t\tcurrent.remove();\n+\t\t\t\tcurrent = current.next();}\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\n+\tpublic class ListEntry<T> {\n+\n+\t\tprivate WeakReference<T> value;\n+\n+\t\tprivate ListEntry<T> next;\n+\n+\t\tprivate ListEntry<T> predecessor;\n+\n+\n+\t\tprivate ListEntry(T value) {\n+\t\t\tthis.value = new WeakReference<T>(value);\n+\t\t}\n+\n+\t\tprivate ListEntry(T value, ListEntry<T> next) {\n+\t\t\tthis(value);\n+\t\t\tthis.next = next;\n+\t\t\tnext.predecessor = this;\n+\t\t}\n+\n+\t\tpublic T getValue() {\n+\t\t\treturn value.get();\n+\t\t}\n+\n+\t\tpublic void remove(){\n+\t\t\tif(predecessor != null){\n+\t\t\t\tpredecessor.setNext(next());\n+\t\t\t}\n+\t\t\telse if(next() != null){\n+\t\t\t\tnext.predecessor = null;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void setNext(ListEntry<T> element) {\n+\t\t\tthis.next = element;\n+\t\t\tif(element != null)element.predecessor = this;\n+\t\t}\n+\n+\t\tpublic ListEntry<T> next() {\n+\t\t\treturn next;\n+\t\t}\n+\n+\t\tpublic boolean hasNext() {\n+\t\t\treturn next() != null;\n+\t\t}\n+\n+\t}\n+}\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/common/IPredicate.java",
            "additions": 14,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,14 @@\n+package org.mbassy.common;\n+\n+/**\n+ * Created with IntelliJ IDEA.\n+ * User: benni\n+ * Date: 10/22/12\n+ * Time: 9:33 AM\n+ * To change this template use File | Settings | File Templates.\n+ */\n+public interface IPredicate<T> {\n+\n+    public boolean apply(T target);\n+\n+}\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/common/IPublicationErrorHandler.java",
            "additions": 13,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,13 @@\n+package org.mbassy.common;\n+\n+/**\n+ * TODO. Insert class description here\n+ * <p/>\n+ * User: benni\n+ * Date: 2/22/12\n+ * Time: 5:03 PM\n+ */\n+public interface IPublicationErrorHandler {\n+\n+\tpublic void handleError(PublicationError error);\n+}\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/common/PublicationError.java",
            "additions": 98,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,98 @@\n+package org.mbassy.common;\n+\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Publication errors are created when object publication fails for some reason and contain details\n+ * as to the cause and location where they occured.\n+ * <p/>\n+ * User: benni\n+ * Date: 2/22/12\n+ * Time: 4:59 PM\n+ */\n+public class PublicationError {\n+\n+\tprivate Throwable cause;\n+\n+\tprivate String message;\n+\n+\tprivate Method listener;\n+\n+\tprivate Object listeningObject;\n+\n+\tprivate Object publishedObject;\n+\n+\n+\tpublic PublicationError(Throwable cause, String message, Method listener, Object listeningObject, Object publishedObject) {\n+\t\tthis.cause = cause;\n+\t\tthis.message = message;\n+\t\tthis.listener = listener;\n+\t\tthis.listeningObject = listeningObject;\n+\t\tthis.publishedObject = publishedObject;\n+\t}\n+\n+\tpublic PublicationError(){\n+\t\tsuper();\n+\t}\n+\n+\tpublic Throwable getCause() {\n+\t\treturn cause;\n+\t}\n+\n+\tpublic PublicationError setCause(Throwable cause) {\n+\t\tthis.cause = cause;\n+\t\treturn this;\n+\t}\n+\n+\tpublic String getMessage() {\n+\t\treturn message;\n+\t}\n+\n+\tpublic PublicationError setMessage(String message) {\n+\t\tthis.message = message;\n+\t\treturn this;\n+\t}\n+\n+\tpublic Method getListener() {\n+\t\treturn listener;\n+\t}\n+\n+\tpublic PublicationError setListener(Method listener) {\n+\t\tthis.listener = listener;\n+\t\treturn this;\n+\t}\n+\n+\tpublic Object getListeningObject() {\n+\t\treturn listeningObject;\n+\t}\n+\n+\tpublic PublicationError setListeningObject(Object listeningObject) {\n+\t\tthis.listeningObject = listeningObject;\n+\t\treturn this;\n+\t}\n+\n+\tpublic Object getPublishedObject() {\n+\t\treturn publishedObject;\n+\t}\n+\n+\tpublic PublicationError setPublishedObject(Object publishedObject) {\n+\t\tthis.publishedObject = publishedObject;\n+\t\treturn this;\n+\t}\n+\n+    @Override\n+    public String toString() {\n+        return \"PublicationError{\" +\n+                \"\\n\" +\n+                \"\\tcause=\" + cause +\n+                \"\\n\" +\n+                \"\\tmessage='\" + message + '\\'' +\n+                \"\\n\" +\n+                \"\\tlistener=\" + listener +\n+                \"\\n\" +\n+                \"\\tlisteningObject=\" + listeningObject +\n+                \"\\n\" +\n+                \"\\tpublishedObject=\" + publishedObject +\n+                '}';\n+    }\n+}\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/common/ReflectionUtils.java",
            "additions": 70,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,70 @@\n+package org.mbassy.common;\n+\n+import com.google.common.base.Predicate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * User: benni\n+ * Date: 2/16/12\n+ * Time: 12:14 PM\n+ */\n+public class ReflectionUtils {\n+\n+\tprivate static final Logger logger = LoggerFactory.getLogger(ReflectionUtils.class);\n+\n+\tpublic static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n+\t\tList<Method> methods = new LinkedList<Method>();\n+\t\ttry {\n+\t\t\tfor (Method method : target.getDeclaredMethods()) {\n+\t\t\t\tif (condition.apply(method)) {\n+\t\t\t\t\tmethods.add(method);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\t//nop\n+\t\t}\n+\t\tif (!target.equals(Object.class)) {\n+\t\t\tmethods.addAll(getMethods(condition, target.getSuperclass()));\n+\t\t}\n+\t\treturn methods;\n+\t}\n+\n+\tpublic static List<Field> getFields(Predicate<Field> condition, Class<?> target) {\n+\t\tList<Field> methods = new LinkedList<Field>();\n+\t\ttry {\n+\t\t\tfor (Field method : target.getDeclaredFields()) {\n+\t\t\t\tif (condition.apply(method)) {\n+\t\t\t\t\tmethods.add(method);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\t//nop\n+\t\t}\n+\t\tif (!target.equals(Object.class)) {\n+\t\t\tmethods.addAll(getFields(condition, target.getSuperclass()));\n+\t\t}\n+\t\treturn methods;\n+\t}\n+\n+\tpublic static Object callMethod(Object o, final String methodName, Object... args) {\n+\n+\t\tif(o == null || methodName == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tObject res = null;\n+\t\ttry {\n+\t\t\tMethod m = o.getClass().getMethod(methodName);\n+\t\t\tres = m.invoke(o, args);\n+\t\t} catch (Exception e) {\n+\t\t\t//logger.warn(\"Not possible to get value\", e);\n+\t\t}\n+\t\treturn res;\n+\t}\n+}\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/filter/Filter.java",
            "additions": 23,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,23 @@\n+package org.mbassy.filter;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * THe filter annotation is used to add filters to message listeners.\n+ * It references a class that implements the MessageFilter interface.\n+ * The object filter will be used to check whether a message should be delivered\n+ * to the message listener or not.\n+ *\n+ * <p/>\n+ * @author  benni\n+ * Date: 2/14/12\n+ */\n+@Retention(value = RetentionPolicy.RUNTIME)\n+@Target(value = {ElementType.ANNOTATION_TYPE})\n+public @interface Filter {\n+\n+\tClass<? extends MessageFilter> value();\n+}\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "src/main/java/org/mbassy/filter/MessageFilter.java",
            "additions": 31,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,31 @@\n+package org.mbassy.filter;\n+\n+/**\n+ * Object filters can be used to prevent certain messages to be delivered to a specific listener.\n+ * If a filter is used the message will only be delivered if it passes the filter(s)\n+ *\n+ * User: benni\n+ * Date: 2/8/12\n+ */\n+public interface MessageFilter {\n+\n+    /**\n+     * Evaluate the message and listener to ensure that the message should be handled by the listener\n+     *\n+     *\n+     * @param event the event to be delivered\n+     * @param listener the listener instance that would receive the event if it passes the filter\n+     * @return\n+     */\n+\tpublic boolean accepts(Object event, Object listener);\n+\n+\n+\tpublic static final class All implements MessageFilter {\n+\n+\t\t@Override\n+\t\tpublic boolean accepts(Object event, Object listener) {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+}\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/ConcurrentExecutor.java",
            "additions": 68,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,68 @@\n+package org.mbassy;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.*;\n+\n+/**\n+ * Run various tests concurrently. A given instance of runnable will be used to spawn and start\n+ * as many threads as specified by an additional parameter or (if multiple runnables have been\n+ * passed to the method) one thread for each runnable.\n+ * <p/>\n+ * Date: 2/14/12\n+ *\n+ * @Author bennidi\n+ */\n+public class ConcurrentExecutor {\n+\n+\n+\tpublic static void runConcurrent(final Runnable unit, int numberOfConcurrentExecutions) {\n+\t\tRunnable[] units = new Runnable[numberOfConcurrentExecutions];\n+\t\t// create the tasks and schedule for execution\n+\t\tfor (int i = 0; i < numberOfConcurrentExecutions; i++) {\n+\t\t\tunits[i] = unit;\n+\t\t}\n+\t\trunConcurrent(units);\n+\n+\t}\n+\n+\tpublic static void runConcurrent(final Runnable... units) {\n+\t\tExecutorService executor = Executors.newCachedThreadPool();\n+\t\tList<Future<Long>> returnValues = new ArrayList<Future<Long>>();\n+\n+\t\t// create the tasks and schedule for execution\n+\t\tfor (final Runnable unit : units) {\n+\t\t\tCallable<Long> wrapper = new Callable<Long>() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic Long call() throws Exception {\n+\t\t\t\t\tlong start = System.currentTimeMillis();\n+\t\t\t\t\tunit.run();\n+\t\t\t\t\treturn System.currentTimeMillis() - start;\n+\t\t\t\t}\n+\t\t\t};\n+\t\t\treturnValues.add(executor.submit(wrapper));\n+\t\t}\n+\n+\t\t// wait until all tasks have been executed\n+\t\ttry {\n+\t\t\texecutor.shutdown();// tells the thread pool to execute all waiting tasks\n+\t\t\texecutor.awaitTermination(5, TimeUnit.MINUTES);\n+\t\t} catch (InterruptedException e) {\n+\t\t\t// unlikely that this will happen\n+\t\t\te.printStackTrace();\n+\t\t}\n+\n+\t\t// print results\n+\t\tfor (Future<Long> result : returnValues)\n+\t\t\ttry {\n+\t\t\t\tSystem.out.println(\"Execution of unit of work to \" + result.get() + \"ms.\");\n+\t\t\t} catch (Exception e) {\n+\t\t\t\t//should never happen\n+\t\t\t\t// since the code waits until all tasks are processed\n+\t\t\t\te.printStackTrace();\n+\t\t\t}\n+\n+\t}\n+\n+\n+}\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "src/test/java/org/mbassy/MBassadorTest.java",
            "additions": 167,
            "deletions": 0
        },
        "diff content": "@@ -0,0 +1,167 @@\n+package org.mbassy;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n+ *\n+ * @author bennidi\n+ * Date: 2/8/12\n+ */\n+public class MBassadorTest {\n+\n+\n+\t@Test\n+\tpublic void testAsynchronous() throws InterruptedException {\n+\n+\t\tMBassador bus = new MBassador();\n+\t\tint listenerCount = 1000;\n+\t\tList<EventingTestBean> persistentReferences = new ArrayList();\n+\n+        for (int i = 1; i <= listenerCount; i++) {\n+\t\t\tEventingTestBean bean = new EventingTestBean();\n+\t\t\tpersistentReferences.add(bean);\n+\t\t\tbus.subscribe(bean);\n+\t\t}\n+\n+\t\tTestEvent event = new TestEvent();\n+\t\tTestEvent subEvent = new SubTestEvent();\n+\n+\t\tbus.publishAsync(event);\n+\t\tbus.publishAsync(subEvent);\n+\n+\t\tThread.sleep(2000);\n+\n+\t\tAssert.assertTrue(event.counter.get() == 1000);\n+\t\tAssert.assertTrue(subEvent.counter.get() == 1000 * 2);\n+\n+\t}\n+\n+    @Test\n+\tpublic void testSynchronous() throws InterruptedException {\n+\n+\t\tMBassador bus = new MBassador();\n+\t\tint listenerCount = 100;\n+\t\tList<EventingTestBean> persistentReferences = new ArrayList();\n+\t\tfor (int i = 1; i <= listenerCount; i++) {\n+\n+\n+\t\t\tEventingTestBean bean = new EventingTestBean();\n+\t\t\tpersistentReferences.add(bean);\n+\t\t\tbus.subscribe(bean);\n+\n+\t\t\tTestEvent event = new TestEvent();\n+\t\t\tTestEvent subEvent = new SubTestEvent();\n+\n+\t\t\tbus.publish(event);\n+\t\t\tbus.publish(subEvent);\n+\n+            Assert.assertEquals(i, event.counter.get());\n+\n+            try {\n+                Thread.sleep(10);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n+            }\n+\n+\t\t\tAssert.assertEquals(i * 2, subEvent.counter.get());\n+\n+\t\t}\n+\n+\t}\n+\n+    @Test\n+\tpublic void testConcurrentPublication() {\n+        final MBassador bus = new MBassador();\n+        final int listenerCount = 100;\n+        final int concurenny = 20;\n+        final CopyOnWriteArrayList<TestEvent> testEvents = new CopyOnWriteArrayList<TestEvent>();\n+        final CopyOnWriteArrayList<SubTestEvent> subtestEvents = new CopyOnWriteArrayList<SubTestEvent>();\n+        final CopyOnWriteArrayList<EventingTestBean> persistentReferences = new CopyOnWriteArrayList<EventingTestBean>();\n+\n+\t\tConcurrentExecutor.runConcurrent(new Runnable() {\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\tlong start = System.currentTimeMillis();\n+\t\t\t\tfor (int i = 0; i < listenerCount; i++) {\n+\t\t\t\t\tEventingTestBean bean = new EventingTestBean();\n+\t\t\t\t\tpersistentReferences.add(bean);\n+                    bus.subscribe(bean);\n+\t\t\t\t}\n+\n+\t\t\t\tlong end = System.currentTimeMillis();\n+\t\t\t\tSystem.out.println(\"MBassador: Creating \" + listenerCount + \" listeners took \" + (end - start) + \" ms\");\n+\t\t\t}\n+\t\t}, concurenny);\n+\n+        ConcurrentExecutor.runConcurrent(new Runnable() {\n+            @Override\n+            public void run() {\n+                long start = System.currentTimeMillis();\n+                for (int i = 0; i < listenerCount; i++) {\n+                    TestEvent event = new TestEvent();\n+                    SubTestEvent subEvent = new SubTestEvent();\n+                    testEvents.add(event);\n+                    subtestEvents.add(subEvent);\n+\n+                    bus.publishAsync(event);\n+                    bus.publish(subEvent);\n+                }\n+\n+                long end = System.currentTimeMillis();\n+                System.out.println(\"MBassador: Publishing \" + 2 * listenerCount + \" events took \" + (end - start) + \" ms\");\n+            }\n+        }, concurenny);\n+\n+        try {\n+            Thread.sleep(3000);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n+        }\n+\n+        for(TestEvent event : testEvents){\n+            Assert.assertEquals(listenerCount * concurenny, event.counter.get());\n+        }\n+\n+        for(SubTestEvent event : subtestEvents){\n+            Assert.assertEquals(listenerCount * concurenny * 2, event.counter.get());\n+        }\n+\n+\t}\n+\n+\n+\tpublic static class TestEvent {\n+\n+\t\tpublic AtomicInteger counter = new AtomicInteger();\n+\n+\t}\n+\n+\tpublic static class SubTestEvent extends TestEvent {\n+\n+\t}\n+\n+\n+\tpublic class EventingTestBean {\n+\n+\n+\t\t@Listener\n+\t\tpublic void handleTestEvent(TestEvent event) {\n+\t\t\tevent.counter.incrementAndGet();\n+\t\t}\n+\n+\t\t@Listener(mode = Listener.Dispatch.Asynchronous)\n+\t\tpublic void handleSubTestEvent(SubTestEvent event) {\n+            event.counter.incrementAndGet();\n+\t\t}\n+\n+\n+\t}\n+\n+\n+}\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/Listener$Dispatch.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/Listener$Dispatch.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/Listener.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/Listener.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/MBassador$1.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/MBassador$1.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/MBassador$2.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/MBassador$2.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/MBassador$ConsoleLogger.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/MBassador$ConsoleLogger.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/MBassador$Subscription$1.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/MBassador$Subscription$1.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/MBassador$Subscription.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/MBassador$Subscription.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/MBassador.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/MBassador.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/common/ConcurrentLinkedBag$1.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/common/ConcurrentLinkedBag$1.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/common/ConcurrentLinkedBag$ListEntry.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/common/ConcurrentLinkedBag$ListEntry.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/common/ConcurrentLinkedBag.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/common/ConcurrentLinkedBag.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/common/IPredicate.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/common/IPredicate.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/common/IPublicationErrorHandler.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/common/IPublicationErrorHandler.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/common/PublicationError.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/common/PublicationError.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/common/ReflectionUtils.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/common/ReflectionUtils.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/filter/Filter.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/filter/Filter.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/filter/MessageFilter$All.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/filter/MessageFilter$All.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/classes/org/mbassy/filter/MessageFilter.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/classes/org/mbassy/filter/MessageFilter.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/test-classes/org/mbassy/ConcurrentExecutor$1.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/test-classes/org/mbassy/ConcurrentExecutor$1.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/test-classes/org/mbassy/ConcurrentExecutor.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/test-classes/org/mbassy/ConcurrentExecutor.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/test-classes/org/mbassy/MBassadorTest$1.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/test-classes/org/mbassy/MBassadorTest$1.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/test-classes/org/mbassy/MBassadorTest$2.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/test-classes/org/mbassy/MBassadorTest$2.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/test-classes/org/mbassy/MBassadorTest$EventingTestBean.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/test-classes/org/mbassy/MBassadorTest$EventingTestBean.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/test-classes/org/mbassy/MBassadorTest$SubTestEvent.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/test-classes/org/mbassy/MBassadorTest$SubTestEvent.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/test-classes/org/mbassy/MBassadorTest$TestEvent.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/test-classes/org/mbassy/MBassadorTest$TestEvent.class differ\n"
    },
    {
        "commit hash": "8c4d515c2131f37f05e4c51028a71d0c73acc6a9",
        "previous commit hash": "88ae82e3caaabe29e40cc6023df7329892e3914c",
        "diff stats": {
            "file_path": "target/test-classes/org/mbassy/MBassadorTest.class",
            "additions": 0,
            "deletions": 0
        },
        "diff content": "Binary files /dev/null and b/target/test-classes/org/mbassy/MBassadorTest.class differ\n"
    }
]